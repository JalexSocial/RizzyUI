# RizzyUI LLM-Authoring Guide

**Fully expanded specification for code-generation models — May 2025, rev 2.4**

---

## 0. Why this file exists

This guide is a **contract for any large-language model**—ChatGPT, Claude, Gemini, Azure OpenAI, etc.—that emits source code destined for the **RizzyUI** repository.
If the model follows every rule, a maintainer can:

1. Paste the generated files into `src/RizzyUI/…`.
2. Apply the indicated cross-file edits (see § 14).
3. Run `dotnet build`.

The solution should compile, pass unit tests, and conform to RizzyUI’s conventions **without manual tweaks**.

SPECIAL NOTE: @* *@ comments in this document are used to provide LLM guidance only. They are **not** to be included in the generated code. 

---

## 1. Output-file syntax (mandatory for new or replacement files)

When the user requests code, wrap each file in a single **`output` block** so automation scripts know where to save it.

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">
  <!-- Razor markup -->
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">
  // C# code-behind
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">
  // Tailwind style provider
  </file>
</files>
```
````

* Never nest `<files>` elements.
* Always close every `<file>` tag.
* If no new files are needed, **omit** the `output` block entirely.

---

## 2. Root element pattern (in every `.razor` file)

```razor
<HtmlElement Element="@EffectiveElement"
             id="@Id"
             class="@RootClass()"
             @attributes="@AdditionalAttributes">
    @* Optional content here, like an Alpine child-container *@
</HtmlElement>
```

* `Element="@EffectiveElement"` keeps the tag overridable (default "div" in `RzComponent`).
* `@Id` is required for HTMX, Alpine, and tests.
* `@RootClass()` is supplied by `RootClass()` in code-behind.
* **Always** write `@attributes="@AdditionalAttributes"` (note the leading `@`).
* **Never** use @* *@ comments inside Razor markup for elements that will be rendered.
* To change the `Element` type, override `OnInitialized()` in the code-behind. Set Element to the new type only if Element is empty or null.
```csharp
        if (string.IsNullOrEmpty(Element))
            Element = "nav";
``` 

---

## 3. `.razor` File Guidelines

*   **Namespace:** Add `@namespace RizzyUI`.
*   **Inheritance:** Add `@inherits RzComponent` (or appropriate base like `RzTypographyBase`).
*   **Root Element:** Use the pattern in §2.
*   **CSS Classes for Internal Elements:**
    *   For HTML elements *inside* the root element, access theme styles **directly** in their `class` attribute:
        *   Static styles: `class="@Theme.RzComponentName.InternalElementStyle"`
        *   Dynamic styles: `class="@Theme.RzComponentName.GetInternalElementVariantCss(Parameter)"`
        *   Combine with other static classes or conditional Alpine classes as needed.
    *   Refer to §6 for Tailwind 4 and semantic token usage.
*   **Alpine Integration:** See §10 for the Alpine child-container convention if Alpine is used.
*   **Accessibility:** Refer to §8 for accessibility guidelines.
*   **Localization:** Refer to §9 for localization guidelines.

---

## 4. Code-behind skeleton (`.razor.cs`)

```csharp
// src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using Blazicons;
// Add other necessary using statements

namespace RizzyUI;

/// <summary>
/// Brief description of RzFancyThing and its purpose.
/// </summary>
public partial class RzFancyThing : RzComponent
{
    /// <summary>
    /// Gets or sets the content to be rendered inside the component.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets an optional leading icon for the component.
    /// </summary>
    [Parameter] public SvgIcon? LeadingIcon { get; set; }

    /// <summary>
    /// Gets or sets the size of the component. Defaults to Medium.
    /// </summary>
    [Parameter] public Size Size { get; set; } = Size.Medium;

    /// <summary>
    /// Gets or sets a value indicating whether the component is active.
    /// </summary>
    [Parameter] public bool IsActive { get; set; }

    /// <summary>
    /// Gets or sets the ARIA label for the component, providing an accessible name.
    /// If not set, a default localized label may be applied.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set Element = "button"; or other specific tag if not a div
        // Initialize AriaLabel with localized default if not provided by user (see §9)
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-apply default localized AriaLabel if AriaLabel parameter becomes null
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override string? RootClass()
    {
        var s = Theme.RzFancyThing; // Access the specific style provider for this component
        return TwMerge.Merge(
            AdditionalAttributes,
            s.Container,             // Base style from the provider
            s.GetSizeCss(Size),      // Dynamic style from the provider
            IsActive ? s.Active : null // Conditional style from the provider
        );
    }

    /// <summary>Assets that must load before the Alpine module (if any) boots.</summary>
    public static readonly string[] DefaultAssets =
    {
        // Example: Constants.ContentUrl("js/rzfancything.js")
        // If no JS, make this an empty array: = Array.Empty<string>();
    };

    // Other component logic, event callbacks, etc.
}
```

Important for the LLM:

* Start with `/// <summary>...</summary>` for the class.
* **All** public members get `<summary>` XML docs.
* Icons are passed as `SvgIcon?`; render with `<Blazicon Svg="@LeadingIcon" … />`.
* Use `TwMerge.Merge(...)`; never concatenate class strings manually in `RootClass()`.
* Default `Element` to "div" unless overridden in `OnInitialized()`.
* If `DefaultAssets` are not needed, initialize as `public static readonly string[] DefaultAssets = Array.Empty<string>();`.
* Include an `AriaLabel` parameter and initialize it with a localized default if not set by the user (see §9).

---

## 5. Icon-passing protocol

```razor
@* Inside RzFancyThing.razor *@
@if (LeadingIcon is not null)
{
    <Blazicon Svg="@LeadingIcon"
              class="@Theme.RzFancyThing.IconStyle"
              aria-hidden="true" /> @* Icons are often decorative *@
}
```

* Accept icons as `SvgIcon?`.
* Parameter names must be `LeadingIcon` or `TrailingIcon` as appropriate.
* Style the `<Blazicon>` using direct theme access in its `class` attribute.
* Add `aria-hidden="true"` if the icon is purely decorative and its meaning is conveyed by adjacent text or the component's `aria-label`.

---

## 6. Using Tailwind 4 with the RizzyUI Theme System

RizzyUI ships its own **Tailwind 4 plugin** (`/packages/rizzyui/src/css/rizzyui-plugin.css`).
That file defines a palette of **CSS custom-property tokens** (surface, on-surface, primary, etc.) plus a `@variant dark` block that swaps token values when `.dark` is present on `html` or any ancestor.

### 6.1 Semantic tokens, not raw palette colors

You never hard-code `text-blue-600` or `bg-slate-900` in a component.
Instead you write utilities that reference the semantic tokens shipped by the plugin:

```
bg-background
text-foreground
hover:bg-secondary
ring-outline-strong
```

Because the **token names stay identical** across light and dark modes, you do **not** need `dark:` prefixes for these semantic tokens:

```html
<span class="text-foreground">Works in both themes</span>
```

Tailwind expands that to:

```css
.text-foreground { color: var(--color-foreground); }
```

and the plugin’s `@variant dark` ensures `--color-foreground` swaps automatically.

### 6.2 Where utilities live

* **Component markup (`.razor`)** should be free of presentation classes except for small, internal layout helpers (`flex`, `gap-2`, etc.).
* **All root and variant styles** belong in a **style-provider object** (see §7) so end users can swap them out.

Example provider properties:

```csharp
public override string Container  =>
    "inline-flex items-center rounded-full px-3 py-1 bg-background text-foreground";

public override string Active     =>
    "ring-2 ring-primary";

public override string IconStyle  =>
    "size-5 text-muted-foreground";
```

### 6.3 TwMerge: the required glue

Use the injected `TwMerge.Merge(attributes, class1, class2, …)` in the `RootClass()` method of your `.razor.cs` file to combine:

```csharp
// In RzFancyThing.razor.cs
protected override string? RootClass()
{
    var s = Theme.RzFancyThing;
    return TwMerge.Merge(
        AdditionalAttributes,    // User-supplied classes (e.g., from <RzFancyThing class="mt-4">)
        s.Container,             // Base classes from the style provider
        s.GetSizeCss(Size),      // Dynamic classes based on parameters
        IsActive ? s.Active : null // Conditional classes
    );
}
```

TwMerge deduplicates utilities and correctly appends any user-supplied `class` from `AdditionalAttributes`.

### 6.4 Defining size / variant helpers in Style Providers

Enums for variants (like `Size`, `ButtonVariant`) should be defined globally in RizzyUI (e.g., `RizzyUI/Components/Variants.cs`).
Style provider methods (`GetSizeCss`, `GetVariantCss`) take these enums.

```csharp
// In DefaultRzFancyThingStyles.cs
public override string GetSizeCss(Size sz) => sz switch // Using global 'Size' enum
{
    Size.Small => "text-xs py-1 px-2",    // Assuming 'Small' is part of the global 'Size' enum
    Size.Medium => "text-sm py-2 px-3",   // Assuming 'Medium' is part of the global 'Size' enum
    Size.Large => "text-base py-3 px-4",  // Assuming 'Large' is part of the global 'Size' enum
    _             => "text-sm py-2 px-3" // Default case
};
```

### 6.5 Overriding in a custom theme

A consumer can replace the default style provider inside their own `Theme` subclass:

```csharp
public sealed class MyTheme : RzTheme
{
    public MyTheme() : base("MyTheme", "my-theme")
    {
        // Assuming RzFancyThing is the property name in RzTheme for RzFancyThingStylesBase
        RzFancyThing = new MyFancyThingStyles(this);
    }
}

public sealed class MyFancyThingStyles : DefaultRzFancyThingStyles // Or RzStylesBase.RzFancyThingStylesBase
{
    public MyFancyThingStyles(RzTheme t) : base(t) { }

    public override string Container =>
        "inline-flex gap-2 rounded-md px-4 py-2 "
      + "bg-gradient-to-r from-primary to-secondary text-primary-foreground"; // Still uses semantic tokens
}
```

Because all classes still use the plugin’s semantic tokens (like `from-primary`, `text-primary-foreground`), light/dark support is automatic.

### 6.6 No purge / safelist step needed

Tailwind 4’s JIT engine and the RizzyUI build process handle class discovery. Any utility string that appears in a style provider or `.razor` file is automatically retained.

---

## 7. Styling providers (`RzStylesBase`, `Default...Styles.cs`)

1.  **Abstract base** goes into `src/RizzyUI/Styles/RzStylesBase.cs` (add a new nested class):

   ```csharp
   // In RzStylesBase.cs
   public abstract partial class RzStylesBase
   {
       public abstract class RzFancyThingStylesBase
       {
           protected RzFancyThingStylesBase(RzTheme theme) { Theme = theme; }
           protected RzTheme Theme { get; }

           public abstract string Container { get; }
           public abstract string Active { get; }
           public abstract string IconStyle { get; }

           public abstract string GetSizeCss(Size sz); // Using global Size enum
       }
   }
   ```

2.  **Default implementation** (e.g., `src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs`):

   ```csharp
   // In DefaultRzFancyThingStyles.cs
   namespace RizzyUI;

   public sealed class DefaultRzFancyThingStyles : RzStylesBase.RzFancyThingStylesBase
   {
       public DefaultRzFancyThingStyles(RzTheme theme) : base(theme) { }

       public override string Container => "inline-flex items-center rounded-full px-3 py-1 bg-background text-foreground"; // Uses semantic tokens
       public override string Active => "ring-2 ring-primary"; // Uses semantic token
       public override string IconStyle => "size-5 text-muted-foreground"; // Uses semantic token

       public override string GetSizeCss(Size sz) => sz switch // Using global Size enum
       {
           Size.Small => "text-xs",
           Size.Medium => "text-sm",
           Size.Large => "text-base",
           _ => "text-sm"
       };
   }
   ```

> **Why the constructor parameter?**
> Passing `RzTheme theme` lets any style object consult **other** style providers (`theme.RzButton`, etc.), enabling cross-component consistency. Properties in the abstract base should typically be `abstract string` or `abstract/virtual string Get...Css()` to enforce implementation by themes.

---

## 8. Accessibility Best Practices

Ensuring components are accessible is paramount. LLMs must generate components that strive to adhere to WCAG standards where applicable.

*   **Semantic HTML:**
    *   Use the most appropriate HTML element for the component's role. The `Element` property in `RzComponent` (defaulting to "div") should be overridden in `OnInitialized()` if a more semantic tag like `<nav>`, `<button>`, `<aside>`, etc., is suitable.
    *   Example: A navigation component should use `<nav>`, a button should use `<button>` or `<a>` with `role="button"`.

*   **ARIA Attributes:**
    *   **Roles:** Apply appropriate `role` attributes (e.g., `role="alert"`, `role="dialog"`, `role="menuitem"`, `role="tab"`, `role="switch"`). The root element pattern in §2 can have its `role` set via `AdditionalAttributes` or directly if static.
    *   **Labels & Descriptions:**
        *   Every interactive component MUST have an accessible name. This is typically provided via an `AriaLabel` parameter in the `.razor.cs` file. If the component has visible text that serves as its label, ensure it's associated (e.g., `<label for="...">` for form inputs, or `aria-labelledby` pointing to the ID of the visible text element).
        *   Use `aria-label` for concise labels when visible text is insufficient or absent (e.g., icon-only buttons).
        *   Use `aria-labelledby` to associate the component with existing visible text that acts as its label.
        *   Use `aria-describedby` to associate the component with descriptive text that provides more context.
    *   **States & Properties:** Use ARIA attributes to convey state:
        *   `aria-expanded` (for accordions, dropdowns, collapsible sections)
        *   `aria-selected` (for tabs, items in a listbox)
        *   `aria-current` (for pagination, breadcrumbs, steps - e.g., `aria-current="page"` or `aria-current="step"`)
        *   `aria-pressed` (for toggle buttons)
        *   `aria-hidden` (use judiciously, e.g., for purely decorative icons or off-screen content)
        *   `aria-modal="true"` (for modal dialogs)
        *   `aria-live` (for dynamic content updates, e.g., alerts, status messages)
        *   `aria-controls` (to link a control to the region it manages)
        *   For inputs: `aria-required`, `aria-invalid`.

*   **Keyboard Navigation & Focus Management:**
    *   All interactive elements MUST be keyboard operable.
    *   Use `tabindex="0"` for custom interactive elements that should be in the tab order.
    *   Use `tabindex="-1"` for elements that should be programmatically focusable but not in the default tab order.
    *   For composite widgets (like dropdowns, menus, tabs), implement appropriate keyboard navigation patterns (arrow keys, Home/End, Enter/Space). This is often handled by the Alpine.js logic.
    *   Ensure a visible focus indicator. RizzyUI themes generally provide this, but be mindful if overriding default focus styles.
    *   For modals and dropdowns that trap focus, use Alpine's `x-trap.inert="isOpen"` directive.

*   **Screen Reader Text:**
    *   Use the `sr-only` Tailwind class (or equivalent CSS) for text that should only be available to screen readers (e.g., providing context for an icon button).
        ```razor
        <button aria-label="@Localizer["RzComponentName.CloseButtonAriaLabel"]">
            <Blazicon Svg="@MdiIcon.Close" aria-hidden="true" />
            <span class="sr-only">@Localizer["RzComponentName.CloseButtonSrText"]</span> @* Alternative if aria-label isn't sufficient *@
        </button>
        ```

*   **Images & Icons:**
    *   Decorative icons should have `aria-hidden="true"`.
    *   Informative icons (if not accompanied by text) need an accessible label (e.g., via `aria-label` on the button or a `sr-only` span).
    *   Images (e.g., `RzAvatar`) must have meaningful `alt` text or `aria-label`.

*   **Forms:**
    *   Associate labels with form controls using `<label for="...">` and matching `id` on the input. `RzFieldLabel` handles this if `For` is provided.
    *   Use `fieldset` and `legend` for groups of related controls (e.g., radio button groups).
    *   Provide clear validation messages, associated with inputs using `aria-describedby`. `RzValidationMessage` typically handles this.

---

## 9. Localization

All user-facing strings within components (default labels, ARIA labels, titles, placeholders, etc.) MUST be localizable.

*   **Accessing Localizer:**
    *   The `RzComponent` base class injects `IStringLocalizer<RizzyLocalization> Localizer`. Use this to retrieve localized strings.

*   **Resource Key Convention:**
    *   Resource keys should follow the pattern: `ComponentName.ResourceKeyName`.
    *   Example: For a default ARIA label in `RzFancyThing`, the key would be `RzFancyThing.DefaultAriaLabel`.
    *   Example: For a "Close" button text, `RzModal.CloseButtonText`.

*   **Parameter Defaults & Localization:**
    *   Component parameters that accept user-facing strings (e.g., `AriaLabel`, `Title`, `Placeholder`) should allow users to provide their own values.
    *   If the user does *not* provide a value for such a parameter (i.e., it remains `null` or its default), the component should attempt to load a localized default string.
    *   This is typically done in `OnInitialized()` and/or `OnParametersSet()`:
        ```csharp
        // In RzFancyThing.razor.cs
        [Parameter] public string? AriaLabel { get; set; }
        [Parameter] public string? PlaceholderText { get; set; }

        protected override void OnInitialized()
        {
            base.OnInitialized();
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }

        protected override void OnParametersSet()
        {
            base.OnParametersSet();
            // If parameters can be changed after init and might become null
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }
        ```

*   **Providing New Resource Strings (LLM Output):**
    *   When generating a new component that introduces new localizable strings, the LLM MUST provide the English (default culture) versions of these strings.
    *   These should be presented in a clear key-value format, suitable for a developer to copy into the `src/RizzyUI/Resources/RizzyLocalization.resx` file.
    *   This information should be provided *outside* the main ````output ... ```` block, typically alongside the "Manual Edits Required for Theme Integration" section.

    **Example Presentation for New Resource Strings:**

    ````markdown
    **New English Localization Strings for `RizzyLocalization.resx`:**

    Please add the following entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

    | Name                               | Value                         | Comment (Optional)                  |
    |------------------------------------|-------------------------------|-------------------------------------|
    | `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
    | `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |
    | `RzAnotherComponent.SomeText`      | `Another default string`      |                                     |

    Alternatively, in raw .resx XML format:
    ```xml
    <data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
      <value>Fancy interactive element</value>
      <comment>Default ARIA label for RzFancyThing</comment>
    </data>
    <data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
      <value>Enter fancy text here...</value>
      <comment>Placeholder for RzFancyThing input</comment>
    </data>
    <data name="RzAnotherComponent.SomeText" xml:space="preserve">
      <value>Another default string</value>
    </data>
    ```
    ````

---

## 10. Alpine.js Integration & Asset Bundling

## 10. Alpine.js Integration & Asset Bundling

RizzyUI components that require client-side interactivity leverage Alpine.js. The integration follows a specific pattern for defining components, managing their assets, and ensuring CSP compliance.

*   **Alpine Child-Container Convention (in `.razor` file):**
    If a RizzyUI component uses Alpine.js, its root `<HtmlElement>` in the `.razor` file MUST contain a direct child `<div>` with the following attributes. This `div` serves as the root for the Alpine component.
    ```razor
    <HtmlElement Element="@EffectiveElement" id="@Id" class="@RootClass()" @attributes="@AdditionalAttributes">
        <div data-alpine-root="@Id" @* Crucial: Must match the Blazor component's @Id *@
             x-data="rzFancyThing"   @* Alpine component name, e.g., 'rzComponentName' *@
             data-assets="@_assets"   @* Serialized JSON string of asset URLs for this component *@
             data-nonce="@Nonce">     @* CSP nonce for inline scripts/styles loaded by this component *@
            @* Alpine-interactive content, x-ref, x-on:, :class, etc. goes here *@
        </div>
    </HtmlElement>
    ```
    *   `data-alpine-root="@Id"`: This attribute is **essential**. It MUST exactly match the Blazor component's `@Id`. It's used by the `Rizzy.$data()` helper to locate the Alpine component's scope.
    *   `x-data="rzComponentName"`: Specifies the name of the Alpine.js component to initialize on this `div`. The name should follow the `rzComponentName` convention.
    *   `data-assets="@_assets"`: A JSON stringified array of asset URLs (JavaScript/CSS) that this specific Alpine component instance needs. This is populated from the C# code-behind.
    *   `data-nonce="@Nonce"`: The CSP nonce value, passed from the C# `RzComponent` base. This is used by the `require` utility to load assets in a CSP-compliant manner.

*   **Asset Declaration (in `.razor.cs` file):**
    *   Each Blazor component that uses an Alpine module should define a `public static readonly string[] DefaultAssets` array. This array lists the URLs of JavaScript or CSS files required by its Alpine counterpart.
    *   Use `Constants.ContentUrl("path/to/asset.js")` for assets internal to the RizzyUI library.
        ```csharp
        // In RzFancyThing.razor.cs
        public static readonly string[] DefaultAssets =
        {
            Constants.ContentUrl("js/lib/some-dependency.js"), // Example third-party lib
            // If the Alpine module itself is in a separate file (less common now):
            // Constants.ContentUrl("js/rzfancymodule.js")
        };
        // If no external assets are needed by the Alpine component:
        // public static readonly string[] DefaultAssets = Array.Empty<string>();
        ```
    *   In the `OnInitialized()` or `OnParametersSet()` method of the Blazor component, serialize this `DefaultAssets` array (or a dynamically determined `ComponentAssets` parameter) into a private string field (e.g., `_assets`). This `_assets` field is then bound to the `data-assets` attribute in the Razor markup.
        ```csharp
        // In RzFancyThing.razor.cs
        private string _assets = string.Empty; // Backing field for data-assets

        [Parameter] public string[] ComponentAssets { get; set; } // Allow overriding default assets

        protected override void OnInitialized()
        {
            base.OnInitialized();
            // Serialize assets for the Alpine component
            _assets = System.Text.Json.JsonSerializer.Serialize(ComponentAssets ?? DefaultAssets);
        }
        ```

*   **Alpine Component Definition (Individual JavaScript File):**
    *   Each new Alpine component (e.g., `rzFancyThing`) MUST have its logic defined in a **new, separate JavaScript file**.
    *   Location: `packages/rizzyui/src/js/lib/components/rzFancyThing.js` (replace `rzFancyThing` with the actual component name).
    *   This file MUST export a default function.
        *   The first argument to this function will always be the `Alpine` instance.
        *   If the component needs to dynamically load assets (using the `data-assets` attribute), the function should accept `require` as a second argument. This `require` is the `rizzyRequire` utility provided by `components.js`.
    *   Inside this exported function, the Alpine component is defined using `Alpine.data('rzFancyThing', () => ({ /* component logic */ }));`. The name used here (e.g., `'rzFancyThing'`) MUST match the `x-data` attribute in the Razor markup.
    *   The `init()` method within the Alpine data object is typically responsible for:
        1.  Retrieving `assetsToLoad` by parsing `this.$el.dataset.assets`.
        2.  Retrieving `nonce` from `this.$el.dataset.nonce`.
        3.  If `assetsToLoad` is not empty and the `require` function was passed in, call `require(assetsToLoad, { success: callback, error: errCallback }, nonce)`.
        4.  Place any Alpine initialization logic that *depends* on these external assets (e.g., initializing a third-party library like Flatpickr or Highlight.js) inside the `success` callback of `require`.
        5.  Other initialization logic (e.g., setting up internal state, watchers) can be placed directly in `init()` or in a separate method called from `init()` (either before or after `require`, or within its callbacks, as appropriate).

    **Example: `packages/rizzyui/src/js/lib/components/rzFancyThing.js`**
    ```javascript
    // This component demonstrates conditional asset loading.
    // If data-assets is empty or 'require' is not provided, it proceeds without loading.
    export default function(Alpine, require) { // 'require' is optional here
        Alpine.data('rzFancyThing', () => ({
            someProperty: 'initialValue',
            assetsLoaded: false,

            init() {
                const assetsToLoad = JSON.parse(this.$el.dataset.assets || '[]');
                const nonce = this.$el.dataset.nonce || '';
                const self = this; // Retain 'this' context for callbacks

                // Example: Read an initial value from a data attribute
                this.someProperty = this.$el.dataset.initialFancyValue || 'default fancy value';

                if (assetsToLoad.length > 0 && typeof require === 'function') {
                    console.log(`rzFancyThing (${this.$el.id}): Attempting to load assets:`, assetsToLoad);
                    require(assetsToLoad, {
                        success: function() {
                            console.log(`rzFancyThing (${self.$el.id}): Assets loaded successfully.`);
                            self.assetsLoaded = true;
                            // Example: Initialize a library if 'some-library.js' was loaded
                            // if (window.SomeLibrary) {
                            //     self.libraryInstance = new window.SomeLibrary(self.$el.querySelector('.target-for-lib'));
                            // }
                            self.setupInteractivity(); // Call main logic after assets
                        },
                        error: function(err) {
                            console.error(`rzFancyThing (${self.$el.id}): Failed to load assets.`, err);
                            // Decide if setupInteractivity should still run or if it's critical
                            self.setupInteractivity(); // Or handle error state
                        }
                    }, nonce);
                } else {
                    // No assets to load, or 'require' function not available/needed by this component.
                    // Proceed with non-asset-dependent setup.
                    console.log(`rzFancyThing (${this.$el.id}): No assets to load or require not provided.`);
                    self.setupInteractivity();
                }
            },

            setupInteractivity() {
                // Main Alpine logic that runs (potentially after assets are loaded)
                console.log(`rzFancyThing (${this.$el.id}): Setting up interactivity. Current someProperty:`, this.someProperty);
                
                // Example: Watch for changes to 'someProperty'
                // this.$watch('someProperty', (value) => {
                //    console.log(`rzFancyThing (${this.$el.id}): someProperty changed to:`, value);
                // });
            },

            updateFancyProperty(newValue) {
                this.someProperty = newValue;
            }
            // ... other methods and properties for rzFancyThing
        }));
    }
    ```

*   **Alpine Component Registration (in `packages/rizzyui/src/js/lib/components.js`):**
    *   The newly created component registration function (e.g., `registerRzFancyThing` which is the default export from `rzFancyThing.js`) MUST be imported into `packages/rizzyui/src/js/lib/components.js`.
    *   It must then be called within the `registerComponents(Alpine)` function in `components.js`. Pass the `Alpine` instance. If the component's registration function (e.g., `export default function(Alpine, require)`) expects the `require` utility, pass `rizzyRequire` (which is `loadjs` aliased as `require` in this file) as the second argument.

    **Example: Modifying `packages/rizzyui/src/js/lib/components.js`**
    ```javascript
    // packages/rizzyui/src/js/lib/components.js
    import loadjs from "./loadjs/loadjs.js"; // Underlying asset loader

    // ... other existing component imports ...
    import registerRzAccordion from './components/rzAccordion.js';
    import registerRzFancyThing from './components/rzFancyThing.js'; // <-- NEW IMPORT

    // ... (rizzyRequire function definition using loadjs) ...
    // async function generateBundleId(paths) { ... }
    // function rizzyRequire(paths, callbackFn, nonce) { ... }


    function registerComponents(Alpine) {
        // ... other existing component registrations ...
        registerRzAccordion(Alpine); // Example of a component not needing 'require'
        
        // Register the new component.
        // Pass 'rizzyRequire' if its definition function expects it.
        registerRzFancyThing(Alpine, rizzyRequire); // <-- NEW REGISTRATION
    }

    export { registerComponents, rizzyRequire as require };
    ```


---

## 11. Unit tests (bUnit) (IMPORTANT: ONLY ON REQUEST)

When unit tests are specifically requested for a new or modified component, they should be generated using bUnit and adhere to the following guidelines. Tests ensure component correctness, accessibility, and integration with the RizzyUI theme system and Alpine.js patterns.

*   **File Location and Naming:**
    *   Test files should reside in the `src/RizzyUI.Tests/Components/` directory, mirroring the component's path under `src/RizzyUI/Components/`.
    *   Example: For `src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor`, the test file would be `src/RizzyUI.Tests/Components/Fancy/RzFancyThingTests.cs`.
    *   Use file-scoped namespaces matching the directory structure within the test project (e.g., `namespace RizzyUI.Tests.Components.Fancy;`).

*   **Test Class Structure:**
    *   Test classes MUST inherit from `BunitAlbaContext`.
    *   Test classes MUST implement `IClassFixture<WebAppFixture>`.
    *   The constructor MUST accept a `WebAppFixture` parameter and pass it to the `base(fixture)` constructor.
    *   The `WebAppFixture` (via `BunitAlbaContext`) handles the setup of essential services like `IHttpContextAccessor`, `IRizzyNonceProvider`, and automatically calls `AddRizzyUI()`, which registers `TwMerge` and the default `RzTheme`.

    ```csharp
    // Example: src/RizzyUI.Tests/Components/Fancy/RzFancyThingTests.cs
    using Bunit;
    using Microsoft.AspNetCore.Components; // For RenderFragment, etc.
    using RizzyUI.Components.Fancy.RzFancyThing; // Import the component being tested
    // Add other necessary using statements (e.g., Blazicons, System.Linq.Expressions)

    namespace RizzyUI.Tests.Components.Fancy; // File-scoped namespace

    public class RzFancyThingTests : BunitAlbaContext, IClassFixture<WebAppFixture>
    {
        // private readonly IAlbaHost _host; // Only needed if testing HTTP interactions via Alba

        public RzFancyThingTests(WebAppFixture fixture) : base(fixture)
        {
            // _host = fixture.Host; // Store if needed for Alba HTTP tests
            // Services.AddRizzyUI(); // This is ALREADY CALLED by WebAppFixture, no need to call again.
        }

        // ... Test methods ...
    }
    ```

*   **Test Method Guidelines (`[Fact]` or `[Theory]`):**

    1.  **Default Render Test:**
        *   Render the component with minimal or no parameters (or only required ones like `Id`).
        *   Assert the root element exists and has the correct default tag (e.g., `div` unless overridden).
        *   Verify the `Id` is correctly applied.
        *   Assert that `RootClass()` applies the expected base classes from the theme's style provider.
        *   Assert default ARIA attributes (e.g., `role`, default `aria-label` if applicable from localization).
        *   If the component uses Alpine.js:
            *   Assert the presence of the Alpine child-container (`div[data-alpine-root='@Id']`).
            *   Assert `x-data` attribute matches the component's Alpine module name.
            *   Assert `data-assets` attribute is present and contains the JSON serialized `DefaultAssets` from the component's `.razor.cs`.
            *   Assert `data-nonce` attribute is present.

    2.  **Parameter Variation Tests:**
        *   For each significant parameter, create tests to verify its effect on rendering.
        *   **CSS Classes:** Use `cut.Find("selector").ClassList.Contains("expected-class")` or `cut.Find("selector").Should().HaveClass("expected-class")` (if using FluentAssertions with bUnit extensions). Verify that dynamic style provider methods (e.g., `GetSizeCss`, `GetVariantCss`) are correctly applying classes.
        *   **ARIA Attributes:** Assert that ARIA attributes change correctly based on parameters (e.g., `aria-expanded`, `aria-pressed`, `aria-current`).
        *   **Conditional Rendering:** Assert elements are rendered or hidden based on boolean parameters (e.g., `ShowIcon`, `Dismissable`).
        *   **Content Parameters:**
            *   Test `Label` parameter vs. `ChildContent` precedence if applicable.
            *   Verify `RenderFragment` parameters like `ChildContent`, `LeadingIcon`, `TrailingIcon`, `HeaderContent`, `FooterContent` are rendered correctly.
            *   For icons (`SvgIcon?`), assert that `<Blazicon Svg="@IconParameter" ... />` is rendered with appropriate classes and `aria-hidden="true"` if decorative.

    3.  **Accessibility Tests:**
        *   Explicitly verify that `AriaLabel` parameter, when set, overrides any default.
        *   Verify that if `AriaLabel` is *not* set, the component applies a default localized ARIA label (retrieved via `Localizer["ComponentName.DefaultAriaLabel"]`).
        *   Check for other critical ARIA attributes relevant to the component's role.

    4.  **Interaction Tests (if applicable):**
        *   For interactive components (e.g., buttons, toggles), simulate user actions:
            *   `cut.Find("button").Click()`
            *   `cut.Find("input").Change("new value")`
        *   Assert that `EventCallback` parameters are invoked.
        *   Assert that component state (if exposed or reflected in markup/ARIA) changes as expected.

    5.  **Styling and `AdditionalAttributes`:**
        *   Verify that classes passed via `AdditionalAttributes` (e.g., `<RzFancyThing class="my-custom-style">`) are correctly merged into the root element's class list by `RootClass()` and `TwMerge`.
        *   Verify other `AdditionalAttributes` are passed through to the root element.

    6.  **Localization of Defaults:**
        *   Test that default text values (e.g., for `AriaLabel`, `Placeholder`, `Title` if not provided by user) are correctly sourced from `Localizer["ComponentName.ResourceKey"]`.

*   **bUnit Assertions:**
    *   Use `cut.Find("css-selector")` to locate elements.
    *   Use `element.MarkupMatches("expected html")` for precise structural and attribute checks. Use `diff.MissingAttributes` or `diff.MissingChildren` from the diff result for debugging.
    *   Use `element.ClassList` for asserting CSS classes.
    *   Use `element.GetAttribute("attribute-name")` for asserting attribute values.
    *   Use `cut.Instance` to access the component instance's properties and methods if needed (e.g., to check the `_assets` field).

*   **Example Test Snippet (Default Render with Alpine):**
    ```csharp
    [Fact]
    public void DefaultRender_ShouldRenderCorrectAlpineAttributesAndBaseClasses()
    {
        // Arrange
        var expectedId = "fancy-default-alpine";
        var expectedDefaultLabel = Localizer["RzFancyThing.DefaultAriaLabel"].Value; // Get localized default

        // Act
        var cut = RenderComponent<RzFancyThing>(parameters => parameters
            .Add(p => p.Id, expectedId)
        );

        // Assert - Root Element
        var rootElement = cut.Find($"div#{expectedId}"); // Assuming default Element is "div"
        Assert.NotNull(rootElement);
        Assert.Equal(expectedDefaultLabel, rootElement.GetAttribute("aria-label"));
        // Example: Assert base class from theme (actual class depends on RzFancyThingStyles.Container)
        // Assert.Contains("fancy-thing-base-class", rootElement.ClassList);

        // Assert - Alpine Child Container
        var alpineRoot = cut.Find($"div[data-alpine-root='{expectedId}']");
        Assert.NotNull(alpineRoot);
        Assert.Equal("rzFancyThing", alpineRoot.GetAttribute("x-data")); // Matches Alpine component name
        
        // Assert data-assets
        var expectedAssetsJson = System.Text.Json.JsonSerializer.Serialize(RzFancyThing.DefaultAssets);
        Assert.Equal(expectedAssetsJson, alpineRoot.GetAttribute("data-assets"));
        
        // Assert data-nonce (presence is usually enough, value is dynamic)
        Assert.NotNull(alpineRoot.GetAttribute("data-nonce"));
    }
    ```

*   **Output Format:**
    *   When tests are requested, the generated `.cs` test file(s) should be included within the `<files>` block of the ````output ... ```` section, just like component files.

---

## 12. The output block example (canonical)

When asked to generate *RzFancyThing*, your response **must** contain an `output` block like this (all XML docs omitted for brevity):

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">…</file>
  @* If new Alpine module needed and LLM is instructed to generate JS: *@
  <file path="packages/rizzyui/src/js/lib/components/rzFancyThing.js">
    // Content of the new rzFancyThing.js file
    // Example:
    // export default function(Alpine, require) { // 'require' is optional
    //     Alpine.data('rzFancyThing', () => ({
    //         // ... component logic ...
    //         init() {
    //             const assets = JSON.parse(this.$el.dataset.assets || '[]');
    //             const nonce = this.$el.dataset.nonce || '';
    //             if (assets.length > 0 && typeof require === 'function') {
    //                 require(assets, { /* callbacks */ }, nonce);
    //             } else {
    //                 this.setupInteractivity();
    //             }
    //         },
    //         setupInteractivity() { /* main logic */ }
    //     }));
    // }
  </file>
</files>
```
````

---

## 13. What **not** to place in the `output` block

Changes to **global theme scaffolding** (`RzTheme.cs`, `RzTheme.StyleProviders.cs`, `RzStylesBase.cs` additions to the *partial class itself*) and **localization resource files** (`RizzyLocalization.resx`) go in a **separate, preface section** that appears *before* the `output` block.
That section must identify each existing file and show the lines/entries to insert, either as a diff or as verbatim code snippets/tables.
Never embed these edits in `<file>` tags because CI merges them manually.

---

## 14. Theme integration & Localization (cross-file edits the LLM must describe)

Whenever a new style provider (e.g., `RzFancyThingStylesBase` and its default implementation) is introduced, or new localizable strings are needed, or a new JavaScript Alpine component is created, instruct the user accordingly:

````markdown
**Manual Edits Required for Theme, Localization, and JavaScript Integration:**

**Theme Integration:**

1.  **Add to `src/RizzyUI/Styles/RzStylesBase.cs`**:
    ```csharp
    // ... (inside public abstract partial class RzStylesBase)
    public abstract class RzFancyThingStylesBase
    {
        // ... (as defined in §7.1 of the guide)
    }
    ```

2.  **Add to `src/RizzyUI/RzTheme.StyleProviders.cs`**:
    ```csharp
    // ... (inside public partial class RzTheme)
    /// <summary>
    /// Gets the style definitions for the <see cref="RzFancyThing" /> component.
    /// </summary>
    public virtual RzStylesBase.RzFancyThingStylesBase RzFancyThing { get; }
    ```

3.  **Add to `src/RizzyUI/RzTheme.cs` constructor**:
    ```csharp
    // ... (inside public RzTheme(string name, string themeCode) constructor)
    RzFancyThing = new DefaultRzFancyThingStyles(this);
    ```

**Localization:**

Please add the following English (default culture) entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

| Name                               | Value                         | Comment (Optional)                  |
|------------------------------------|-------------------------------|-------------------------------------|
| `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
| `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |

Alternatively, in raw .resx XML format:
```xml
<data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
  <value>Fancy interactive element</value>
  <comment>Default ARIA label for RzFancyThing</comment>
</data>
<data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
  <value>Enter fancy text here...</value>
  <comment>Placeholder for RzFancyThing input</comment>
</data>
```

**JavaScript Integration (if new Alpine component `rzFancyThing` was created in `packages/rizzyui/src/js/lib/components/rzFancyThing.js`):**

1.  **Modify `packages/rizzyui/src/js/lib/components.js`**:
    *   Add an import statement for your new component module at the top of the file:
        ```javascript
        // ... other existing component imports ...
        import registerRzFancyThing from './components/rzFancyThing.js'; 
        ```
    *   Call the imported registration function within the `registerComponents(Alpine)` function:
        ```javascript
        function registerComponents(Alpine) {
            // ... other existing component registrations ...
            
            // Register the new RzFancyThing component.
            // Pass 'rizzyRequire' as the second argument if your 
            // rzFancyThing.js's exported function expects 'require'.
            registerRzFancyThing(Alpine, rizzyRequire); 
            // If rzFancyThing.js does not use 'require', call it as:
            // registerRzFancyThing(Alpine); 
        }
        ```
````

---

## 15. Final checklist for the LLM

* CRITICAL - Only generate or modify code directly related to the task requested. You are not permitted to modify code outside the scope of the request.
* Prepend the cross-file edit instructions for theme and localization if needed (§14).
* Provide an `output` block for new or replaced component-specific files only (§1, §12).
* Use the root element pattern (§2) and Alpine child-container convention if Alpine is used (§10).
* `.razor` files: Use direct `@Theme...` access for internal element styling (§3, §5). Implement accessibility attributes (§8).
* `.razor.cs` files: Start with `/// <summary>...</summary>` for the class, ensure public members have `<summary>`, use `TwMerge` in `RootClass()`, define `DefaultAssets`, serialize assets to `_assets` string, set `Element` if not "div", and handle default localized strings for parameters like `AriaLabel` (§4, §9).
* Styling providers: Abstract base in `RzStylesBase.cs` and default implementation in its own file; constructor takes `RzTheme` (§6, §7).
* Asset bundling: Follow the C# -> `data-assets` -> JS `require()` flow (§10).
* Include unit tests *only* when specifically requested (§11).
* Adhere to all specified conventions and avoid manual concatenation of class strings.
* Do not include comments in Razor markup.
* Do not add comments to using statements.
* Any comments added within code blocks should be production-ready and not for commentary on changes.

If all bullets are satisfied, **any** compliant LLM will produce RizzyUI-ready code.