# RizzyUI LLM-Authoring Guide

**Fully expanded specification for code-generation models — May 2025, rev 2.3**

---

## 0. Why this file exists

This guide is a **contract for any large-language model**—ChatGPT, Claude, Gemini, Azure OpenAI, etc.—that emits source code destined for the **RizzyUI** repository.
If the model follows every rule, a maintainer can:

1. Paste the generated files into `src/RizzyUI/…`.
2. Apply the indicated cross-file edits (see § 13).
3. Run `dotnet build`.

The solution should compile, pass unit tests, and conform to RizzyUI’s conventions **without manual tweaks**.

---

## 1. Output-file syntax (mandatory for new or replacement files)

When the user requests code, wrap each file in a single **`output` block** so automation scripts know where to save it.

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">
  <!-- Razor markup -->
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">
  // C# code-behind
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">
  // Tailwind style provider
  </file>
</files>
```
````

* Never nest `<files>` elements.
* Always close every `<file>` tag.
* If no new files are needed, **omit** the `output` block entirely.

---

## 2. Root element pattern (in every `.razor` file)

```razor
<HtmlElement Element="@Element"
             id="@Id"
             class="@RootClass()"
             @attributes="@AdditionalAttributes">
    @* Optional content here, like an Alpine child-container *@
</HtmlElement>
```

* `Element="@Element"` keeps the tag overridable (default "div" in `RzComponent`).
* `@Id` is required for HTMX, Alpine, and tests.
* `@RootClass()` is supplied by `RootClass()` in code-behind.
* **Always** write `@attributes="@AdditionalAttributes"` (note the leading `@`).
* **Never** use @* *@ comments inside Razor markup for elements that will be rendered.

---

## 3. `.razor` File Guidelines

*   **Namespace:** Add `@namespace RizzyUI`.
*   **Inheritance:** Add `@inherits RzComponent` (or appropriate base like `RzTypographyBase`).
*   **Root Element:** Use the pattern in §2.
*   **CSS Classes for Internal Elements:**
    *   For HTML elements *inside* the root element, access theme styles **directly** in their `class` attribute:
        *   Static styles: `class="@Theme.RzComponentName.InternalElementStyle"`
        *   Dynamic styles: `class="@Theme.RzComponentName.GetInternalElementVariantCss(Parameter)"`
        *   Combine with other static classes or conditional Alpine classes as needed.
*   **Alpine Integration:** See §9 for the Alpine child-container convention if Alpine is used.
*   **Accessibility:** Refer to §7 for accessibility guidelines.
*   **Localization:** Refer to §8 for localization guidelines.

---

## 4. Code-behind skeleton (`.razor.cs`)

```csharp
// src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs
using Microsoft.AspNetCore.Components; // For [Parameter], RenderFragment
using RizzyUI.Extensions;            // For TwMerge extensions
using Blazicons;                     // For SvgIcon (if used)
// Add other necessary using statements

namespace RizzyUI;

/// <summary>
/// Brief description of RzFancyThing and its purpose.
/// </summary>
public partial class RzFancyThing : RzComponent
{
    /// <summary>
    /// Gets or sets the content to be rendered inside the component.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets an optional leading icon for the component.
    /// </summary>
    [Parameter] public SvgIcon? LeadingIcon { get; set; }

    /// <summary>
    /// Gets or sets the size of the component. Defaults to Medium.
    /// </summary>
    [Parameter] public Size Size { get; set; } = Size.Medium;

    /// <summary>
    /// Gets or sets a value indicating whether the component is active.
    /// </summary>
    [Parameter] public bool IsActive { get; set; }

    /// <summary>
    /// Gets or sets the ARIA label for the component, providing an accessible name.
    /// If not set, a default localized label may be applied.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set Element = "button"; or other specific tag if not a div
        // Initialize AriaLabel with localized default if not provided by user (see §8)
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-apply default localized AriaLabel if AriaLabel parameter becomes null
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override string? RootClass()
    {
        var s = Theme.RzFancyThing; // Access the specific style provider for this component
        return TwMerge.Merge(
            AdditionalAttributes,
            s.Container,             // Base style from the provider
            s.GetSizeCss(Size),      // Dynamic style from the provider
            IsActive ? s.Active : null // Conditional style from the provider
        );
    }

    /// <summary>Assets that must load before the Alpine module (if any) boots.</summary>
    public static readonly string[] DefaultAssets =
    {
        // Example: Constants.ContentUrl("js/rzfancything.js")
        // If no JS, make this an empty array: = Array.Empty<string>();
    };

    // Other component logic, event callbacks, etc.
}
```

Important for the LLM:

* Start with `/// <summary>...</summary>` for the class.
* **All** public members get `<summary>` XML docs.
* Icons are passed as `SvgIcon?`; render with `<Blazicon Svg="@LeadingIcon" … />`.
* Use `TwMerge.Merge(...)`; never concatenate class strings manually in `RootClass()`.
* Default `Element` to "div" unless overridden in `OnInitialized()`.
* If `DefaultAssets` are not needed, initialize as `public static readonly string[] DefaultAssets = Array.Empty<string>();`.
* Include an `AriaLabel` parameter and initialize it with a localized default if not set by the user (see §8).

---

## 5. Icon-passing protocol

```razor
@* Inside RzFancyThing.razor *@
@if (LeadingIcon is not null)
{
    <Blazicon Svg="@LeadingIcon"
              class="@Theme.RzFancyThing.IconStyle"
              aria-hidden="true" /> @* Icons are often decorative *@
}
```

* Accept icons as `SvgIcon?`.
* Parameter names must be `LeadingIcon` or `TrailingIcon` as appropriate.
* Style the `<Blazicon>` using direct theme access in its `class` attribute.
* Add `aria-hidden="true"` if the icon is purely decorative and its meaning is conveyed by adjacent text or the component's `aria-label`.

---

## 6. Styling providers (`RzStylesBase`, `Default...Styles.cs`)

1.  **Abstract base** goes into `src/RizzyUI/Styles/RzStylesBase.cs` (add a new nested class):

   ```csharp
   // In RzStylesBase.cs
   public abstract partial class RzStylesBase
   {
       public abstract class RzFancyThingStylesBase
       {
           protected RzFancyThingStylesBase(RzTheme theme) { Theme = theme; }
           protected RzTheme Theme { get; }

           public abstract string Container { get; }
           public abstract string Active { get; }
           public abstract string IconStyle { get; } // Example for icon styling

           public abstract string GetSizeCss(Size sz);
       }
   }
   ```

2.  **Default implementation** (e.g., `src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs`):

   ```csharp
   // In DefaultRzFancyThingStyles.cs
   namespace RizzyUI;

   public sealed class DefaultRzFancyThingStyles : RzStylesBase.RzFancyThingStylesBase
   {
       public DefaultRzFancyThingStyles(RzTheme theme) : base(theme) { }

       public override string Container => "inline-flex items-center rounded-full px-3 py-1 bg-neutral-100 dark:bg-neutral-700";
       public override string Active => "ring-2 ring-primary dark:ring-primary";
       public override string IconStyle => "size-5 text-on-surface"; // Example

       public override string GetSizeCss(Size sz) => sz switch
       {
           Size.Small => "text-xs",
           Size.Medium => "text-sm",
           Size.Large => "text-base",
           _ => "text-sm"
       };
   }
   ```

> **Why the constructor parameter?**
> Passing `RzTheme theme` lets any style object consult **other** style providers (`theme.RzButton`, etc.), enabling cross-component consistency. Properties in the abstract base should typically be `abstract string` or `abstract/virtual string Get...Css()` to enforce implementation by themes.

---

## 7. Accessibility Best Practices

Ensuring components are accessible is paramount. LLMs must generate components that strive to adhere to WCAG standards where applicable.

*   **Semantic HTML:**
    *   Use the most appropriate HTML element for the component's role. The `Element` property in `RzComponent` (defaulting to "div") should be overridden in `OnInitialized()` if a more semantic tag like `<nav>`, `<button>`, `<aside>`, etc., is suitable.
    *   Example: A navigation component should use `<nav>`, a button should use `<button>` or `<a>` with `role="button"`.

*   **ARIA Attributes:**
    *   **Roles:** Apply appropriate `role` attributes (e.g., `role="alert"`, `role="dialog"`, `role="menuitem"`, `role="tab"`, `role="switch"`). The root element pattern in §2 can have its `role` set via `AdditionalAttributes` or directly if static.
    *   **Labels & Descriptions:**
        *   Every interactive component MUST have an accessible name. This is typically provided via an `AriaLabel` parameter in the `.razor.cs` file. If the component has visible text that serves as its label, ensure it's associated (e.g., `<label for="...">` for form inputs, or `aria-labelledby` pointing to the ID of the visible text element).
        *   Use `aria-label` for concise labels when visible text is insufficient or absent (e.g., icon-only buttons).
        *   Use `aria-labelledby` to associate the component with existing visible text that acts as its label.
        *   Use `aria-describedby` to associate the component with descriptive text that provides more context.
    *   **States & Properties:** Use ARIA attributes to convey state:
        *   `aria-expanded` (for accordions, dropdowns, collapsible sections)
        *   `aria-selected` (for tabs, items in a listbox)
        *   `aria-current` (for pagination, breadcrumbs, steps - e.g., `aria-current="page"` or `aria-current="step"`)
        *   `aria-pressed` (for toggle buttons)
        *   `aria-hidden` (use judiciously, e.g., for purely decorative icons or off-screen content)
        *   `aria-modal="true"` (for modal dialogs)
        *   `aria-live` (for dynamic content updates, e.g., alerts, status messages)
        *   `aria-controls` (to link a control to the region it manages)
        *   For inputs: `aria-required`, `aria-invalid`.

*   **Keyboard Navigation & Focus Management:**
    *   All interactive elements MUST be keyboard operable.
    *   Use `tabindex="0"` for custom interactive elements that should be in the tab order.
    *   Use `tabindex="-1"` for elements that should be programmatically focusable but not in the default tab order.
    *   For composite widgets (like dropdowns, menus, tabs), implement appropriate keyboard navigation patterns (arrow keys, Home/End, Enter/Space). This is often handled by the Alpine.js logic.
    *   Ensure a visible focus indicator. RizzyUI themes generally provide this, but be mindful if overriding default focus styles.
    *   For modals and dropdowns that trap focus, use Alpine's `x-trap.inert="isOpen"` directive.

*   **Screen Reader Text:**
    *   Use the `sr-only` Tailwind class (or equivalent CSS) for text that should only be available to screen readers (e.g., providing context for an icon button).
        ```razor
        <button aria-label="@Localizer["RzComponentName.CloseButtonAriaLabel"]">
            <Blazicon Svg="@MdiIcon.Close" aria-hidden="true" />
            <span class="sr-only">@Localizer["RzComponentName.CloseButtonSrText"]</span> @* Alternative if aria-label isn't sufficient *@
        </button>
        ```

*   **Images & Icons:**
    *   Decorative icons should have `aria-hidden="true"`.
    *   Informative icons (if not accompanied by text) need an accessible label (e.g., via `aria-label` on the button or a `sr-only` span).
    *   Images (e.g., `RzAvatar`) must have meaningful `alt` text or `aria-label`.

*   **Forms:**
    *   Associate labels with form controls using `<label for="...">` and matching `id` on the input. `RzFieldLabel` handles this if `For` is provided.
    *   Use `fieldset` and `legend` for groups of related controls (e.g., radio button groups).
    *   Provide clear validation messages, associated with inputs using `aria-describedby`. `RzValidationMessage` typically handles this.

---

## 8. Localization

All user-facing strings within components (default labels, ARIA labels, titles, placeholders, etc.) MUST be localizable.

*   **Accessing Localizer:**
    *   The `RzComponent` base class injects `IStringLocalizer<RizzyLocalization> Localizer`. Use this to retrieve localized strings.

*   **Resource Key Convention:**
    *   Resource keys should follow the pattern: `ComponentName.ResourceKeyName`.
    *   Example: For a default ARIA label in `RzFancyThing`, the key would be `RzFancyThing.DefaultAriaLabel`.
    *   Example: For a "Close" button text, `RzModal.CloseButtonText`.

*   **Parameter Defaults & Localization:**
    *   Component parameters that accept user-facing strings (e.g., `AriaLabel`, `Title`, `Placeholder`) should allow users to provide their own values.
    *   If the user does *not* provide a value for such a parameter (i.e., it remains `null` or its default), the component should attempt to load a localized default string.
    *   This is typically done in `OnInitialized()` and/or `OnParametersSet()`:
        ```csharp
        // In RzFancyThing.razor.cs
        [Parameter] public string? AriaLabel { get; set; }
        [Parameter] public string? PlaceholderText { get; set; }

        protected override void OnInitialized()
        {
            base.OnInitialized();
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }

        protected override void OnParametersSet()
        {
            base.OnParametersSet();
            // If parameters can be changed after init and might become null
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }
        ```

*   **Providing New Resource Strings (LLM Output):**
    *   When generating a new component that introduces new localizable strings, the LLM MUST provide the English (default culture) versions of these strings.
    *   These should be presented in a clear key-value format, suitable for a developer to copy into the `src/RizzyUI/Resources/RizzyLocalization.resx` file.
    *   This information should be provided *outside* the main ````output ... ```` block, typically alongside the "Manual Edits Required for Theme Integration" section.

    **Example Presentation for New Resource Strings:**

    ````markdown
    **New English Localization Strings for `RizzyLocalization.en.resx`:**

    Please add the following entries to `src/RizzyUI/Resources/RizzyLocalization.en.resx`:

    | Name                               | Value                         | Comment (Optional)                  |
    |------------------------------------|-------------------------------|-------------------------------------|
    | `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
    | `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |
    | `RzAnotherComponent.SomeText`      | `Another default string`      |                                     |

    Alternatively, in raw .resx XML format:
    ```xml
    <data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
      <value>Fancy interactive element</value>
      <comment>Default ARIA label for RzFancyThing</comment>
    </data>
    <data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
      <value>Enter fancy text here...</value>
      <comment>Placeholder for RzFancyThing input</comment>
    </data>
    <data name="RzAnotherComponent.SomeText" xml:space="preserve">
      <value>Another default string</value>
    </data>
    ```
    ````

---

## 9. Alpine.js Integration & Asset Bundling

*   **Special note**: Comments in the Razor markup below are for LLM guidance only and should not be included in the final output.  You are not allowed to ever include comments in Razor markup.
*   **Alpine Child-Container Convention:** If the component uses Alpine.js for interactivity, the root element in the `.razor` file (e.g., `<HtmlElement>`) MUST contain a direct child `<div>` with the following attributes:
    ```razor
    <HtmlElement ...>
        <div data-alpine-root="@Id"
             x-data="rzFancyThing" @* 'rzFancyThing' should match the Alpine component name *@
             data-assets="@_assets" @* Serialized JSON string of asset URLs *@
             data-nonce="@Nonce">
            @* Interactive content, x-ref, x-on:, :class, etc. goes here *@
        </div>
    </HtmlElement>
    ```
    *   `data-alpine-root` MUST exactly equal the component's `@Id`.
    *   `x-data` MUST reference the corresponding Alpine component name (e.g., `rzComponentName`).
    *   `data-assets` (see below) and `data-nonce` are crucial for dynamic asset loading and CSP.

*   **Asset Declaration (`.razor.cs`):**
    *   Define a `public static readonly string[] DefaultAssets` array in the component's code-behind.
    *   Populate it with URLs to necessary JS/CSS files. Use `Constants.ContentUrl("path/to/asset.js")` for library-internal assets.
        ```csharp
        public static readonly string[] DefaultAssets =
        {
            Constants.ContentUrl("js/lib/some-dependency.js"), // Example
            Constants.ContentUrl("js/rzfancything-alpine-module.js") // If module is separate
        };
        // Or if no assets: public static readonly string[] DefaultAssets = Array.Empty<string>();
        ```
    *   In `OnInitialized()` or `OnParametersSet()`, serialize this array to a private string field (e.g., `_assets`):
        ```csharp
        _assets = System.Text.Json.JsonSerializer.Serialize(ComponentAssets ?? DefaultAssets);
        ```

*   **Alpine Component Definition & Asset Loading (JavaScript):**
    *   New Alpine component logic (`Alpine.data('rzFancyThing', ...`) should be defined in `packages/rizzyui/src/js/lib/components.js`.
    *   Within the Alpine component's `init()` function:
        1.  Parse `this.$el.dataset.assets` (the JSON string from `data-assets`).
        2.  Parse `this.$el.dataset.nonce` (the string from `data-nonce`).
        3.  Use the `require(assets, { success: callback, error: errCallback }, nonce)` function (from `components.js`) to load these assets.
        4.  Place the actual Alpine initialization logic (event listeners, watches, etc.) inside the `success` callback of `require`.
        ```javascript
        // In packages/rizzyui/src/js/lib/components.js
        // Make sure 'require' is imported or available in this scope
        Alpine.data('rzFancyThing', () => ({
            someProperty: '',
            init() {
                const assets = JSON.parse(this.$el.dataset.assets || '[]');
                const nonce = this.$el.dataset.nonce || '';
                const self = this; // To retain 'this' context in callbacks

                require(assets, {
                    success: function() {
                        // Asset-dependent initialization logic here
                        // e.g., if an asset was Flatpickr: window.flatpickr(self.$refs.input, {});
                        console.log('Assets for rzFancyThing loaded.');
                        self.setupInteractivity();
                    },
                    error: function(err) {
                        console.error('Failed to load assets for rzFancyThing:', err);
                    }
                }, nonce);
            },
            setupInteractivity() {
                // Main Alpine logic that runs after assets are loaded
                // Example: this.someProperty = this.$el.dataset.initialValue;
            }
            // ... other methods and properties
        }));
        ```

---

## 10. Unit tests (bUnit) (IMPORTANT: ONLY ON REQUEST)

* Render the component and assert:
    * Presence of `data-alpine-root="@Id"` if an `x-data` section is utilized.
    * Correct JSON in `data-assets` if assets are used (verify `_assets` field after rendering).
    * Correct classes after parameter updates using `MarkupMatches`.
    * Correct ARIA attributes are present and have expected (or default localized) values.
    * Test behavior by invoking event handlers if applicable.

---

## 11. The output block example (canonical)

When asked to generate *RzFancyThing*, your response **must** contain an `output` block like this (all XML docs omitted for brevity):

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">…</file>
  @* If new Alpine module needed and LLM is instructed to generate JS: *@
  @* <file path="packages/rizzyui/src/js/lib/components.js">
    // Append the new Alpine.data('rzFancyThing', ...) to existing content.
    // LLM should indicate this is an APPEND operation.
    // ... existing content ...
    Alpine.data('rzFancyThing', () => ({ /* ... */ }));
  </file> *@
</files>
```
````
*(Note on JS output: If providing JS, clearly state if it's a new file or an append/modification to `components.js`. For simplicity, initially focus on Razor/C# generation; JS generation can be a separate, more complex step.)*

---

## 12. What **not** to place in the `output` block

Changes to **global theme scaffolding** (`RzTheme.cs`, `RzTheme.StyleProviders.cs`, `RzStylesBase.cs` additions to the *partial class itself*) and **localization resource files** (`RizzyLocalization.resx`) go in a **separate, preface section** that appears *before* the `output` block.
That section must identify each existing file and show the lines/entries to insert, either as a diff or as verbatim code snippets/tables.
Never embed these edits in `<file>` tags because CI merges them manually.

---

## 13. Theme integration & Localization (cross-file edits the LLM must describe)

Whenever a new style provider (e.g., `RzFancyThingStylesBase` and its default implementation) is introduced, or new localizable strings are needed, instruct the user accordingly:

````markdown
**Manual Edits Required for Theme Integration & Localization:**

**Theme Integration:**

1.  **Add to `src/RizzyUI/Styles/RzStylesBase.cs`**:
    ```csharp
    // ... (inside public abstract partial class RzStylesBase)
    public abstract class RzFancyThingStylesBase
    {
        // ... (as defined in §6.1 of the guide)
    }
    ```

2.  **Add to `src/RizzyUI/RzTheme.StyleProviders.cs`**:
    ```csharp
    // ... (inside public partial class RzTheme)
    /// <summary>
    /// Gets the style definitions for the <see cref="RzFancyThing" /> component.
    /// </summary>
    public virtual RzStylesBase.RzFancyThingStylesBase RzFancyThing { get; }
    ```

3.  **Add to `src/RizzyUI/RzTheme.cs` constructor**:
    ```csharp
    // ... (inside public RzTheme(string name, string themeCode) constructor)
    RzFancyThing = new DefaultRzFancyThingStyles(this);
    ```

**Localization:**

Please add the following English (default culture) entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

| Name                               | Value                         | Comment (Optional)                  |
|------------------------------------|-------------------------------|-------------------------------------|
| `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
| `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |

Alternatively, in raw .resx XML format:
```xml
<data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
  <value>Fancy interactive element</value>
  <comment>Default ARIA label for RzFancyThing</comment>
</data>
<data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
  <value>Enter fancy text here...</value>
  <comment>Placeholder for RzFancyThing input</comment>
</data>
```
````

---

## 14. Final checklist for the LLM

* CRITICAL - Only generate or modify code directly related to the task requested. You are not permitted to modify code outside the scope of the request.
* Prepend the cross-file edit instructions for theme and localization if needed (§13).
* Provide an `output` block for new or replaced component-specific files only (§1, §11).
* Use the root element pattern (§2) and Alpine child-container convention if Alpine is used (§9).
* `.razor` files: Use direct `@Theme...` access for internal element styling (§3, §5). Implement accessibility attributes (§7).
* `.razor.cs` files: Start with `/// <summary>...</summary>` for the class, ensure public members have `<summary>`, use `TwMerge` in `RootClass()`, define `DefaultAssets`, serialize assets to `_assets` string, set `Element` if not "div", and handle default localized strings for parameters like `AriaLabel` (§4, §8).
* Styling providers: Abstract base in `RzStylesBase.cs` and default implementation in its own file; constructor takes `RzTheme` (§6).
* Asset bundling: Follow the C# -> `data-assets` -> JS `require()` flow (§9).
* Include unit tests *only* when specifically requested (§10).
* Adhere to all specified conventions and avoid manual concatenation of class strings.
* Do not include comments in Razor markup.
* Do not add comments to using statements.
* Any comments added within code blocks should be production-ready and not for commentary on changes.

If all bullets are satisfied, **any** compliant LLM will produce RizzyUI-ready code.