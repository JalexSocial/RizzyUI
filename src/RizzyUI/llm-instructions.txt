# RizzyUI Component Creation Guidelines (LLM Instructions)

## Purpose
This document outlines the standard structure and conventions for creating new Razor components within the RizzyUI library. Adhering to these guidelines ensures consistency, maintainability, and proper integration with the theme system, Tailwind CSS, and Alpine.js.

## Core Principles
1.  **Two-File Structure:** Each component MUST consist of two files: a `.razor` file for markup and a `.razor.cs` file for code-behind logic.
2.  **Base Component:** All components MUST inherit from `RzComponent` (or an appropriate derived base class like `RzTypographyBase` if applicable).
3.  **Theme-Driven Styling:** Styling MUST be primarily driven by the `RzTheme` object available in the base class. CSS classes are accessed directly from the theme within the `.razor` file.
4.  **Direct Theme Access in Markup:** Access theme style strings and methods directly within the `.razor` file's `class` attributes (e.g., `class="@Theme.ComponentName.StyleName"` or `class="@Theme.ComponentName.GetVariantCss(Variant)"`).
5.  **Minimal Code-Behind for Styles:** The `.razor.cs` file should NOT contain simple pass-through properties that just return a value from the `Theme` object (e.g., `protected string ContainerClass => Theme.ComponentName.Container;` is **DISCOURAGED**). Only keep properties in the code-behind if they involve computation or complex logic beyond direct theme access.
6.  **Tailwind CSS & TwMerge:** Use Tailwind utility classes defined by the theme system. Use the `TwMerge` service (available via injection in `RzComponent`) in the `RootClass()` method to correctly merge base, variant, and user-provided classes.
7.  **Alpine.js for Interactivity:** Use Alpine.js for client-side interactivity. Define Alpine components (`Alpine.data(...)`) in `src/RizzyUI/wwwroot/js/lib/components.js`. Use `x-data`, `x-ref`, `x-on:`, `:class`, etc., in the `.razor` markup. Load necessary JS/CSS assets via the `require` utility function.

## File Structure
```
src/RizzyUI/Components/
└── ComponentCategory/
    └── RzComponentName/
        ├── RzComponentName.razor
        ├── RzComponentName.razor.cs
        └── Styling/ (Optional, only if custom default styles needed beyond base)
            └── DefaultRzComponentNameStyles.cs
```

## `.razor` File Guidelines
1.  **Namespace:** Add `@namespace RizzyUI`.
2.  **Inheritance:** Add `@inherits RzComponent` (or appropriate base).
3.  **Root Element:** Use `<HtmlElement Element="@Element" ...>` for flexibility or a specific semantic tag (e.g., `<button>`, `<nav>`) if required.
4.  **Attributes:** Splat `AdditionalAttributes` onto the root element: `@attributes="AdditionalAttributes"`.
5.  **CSS Classes:**
    *   Set the `class` attribute on the root element to `@RootClass()`.
    *   For internal elements, access theme styles **directly**:
        *   `class="@Theme.ComponentName.StyleName"` for static styles.
        *   `class="@Theme.ComponentName.GetVariantCss(Variant)"` for dynamic styles based on parameters.
        *   Combine multiple classes using string interpolation or `string.Join`.
    *   Use Alpine's `:class` directive for conditional classes based on component state (e.g., `:class="isActive ? 'active-class' : ''"`).
6.  **Content:** Use `@ChildContent` or specific named `[Parameter] RenderFragment` properties where appropriate.
7.  **Alpine Integration:** Use `x-data`, `x-ref`, `x-on:`, etc., as needed for interactivity. Pass data via `data-*` attributes if required by the Alpine component.
8.  **Blazicons:** Use `<Blazicon Svg="IconParameter"/>` for icons passed as parameters.

## `.razor.cs` File Guidelines
1.  **Namespace:** Add `namespace RizzyUI;`.
2.  **Inheritance:** Inherit from `RzComponent` (or appropriate base): `public partial class RzComponentName : RzComponent`. Use `sealed` if the class is not intended for further inheritance.
3.  **Parameters:** Define necessary `[Parameter]` properties for configuration, data binding (using `InputBase<T>` if applicable), and content (`RenderFragment`). Use `[EditorRequired]` where applicable.
4.  **Theme Access:** The `Theme` property is inherited from `RzComponent` and provides access to the current theme's style definitions.
5.  **NO Simple Style Wrappers:** **DO NOT** create properties like `protected string ContainerClass => Theme.ComponentName.Container;`. Access these directly in the `.razor` file.
6.  **KEEP Computed Properties:** *Keep* properties in the code-behind if they compute a value needed by the markup beyond direct theme access (e.g., `AlternateText` in `RzAvatar`, `AriaCheckedValue` in `RzToggle`).
7.  **`RootClass()` Method:** Override the `RootClass()` method to merge classes:
    ```csharp
    protected override string? RootClass()
    {
        // Access theme styles directly here if needed for the root element
        var styles = Theme.ComponentName;
        return TwMerge.Merge(AdditionalAttributes,
            styles.BaseStyle, // Example: Base class from theme
            styles.GetVariantCss(VariantParameter), // Example: Variant class
            ConditionalClass // Example: Class based on internal state
        );
    }
    ```
8.  **Lifecycle Methods:** Use `OnInitialized`, `OnParametersSet`, `OnAfterRender` as needed for component logic. Remember to call `base.` methods.
9.  **XML Documentation:** Add `<xmldoc>` comments to the class and `<summary>` comments to public parameters and properties.
10. **Helpers:** Internal helper methods or properties can be defined as needed.

## Styling (`RzStylesBase`, `Default...Styles`)
1.  **Abstract Definition:** Define the *structure* of the component's styles in `src/RizzyUI/Styles/RzStylesBase.cs` by adding a nested abstract class (e.g., `public abstract class RzComponentNameStylesBase { ... }`). Define abstract string properties for static classes and abstract methods (`Get...Css`) for dynamic classes based on parameters (like `Variant`, `Size`, `Orientation`).
2.  **Default Implementation:** Create a `DefaultRzComponentNameStyles.cs` file (e.g., in `Components/ComponentCategory/RzComponentName/Styling/`). Implement the abstract class, providing Tailwind class strings for each property and method. Use theme tokens (`Theme.Light.Primary`, `Theme.BorderRadius`, etc.) where appropriate.
3.  **Theme Integration:** Add a property to `RzTheme.StyleProviders.cs` (partial class of `RzTheme`) for your new style definition (e.g., `public virtual RzStylesBase.RzComponentNameStylesBase RzComponentName { get; }`). Initialize it in the `RzTheme` constructor using the default implementation (e.g., `RzComponentName = new DefaultRzComponentNameStyles(this);`).

## Theme Access in Components
The resolved theme (`RzTheme` instance) is available via the inherited `Theme` property in any component deriving from `RzComponent`.

## CSS Class Merging (`TwMerge`)
The `TwMerge` service (injected into `RzComponent`) is crucial for correctly merging default component classes, variant classes, and user-provided classes passed via `AdditionalAttributes`. Always use it in the `RootClass()` override.

## Alpine.js Integration
- Define Alpine logic in `packages/rizzyui/src/js/lib/components.js` using `Alpine.data('componentName', () => ({ ... }))`.
- Add `x-data="componentName"` to the appropriate element in the `.razor` file.
- Use `x-ref`, `x-on:`, `:class`, `:style`, `$watch`, etc., for interactivity.
- Pass necessary configuration or initial state from Blazor to Alpine using `data-*` attributes on the `x-data` element. Parse this data (often JSON) within the Alpine component's `init()` function.
- If external JS/CSS assets are needed (like Flatpickr, Highlight.js), define them as a static `DefaultAssets` array in the `.razor.cs` file and pass them serialized via a `data-assets` attribute. Use the `require(assets, { success: ..., error: ... }, nonce)` function within the Alpine `init()` to load them dynamically. Ensure the `nonce` attribute is also passed if CSP is a concern.

## Example (`RzSimpleButton.razor` / `.cs`)

**`RzSimpleButton.razor.cs`**
```csharp
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;

namespace RizzyUI;

/// <xmldoc>A simple button example.</xmldoc>
public partial class RzSimpleButton : RzComponent
{
    [Parameter] public ButtonVariant Variant { get; set; } = ButtonVariant.Primary;
    [Parameter] public Size Size { get; set; } = Size.Medium;
    [Parameter] public RenderFragment? ChildContent { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "button"; // It's a button
    }

    // NO simple style properties like ButtonClass, AnimatedClass, etc.

    protected override string? RootClass()
    {
        // Access theme directly within the method
        var styles = Theme.RzButton; // Assuming RzButton styles exist
        return TwMerge.Merge(AdditionalAttributes,
            styles.Button, // Base button style
            styles.GetVariantCss(Variant), // Variant style
            styles.Animated, // Animation style (if applicable)
            styles.GetSizeCss(Size) // Size style
        );
    }
}
```

**`RzSimpleButton.razor`**
```html
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@Element" @attributes="AdditionalAttributes" class="@RootClass()">
    @* No internal elements needing direct theme access in this simple example,
       but if there were, it would look like:
       <span class="@Theme.RzButton.InnerSpan">...</span>
    *@
    @ChildContent
</HtmlElement>
```

By following these updated guidelines, components will be simpler, easier to maintain, and directly leverage the theme system within the markup where styling is most relevant.
