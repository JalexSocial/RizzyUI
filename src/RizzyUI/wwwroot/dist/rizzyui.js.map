{"version":3,"file":"rizzyui.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA,CAAC,I;;;;;;;;AC5TD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iCAAiC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,4BAA4B;AACpF,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA,uCAAuC,QAAQ;AAC/C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2CAA2C,yCAAyC;AACpF,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B;AACnE;AACA,sCAAsC,uCAAuC;AAC7E;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC,0BAA0B;AAC9D;AACA,uCAAuC,qCAAqC;AAC5E;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,CAAC,C;;;;;;;;ACliBD;AACA,iCAAiC;AACjC,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,UAAU;AACzB;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,0BAA0B;AACzC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,I","sources":["webpack://rizzyui/./wwwroot/js/blazor-streaming.js","webpack://rizzyui/./wwwroot/js/rizzyui.js","webpack://rizzyui/./wwwroot/js/vendor/loadjs/loadjs.js"],"sourcesContent":["ï»¿/*\r\n * Blazor Stream Rendering HTMX Extension\r\n * Author: Michael Tanczos\r\n * Credits to SSE extension and Microsoft aspnetcore\r\n * at https://github.com/dotnet/aspnetcore/blob/main/src/Components/Web.JS/src/Rendering/StreamingRendering.ts\r\n */\r\n(function () {\r\n\r\n    var api;\r\n    var enableDomPreservation = true;\r\n    var componentLoaded = false;\r\n\r\n    class BlazorStreamingUpdate extends HTMLElement {\r\n        connectedCallback() {\r\n            const blazorSsrElement = this.parentNode\r\n\r\n            // Synchronously remove this from the DOM to minimize our chance of affecting anything else\r\n            blazorSsrElement.parentNode?.removeChild(blazorSsrElement)\r\n\r\n            // When this element receives content, if it's <template blazor-component-id=\"...\">...</template>,\r\n            // insert the template content into the DOM\r\n            blazorSsrElement.childNodes.forEach(node => {\r\n                if (node instanceof HTMLTemplateElement) {\r\n                    const componentId = node.getAttribute(\"blazor-component-id\")\r\n                    if (componentId) {\r\n                        insertStreamingContentIntoDocument(componentId, node.content)\r\n                    }\r\n                }\r\n            })\r\n\r\n            htmx?.process(document.body)\r\n        }\r\n    }\r\n\r\n    htmx.defineExtension(\"blazor-streaming\",\r\n        {\r\n            /**\r\n             * Init saves the provided reference to the internal HTMX API.\r\n             *\r\n             * @param {import(\"../htmx\").HtmxInternalApi} api\r\n             * @returns void\r\n             */\r\n            init: function (apiRef) {\r\n                // store a reference to the internal API.\r\n                api = apiRef;\r\n\r\n                // set a function in the public API for creating new EventSource objects\r\n                if (htmx.blazorSwapSsr == undefined) {\r\n                    if (customElements.get('blazor-ssr-end') === undefined) {\r\n                        customElements.define('blazor-ssr-end', BlazorStreamingUpdate);\r\n                    }\r\n                    htmx.blazorSwapSsr = blazorSwapSsr;\r\n                }\r\n            },\r\n            onEvent: function (name, evt) {\r\n                if (name === \"htmx:afterOnLoad\") {\r\n                    htmx?.process(document.body);\r\n                }\r\n                else if (name === \"htmx:beforeRequest\") {\r\n                    var element = evt.detail.elt;\r\n                    if (evt.detail.requestConfig.target) {\r\n                        evt.detail.requestConfig.target.addEventListener(\"htmx:beforeSwap\",\r\n                            e => {\r\n                                // Any html that was already streamed in could have been updated with\r\n                                // blazor ssr content so the final xhr response can be thrown away\r\n                                //e.detail.shouldSwap = false;\r\n                            }, { once: true });\r\n                    }\r\n\r\n                    var last = 0;\r\n                    var swapSpec = api.getSwapSpecification(element);\r\n                    var xhr = evt.detail.xhr;\r\n\r\n                    // Create a container id for a temporary div container. All streamed html will be placed \r\n                    // inside the container so that htmx swap methods work correctly\r\n                    var cid = 'ctr' + crypto.randomUUID();\r\n\r\n                    xhr.addEventListener(\"readystatechange\", () => {\r\n\r\n                        // If finished we can unwrap the container all html was stored into\r\n                        if (xhr.readyState === 4) {\r\n                            var container = document.getElementById(cid);\r\n\r\n                            if (container != null)\r\n                                unwrap(container);\r\n                        }\r\n                    });\r\n\r\n                    xhr.addEventListener(\"progress\", e => {\r\n\r\n                        var container = document.getElementById(cid);\r\n\r\n                        // If the container doesn't exist we need to create it and swap it into the element\r\n                        // target space. From here on we can stream responses into the container directly.\r\n                        if (container == null) {\r\n                            container = document.createElement('div');\r\n                            container.id = cid;\r\n\r\n                            // Swap in a container div to hold the streaming html\r\n                            swap(element, container.outerHTML, swapSpec);\r\n\r\n                            // The very first swap into the container can be a replacement swap\r\n                            swapSpec.swapStyle = \"innerHTML\";\r\n\r\n                            // Ensure there is always a container even if not added to the dom\r\n                            container = document.getElementById(cid) ?? container;\r\n                        }\r\n\r\n                        // Compute any new html in this chunk\r\n                        diff = e.currentTarget.response.substring(last);\r\n                        swap(container, diff, swapSpec);\r\n\r\n                        swapSpec.settleDelay = 0;\r\n                        swapSpec.swapStyle = \"beforeend\";\r\n                        last = e.loaded;\r\n                    });\r\n\r\n                }\r\n\r\n                return true;\r\n            }\r\n        });\r\n\r\n    function isCommentNodeInHead(commentNode) {\r\n        // Ensure that the provided node is indeed a comment node\r\n        if (commentNode && commentNode.nodeType === Node.COMMENT_NODE) {\r\n            let currentNode = commentNode.parentNode;\r\n            // Traverse up the DOM tree\r\n            while (currentNode !== null) {\r\n                if (currentNode === document.head) {\r\n                    // The comment node is within the <head>\r\n                    return true;\r\n                }\r\n                currentNode = currentNode.parentNode;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n        // The traversal reached the root without finding <head>, or <head> does not exist\r\n        return false;\r\n    }\r\n\r\n    function blazorSwapSsr(start, end, docFrag) {\r\n        var newDiv = wrap(start, end, 'ssr' + crypto.randomUUID());\r\n\r\n        var container = document.createElement('div');\r\n        container.appendChild(docFrag);\r\n\r\n        swap(newDiv, container.innerHTML);\r\n\r\n        unwrap(newDiv);\r\n    }\r\n\r\n    function wrap(start, end, id) {\r\n\r\n        var newDiv = document.createElement('div');\r\n        newDiv.id = id;\r\n\r\n        // Iterate through nodes between start and end\r\n        var currentNode = start.nextSibling;\r\n        while (currentNode && currentNode !== end) {\r\n            newDiv.appendChild(currentNode);\r\n            currentNode = start.nextSibling;\r\n        }\r\n\r\n        start.parentNode.insertBefore(newDiv, end);\r\n\r\n        return newDiv;\r\n    }\r\n\r\n    function unwrap(element) {\r\n        // Ensure that the element has a parent\r\n        if (element.parentNode) {\r\n            // Move all child nodes out of the element\r\n            while (element.firstChild) {\r\n                element.parentNode.insertBefore(element.firstChild, element);\r\n            }\r\n\r\n            // Remove the empty element\r\n            element.parentNode.removeChild(element);\r\n        }\r\n    }\r\n\r\n    function handleOutOfBandSwaps(elt, fragment, settleInfo) {\r\n        var oobSelects = api.getClosestAttributeValue(elt, \"hx-select-oob\");\r\n        if (oobSelects) {\r\n            var oobSelectValues = oobSelects.split(\",\");\r\n            for (var i = 0; i < oobSelectValues.length; i++) {\r\n                var oobSelectValue = oobSelectValues[i].split(\":\", 2);\r\n                var id = oobSelectValue[0].trim();\r\n                if (id.indexOf(\"#\") === 0) {\r\n                    id = id.substring(1);\r\n                }\r\n                var oobValue = oobSelectValue[1] || \"true\";\r\n                var oobElement = fragment.querySelector(\"#\" + id);\r\n                if (oobElement) {\r\n                    api.oobSwap(oobValue, oobElement, settleInfo);\r\n                }\r\n            }\r\n        }\r\n        forEach(findAll(fragment, '[hx-swap-oob], [data-hx-swap-oob]'), function (oobElement) {\r\n            var oobValue = getAttributeValue(oobElement, \"hx-swap-oob\");\r\n            if (oobValue != null) {\r\n                api.oobSwap(oobValue, oobElement, settleInfo);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {HTMLElement} elt\r\n     * @param {string} content\r\n     */\r\n    function swap(elt, content, swapSpec) {\r\n\r\n        api.withExtensions(elt, function (extension) {\r\n            content = extension.transformResponse(content, null, elt);\r\n        });\r\n\r\n        swapSpec ??= api.getSwapSpecification(elt);\r\n        var target = api.getTarget(elt);\r\n        var settleInfo = api.makeSettleInfo(elt);\r\n\r\n        // htmx 2.0\r\n        api.swap(target, content, swapSpec);\r\n\r\n        //api.selectAndSwap(swapSpec.swapStyle, target, elt, content, settleInfo);\r\n\r\n        settleInfo.elts.forEach(function (elt) {\r\n            if (elt.classList) {\r\n                elt.classList.add(htmx.config.settlingClass);\r\n            }\r\n            api.triggerEvent(elt, 'htmx:beforeSettle');\r\n        });\r\n\r\n        // Handle settle tasks (with delay if requested)\r\n        if (swapSpec.settleDelay > 0) {\r\n            setTimeout(doSettle(settleInfo), swapSpec.settleDelay);\r\n        } else {\r\n            doSettle(settleInfo)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * doSettle mirrors much of the functionality in htmx that\r\n     * settles elements after their content has been swapped.\r\n     * TODO: this should be published by htmx, and not duplicated here\r\n     * @param {import(\"../htmx\").HtmxSettleInfo} settleInfo\r\n     * @returns () => void\r\n     */\r\n    function doSettle(settleInfo) {\r\n\r\n        return function () {\r\n            settleInfo.tasks.forEach(function (task) {\r\n                task.call();\r\n            });\r\n\r\n            settleInfo.elts.forEach(function (elt) {\r\n                if (elt.classList) {\r\n                    elt.classList.remove(htmx.config.settlingClass);\r\n                }\r\n                api.triggerEvent(elt, 'htmx:afterSettle');\r\n            });\r\n        }\r\n    }\r\n\r\n    function insertStreamingContentIntoDocument(componentIdAsString, docFrag) {\r\n        const markers = findStreamingMarkers(componentIdAsString)\r\n        if (markers) {\r\n            const { startMarker, endMarker } = markers\r\n            enableDomPreservation = !isCommentNodeInHead(startMarker);\r\n            if (enableDomPreservation) {\r\n                blazorSwapSsr(startMarker, endMarker, docFrag);\r\n            } else {\r\n                // In this mode we completely delete the old content before inserting the new content\r\n                const destinationRoot = endMarker.parentNode\r\n                const existingContent = new Range()\r\n                existingContent.setStart(startMarker, startMarker.textContent.length)\r\n                existingContent.setEnd(endMarker, 0)\r\n                existingContent.deleteContents()\r\n\r\n                while (docFrag.childNodes[0]) {\r\n                    destinationRoot.insertBefore(docFrag.childNodes[0], endMarker)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function findStreamingMarkers(componentIdAsString) {\r\n        // Find start marker\r\n        const expectedStartText = `bl:${componentIdAsString}`\r\n        const iterator = document.createNodeIterator(\r\n            document,\r\n            NodeFilter.SHOW_COMMENT\r\n        )\r\n        let startMarker = null\r\n        while ((startMarker = iterator.nextNode())) {\r\n            if (startMarker.textContent === expectedStartText) {\r\n                break\r\n            }\r\n        }\r\n\r\n        if (!startMarker) {\r\n            return null\r\n        }\r\n\r\n        // Find end marker\r\n        const expectedEndText = `/bl:${componentIdAsString}`\r\n        let endMarker = null\r\n        while ((endMarker = iterator.nextNode())) {\r\n            if (endMarker.textContent === expectedEndText) {\r\n                break\r\n            }\r\n        }\r\n\r\n        return endMarker ? { startMarker, endMarker } : null\r\n    }\r\n})();","ï»¿/* RizzyUI JS */\r\nif (!document.__htmx_nonceprovider) {\r\n    document.addEventListener(\"htmx:configRequest\", (event) => {\r\n        const headers = event.detail.headers;\r\n        if (htmx.config.inlineScriptNonce) {\r\n            headers['Rizzy-Script-Nonce'] = htmx.config.inlineScriptNonce;\r\n        }\r\n        if (htmx.config.inlineStyleNonce) {\r\n            headers['Rizzy-Style-Nonce'] = htmx.config.inlineStyleNonce;\r\n        }\r\n    });\r\n\r\n    document.__htmx_nonceprovider = true;\r\n}\r\n\r\ndocument.addEventListener('alpine:init', () => {\r\n\r\n        try {\r\n\r\n            let v = new aspnetValidation.ValidationService();\r\n            v.bootstrap({ watch: true });\r\n\r\n            window.validation = v;\r\n        } catch (error) {\r\n            console.log(error);\r\n        }\r\n\r\n        Alpine.data('rzDarkModeToggle', () => ({\r\n\r\n            mode: 'light',\r\n\r\n            init() {\r\n                const storedMode = localStorage.getItem('darkMode') ?? 'auto';\r\n                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n\r\n                localStorage.setItem('darkMode', storedMode);\r\n\r\n                const applyTheme = () => {\r\n                    document.documentElement.classList.toggle('dark',\r\n                        storedMode === 'dark' || (storedMode === 'auto' && prefersDark));\r\n                };\r\n\r\n                applyTheme();\r\n\r\n                // Reapply theme on OS-level changes to the color scheme\r\n                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);\r\n            },\r\n\r\n            // Getter properties used by the Razor markup\r\n            isDark() {\r\n                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n                var storedMode = localStorage.getItem('darkMode');\r\n\r\n                return this.mode === 'dark' || (this.mode === 'auto' && prefersDark);\r\n            },\r\n            isLight() {\r\n                return !this.isDark();\r\n            },\r\n\r\n            toggle() {\r\n                var storedMode = localStorage.getItem('darkMode');\r\n                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\r\n\r\n                if (storedMode === 'light')\r\n                    storedMode = 'dark';\r\n                else if (storedMode === 'dark')\r\n                    storedMode = 'light';\r\n                else if (storedMode === 'auto') {\r\n                    if (prefersDark)\r\n                        storedMode = 'light';\r\n                    else\r\n                        storedMode = 'dark';\r\n                }\r\n\r\n                localStorage.setItem('darkMode', storedMode);\r\n                this.mode = storedMode;\r\n\r\n                const isDark = storedMode === 'dark' || (storedMode === 'auto' && prefersDark);\r\n                document.documentElement.classList.toggle('dark', isDark);\r\n\r\n                const darkModeEvent = new CustomEvent('darkModeToggle', {\r\n                    detail: { darkMode: isDark }\r\n                });\r\n\r\n                window.dispatchEvent(darkModeEvent);\r\n            }\r\n        }));\r\n\r\n        Alpine.data('rzAlert',\r\n            () => {\r\n                return {\r\n                    showAlert: true,\r\n\r\n                    dismiss() {\r\n                        this.showAlert = false;\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzBrowser',\r\n            () => {\r\n                return {\r\n                    screenSize: '',\r\n\r\n                    setDesktopScreenSize() {\r\n                        this.screenSize = '';\r\n                    },\r\n\r\n                    setTabletScreenSize() {\r\n                        this.screenSize = 'max-w-2xl';\r\n                    },\r\n\r\n                    setPhoneScreenSize() {\r\n                        this.screenSize = 'max-w-sm';\r\n                    },\r\n\r\n                    getBrowserBorderCss() {\r\n                        return [this.screenSize, this.screenSize === '' ? 'border-none' : 'border-x'];\r\n                    },\r\n\r\n                    getDesktopScreenCss() {\r\n                        return [ this.screenSize === '' ? 'text-onSurfaceStrong forced-color-adjust-auto dark:text-onSurfaceDarkStrong' : 'opacity-60' ];\r\n                    },\r\n\r\n                    getTabletScreenCss() {\r\n                        return [ this.screenSize === 'max-w-2xl' ? 'text-onSurfaceStrong forced-color-adjust-auto dark:text-onSurfaceStrongDark' : 'opacity-60' ];\r\n                    },\r\n\r\n                    getPhoneScreenCss() {\r\n                        return [ this.screenSize === 'max-w-sm' ? 'text-onSurfaceStrong forced-color-adjust-auto dark:text-onSurfaceStrongDark' : 'opacity-60'];\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzCodeViewer',\r\n            () => {\r\n                return {\r\n                    expand: false,\r\n                    border: true,\r\n                    codeStyle: '',\r\n                    copied: false,\r\n                    init() {\r\n                        // Retrieve the assets from the dataset\r\n                        const assets = JSON.parse(this.$el.dataset.assets);\r\n                        const codeId = this.$el.dataset.codeid;\r\n                        const scriptNonce = this.$el.dataset.scriptnonce;\r\n                        const styleNonce = this.$el.dataset.stylenonce;\r\n\r\n                        loadjs(assets, {\r\n                            success: () => {\r\n                                // Ensure Highlight.js styles are applied after the script loads\r\n                                const codeBlock = document.getElementById(codeId);\r\n\r\n                                if (window.hljs && codeBlock) {\r\n                                    window.hljs.highlightElement(codeBlock);\r\n                                }\r\n                            },\r\n                            error: () => {\r\n                                console.error('Failed to load Highlight.js');\r\n                            },\r\n                            async: false,\r\n                            inlineScriptNonce: scriptNonce,\r\n                            inlineStyleNonce: styleNonce\r\n                        });\r\n                    },\r\n                    notCopied() {\r\n                        return !this.copied;\r\n                    },\r\n                    disableCopied() {\r\n                        this.copied = false;\r\n                    },\r\n                    toggleExpand() {\r\n                        this.expand = !this.expand;\r\n                    },\r\n                    copyHTML() {\r\n                        navigator.clipboard.writeText(this.$refs.codeBlock.textContent);\r\n                        this.copied = !this.copied;\r\n                    },\r\n                    getCopiedTitle() {\r\n                        return this.copied ? 'copied' : 'copy';\r\n                    },\r\n                    getCopiedCss() {\r\n                        return [this.copied ? 'focus-visible:outline-success' : 'focus-visible:outline-onSurfaceDark'];\r\n                    },\r\n                    getExpandCss() {\r\n                        return [this.expand ? '' : 'max-h-60'];\r\n                    },\r\n                    getExpandButtonCss() {\r\n                        return this.expand ? 'rotate-180' : 'rotate-0';\r\n                    },\r\n                    getExpandMaxHeightCss() {\r\n                        return [this.expand ? '' : 'max-h-[400px]', this.border ? 'border' : 'border-none', 'rounded-b'];\r\n                    },\r\n                    getBorderCss() {\r\n                        return [this.border ? 'border-b' : ''];\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzEmbeddedPreview', () => {\r\n            return {\r\n                iframe: null,\r\n                onDarkModeToggle: null,\r\n                init() {\r\n                    try {\r\n                        this.iframe = this.$refs.iframe;\r\n                        const resize = this.debounce(() => { this.resizeIframe(this.iframe); }, 50);\r\n\r\n                        // If init is called after the iframe loads, make sure we still resize the iframe\r\n                        this.resizeIframe(this.iframe);\r\n\r\n                        // observe any changes in size to the iframe\r\n                        const resizeObserver = new ResizeObserver(entries => {\r\n                            for (let entry of entries) {\r\n                                resize();\r\n                            }\r\n                        });\r\n\r\n                        resizeObserver.observe(this.iframe);\r\n\r\n                        const iframe = this.iframe;\r\n                        this.onDarkModeToggle = (event) => {\r\n                            iframe.contentWindow.postMessage(event.detail, '*');\r\n                        };\r\n\r\n                        window.addEventListener('darkModeToggle', this.onDarkModeToggle);\r\n\r\n                    } catch (error) {\r\n                        console.error('Cannot access iframe content');\r\n                    }\r\n                },\r\n                resizeIframe(iframe) {\r\n\r\n                    if (iframe) {\r\n                        try {\r\n                            const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;\r\n\r\n                            if (iframeDocument) {\r\n\r\n                                const iframeBody = iframeDocument.body;\r\n\r\n                                if (!iframeBody) {\r\n                                    setInterval(() => { this.resizeIframe(iframe); }, 150);\r\n                                } else {\r\n                                    const newHeight = iframeBody.scrollHeight + 15;\r\n\r\n                                    iframe.style.height = newHeight + 'px';\r\n                                }\r\n\r\n                            }\r\n                        } catch (error) {\r\n                            console.error('Error resizing iframe:', error);\r\n                        }\r\n                    }\r\n                },\r\n                debounce(func, timeout = 300) {\r\n                    let timer;\r\n                    return (...args) => {\r\n                        clearTimeout(timer);\r\n                        timer = setTimeout(() => { func.apply(this, args); }, timeout);\r\n                    };\r\n                },\r\n                destroy() {\r\n                    window.removeEventListener('darkModeToggle', this.onDarkModeToggle);\r\n                }\r\n            }\r\n        });\r\n\r\n        Alpine.data('rzProgress', () => ({\r\n            currentVal: 0,\r\n            minVal: 0,\r\n            maxVal: 100,\r\n            percentage: 0,\r\n            label: '',\r\n\r\n            init() {\r\n                const element = this.$el;\r\n\r\n                // Retrieve data attributes from the root element\r\n                this.currentVal = parseInt(element.getAttribute('data-current-val')) || 0;\r\n                this.minVal = parseInt(element.getAttribute('data-min-val')) || 0;\r\n                this.maxVal = parseInt(element.getAttribute('data-max-val')) || 100;\r\n                this.label = element.getAttribute('data-label');\r\n\r\n                // Calculate initial percentage\r\n                this.calculatePercentage();\r\n\r\n                // Update ARIA attributes\r\n                element.setAttribute('aria-valuenow', this.currentVal);\r\n                element.setAttribute('aria-valuemin', this.minVal);\r\n                element.setAttribute('aria-valuemax', this.maxVal);\r\n                element.setAttribute('aria-valuetext', `${this.percentage}%`);\r\n\r\n                // Set the width of the progress bar\r\n                this.updateProgressBar();\r\n\r\n                const resizeObserver = new ResizeObserver(entries => {\r\n                    this.updateProgressBar();\r\n                });\r\n\r\n                resizeObserver.observe(element);\r\n\r\n                // Listen for custom events to update progress\r\n                this.$watch('currentVal', () => {\r\n                    this.calculatePercentage();\r\n                    this.updateProgressBar();\r\n                    element.setAttribute('aria-valuenow', this.currentVal);\r\n                    element.setAttribute('aria-valuetext', `${this.percentage}%`);\r\n                });\r\n            },\r\n\r\n            calculatePercentage() {\r\n                if (this.maxVal === this.minVal) {\r\n                    this.percentage = 0;\r\n                } else {\r\n                    this.percentage = Math.min(Math.max(((this.currentVal - this.minVal) / (this.maxVal - this.minVal)) * 100, 0), 100);\r\n                }\r\n            },\r\n\r\n            buildLabel() {\r\n                var label = this.label || '{percent}%';\r\n                this.calculatePercentage();\r\n                return label.replace('{percent}', this.percentage);\r\n            },\r\n\r\n            buildInsideLabelPosition() {\r\n                const progressBar = this.$refs.progressBar;\r\n                const barLabel = this.$refs.progressBarLabel;\r\n                const innerLabel = this.$refs.innerLabel;\r\n\r\n                if (barLabel && progressBar && innerLabel) {\r\n                    innerLabel.innerText = this.buildLabel();\r\n\r\n                    if (barLabel.clientWidth > progressBar.clientWidth) {\r\n                        barLabel.style.left = (progressBar.clientWidth + 10) + 'px';\r\n                    } else {\r\n                        barLabel.style.left = (progressBar.clientWidth / 2 - barLabel.clientWidth / 2) + 'px';\r\n                    }\r\n                }\r\n            },\r\n\r\n            getLabelCss() {\r\n                const barLabel = this.$refs.progressBarLabel;\r\n                const progressBar = this.$refs.progressBar;\r\n\r\n                if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {\r\n                    return \"text-onSurface dark:text-onSurfaceDark\";\r\n                }\r\n\r\n                return \"\";\r\n            },\r\n\r\n            updateProgressBar() {\r\n                const progressBar = this.$refs.progressBar;\r\n                if (progressBar) {\r\n                    progressBar.style.width = `${this.percentage}%`;\r\n                    this.buildInsideLabelPosition();\r\n                }\r\n            },\r\n\r\n            // Method to update progress value\r\n            setProgress(value) {\r\n                this.currentVal = value;\r\n            },\r\n\r\n            // Method to increment progress value\r\n            increment(val = 1) {\r\n                this.currentVal = Math.min(this.currentVal + val, this.maxVal);\r\n            },\r\n\r\n            // Method to decrement progress value\r\n            decrement(val = 1) {\r\n                this.currentVal = Math.max(this.currentVal - val, this.minVal);\r\n            }\r\n        }));\r\n\r\n        Alpine.data('rzQuickReferenceContainer',\r\n            () => {\r\n                return {\r\n                    headings: [],\r\n                    currentHeadingId: '',\r\n                    handleHeadingClick() {\r\n                        const id = this.$el.dataset.headingid;\r\n                        setTimeout(() => { this.currentHeadingId = id; }, 10);\r\n                    },\r\n                    setCurrentHeading(id) {\r\n                        if (this.headings.includes(id)) {\r\n                            this.currentHeadingId = id;\r\n                        }\r\n                    },\r\n                    getSelectedCss() {\r\n                        const id = this.$el.dataset.headingid;\r\n\r\n                        return { 'font-bold': this.currentHeadingId === id };\r\n                    },\r\n                    init() {\r\n                        this.headings = JSON.parse(this.$el.dataset.headings);\r\n                        this.currentHeadingId = this.$el.dataset.currentheadingid;\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzTabs',\r\n            () => {\r\n                return {\r\n                    buttonRef: null,\r\n                    tabSelected: '',\r\n                    tabButton: null,\r\n                    init() {\r\n                        this.buttonRef = document.getElementById(this.$el.dataset.buttonref);\r\n                        this.tabSelected = this.$el.dataset.tabselected;\r\n                        this.tabButton = this.buttonRef.querySelector('[data-name=\\'' + this.tabSelected + '\\']');\r\n\r\n                        this.tabRepositionMarker(this.tabButton);\r\n                    },\r\n                    tabButtonClicked(tabButton) {\r\n                        if (tabButton instanceof Event)\r\n                            tabButton = tabButton.target;\r\n\r\n                        this.tabSelected = tabButton.dataset.name;\r\n                        this.tabRepositionMarker(tabButton);\r\n                        tabButton.focus();\r\n                    },\r\n                    tabRepositionMarker(tabButton){\r\n                        this.tabButton = tabButton;\r\n                        this.$refs.tabMarker.style.width = tabButton.offsetWidth + 'px';\r\n                        this.$refs.tabMarker.style.height = tabButton.offsetHeight + 'px';\r\n                        this.$refs.tabMarker.style.left = tabButton.offsetLeft + 'px';\r\n                        setTimeout(() => { this.$refs.tabMarker.style.opacity = 1; }, 150);\r\n                    },\r\n                    tabContentActive(tabContent) {\r\n                        tabContent = tabContent ?? this.$el;\r\n                        return this.tabSelected === tabContent.dataset.name;\r\n                    },\r\n                    tabButtonActive(tabButton) {\r\n                        tabButton = tabButton ?? this.$el;\r\n                        return this.tabSelected === tabButton.dataset.name;\r\n                    },\r\n                    selectedTabTextColor() {\r\n                        const color = this.$el.dataset.selectedtextcolor ?? '';\r\n\r\n                        if (this.tabButtonActive(this.$el)) {\r\n                            return color;\r\n                        }\r\n\r\n                        return '';\r\n                    },\r\n                    handleResize() {\r\n                        this.tabRepositionMarker(this.tabButton);\r\n                    },\r\n                    handleKeyDown(event){\r\n                        const key = event.key;\r\n                        const tabButtons = Array.from(this.buttonRef.querySelectorAll('[role=\\'tab\\']'));\r\n                        const currentIndex = tabButtons.findIndex(button => this.tabButtonActive(button));\r\n                        let newIndex = currentIndex;\r\n\r\n                        if (key === 'ArrowRight') {\r\n                            newIndex = (currentIndex + 1) % tabButtons.length;\r\n                            event.preventDefault();\r\n                        } else if (key === 'ArrowLeft') {\r\n                            newIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;\r\n                            event.preventDefault();\r\n                        } else if (key === 'Home') {\r\n                            newIndex = 0;\r\n                            event.preventDefault();\r\n                        } else if (key === 'End') {\r\n                            newIndex = tabButtons.length - 1;\r\n                            event.preventDefault();\r\n                        }\r\n\r\n                        if (newIndex !== currentIndex) {\r\n                            this.tabButtonClicked(tabButtons[newIndex]);\r\n                        }\r\n                    }\r\n            }\r\n            });\r\n\r\n        Alpine.data('rzSidebar',\r\n            () => {\r\n                return {\r\n                    showSidebar: false,\r\n\r\n                    isSidebarHidden() { return !this.showSidebar; },\r\n\r\n                    toggleSidebar() { this.showSidebar = !this.showSidebar; },\r\n\r\n                    hideSidebar() { this.showSidebar = false; },\r\n\r\n                    getSidebarTranslation() {\r\n                        return this.showSidebar ? 'translate-x-0' : '-translate-x-60';\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzSidebarLinkItem',\r\n            () => {\r\n                return {\r\n                    isExpanded: false,\r\n\r\n                    init() {\r\n                        this.isExpanded = this.$el.dataset.expanded;\r\n                    },\r\n\r\n                    isCollapsed() { return !this.isExpanded; },\r\n\r\n                    toggleExpanded() { this.isExpanded = !this.isExpanded; },\r\n\r\n                    hideSidebar() { this.showSidebar = false; },\r\n\r\n                    getExpandedClass() {\r\n                        return this.isExpanded ? 'rotate-180' : 'rotate-0';\r\n                    }\r\n                }\r\n            });\r\n\r\n        Alpine.data('rzHeading',\r\n            () => {\r\n                return {\r\n                    observer: null,\r\n\r\n                    init() {\r\n                        if (typeof this.setCurrentHeading === 'function') {\r\n\r\n                            const callback = (entries, observer) => {\r\n                                entries.forEach(entry => {\r\n                                    if (entry.isIntersecting) {\r\n                                        this.setCurrentHeading(this.$el.id);\r\n                                    }\r\n                                });\r\n                            };\r\n\r\n                            const options = { threshold: 0.5 };\r\n                            this.observer = new IntersectionObserver(callback, options);\r\n\r\n                            // Start observing the element\r\n                            this.observer.observe(this.$el);\r\n                        }\r\n                    },\r\n\r\n                    destroy() {\r\n                        if (this.observer != null)\r\n                            this.observer.disconnect();\r\n                    }\r\n                }\r\n            });\r\n\r\n})","(function () {\r\n    var devnull = function () { },\r\n        bundleIdCache = {},\r\n        bundleResultCache = {},\r\n        bundleCallbackQueue = {};\r\n\r\n    /**\r\n     * Subscribe to bundle load event.\r\n     * @param {string[]} bundleIds - Bundle ids\r\n     * @param {Function} callbackFn - The callback function\r\n     */\r\n    function subscribe(bundleIds, callbackFn) {\r\n        // listify\r\n        bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];\r\n\r\n        var depsNotFound = [],\r\n            i = bundleIds.length,\r\n            numWaiting = i,\r\n            fn,\r\n            bundleId,\r\n            r,\r\n            q;\r\n\r\n        // define callback function\r\n        fn = function (bundleId, pathsNotFound) {\r\n            if (pathsNotFound.length) depsNotFound.push(bundleId);\r\n\r\n            numWaiting--;\r\n            if (!numWaiting) callbackFn(depsNotFound);\r\n        };\r\n\r\n        // register callback\r\n        while (i--) {\r\n            bundleId = bundleIds[i];\r\n\r\n            // execute callback if in result cache\r\n            r = bundleResultCache[bundleId];\r\n            if (r) {\r\n                fn(bundleId, r);\r\n                continue;\r\n            }\r\n\r\n            // add to callback queue\r\n            q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];\r\n            q.push(fn);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Publish bundle load event.\r\n     * @param {string} bundleId - Bundle id\r\n     * @param {string[]} pathsNotFound - List of files not found\r\n     */\r\n    function publish(bundleId, pathsNotFound) {\r\n        if (!bundleId) return;\r\n\r\n        var q = bundleCallbackQueue[bundleId];\r\n\r\n        // cache result\r\n        bundleResultCache[bundleId] = pathsNotFound;\r\n\r\n        // exit if queue is empty\r\n        if (!q) return;\r\n\r\n        // empty callback queue\r\n        while (q.length) {\r\n            q[0](bundleId, pathsNotFound);\r\n            q.splice(0, 1);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute callbacks.\r\n     * @param {Object|Function} args - The callback args\r\n     * @param {string[]} depsNotFound - List of dependencies not found\r\n     */\r\n    function executeCallbacks(args, depsNotFound) {\r\n        // accept function as argument\r\n        if (typeof args === 'function') args = { success: args };\r\n\r\n        // success and error callbacks\r\n        if (depsNotFound.length) (args.error || devnull)(depsNotFound);\r\n        else (args.success || devnull)(args);\r\n    }\r\n\r\n\r\n    /**\r\n     * Handle resource event (load/error).\r\n     */\r\n    function handleResourceEvent(ev, path, e, callbackFn, args, numTries, maxTries, isLegacyIECss) {\r\n        var result = ev.type[0]; // 'l' for load, 'e' for error\r\n\r\n        // treat empty stylesheets as failures to get around lack of onerror\r\n        // support in IE9-11\r\n        if (isLegacyIECss) {\r\n            try {\r\n                if (!e.sheet.cssText.length) result = 'e';\r\n            } catch (x) {\r\n                // For load errors, accessing cssText might throw\r\n                if (x.code !== 18) result = 'e';\r\n            }\r\n        }\r\n\r\n        // handle retries in case of load failure\r\n        if (result === 'e') {\r\n            // increment counter\r\n            numTries += 1;\r\n\r\n            // exit function and try again if we haven't reached maxTries\r\n            if (numTries < maxTries) {\r\n                return loadFile(path, callbackFn, args, numTries);\r\n            }\r\n        } else if (e.rel === 'preload' && e.as === 'style') {\r\n            // activate preloaded stylesheets\r\n            e.rel = 'stylesheet';\r\n            return;\r\n        }\r\n\r\n        // execute callback\r\n        callbackFn(path, result, ev.defaultPrevented);\r\n    }\r\n\r\n\r\n    /**\r\n     * Load individual file.\r\n     * @param {string} path - The file path\r\n     * @param {Function} callbackFn - The callback function\r\n     * @param {Object} args - Arguments including async, before, inlineScriptNonce, inlineStyleNonce\r\n     * @param {number} numTries - Number of retry attempts so far\r\n     */\r\n    function loadFile(path, callbackFn, args, numTries) {\r\n        var doc = document,\r\n            async = args.async,\r\n            maxTries = (args.numRetries || 0) + 1,\r\n            beforeCallbackFn = args.before || devnull,\r\n            pathname = path.replace(/[\\?|#].*$/, ''),\r\n            pathStripped = path.replace(/^(css|img|module|nomodule)!/, ''),\r\n            isLegacyIECss,\r\n            hasModuleSupport,\r\n            e;\r\n\r\n        numTries = numTries || 0;\r\n\r\n        if (/(^css!|\\.css$)/.test(pathname)) {\r\n            // css\r\n            e = doc.createElement('link');\r\n            e.rel = 'stylesheet';\r\n            e.href = pathStripped;\r\n\r\n            // tag IE9+\r\n            isLegacyIECss = 'hideFocus' in e;\r\n\r\n            // use preload in IE Edge (to detect load errors)\r\n            if (isLegacyIECss && e.relList) {\r\n                isLegacyIECss = 0;\r\n                e.rel = 'preload';\r\n                e.as = 'style';\r\n            }\r\n\r\n            // If inlineStyleNonce provided, set it on the link tag\r\n            if (args.inlineStyleNonce) {\r\n                e.setAttribute('nonce', args.inlineStyleNonce);\r\n            }\r\n\r\n        } else if (/(^img!|\\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {\r\n            // image\r\n            e = doc.createElement('img');\r\n            e.src = pathStripped;\r\n\r\n            // No nonce needed for images\r\n\r\n        } else {\r\n            // javascript\r\n            e = doc.createElement('script');\r\n            e.src = pathStripped;\r\n            e.async = async === undefined ? true : async;\r\n\r\n            // Set inlineScriptNonce if provided\r\n            if (args.inlineScriptNonce) {\r\n                e.setAttribute('nonce', args.inlineScriptNonce);\r\n            }\r\n\r\n            // handle es modules\r\n            hasModuleSupport = 'noModule' in e;\r\n            if (/^module!/.test(pathname)) {\r\n                if (!hasModuleSupport) return callbackFn(path, 'l');\r\n                e.type = \"module\";\r\n            } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {\r\n                return callbackFn(path, 'l');\r\n            }\r\n        }\r\n\r\n        // Event handlers\r\n        var onEvent = function (ev) {\r\n            handleResourceEvent(ev, path, e, callbackFn, args, numTries, maxTries, isLegacyIECss);\r\n        };\r\n\r\n        e.addEventListener('load', onEvent, { once: true });\r\n        e.addEventListener('error', onEvent, { once: true });\r\n\r\n        // add to document (unless callback returns `false`)\r\n        if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);\r\n    }\r\n\r\n\r\n    /**\r\n     * Load multiple files.\r\n     * @param {string[]} paths - The file paths\r\n     * @param {Function} callbackFn - The callback function\r\n     * @param {Object} args - Arguments including inlineScriptNonce, inlineStyleNonce\r\n     */\r\n    function loadFiles(paths, callbackFn, args) {\r\n        // listify paths\r\n        paths = Array.isArray(paths) ? paths : [paths];\r\n\r\n        var numWaiting = paths.length,\r\n            x = numWaiting,\r\n            pathsNotFound = [];\r\n\r\n        function fn(path, result, defaultPrevented) {\r\n            // handle error\r\n            if (result === 'e') pathsNotFound.push(path);\r\n\r\n            // handle beforeload event. If defaultPrevented then that means the load\r\n            // will be blocked (ex. Ghostery/ABP on Safari)\r\n            if (result === 'b') {\r\n                if (defaultPrevented) pathsNotFound.push(path);\r\n                else return;\r\n            }\r\n\r\n            numWaiting--;\r\n            if (!numWaiting) callbackFn(pathsNotFound);\r\n        }\r\n\r\n        for (var i = 0; i < x; i++) loadFile(paths[i], fn, args);\r\n    }\r\n\r\n\r\n    /**\r\n     * Initiate script load and register bundle.\r\n     * @param {(string|string[])} paths - The file paths\r\n     * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success callback\r\n     * @param {(Function|Object)} [arg2] - success callback or object literal\r\n     */\r\n    function loadjs(paths, arg1, arg2) {\r\n        var bundleId,\r\n            args;\r\n\r\n        // If first argument is a string (other than an array), treat as bundleId\r\n        if (arg1 && typeof arg1 === 'string' && arg1.trim) bundleId = arg1.trim();\r\n\r\n        // Arguments object\r\n        args = (bundleId ? arg2 : arg1) || {};\r\n\r\n        // throw error if bundle is already defined\r\n        if (bundleId) {\r\n            if (bundleId in bundleIdCache) {\r\n                throw \"LoadJS\";\r\n            } else {\r\n                bundleIdCache[bundleId] = true;\r\n            }\r\n        }\r\n\r\n        function loadFn(resolve, reject) {\r\n            loadFiles(paths, function (pathsNotFound) {\r\n                // execute callbacks\r\n                executeCallbacks(args, pathsNotFound);\r\n\r\n                // resolve Promise if requested\r\n                if (resolve) {\r\n                    executeCallbacks({ success: resolve, error: reject }, pathsNotFound);\r\n                }\r\n\r\n                // publish bundle load event\r\n                publish(bundleId, pathsNotFound);\r\n            }, args);\r\n        }\r\n\r\n        if (args.returnPromise) return new Promise(loadFn);\r\n        else loadFn();\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute callbacks when dependencies have been satisfied.\r\n     * @param {(string|string[])} deps - List of bundle ids\r\n     * @param {Object} args - success/error arguments\r\n     */\r\n    loadjs.ready = function ready(deps, args) {\r\n        subscribe(deps, function (depsNotFound) {\r\n            executeCallbacks(args, depsNotFound);\r\n        });\r\n        return loadjs;\r\n    };\r\n\r\n\r\n    /**\r\n     * Manually satisfy bundle dependencies.\r\n     * @param {string} bundleId - The bundle id\r\n     */\r\n    loadjs.done = function done(bundleId) {\r\n        publish(bundleId, []);\r\n    };\r\n\r\n\r\n    /**\r\n     * Reset loadjs dependencies statuses\r\n     */\r\n    loadjs.reset = function reset() {\r\n        bundleIdCache = {};\r\n        bundleResultCache = {};\r\n        bundleCallbackQueue = {};\r\n    };\r\n\r\n\r\n    /**\r\n     * Determine if bundle has already been defined\r\n     * @param {String} bundleId - The bundle id\r\n     */\r\n    loadjs.isDefined = function isDefined(bundleId) {\r\n        return bundleId in bundleIdCache;\r\n    };\r\n\r\n    // export\r\n    window.loadjs = loadjs;\r\n})();"],"names":[],"sourceRoot":""}