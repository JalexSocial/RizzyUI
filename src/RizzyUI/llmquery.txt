This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document. The content has been processed where empty lines have been removed.
Generated by Repomix on: 2025-12-18T17:16:22.539Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.razor, **/*.razor.cs, **/*.cs, **/js/*.js
- Files matching these patterns are excluded: obj/, bin/, **/js/vendor/*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
_Imports.razor
Attributes/AssemblyRzAlpineCodeBehindAttribute.cs
Attributes/RzAlpineCodeBehindAttribute.cs
Color.cs
Colors.cs
ColorScale.cs
Components/DataTable/Models/ColumnDefinition.cs
Components/DataTable/Models/PaginationState.cs
Components/DataTable/Models/SortDirection.cs
Components/DataTable/Models/TableRequestModel.cs
Components/DataTable/Models/TableSelectionMode.cs
Components/DataTable/RzTable/RzTable.razor
Components/DataTable/RzTable/RzTable.razor.cs
Components/DataTable/RzTable/Styling/RzTableStyles.cs
Components/DataTable/RzTable/Styling/TableBodyStyles.cs
Components/DataTable/RzTable/Styling/TableCellStyles.cs
Components/DataTable/RzTable/Styling/TableHeaderCellStyles.cs
Components/DataTable/RzTable/Styling/TablePaginationStyles.cs
Components/DataTable/RzTable/Styling/TableRowStyles.cs
Components/DataTable/RzTable/TableBody.razor
Components/DataTable/RzTable/TableBody.razor.cs
Components/DataTable/RzTable/TableCell.razor
Components/DataTable/RzTable/TableCell.razor.cs
Components/DataTable/RzTable/TableHeaderCell.razor
Components/DataTable/RzTable/TableHeaderCell.razor.cs
Components/DataTable/RzTable/TablePagination.razor
Components/DataTable/RzTable/TablePagination.razor.cs
Components/DataTable/RzTable/TableRow.razor
Components/DataTable/RzTable/TableRow.razor.cs
Components/Display/RzAvatar/AvatarFallback.razor
Components/Display/RzAvatar/AvatarFallback.razor.cs
Components/Display/RzAvatar/AvatarImage.razor
Components/Display/RzAvatar/AvatarImage.razor.cs
Components/Display/RzAvatar/RzAvatar.razor
Components/Display/RzAvatar/RzAvatar.razor.cs
Components/Display/RzBadge/RzBadge.razor
Components/Display/RzBadge/RzBadge.razor.cs
Components/Display/RzIndicator/IndicatorPosition.cs
Components/Display/RzIndicator/RzIndicator.razor
Components/Display/RzIndicator/RzIndicator.razor.cs
Components/Display/RzProgress/RzProgress.razor
Components/Display/RzProgress/RzProgress.razor.cs
Components/Display/RzSeparator/RzSeparator.razor
Components/Display/RzSeparator/RzSeparator.razor.cs
Components/Document/Models/HeadingItem.cs
Components/Document/RzArticle/RzArticle.razor
Components/Document/RzArticle/RzArticle.razor.cs
Components/Document/RzBrowser/RzBrowser.razor
Components/Document/RzBrowser/RzBrowser.razor.cs
Components/Document/RzCodeViewer/CodeLanguage.cs
Components/Document/RzCodeViewer/RzCodeViewer.razor
Components/Document/RzCodeViewer/RzCodeViewer.razor.cs
Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor
Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor.cs
Components/Document/RzMarkdown/RzMarkdown.razor
Components/Document/RzMarkdown/RzMarkdown.razor.cs
Components/Document/RzQuickReference/RzQuickReference.razor
Components/Document/RzQuickReference/RzQuickReference.razor.cs
Components/Document/RzQuickReference/RzQuickReferenceContainer.razor
Components/Document/RzQuickReference/RzQuickReferenceContainer.razor.cs
Components/Feedback/RzAlert/AlertDescription.razor
Components/Feedback/RzAlert/AlertDescription.razor.cs
Components/Feedback/RzAlert/AlertTitle.razor
Components/Feedback/RzAlert/AlertTitle.razor.cs
Components/Feedback/RzAlert/RzAlert.razor
Components/Feedback/RzAlert/RzAlert.razor.cs
Components/Feedback/RzDialog/DialogClose.razor
Components/Feedback/RzDialog/DialogClose.razor.cs
Components/Feedback/RzDialog/DialogContent.razor
Components/Feedback/RzDialog/DialogContent.razor.cs
Components/Feedback/RzDialog/DialogDescription.razor
Components/Feedback/RzDialog/DialogDescription.razor.cs
Components/Feedback/RzDialog/DialogFooter.razor
Components/Feedback/RzDialog/DialogFooter.razor.cs
Components/Feedback/RzDialog/DialogHeader.razor
Components/Feedback/RzDialog/DialogHeader.razor.cs
Components/Feedback/RzDialog/DialogTitle.razor
Components/Feedback/RzDialog/DialogTitle.razor.cs
Components/Feedback/RzDialog/DialogTrigger.razor
Components/Feedback/RzDialog/DialogTrigger.razor.cs
Components/Feedback/RzDialog/RzDialog.razor
Components/Feedback/RzDialog/RzDialog.razor.cs
Components/Feedback/RzEmpty/EmptyContent.razor
Components/Feedback/RzEmpty/EmptyContent.razor.cs
Components/Feedback/RzEmpty/EmptyDescription.razor
Components/Feedback/RzEmpty/EmptyDescription.razor.cs
Components/Feedback/RzEmpty/EmptyHeader.razor
Components/Feedback/RzEmpty/EmptyHeader.razor.cs
Components/Feedback/RzEmpty/EmptyMedia.razor
Components/Feedback/RzEmpty/EmptyMedia.razor.cs
Components/Feedback/RzEmpty/EmptyMediaVariant.cs
Components/Feedback/RzEmpty/EmptyTitle.razor
Components/Feedback/RzEmpty/EmptyTitle.razor.cs
Components/Feedback/RzEmpty/RzEmpty.razor
Components/Feedback/RzEmpty/RzEmpty.razor.cs
Components/Feedback/RzPopover/AnchorStrategy.cs
Components/Feedback/RzPopover/PopoverContent.razor
Components/Feedback/RzPopover/PopoverContent.razor.cs
Components/Feedback/RzPopover/PopoverTrigger.razor
Components/Feedback/RzPopover/PopoverTrigger.razor.cs
Components/Feedback/RzPopover/RzPopover.razor
Components/Feedback/RzPopover/RzPopover.razor.cs
Components/Feedback/RzSheet/RzSheet.razor
Components/Feedback/RzSheet/RzSheet.razor.cs
Components/Feedback/RzSheet/SheetClose.razor
Components/Feedback/RzSheet/SheetClose.razor.cs
Components/Feedback/RzSheet/SheetContent.razor
Components/Feedback/RzSheet/SheetContent.razor.cs
Components/Feedback/RzSheet/SheetDescription.razor
Components/Feedback/RzSheet/SheetDescription.razor.cs
Components/Feedback/RzSheet/SheetFooter.razor
Components/Feedback/RzSheet/SheetFooter.razor.cs
Components/Feedback/RzSheet/SheetHeader.razor
Components/Feedback/RzSheet/SheetHeader.razor.cs
Components/Feedback/RzSheet/SheetSide.cs
Components/Feedback/RzSheet/SheetTitle.razor
Components/Feedback/RzSheet/SheetTitle.razor.cs
Components/Feedback/RzSheet/SheetTrigger.razor
Components/Feedback/RzSheet/SheetTrigger.razor.cs
Components/Feedback/RzSpinner/RzSpinner.razor
Components/Feedback/RzSpinner/RzSpinner.razor.cs
Components/Form/_Imports.razor
Components/Form/Enum/Orientation.cs
Components/Form/Enum/SectionLayout.cs
Components/Form/Enum/TextRole.cs
Components/Form/Field/Field.razor
Components/Form/Field/Field.razor.cs
Components/Form/Field/FieldContent.razor
Components/Form/Field/FieldContent.razor.cs
Components/Form/Field/FieldDescription.razor
Components/Form/Field/FieldDescription.razor.cs
Components/Form/Field/FieldError.razor
Components/Form/Field/FieldError.razor.cs
Components/Form/Field/FieldLabel.razor
Components/Form/Field/FieldLabel.razor.cs
Components/Form/Field/FieldLegend.razor
Components/Form/Field/FieldLegend.razor.cs
Components/Form/Field/FieldSeparator.razor
Components/Form/Field/FieldSeparator.razor.cs
Components/Form/Field/FieldTitle.razor
Components/Form/Field/FieldTitle.razor.cs
Components/Form/Field/RzFieldGroup.razor
Components/Form/Field/RzFieldGroup.razor.cs
Components/Form/Field/RzFieldSet.razor
Components/Form/Field/RzFieldSet.razor.cs
Components/Form/Field/Styling/FieldLabelStyles.cs
Components/Form/Field/Styling/FieldStyles.cs
Components/Form/InputBase.cs
Components/Form/InputGroup/InputGroupAddon.razor
Components/Form/InputGroup/InputGroupAddon.razor.cs
Components/Form/InputGroup/InputGroupButton.razor
Components/Form/InputGroup/InputGroupButton.razor.cs
Components/Form/InputGroup/InputGroupInput.razor
Components/Form/InputGroup/InputGroupInput.razor.cs
Components/Form/InputGroup/InputGroupText.razor
Components/Form/InputGroup/InputGroupText.razor.cs
Components/Form/InputGroup/InputGroupTextarea.razor
Components/Form/InputGroup/InputGroupTextarea.razor.cs
Components/Form/InputGroup/RzInputGroup.razor
Components/Form/InputGroup/RzInputGroup.razor.cs
Components/Form/InputGroup/Styling/InputGroupAddonStyles.cs
Components/Form/InputGroup/Styling/InputGroupButtonStyles.cs
Components/Form/Label/Label.razor
Components/Form/Label/Label.razor.cs
Components/Form/Models/CalendarOptions.cs
Components/Form/Models/FlatpickrOptions.cs
Components/Form/RzButton/RzButton.razor
Components/Form/RzButton/RzButton.razor.cs
Components/Form/RzButtonGroup/ButtonGroupSeparator.razor
Components/Form/RzButtonGroup/ButtonGroupSeparator.razor.cs
Components/Form/RzButtonGroup/ButtonGroupText.razor
Components/Form/RzButtonGroup/ButtonGroupText.razor.cs
Components/Form/RzButtonGroup/RzButtonGroup.razor
Components/Form/RzButtonGroup/RzButtonGroup.razor.cs
Components/Form/RzCalendar/RzCalendar.razor
Components/Form/RzCalendar/RzCalendar.razor.cs
Components/Form/RzCheckboxGroup/CheckboxGroupItemIndicator.razor
Components/Form/RzCheckboxGroup/CheckboxGroupItemIndicator.razor.cs
Components/Form/RzCheckboxGroup/RzCheckboxGroup.razor
Components/Form/RzCheckboxGroup/RzCheckboxGroup.razor.cs
Components/Form/RzCheckboxGroup/RzCheckboxGroupItem.razor
Components/Form/RzCheckboxGroup/RzCheckboxGroupItem.razor.cs
Components/Form/RzCheckboxGroup/RzInputCheckbox.razor
Components/Form/RzCheckboxGroup/RzInputCheckbox.razor.cs
Components/Form/RzCheckboxGroup/RzInputCheckboxGroupBase.cs
Components/Form/RzCheckboxGroup/Styling/CheckboxGroupItemIndicatorStyles.cs
Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupFieldStyles.cs
Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupItemStyles.cs
Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupStyles.cs
Components/Form/RzCombobox/Models/ComboboxOptions.cs
Components/Form/RzCombobox/Models/Plugins/IComboboxPlugin.cs
Components/Form/RzCombobox/Models/Plugins/PluginDefinitions.cs
Components/Form/RzCombobox/RzCombobox.razor
Components/Form/RzCombobox/RzCombobox.razor.cs
Components/Form/RzCombobox/Styling/RzComboboxStyles.cs
Components/Form/RzDateEdit/RzDateEdit.razor
Components/Form/RzDateEdit/RzDateEdit.razor.cs
Components/Form/RzFormSection/RzFormSection.razor
Components/Form/RzFormSection/RzFormSection.razor.cs
Components/Form/RzInputNumber/RzInputNumber.razor
Components/Form/RzInputNumber/RzInputNumber.razor.cs
Components/Form/RzInputNumber/Styling/RzInputNumberStyles.cs
Components/Form/RzInputText/RzInputText.razor
Components/Form/RzInputText/RzInputText.razor.cs
Components/Form/RzInputTextArea/RzInputTextArea.razor
Components/Form/RzInputTextArea/RzInputTextArea.razor.cs
Components/Form/RzNativeSelect/RzNativeSelect.razor
Components/Form/RzNativeSelect/RzNativeSelect.razor.cs
Components/Form/RzNativeSelect/RzNativeSelectOptGroup.razor
Components/Form/RzNativeSelect/RzNativeSelectOptGroup.razor.cs
Components/Form/RzNativeSelect/RzNativeSelectOption.razor
Components/Form/RzNativeSelect/RzNativeSelectOption.razor.cs
Components/Form/RzNativeSelect/Styling/RzNativeSelectStyles.cs
Components/Form/RzRadioGroup/RadioGroupItem.razor
Components/Form/RzRadioGroup/RadioGroupItem.razor.cs
Components/Form/RzRadioGroup/RadioGroupItemIndicator.razor
Components/Form/RzRadioGroup/RadioGroupItemIndicator.razor.cs
Components/Form/RzRadioGroup/RzRadioGroup.razor
Components/Form/RzRadioGroup/RzRadioGroup.razor.cs
Components/Form/RzRadioGroup/Styling/RadioGroupItemStyles.cs
Components/Form/RzRadioGroup/Styling/RzRadioGroupStyles.cs
Components/Form/RzSwitch/RzSwitch.razor
Components/Form/RzSwitch/RzSwitch.razor.cs
Components/Form/RzSwitch/Styling/RzSwitchStyles.cs
Components/Form/Styling/FormInputStyles.cs
Components/FragmentComponent.cs
Components/HtmlElement.cs
Components/Interactivity/RzAlpineComponent.razor
Components/Interactivity/RzAlpineComponent.razor.cs
Components/Layout/RzAccordion/AccordionItem.razor
Components/Layout/RzAccordion/AccordionItem.razor.cs
Components/Layout/RzAccordion/RzAccordion.razor
Components/Layout/RzAccordion/RzAccordion.razor.cs
Components/Layout/RzAspectRatio/RzAspectRatio.razor
Components/Layout/RzAspectRatio/RzAspectRatio.razor.cs
Components/Layout/RzCard/CardAction.razor
Components/Layout/RzCard/CardAction.razor.cs
Components/Layout/RzCard/CardContent.razor
Components/Layout/RzCard/CardContent.razor.cs
Components/Layout/RzCard/CardDescription.razor
Components/Layout/RzCard/CardDescription.razor.cs
Components/Layout/RzCard/CardFooter.razor
Components/Layout/RzCard/CardFooter.razor.cs
Components/Layout/RzCard/CardHeader.razor
Components/Layout/RzCard/CardHeader.razor.cs
Components/Layout/RzCard/CardTitle.razor
Components/Layout/RzCard/CardTitle.razor.cs
Components/Layout/RzCard/RzCard.razor
Components/Layout/RzCard/RzCard.razor.cs
Components/Layout/RzCarousel/CarouselContent.razor
Components/Layout/RzCarousel/CarouselContent.razor.cs
Components/Layout/RzCarousel/CarouselItem.razor
Components/Layout/RzCarousel/CarouselItem.razor.cs
Components/Layout/RzCarousel/CarouselNext.razor
Components/Layout/RzCarousel/CarouselNext.razor.cs
Components/Layout/RzCarousel/CarouselPrevious.razor
Components/Layout/RzCarousel/CarouselPrevious.razor.cs
Components/Layout/RzCarousel/Models/CarouselOptions.cs
Components/Layout/RzCarousel/Models/Plugins/AutoHeightPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/AutoHeightPluginOptions.cs
Components/Layout/RzCarousel/Models/Plugins/AutoplayPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/AutoplayPluginOptions.cs
Components/Layout/RzCarousel/Models/Plugins/AutoScrollPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/AutoScrollPluginOptions.cs
Components/Layout/RzCarousel/Models/Plugins/ClassNamesPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/ClassNamesPluginOptions.cs
Components/Layout/RzCarousel/Models/Plugins/EmblaPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/FadePlugin.cs
Components/Layout/RzCarousel/Models/Plugins/FadePluginOptions.cs
Components/Layout/RzCarousel/Models/Plugins/GenericEmblaPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/WheelGesturesPlugin.cs
Components/Layout/RzCarousel/Models/Plugins/WheelGesturesPluginOptions.cs
Components/Layout/RzCarousel/RzCarousel.razor
Components/Layout/RzCarousel/RzCarousel.razor.cs
Components/Layout/RzCollapsible/CollapsibleContent.razor
Components/Layout/RzCollapsible/CollapsibleContent.razor.cs
Components/Layout/RzCollapsible/CollapsibleTrigger.razor
Components/Layout/RzCollapsible/CollapsibleTrigger.razor.cs
Components/Layout/RzCollapsible/RzCollapsible.razor
Components/Layout/RzCollapsible/RzCollapsible.razor.cs
Components/Layout/RzItem/ItemActions.razor
Components/Layout/RzItem/ItemActions.razor.cs
Components/Layout/RzItem/ItemContent.razor
Components/Layout/RzItem/ItemContent.razor.cs
Components/Layout/RzItem/ItemDescription.razor
Components/Layout/RzItem/ItemDescription.razor.cs
Components/Layout/RzItem/ItemFooter.razor
Components/Layout/RzItem/ItemFooter.razor.cs
Components/Layout/RzItem/ItemHeader.razor
Components/Layout/RzItem/ItemHeader.razor.cs
Components/Layout/RzItem/ItemMedia.razor
Components/Layout/RzItem/ItemMedia.razor.cs
Components/Layout/RzItem/ItemTitle.razor
Components/Layout/RzItem/ItemTitle.razor.cs
Components/Layout/RzItem/ItemVariant.cs
Components/Layout/RzItem/RzItem.razor
Components/Layout/RzItem/RzItem.razor.cs
Components/Layout/RzItem/RzItemGroup.razor
Components/Layout/RzItem/RzItemGroup.razor.cs
Components/Layout/RzItem/RzItemSeparator.razor
Components/Layout/RzItem/RzItemSeparator.razor.cs
Components/Layout/RzSearchButton/RzSearchButton.razor
Components/Layout/RzSearchButton/RzSearchButton.razor.cs
Components/Layout/RzStep/RzStep.cs
Components/Layout/RzStep/RzSteps.razor
Components/Layout/RzStep/RzSteps.razor.cs
Components/Layout/RzStep/StepColorExtensions.cs
Components/Layout/RzStep/StepData.cs
Components/Layout/RzStep/StepStatus.cs
Components/Navigation/RzBreadcrumb/BreadcrumbEllipsis.razor
Components/Navigation/RzBreadcrumb/BreadcrumbEllipsis.razor.cs
Components/Navigation/RzBreadcrumb/BreadcrumbItem.razor
Components/Navigation/RzBreadcrumb/BreadcrumbItem.razor.cs
Components/Navigation/RzBreadcrumb/BreadcrumbLink.razor
Components/Navigation/RzBreadcrumb/BreadcrumbLink.razor.cs
Components/Navigation/RzBreadcrumb/BreadcrumbList.razor
Components/Navigation/RzBreadcrumb/BreadcrumbList.razor.cs
Components/Navigation/RzBreadcrumb/BreadcrumbPage.razor
Components/Navigation/RzBreadcrumb/BreadcrumbPage.razor.cs
Components/Navigation/RzBreadcrumb/BreadcrumbSeparator.razor
Components/Navigation/RzBreadcrumb/BreadcrumbSeparator.razor.cs
Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor
Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor.cs
Components/Navigation/RzCommand/CommandEmpty.razor
Components/Navigation/RzCommand/CommandEmpty.razor.cs
Components/Navigation/RzCommand/CommandGroup.razor
Components/Navigation/RzCommand/CommandGroup.razor.cs
Components/Navigation/RzCommand/CommandInput.razor
Components/Navigation/RzCommand/CommandInput.razor.cs
Components/Navigation/RzCommand/CommandItem.razor
Components/Navigation/RzCommand/CommandItem.razor.cs
Components/Navigation/RzCommand/CommandItemData.cs
Components/Navigation/RzCommand/CommandItemTemplate.razor
Components/Navigation/RzCommand/CommandItemTemplate.razor.cs
Components/Navigation/RzCommand/CommandList.razor
Components/Navigation/RzCommand/CommandList.razor.cs
Components/Navigation/RzCommand/CommandSeparator.razor
Components/Navigation/RzCommand/CommandSeparator.razor.cs
Components/Navigation/RzCommand/CommandShortcut.razor
Components/Navigation/RzCommand/CommandShortcut.razor.cs
Components/Navigation/RzCommand/ICommandItemData.cs
Components/Navigation/RzCommand/RzCommand.razor
Components/Navigation/RzCommand/RzCommand.razor.cs
Components/Navigation/RzCommand/RzCommandDialog.razor
Components/Navigation/RzCommand/RzCommandDialog.razor.cs
Components/Navigation/RzDropdown/DropdownMenuContent.razor
Components/Navigation/RzDropdown/DropdownMenuContent.razor.cs
Components/Navigation/RzDropdown/DropdownMenuGroup.razor
Components/Navigation/RzDropdown/DropdownMenuGroup.razor.cs
Components/Navigation/RzDropdown/DropdownMenuItem.razor
Components/Navigation/RzDropdown/DropdownMenuItem.razor.cs
Components/Navigation/RzDropdown/DropdownMenuLabel.razor
Components/Navigation/RzDropdown/DropdownMenuLabel.razor.cs
Components/Navigation/RzDropdown/DropdownMenuSeparator.razor
Components/Navigation/RzDropdown/DropdownMenuSeparator.razor.cs
Components/Navigation/RzDropdown/DropdownMenuShortcut.razor
Components/Navigation/RzDropdown/DropdownMenuShortcut.razor.cs
Components/Navigation/RzDropdown/DropdownMenuSub.razor
Components/Navigation/RzDropdown/DropdownMenuSub.razor.cs
Components/Navigation/RzDropdown/DropdownMenuSubContent.razor
Components/Navigation/RzDropdown/DropdownMenuSubContent.razor.cs
Components/Navigation/RzDropdown/DropdownMenuSubTrigger.razor
Components/Navigation/RzDropdown/DropdownMenuSubTrigger.razor.cs
Components/Navigation/RzDropdown/DropdownMenuTrigger.razor
Components/Navigation/RzDropdown/DropdownMenuTrigger.razor.cs
Components/Navigation/RzDropdown/RzDropdownMenu.razor
Components/Navigation/RzDropdown/RzDropdownMenu.razor.cs
Components/Navigation/RzLink/RzLink.razor
Components/Navigation/RzLink/RzLink.razor.cs
Components/Navigation/RzNavigationMenu/NavigationMenuContent.razor
Components/Navigation/RzNavigationMenu/NavigationMenuContent.razor.cs
Components/Navigation/RzNavigationMenu/NavigationMenuItem.razor
Components/Navigation/RzNavigationMenu/NavigationMenuItem.razor.cs
Components/Navigation/RzNavigationMenu/NavigationMenuLink.razor
Components/Navigation/RzNavigationMenu/NavigationMenuLink.razor.cs
Components/Navigation/RzNavigationMenu/NavigationMenuList.razor
Components/Navigation/RzNavigationMenu/NavigationMenuList.razor.cs
Components/Navigation/RzNavigationMenu/NavigationMenuTrigger.razor
Components/Navigation/RzNavigationMenu/NavigationMenuTrigger.razor.cs
Components/Navigation/RzNavigationMenu/RzNavigationMenu.razor
Components/Navigation/RzNavigationMenu/RzNavigationMenu.razor.cs
Components/Navigation/RzSidebar/RzSidebarProvider.razor
Components/Navigation/RzSidebar/RzSidebarProvider.razor.cs
Components/Navigation/RzSidebar/Sidebar.razor
Components/Navigation/RzSidebar/Sidebar.razor.cs
Components/Navigation/RzSidebar/SidebarContent.razor
Components/Navigation/RzSidebar/SidebarContent.razor.cs
Components/Navigation/RzSidebar/SidebarFooter.razor
Components/Navigation/RzSidebar/SidebarFooter.razor.cs
Components/Navigation/RzSidebar/SidebarGroup.razor
Components/Navigation/RzSidebar/SidebarGroup.razor.cs
Components/Navigation/RzSidebar/SidebarGroupContent.razor
Components/Navigation/RzSidebar/SidebarGroupContent.razor.cs
Components/Navigation/RzSidebar/SidebarGroupLabel.razor
Components/Navigation/RzSidebar/SidebarGroupLabel.razor.cs
Components/Navigation/RzSidebar/SidebarHeader.razor
Components/Navigation/RzSidebar/SidebarHeader.razor.cs
Components/Navigation/RzSidebar/SidebarInset.razor
Components/Navigation/RzSidebar/SidebarInset.razor.cs
Components/Navigation/RzSidebar/SidebarMenu.razor
Components/Navigation/RzSidebar/SidebarMenu.razor.cs
Components/Navigation/RzSidebar/SidebarMenuAction.razor
Components/Navigation/RzSidebar/SidebarMenuAction.razor.cs
Components/Navigation/RzSidebar/SidebarMenuBadge.razor
Components/Navigation/RzSidebar/SidebarMenuBadge.razor.cs
Components/Navigation/RzSidebar/SidebarMenuButton.razor
Components/Navigation/RzSidebar/SidebarMenuButton.razor.cs
Components/Navigation/RzSidebar/SidebarMenuItem.razor
Components/Navigation/RzSidebar/SidebarMenuItem.razor.cs
Components/Navigation/RzSidebar/SidebarMenuSub.razor
Components/Navigation/RzSidebar/SidebarMenuSub.razor.cs
Components/Navigation/RzSidebar/SidebarRail.razor
Components/Navigation/RzSidebar/SidebarRail.razor.cs
Components/Navigation/RzSidebar/SidebarSeparator.razor
Components/Navigation/RzSidebar/SidebarSeparator.razor.cs
Components/Navigation/RzSidebar/SidebarTrigger.razor
Components/Navigation/RzSidebar/SidebarTrigger.razor.cs
Components/Navigation/RzTabs/RzTabs.razor
Components/Navigation/RzTabs/RzTabs.razor.cs
Components/Navigation/RzTabs/TabsContent.razor
Components/Navigation/RzTabs/TabsContent.razor.cs
Components/Navigation/RzTabs/TabsList.razor
Components/Navigation/RzTabs/TabsList.razor.cs
Components/Navigation/RzTabs/TabsTrigger.razor
Components/Navigation/RzTabs/TabsTrigger.razor.cs
Components/Theme/RzDarkMode/RzDarkModeToggle.razor
Components/Theme/RzDarkMode/RzDarkModeToggle.razor.cs
Components/Theme/RzThemeProvider.cs
Components/Theme/Themes/ArcticTheme.cs
Components/Theme/Themes/Code/CodeThemes.cs
Components/Theme/Themes/Code/RizzyCodeTheme.cs
Components/Typography/RzHeading.razor
Components/Typography/RzHeading.razor.cs
Components/Typography/RzKbd/RzKbd.razor
Components/Typography/RzKbd/RzKbd.razor.cs
Components/Typography/RzKbd/RzKbdGroup.razor
Components/Typography/RzKbd/RzKbdGroup.razor.cs
Components/Typography/RzParagraph.razor
Components/Typography/RzParagraph.razor.cs
Components/Typography/RzTypographyBase.cs
Components/Typography/Styles.cs
Components/Utility/ColorUtil.cs
Components/Variants.cs
Constants.cs
Extensions/BlaziconsDataUriExtensions.cs
Extensions/MarkdigExtensions.cs
Extensions/ServiceCollectionExtensions.cs
Extensions/StringExtensions.cs
Extensions/TwMergeExtensions.cs
GlobalSuppressions.cs
GlobalUsings.cs
Localization/DummyRizzyStringLocalizer.cs
Localization/RizzyStringLocalizer.cs
Localization/RizzyStringLocalizerFactory.cs
RizzyLocalization.cs
RizzyUIConfig.cs
RzAsChildComponent.CloneFragment.cs
RzAsChildComponent.cs
RzAsChildComponentOfT.cs
RzComponent.cs
RzComponentOfT.cs
RzTheme.cs
RzTheme.StyleProviders.cs
RzThemeVariant.cs
Utility/Parser/HtmlUtils.cs
Utility/Serialization/Converters/CalendarPositionConverter.cs
Utility/Serialization/Converters/RawStringConverter.cs
Utility/Serialization/Converters/RzThemeConverter.cs
Utility/Serialization/Converters/SingleQuoteStringConverter.cs
Utility/ThemeLoader.cs
wwwroot/js/antiforgerySnippet.js
wwwroot/js/antiforgerySnippet.min.js
wwwroot/js/rizzyui-csp.es.js
wwwroot/js/rizzyui-csp.js
wwwroot/js/rizzyui-csp.min.es.js
wwwroot/js/rizzyui-csp.min.js
wwwroot/js/rizzyui.es.js
wwwroot/js/rizzyui.js
wwwroot/js/rizzyui.min.es.js
wwwroot/js/rizzyui.min.js
wwwroot/js/safelist.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_Imports.razor">
@using Microsoft.AspNetCore.Components.Web
@using RizzyUI.Extensions
</file>

<file path="Attributes/AssemblyRzAlpineCodeBehindAttribute.cs">
using System.ComponentModel;
namespace RizzyUI;
/// <summary>
/// An assembly-level attribute that provides necessary path information for the Alpine Code-Behind feature.
/// This attribute is emitted by RizzyUI's build tasks and should not be used directly by consumers.
/// </summary>
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]
[EditorBrowsable(EditorBrowsableState.Never)]
public sealed class AssemblyRzAlpineCodeBehindAttribute : Attribute
{
    /// <summary>
    /// Gets the normalized path prefix of the project directory, used to calculate relative paths for co-located JavaScript files.
    /// </summary>
	public string CallerFileNamePathPrefix { get; }
    /// <summary>
    /// Gets the static web asset base path for the project (e.g., "_content/MyProject"), used to construct correct web-accessible URLs for JavaScript modules.
    /// </summary>
    public string StaticWebAssetBasePath { get; }
    /// <summary>
    /// Initializes a new instance of the <see cref="AssemblyRzAlpineCodeBehindAttribute"/> class with a caller file name path prefix and a static web asset base path.
    /// </summary>
    /// <param name="callerFileNamePathPrefix">The normalized path prefix of the project directory.</param>
    /// <param name="staticWebAssetBasePath">The static web asset base path for the project.</param>
	public AssemblyRzAlpineCodeBehindAttribute(string callerFileNamePathPrefix, string staticWebAssetBasePath)
    {
        CallerFileNamePathPrefix = callerFileNamePathPrefix;
        StaticWebAssetBasePath = staticWebAssetBasePath;
    }
    /// <summary>
    /// Initializes a new instance of the <see cref="AssemblyRzAlpineCodeBehindAttribute"/> class with only a caller file name path prefix.
    /// </summary>
    /// <param name="callerFileNamePathPrefix">The normalized path prefix of the project directory.</param>
    public AssemblyRzAlpineCodeBehindAttribute(string callerFileNamePathPrefix)
        : this(callerFileNamePathPrefix, string.Empty)
    {
    }
}
</file>

<file path="Attributes/RzAlpineCodeBehindAttribute.cs">
using System.Runtime.CompilerServices;
namespace RizzyUI;
/// <summary>
/// An attribute that marks a Blazor component as having a co-located JavaScript module for Alpine.js interactivity.
/// This enables the "Alpine Code-Behind" feature, which automatically discovers and registers a `.razor.js` file
/// associated with the component.
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public sealed class RzAlpineCodeBehindAttribute([CallerFilePath] string? razorFilePath = null) : Attribute
{
    /// <summary>
    /// Gets the full file path of the Razor component to which this attribute is applied.
    /// This path is captured automatically by the compiler using the <see cref="CallerFilePathAttribute"/>.
    /// </summary>
    public string? RazorFilePath { get; } = razorFilePath;
}
</file>

<file path="Color.cs">
namespace RizzyUI;
/// <summary>
///     Represents a CSS color variable or Oklch color
/// </summary>
public record Color
{
    /// <summary>
    ///     Stores css color value for color (e.g. "fff" or "oklch(0.973 0.071 103.193)")
    /// </summary>
    private readonly string _cssColorValue;
    /// <summary>
    ///     Stores variable string name (if _type is ColorType.Variable)
    /// </summary>
    private readonly string _cssColorName;
    /// <summary>
    ///     Stores a color in Oklch format
    /// </summary>
    /// <param name="color">The Oklch color value.</param>
    /// <param name="colorName">The optional CSS variable name for the color.</param>
    public Color(Oklch color, string colorName = "")
    {
        _cssColorName = colorName;
        _cssColorValue = $"[{ToCssColorString()}]";
    }
    /// <summary>
    ///     Stores a color as a variable
    /// </summary>
    /// <param name="colorValue">The CSS color value (e.g., "var(--my-color)", "oklch(...)").</param>
    /// <param name="colorName">The optional CSS variable name for the color.</param>
    public Color(string colorValue, string colorName = "")
    {
        _cssColorName = colorName;
        _cssColorValue = colorValue;
    }
    /// <summary>
    ///     Initializes a color using another color as a base
    /// </summary>
    /// <param name="other">The other color to copy from.</param>
    /// <param name="alternateColorName">An optional alternate name for the new color.</param>
    public Color(Color other, string alternateColorName = "")
    {
        _cssColorName = string.IsNullOrEmpty(alternateColorName) ? other._cssColorName.ToLowerInvariant() : alternateColorName;
        _cssColorValue = other._cssColorValue;
    }
    /// <summary>
    ///     Outputs the standard CSS function syntax: oklch(L C H / Alpha) or var(--color-rose-500)
    /// </summary>
    /// <returns>The CSS color string.</returns>
    public string ToCssColorString() => _cssColorValue;
    /// <summary>
    ///     Outputs a Tailwind class that can be directly used in a class attribute
    /// </summary>
    /// <param name="utility">bg, text, accent, etc. (as part of bg-rose-500, text-rose-500)</param>
    /// <returns>The Tailwind CSS class string.</returns>
    public virtual string ToCssClassString(string utility)
    {
        return string.IsNullOrEmpty(_cssColorName) ? $"{utility}-[{_cssColorValue}]" : $"{utility}-{_cssColorName}";
    }
}
/// <summary>
///     Represents a color in OKLCH space, plus an alpha (default 1.0).
/// </summary>
/// <param name="L">Lightness component.</param>
/// <param name="C">Chroma component.</param>
/// <param name="H">Hue component.</param>
/// <param name="Alpha">Alpha (transparency) component.</param>
// ReSharper disable once IdentifierTypo
public readonly record struct Oklch(float L, float C, float H, float Alpha = 1.0f)
{
    /// <summary>
    /// Provides a string representation of the color in CSS format.
    /// </summary>
    /// <returns>The CSS color string.</returns>
    public string ToCssColorString()
    {
        return Alpha < 1f
            ? $"oklch({L} {C} {H})"
            : $"oklch({L} {C} {H} / {Alpha})";
    }
}
</file>

<file path="Colors.cs">
namespace RizzyUI;
/// <summary>
///     Provides static readonly properties to access each Tailwind color palette.
///     Example: Colors.Rose.L500 or Colors.Rose["500"]
/// </summary>
public static class Colors
{
    /// <summary>
    ///     Transparent
    /// </summary>
    public static readonly Color Transparent = new(new Oklch(0, 0, 0, 0));
    /// <summary>
    ///     The color white.
    /// </summary>
    public static readonly Color White = new("var(--color-white)", "white");
    /// <summary>
    ///     The color black.
    /// </summary>
    public static readonly Color Black = new("var(--color-black)", "black");
    /// <summary>
    ///     Red color scale.
    /// </summary>
    public static readonly ColorScale Red = new Red();
    /// <summary>
    ///     Orange color scale.
    /// </summary>
    public static readonly ColorScale Orange = new Orange();
    /// <summary>
    ///     Amber color scale.
    /// </summary>
    public static readonly ColorScale Amber = new Amber();
    /// <summary>
    ///     Yellow color scale.
    /// </summary>
    public static readonly ColorScale Yellow = new Yellow();
    /// <summary>
    ///     Lime color scale.
    /// </summary>
    public static readonly ColorScale Lime = new Lime();
    /// <summary>
    ///     Green color scale.
    /// </summary>
    public static readonly ColorScale Green = new Green();
    /// <summary>
    ///     Emerald color scale.
    /// </summary>
    public static readonly ColorScale Emerald = new Emerald();
    /// <summary>
    ///     Teal color scale.
    /// </summary>
    public static readonly ColorScale Teal = new Teal();
    /// <summary>
    ///     Cyan color scale.
    /// </summary>
    public static readonly ColorScale Cyan = new Cyan();
    /// <summary>
    ///     Sky color scale.
    /// </summary>
    public static readonly ColorScale Sky = new Sky();
    /// <summary>
    ///     Blue color scale.
    /// </summary>
    public static readonly ColorScale Blue = new Blue();
    /// <summary>
    ///     Indigo color scale.
    /// </summary>
    public static readonly ColorScale Indigo = new Indigo();
    /// <summary>
    ///     Violet color scale.
    /// </summary>
    public static readonly ColorScale Violet = new Violet();
    /// <summary>
    ///     Purple color scale.
    /// </summary>
    public static readonly ColorScale Purple = new Purple();
    /// <summary>
    ///     Fuchsia color scale.
    /// </summary>
    public static readonly ColorScale Fuchsia = new Fuchsia();
    /// <summary>
    ///     Pink color scale.
    /// </summary>
    public static readonly ColorScale Pink = new Pink();
    /// <summary>
    ///     Rose color scale.
    /// </summary>
    public static readonly ColorScale Rose = new Rose();
    /// <summary>
    ///     Stone color scale.
    /// </summary>
    public static readonly ColorScale Stone = new Stone();
    /// <summary>
    ///     Neutral color scale.
    /// </summary>
    public static readonly ColorScale Neutral = new Neutral();
    /// <summary>
    ///     Zinc color scale.
    /// </summary>
    public static readonly ColorScale Zinc = new Zinc();
    /// <summary>
    ///     Gray color scale.
    /// </summary>
    public static readonly ColorScale Gray = new Gray();
    /// <summary>
    ///     Slate color scale.
    /// </summary>
    public static readonly ColorScale Slate = new Slate();
}
</file>

<file path="ColorScale.cs">
namespace RizzyUI;
/// <summary>
///     Represents a scale of colors with various lightness levels.
/// </summary>
public abstract class ColorScale
{
    /// <summary>
    ///     Gets the color shade at level 50.
    /// </summary>
    public abstract Color L50 { get; }
    /// <summary>
    ///     Gets the color shade at level 100.
    /// </summary>
    public abstract Color L100 { get; }
    /// <summary>
    ///     Gets the color shade at level 200.
    /// </summary>
    public abstract Color L200 { get; }
    /// <summary>
    ///     Gets the color shade at level 300.
    /// </summary>
    public abstract Color L300 { get; }
    /// <summary>
    ///     Gets the color shade at level 400.
    /// </summary>
    public abstract Color L400 { get; }
    /// <summary>
    ///     Gets the color shade at level 500.
    /// </summary>
    public abstract Color L500 { get; }
    /// <summary>
    ///     Gets the color shade at level 600.
    /// </summary>
    public abstract Color L600 { get; }
    /// <summary>
    ///     Gets the color shade at level 700.
    /// </summary>
    public abstract Color L700 { get; }
    /// <summary>
    ///     Gets the color shade at level 800.
    /// </summary>
    public abstract Color L800 { get; }
    /// <summary>
    ///     Gets the color shade at level 900.
    /// </summary>
    public abstract Color L900 { get; }
    /// <summary>
    ///     Gets the color shade at level 950.
    /// </summary>
    public abstract Color L950 { get; }
}
/// <summary>
///     Represents the red color scale.
/// </summary>
public sealed class Red : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.971 0.013 17.38)", "red-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.936 0.032 17.717)", "red-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.885 0.062 18.334)", "red-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.808 0.114 19.571)", "red-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.704 0.191 22.216)", "red-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.637 0.237 25.331)", "red-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.577 0.245 27.325)", "red-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.505 0.213 27.518)", "red-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.444 0.177 26.899)", "red-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.396 0.141 25.723)", "red-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.258 0.092 26.042)", "red-950");
}
/// <summary>
///     Represents the orange color scale.
/// </summary>
public sealed class Orange : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.98 0.016 73.684)", "orange-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.954 0.038 75.164)", "orange-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.901 0.076 70.697)", "orange-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.837 0.128 66.29)", "orange-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.75 0.183 55.934)", "orange-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.705 0.213 47.604)", "orange-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.646 0.222 41.116)", "orange-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.553 0.195 38.402)", "orange-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.47 0.157 37.304)", "orange-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.408 0.123 38.172)", "orange-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.266 0.079 36.259)", "orange-950");
}
/// <summary>
///     Represents the amber color scale.
/// </summary>
public sealed class Amber : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.987 0.022 95.277)", "amber-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.962 0.059 95.617)", "amber-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.924 0.12 95.746)", "amber-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.879 0.169 91.605)", "amber-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.828 0.189 84.429)", "amber-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.769 0.188 70.08)", "amber-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.666 0.179 58.318)", "amber-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.555 0.163 48.998)", "amber-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.473 0.137 46.201)", "amber-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.414 0.112 45.904)", "amber-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.279 0.077 45.635)", "amber-950");
}
/// <summary>
///     Represents the yellow color scale.
/// </summary>
public sealed class Yellow : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.987 0.026 102.212)", "yellow-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.973 0.071 103.193)", "yellow-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.945 0.129 101.54)", "yellow-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.905 0.182 98.111)", "yellow-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.852 0.199 91.936)", "yellow-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.795 0.184 86.047)", "yellow-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.681 0.162 75.834)", "yellow-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.554 0.135 66.442)", "yellow-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.476 0.114 61.907)", "yellow-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.421 0.095 57.708)", "yellow-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.286 0.066 53.813)", "yellow-950");
}
/// <summary>
///     Represents the lime color scale.
/// </summary>
public sealed class Lime : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.986 0.031 120.757)", "lime-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.967 0.067 122.328)", "lime-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.938 0.127 124.321)", "lime-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.897 0.196 126.665)", "lime-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.841 0.238 128.85)", "lime-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.768 0.233 130.85)", "lime-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.648 0.2 131.684)", "lime-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.532 0.157 131.589)", "lime-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.453 0.124 130.933)", "lime-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.405 0.101 131.063)", "lime-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.274 0.072 132.109)", "lime-950");
}
/// <summary>
///     Represents the green color scale.
/// </summary>
public sealed class Green : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.982 0.018 155.826)", "green-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.962 0.044 156.743)", "green-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.925 0.084 155.995)", "green-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.871 0.15 154.449)", "green-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.792 0.209 151.711)", "green-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.723 0.219 149.579)", "green-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.627 0.194 149.214)", "green-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.527 0.154 150.069)", "green-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.448 0.119 151.328)", "green-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.393 0.095 152.535)", "green-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.266 0.065 152.934)", "green-950");
}
/// <summary>
///     Represents the emerald color scale.
/// </summary>
public sealed class Emerald : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.979 0.021 166.113)", "emerald-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.95 0.052 163.051)", "emerald-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.905 0.093 164.15)", "emerald-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.845 0.143 164.978)", "emerald-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.765 0.177 163.223)", "emerald-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.696 0.17 162.48)", "emerald-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.596 0.145 163.225)", "emerald-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.508 0.118 165.612)", "emerald-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.432 0.095 166.913)", "emerald-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.378 0.077 168.94)", "emerald-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.262 0.051 172.552)", "emerald-950");
}
/// <summary>
///     Represents the teal color scale.
/// </summary>
public sealed class Teal : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.984 0.014 180.72)", "teal-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.953 0.051 180.801)", "teal-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.91 0.096 180.426)", "teal-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.855 0.138 181.071)", "teal-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.777 0.152 181.912)", "teal-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.704 0.14 182.503)", "teal-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.6 0.118 184.704)", "teal-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.511 0.096 186.391)", "teal-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.437 0.078 188.216)", "teal-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.386 0.063 188.416)", "teal-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.277 0.046 192.524)", "teal-950");
}
/// <summary>
///     Represents the cyan color scale.
/// </summary>
public sealed class Cyan : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.984 0.019 200.873)", "cyan-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.956 0.045 203.388)", "cyan-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.917 0.08 205.041)", "cyan-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.865 0.127 207.078)", "cyan-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.789 0.154 211.53)", "cyan-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.715 0.143 215.221)", "cyan-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.609 0.126 221.723)", "cyan-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.52 0.105 223.128)", "cyan-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.45 0.085 224.283)", "cyan-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.398 0.07 227.392)", "cyan-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.302 0.056 229.695)", "cyan-950");
}
/// <summary>
///     Represents the sky color scale.
/// </summary>
public sealed class Sky : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.977 0.013 236.62)", "sky-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.951 0.026 236.824)", "sky-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.901 0.058 230.902)", "sky-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.828 0.111 230.318)", "sky-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.746 0.16 232.661)", "sky-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.685 0.169 237.323)", "sky-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.588 0.158 241.966)", "sky-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.5 0.134 242.749)", "sky-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.443 0.11 240.79)", "sky-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.391 0.09 240.876)", "sky-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.293 0.066 243.157)", "sky-950");
}
/// <summary>
///     Represents the blue color scale.
/// </summary>
public sealed class Blue : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.97 0.014 254.604)", "blue-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.932 0.032 255.585)", "blue-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.882 0.059 254.128)", "blue-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.809 0.105 251.813)", "blue-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.707 0.165 254.624)", "blue-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.623 0.214 259.815)", "blue-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.546 0.245 262.881)", "blue-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.488 0.243 264.376)", "blue-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.424 0.199 265.638)", "blue-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.379 0.146 265.522)", "blue-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.282 0.091 267.935)", "blue-950");
}
/// <summary>
///     Represents the indigo color scale.
/// </summary>
public sealed class Indigo : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.962 0.018 272.314)", "indigo-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.93 0.034 272.788)", "indigo-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.87 0.065 274.039)", "indigo-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.785 0.115 274.713)", "indigo-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.673 0.182 276.935)", "indigo-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.585 0.233 277.117)", "indigo-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.511 0.262 276.966)", "indigo-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.457 0.24 277.023)", "indigo-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.398 0.195 277.366)", "indigo-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.359 0.144 278.697)", "indigo-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.257 0.09 281.288)", "indigo-950");
}
/// <summary>
///     Represents the violet color scale.
/// </summary>
public sealed class Violet : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.969 0.016 293.756)", "violet-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.943 0.029 294.588)", "violet-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.894 0.057 293.283)", "violet-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.811 0.111 293.571)", "violet-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.702 0.183 293.541)", "violet-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.606 0.25 292.717)", "violet-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.541 0.281 293.009)", "violet-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.491 0.27 292.581)", "violet-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.432 0.232 292.759)", "violet-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.38 0.189 293.745)", "violet-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.283 0.141 291.089)", "violet-950");
}
/// <summary>
///     Represents the purple color scale.
/// </summary>
public sealed class Purple : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.977 0.014 308.299)", "purple-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.946 0.033 307.174)", "purple-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.902 0.063 306.703)", "purple-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.827 0.119 306.383)", "purple-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.714 0.203 305.504)", "purple-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.627 0.265 303.9)", "purple-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.558 0.288 302.321)", "purple-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.496 0.265 301.924)", "purple-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.438 0.218 303.724)", "purple-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.381 0.176 304.987)", "purple-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.291 0.149 302.717)", "purple-950");
}
/// <summary>
///     Represents the fuchsia color scale.
/// </summary>
public sealed class Fuchsia : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.977 0.017 320.058)", "fuchsia-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.952 0.037 318.852)", "fuchsia-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.903 0.076 319.62)", "fuchsia-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.833 0.145 321.434)", "fuchsia-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.74 0.238 322.16)", "fuchsia-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.667 0.295 322.15)", "fuchsia-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.591 0.293 322.896)", "fuchsia-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.518 0.253 323.949)", "fuchsia-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.452 0.211 324.591)", "fuchsia-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.401 0.17 325.612)", "fuchsia-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.293 0.136 325.661)", "fuchsia-950");
}
/// <summary>
///     Represents the pink color scale.
/// </summary>
public sealed class Pink : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.971 0.014 343.198)", "pink-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.948 0.028 342.258)", "pink-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.899 0.061 343.231)", "pink-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.823 0.12 346.018)", "pink-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.718 0.202 349.761)", "pink-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.656 0.241 354.308)", "pink-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.592 0.249 0.584)", "pink-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.525 0.223 3.958)", "pink-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.459 0.187 3.815)", "pink-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.408 0.153 2.432)", "pink-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.284 0.109 3.907)", "pink-950");
}
/// <summary>
///     Represents the rose color scale.
/// </summary>
public sealed class Rose : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.969 0.015 12.422)", "rose-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.941 0.03 12.58)", "rose-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.892 0.058 10.001)", "rose-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.81 0.117 11.638)", "rose-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.712 0.194 13.428)", "rose-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.645 0.246 16.439)", "rose-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.586 0.253 17.585)", "rose-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.514 0.222 16.935)", "rose-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.455 0.188 13.697)", "rose-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.41 0.159 10.272)", "rose-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.271 0.105 12.094)", "rose-950");
}
/// <summary>
///     Represents the slate color scale.
/// </summary>
public sealed class Slate : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.984 0.003 247.858)", "slate-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.968 0.007 247.896)", "slate-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.929 0.013 255.508)", "slate-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.869 0.022 252.894)", "slate-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.704 0.04 256.788)", "slate-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.554 0.046 257.417)", "slate-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.446 0.043 257.281)", "slate-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.372 0.044 257.287)", "slate-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.279 0.041 260.031)", "slate-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.208 0.042 265.755)", "slate-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.129 0.042 264.695)", "slate-950");
}
/// <summary>
///     Represents the gray color scale.
/// </summary>
public sealed class Gray : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.985 0.002 247.839)", "gray-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.967 0.003 264.542)", "gray-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.928 0.006 264.531)", "gray-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.872 0.01 258.338)", "gray-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.707 0.022 261.325)", "gray-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.551 0.027 264.364)", "gray-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.446 0.03 256.802)", "gray-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.373 0.034 259.733)", "gray-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.278 0.033 256.848)", "gray-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.21 0.034 264.665)", "gray-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.13 0.028 261.692)", "gray-950");
}
/// <summary>
///     Represents the zinc color scale.
/// </summary>
public sealed class Zinc : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.985 0 0)", "zinc-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.967 0.001 286.375)", "zinc-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.92 0.004 286.32)", "zinc-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.871 0.006 286.286)", "zinc-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.705 0.015 286.067)", "zinc-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.552 0.016 285.938)", "zinc-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.442 0.017 285.786)", "zinc-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.37 0.013 285.805)", "zinc-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.274 0.006 286.033)", "zinc-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.21 0.006 285.885)", "zinc-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.141 0.005 285.823)", "zinc-950");
}
/// <summary>
///     Represents the neutral color scale.
/// </summary>
public sealed class Neutral : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.985 0 0)", "neutral-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.97 0 0)", "neutral-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.922 0 0)", "neutral-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.87 0 0)", "neutral-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.708 0 0)", "neutral-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.556 0 0)", "neutral-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.439 0 0)", "neutral-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.371 0 0)", "neutral-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.269 0 0)", "neutral-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.205 0 0)", "neutral-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.145 0 0)", "neutral-950");
}
/// <summary>
///     Represents the stone color scale.
/// </summary>
public sealed class Stone : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("oklch(0.985 0.001 106.423)", "stone-50");
    /// <inheritdoc />
    public override Color L100 => new("oklch(0.97 0.001 106.424)", "stone-100");
    /// <inheritdoc />
    public override Color L200 => new("oklch(0.923 0.003 48.717)", "stone-200");
    /// <inheritdoc />
    public override Color L300 => new("oklch(0.869 0.005 56.366)", "stone-300");
    /// <inheritdoc />
    public override Color L400 => new("oklch(0.709 0.01 56.259)", "stone-400");
    /// <inheritdoc />
    public override Color L500 => new("oklch(0.553 0.013 58.071)", "stone-500");
    /// <inheritdoc />
    public override Color L600 => new("oklch(0.444 0.011 73.639)", "stone-600");
    /// <inheritdoc />
    public override Color L700 => new("oklch(0.374 0.01 67.558)", "stone-700");
    /// <inheritdoc />
    public override Color L800 => new("oklch(0.268 0.007 34.298)", "stone-800");
    /// <inheritdoc />
    public override Color L900 => new("oklch(0.216 0.006 56.043)", "stone-900");
    /// <inheritdoc />
    public override Color L950 => new("oklch(0.147 0.004 49.25)", "stone-950");
}
</file>

<file path="Components/DataTable/Models/ColumnDefinition.cs">
using Microsoft.AspNetCore.Components; // Required for RenderFragment
using System.Linq.Expressions;
namespace RizzyUI;
/// <summary>
/// Represents the definition of a table column, primarily used by RzTable to store
/// information about columns declared via RzTableHeaderCell.
/// </summary>
/// <typeparam name="TItem">The type of data item for the row.</typeparam>
/// <param name="Key">A unique key for the column, typically derived from the property name.</param>
/// <param name="TitleFragment">The RenderFragment for the header cell's title.</param>
/// <param name="IsSortable">Indicates if the column can be sorted.</param>
/// <param name="InitialSortDirection">The initial sort direction if the column is sortable.</param>
/// <param name="PropertyExpression">The lambda expression pointing to the TItem property this column represents. Can be null if column is not directly mapped to a property.</param>
internal record ColumnDefinition<TItem>(
    string Key,
    RenderFragment TitleFragment,
    bool IsSortable,
    SortDirection InitialSortDirection,
    Expression<Func<TItem, object?>>? PropertyExpression
);
</file>

<file path="Components/DataTable/Models/PaginationState.cs">
namespace RizzyUI;
/// <summary>
/// Represents the state of pagination for a data set.
/// </summary>
/// <param name="CurrentPage">The current page number (1-based).</param>
/// <param name="TotalPages">The total number of pages available.</param>
/// <param name="PageSize">The number of items displayed per page.</param>
/// <param name="TotalItems">The total number of items in the entire data set.</param>
public record PaginationState(int CurrentPage, int TotalPages, int PageSize, long TotalItems);
</file>

<file path="Components/DataTable/Models/SortDirection.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the direction of sorting for a table column.
/// </summary>
public enum SortDirection
{
    /// <summary>
    /// No sorting is applied, or the column is not currently sorted.
    /// </summary>
    Unset,
    /// <summary>
    /// Sort in ascending order (e.g., A-Z, 0-9).
    /// </summary>
    Ascending,
    /// <summary>
    /// Sort in descending order (e.g., Z-A, 9-0).
    /// </summary>
    Descending
}
</file>

<file path="Components/DataTable/Models/TableRequestModel.cs">
using Microsoft.AspNetCore.Http.Extensions; // For QueryBuilder
namespace RizzyUI;
/// <summary>
/// Represents the parameters for an HTMX table request, including pagination, sorting, and filtering.
/// </summary>
public record TableRequestModel
{
    /// <summary>
    /// Free-text search query. Corresponds to the 'q' parameter.
    /// </summary>
    public string? Query { get; init; }
    /// <summary>
    /// Current page number (1-based). Corresponds to the 'page' parameter.
    /// </summary>
    public int Page { get; init; } = 1;
    /// <summary>
    /// Number of items per page. Corresponds to the 'pageSize' parameter.
    /// </summary>
    public int PageSize { get; init; } = 10;
    /// <summary>
    /// Column(s) to sort by. Can be a single column key or comma-separated for multi-column sort.
    /// Corresponds to the 'sortBy' parameter.
    /// For nested properties, use dot notation (e.g., "Category.Name") if the server-side binder supports it,
    /// or ensure your ColumnKey on RzTableHeaderCell matches what the server expects.
    /// </summary>
    public string? SortBy { get; init; }
    /// <summary>
    /// Sort direction(s) ("asc" or "desc"). Can be a single direction or comma-separated for multi-column sort,
    /// corresponding to the SortBy columns. Corresponds to the 'sortDir' parameter.
    /// </summary>
    public string? SortDir { get; init; }
    /// <summary>
    /// Column-specific filters. Keys are in the format "filter.{columnKey}".
    /// </summary>
    public Dictionary<string, string> Filters { get; init; } = new();
    /// <summary>
    /// Converts the model to a query string, excluding null/empty values and default pagination.
    /// </summary>
    /// <returns>A query string representation.</returns>
    public string ToQueryString()
    {
        var queryParams = new Dictionary<string, string?>();
        if (!string.IsNullOrWhiteSpace(Query))
            queryParams["q"] = Query;
        if (Page > 1) // Only include page if not the first page
            queryParams["page"] = Page.ToString();
        // Only include pageSize if not the default (assuming 10 is default)
        // However, it's often safer to always include pageSize if it's part of the request contract
        // For this example, let's include it if it's not the absolute common default or has been set.
        if (PageSize != 10)
            queryParams["pageSize"] = PageSize.ToString();
        if (!string.IsNullOrWhiteSpace(SortBy))
        {
            queryParams["sortBy"] = SortBy;
            if (!string.IsNullOrWhiteSpace(SortDir)) // Only include sortDir if sortBy is present
            {
                queryParams["sortDir"] = SortDir;
            }
        }
        foreach (var filter in Filters.Where(f => !string.IsNullOrWhiteSpace(f.Value)))
        {
            queryParams[filter.Key] = filter.Value;
        }
        var builder = new QueryBuilder();
        foreach (var kvp in queryParams.Where(kvp => kvp.Value != null))
        {
            builder.Add(kvp.Key, kvp.Value!);
        }
        return builder.ToQueryString().ToString();
    }
    /// <summary>
    /// Converts the model to a query string, excluding pagination parameters (page and pageSize)
    /// but including sort and filter parameters. Useful for constructing pagination links
    /// that preserve current sort/filter state.
    /// </summary>
    /// <returns>A query string representation without pagination parameters.</returns>
    public string ToQueryStringSansPage()
    {
        var queryParams = new Dictionary<string, string?>();
        if (!string.IsNullOrWhiteSpace(Query))
            queryParams["q"] = Query;
        // Page and PageSize are intentionally omitted
        if (!string.IsNullOrWhiteSpace(SortBy))
        {
            queryParams["sortBy"] = SortBy;
            if (!string.IsNullOrWhiteSpace(SortDir))
            {
                queryParams["sortDir"] = SortDir;
            }
        }
        foreach (var filter in Filters.Where(f => !string.IsNullOrWhiteSpace(f.Value)))
        {
            queryParams[filter.Key] = filter.Value;
        }
        var builder = new QueryBuilder();
        foreach (var kvp in queryParams.Where(kvp => kvp.Value != null))
        {
            builder.Add(kvp.Key, kvp.Value!);
        }
        return builder.ToQueryString().ToString();
    }
}
</file>

<file path="Components/DataTable/Models/TableSelectionMode.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the row selection behavior for an RzTable.
/// </summary>
public enum TableSelectionMode
{
    /// <summary>
    /// Row selection is disabled.
    /// </summary>
    None,
    /// <summary>
    /// Only a single row can be selected at a time.
    /// </summary>
    Single,
    /// <summary>
    /// Multiple rows can be selected.
    /// </summary>
    Multiple
}
</file>

<file path="Components/DataTable/RzTable/RzTable.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent<RzTableSlots>

<CascadingValue Value="this" Name="ParentRzTable" IsFixed="true">
    <HtmlElement Element="div" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
        <table class="@SlotClasses.GetTable()" id="@TableId"> 
            @if (Header != null)
            {
                <thead class="@SlotClasses.GetThead()" id="@TableHeaderId">
                @Header(this)
                </thead>
            }
            
            @if (Body != null)
            {
                @Body!(this)
            }

            @if (Footer != null)
            {
                <tfoot class="@SlotClasses.GetTfoot()" id="@TableFooterId">
                @Footer(this)
                </tfoot>
            }
        </table>
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/DataTable/RzTable/RzTable.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A highly configurable and HTMX-interactive table component.
/// It supports generic data types, templated headers, body, and footers,
/// and integrates with HTMX for dynamic operations like sorting, pagination, and filtering.
/// This component cascades itself to child components for easy access to table-wide properties.
/// </summary>
[CascadingTypeParameter(nameof(TItem))]
public partial class RzTable<TItem> : RzComponent<RzTableSlots>, IHasTableStylingProperties
{
    private readonly List<ColumnDefinition<TItem>> _columnDefinitions = new();
    private string? _tableBodyIdInternal;
    private bool _hasRegisteredBody = false;
    internal string? TableBodyIdInternal
    {
        get => _tableBodyIdInternal;
        private set => _tableBodyIdInternal = value;
    }
    internal void RegisterTableBodyId(string tableBodyId)
    {
        if (_hasRegisteredBody && TableBodyIdInternal != tableBodyId)
        {
            throw new InvalidOperationException($"An RzTableBody with ID '{TableBodyIdInternal}' is already registered with this RzTable. Only one RzTableBody is allowed.");
        }
        TableBodyIdInternal = tableBodyId;
        _hasRegisteredBody = true;
    }
    /// <summary>
    /// Gets the effective CSS selector for HTMX `hx-target` attributes.
    /// It prioritizes the user-provided <see cref="HxTargetSelector"/>, then the ID of a registered <see cref="TableBody{TItem}"/>,
    /// and finally falls back to a data attribute selector based on this table's ID.
    /// </summary>
    public string EffectiveHxTargetSelector =>
        HxTargetSelector ??
        (!string.IsNullOrEmpty(TableBodyIdInternal) ? $"#{TableBodyIdInternal}" : $"[data-rztable-body-for='{Id}']");
    /// <summary>
    /// Gets or sets the collection of items to be displayed in the table. This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public IEnumerable<TItem> Items { get; set; } = Enumerable.Empty<TItem>();
    /// <summary>
    /// Gets or sets the base URL for HTMX requests (e.g., sorting, pagination). This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public string HxControllerUrl { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets the current state of the table request, including sorting, filtering, and pagination info.
    /// </summary>
    [Parameter] public TableRequestModel CurrentTableRequest { get; set; } = new();
    /// <summary>
    /// Gets or sets the current pagination state of the table, including total items and page count.
    /// </summary>
    [Parameter] public PaginationState CurrentPaginationState { get; set; } = new(1, 0, 10, 0);
    /// <summary>
    /// Gets or sets a specific CSS selector for the `hx-target` attribute, overriding the default behavior.
    /// </summary>
    [Parameter] public string? HxTargetSelector { get; set; }
    /// <summary>
    /// Gets or sets the HTMX swap mode (e.g., "innerHTML", "outerHTML"). Defaults to "innerHTML".
    /// </summary>
    [Parameter] public string HxSwapMode { get; set; } = "innerHTML";
    /// <summary>
    /// Gets or sets the CSS selector for an element to be shown as a loading indicator during HTMX requests.
    /// </summary>
    [Parameter] public string? HxIndicatorSelector { get; set; }
    /// <summary>
    /// Gets or sets the render fragment for the table's header section (`&lt;thead&gt;`). This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<RzTable<TItem>>? Header { get; set; }
    /// <summary>
    /// Gets or sets the render fragment for the table's body section (`&lt;tbody&gt;`). This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<RzTable<TItem>>? Body { get; set; }
    /// <summary>
    /// Gets or sets the render fragment for the table's footer section (`&lt;tfoot&gt;`).
    /// </summary>
    [Parameter] public RenderFragment<RzTable<TItem>>? Footer { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether to apply striped styling to table rows. Defaults to false.
    /// </summary>
    [Parameter] public bool Striped { get; set; } = false;
    /// <summary>
    /// Gets or sets a value indicating whether rows should have a hover effect. Defaults to true.
    /// </summary>
    [Parameter] public bool Hoverable { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether the table should have a border. Defaults to false.
    /// </summary>
    [Parameter] public bool Border { get; set; } = false;
    /// <summary>
    /// Gets or sets the row selection mode for the table. Defaults to <see cref="TableSelectionMode.None"/>.
    /// </summary>
    [Parameter] public TableSelectionMode SelectionMode { get; set; } = TableSelectionMode.None;
    /// <summary>
    /// Gets or sets an event callback that is invoked when the selected items change.
    /// </summary>
    [Parameter] public EventCallback<List<TItem>> SelectedItemsChanged { get; set; }
    /// <summary>
    /// Gets or sets the list of currently selected items in the table.
    /// </summary>
    [Parameter] public List<TItem> SelectedItems { get; set; } = new();
    /// <summary>
    /// Gets or sets a value indicating whether the table header should remain fixed while scrolling. Defaults to false.
    /// </summary>
    [Parameter] public bool FixedHeader { get; set; } = false;
    /// <summary>
    /// Gets or sets the CSS height class for the table body when <see cref="FixedHeader"/> is true. Defaults to "h-96".
    /// </summary>
    [Parameter] public string TableBodyHeightClass { get; set; } = "h-96";
    /// <summary>
    /// Gets the unique ID for the inner `&lt;table&gt;` element.
    /// </summary>
    public string TableId => $"{Id}-table";
    /// <summary>
    /// Gets the unique ID for the `&lt;thead&gt;` element.
    /// </summary>
    public string TableHeaderId => $"{Id}-table-head";
    /// <summary>
    /// Gets the unique ID for the `&lt;tfoot&gt;` element.
    /// </summary>
    public string TableFooterId => $"{Id}-table-foot";
    internal void AddColumnDefinition(ColumnDefinition<TItem> columnDefinition)
    {
        if (!_columnDefinitions.Any(cd => cd.Key == columnDefinition.Key))
        {
            _columnDefinitions.Add(columnDefinition);
            StateHasChanged();
        }
    }
    internal IReadOnlyList<ColumnDefinition<TItem>> GetColumnDefinitions() => _columnDefinitions.AsReadOnly();
    /// <summary>
    /// Gets the total number of columns defined in the table.
    /// </summary>
    public int ColumnCount => _columnDefinitions.Count > 0 ? _columnDefinitions.Count : 1;
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (FixedHeader)
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            if (AdditionalAttributes.TryGetValue("class", out var existingClass))
            {
                AdditionalAttributes["class"] = $"{existingClass} {TableBodyHeightClass}";
            }
            else
            {
                AdditionalAttributes["class"] = TableBodyHeightClass;
            }
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<RzTableSlots>, RzTableSlots> GetDescriptor() => Theme.RzTable;
}
</file>

<file path="Components/DataTable/RzTable/Styling/RzTableStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for an RzTable component.
/// </summary>
public interface IHasTableStylingProperties
{
    /// <summary>
    /// Gets a value indicating whether the table header should be fixed.
    /// </summary>
    public bool FixedHeader { get; }
}
/// <summary>
/// Defines the slots available for styling in the RzTable component.
/// </summary>
public sealed partial class RzTableSlots : ISlots
{
    /// <summary>
    /// The base slot for the main table container.
    /// </summary>
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the `&lt;table&gt;` element itself.
    /// </summary>
    public string? Table { get; set; }
    /// <summary>
    /// The slot for the `&lt;thead&gt;` element.
    /// </summary>
    public string? Thead { get; set; }
    /// <summary>
    /// The slot for the `&lt;tfoot&gt;` element.
    /// </summary>
    public string? Tfoot { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzTable component.
/// </summary>
public static class RzTableStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzTable component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzTableSlots>, RzTableSlots> DefaultDescriptor = new(
        @base: "relative w-full overflow-x-auto rounded-lg border",
        slots: new()
        {
            [s => s.Table] = "w-full caption-bottom text-sm",
            [s => s.Thead] = "[&_tr]:border-b",
            [s => s.Tfoot] = "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0"
        },
        variants: new()
        {
            [c => ((IHasTableStylingProperties)c).FixedHeader] = new Variant<bool, RzTableSlots>
            {
                [true] = new()
                {
                    [s => s.Base] = "relative overflow-y-auto",
                    [s => s.Thead] = "sticky top-0 z-10 bg-card",
                    [s => s.Tfoot] = "sticky bottom-0 z-10 bg-muted/50"
                }
            }
        }
    );
}
</file>

<file path="Components/DataTable/RzTable/Styling/TableBodyStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the slots available for styling in the TableBody component.
/// </summary>
public sealed partial class TableBodySlots : ISlots
{
    /// <summary>
    /// The base slot for the `&lt;tbody&gt;` element.
    /// </summary>
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the TableBody component.
/// </summary>
public static class TableBodyStyles
{
    /// <summary>
    /// The default TvDescriptor for the TableBody component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<TableBodySlots>, TableBodySlots> DefaultDescriptor = new(
        @base: "[&_tr:last-child]:border-0"
    );
}
</file>

<file path="Components/DataTable/RzTable/Styling/TableCellStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the slots available for styling in the TableCell component.
/// </summary>
public sealed partial class TableCellSlots : ISlots
{
    /// <summary>
    /// The base slot for the `&lt;td&gt;` element.
    /// </summary>
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the TableCell component.
/// </summary>
public static class TableCellStyles
{
    /// <summary>
    /// The default TvDescriptor for the TableCell component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<TableCellSlots>, TableCellSlots> DefaultDescriptor = new(
        @base: "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]"
    );
}
</file>

<file path="Components/DataTable/RzTable/Styling/TableHeaderCellStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a TableHeaderCell component.
/// </summary>
public interface IHasTableHeaderCellStylingProperties
{
    /// <summary>
    /// Gets whether the column is sortable.
    /// </summary>
    public bool Sortable { get; }
    /// <summary>
    /// Gets the current sort direction of the column.
    /// </summary>
    public SortDirection CurrentSortDirection { get; }
}
/// <summary>
/// Defines the slots available for styling in the TableHeaderCell component.
/// </summary>
public sealed partial class TableHeaderCellSlots : ISlots
{
    /// <summary>
    /// The base slot for the `&lt;th&gt;` element.
    /// </summary>
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the sortable button within the header cell.
    /// </summary>
    public string? SortableButton { get; set; }
    /// <summary>
    /// The slot for the title span within the header cell.
    /// </summary>
    public string? TitleSpan { get; set; }
    /// <summary>
    /// The slot for the sort direction indicator icon.
    /// </summary>
    public string? SortIndicator { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the TableHeaderCell component.
/// </summary>
public static class TableHeaderCellStyles
{
    /// <summary>
    /// The default TvDescriptor for the TableHeaderCell component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<TableHeaderCellSlots>, TableHeaderCellSlots> DefaultDescriptor = new(
        @base: "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        slots: new()
        {
            [s => s.SortableButton] = "flex items-center justify-between gap-2 w-full text-left focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 dark:focus-visible:ring-offset-background rounded-sm",
            [s => s.TitleSpan] = "flex-grow",
            [s => s.SortIndicator] = "size-4"
        },
        variants: new()
        {
            [c => ((IHasTableHeaderCellStylingProperties)c).Sortable] = new Variant<bool, TableHeaderCellSlots>
            {
                [true] = new() { [s => s.Base] = "cursor-pointer hover:bg-muted/50" }
            },
            [c => ((IHasTableHeaderCellStylingProperties)c).CurrentSortDirection] = new Variant<SortDirection, TableHeaderCellSlots>
            {
                [SortDirection.Ascending] = new() { [s => s.SortIndicator] = "text-foreground" },
                [SortDirection.Descending] = new() { [s => s.SortIndicator] = "text-foreground" },
                [SortDirection.Unset] = new() { [s => s.SortIndicator] = "text-muted-foreground opacity-60" }
            }
        }
    );
}
</file>

<file path="Components/DataTable/RzTable/Styling/TablePaginationStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the slots available for styling in the TablePagination component.
/// </summary>
public sealed partial class TablePaginationSlots : ISlots
{
    /// <summary>
    /// The base slot for the main pagination container.
    /// </summary>
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the `&lt;ul&gt;` element containing pagination links.
    /// </summary>
    public string? List { get; set; }
    /// <summary>
    /// The slot for a standard pagination link/button.
    /// </summary>
    public string? Link { get; set; }
    /// <summary>
    /// The slot for the current page link/button.
    /// </summary>
    public string? LinkCurrent { get; set; }
    /// <summary>
    /// The slot for a disabled pagination link/button.
    /// </summary>
    public string? LinkDisabled { get; set; }
    /// <summary>
    /// The slot for the ellipsis (...) element.
    /// </summary>
    public string? Ellipsis { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the TablePagination component.
/// </summary>
public static class TablePaginationStyles
{
    /// <summary>
    /// The default TvDescriptor for the TablePagination component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<TablePaginationSlots>, TablePaginationSlots> DefaultDescriptor = new(
        @base: "flex justify-center items-center",
        slots: new()
        {
            [s => s.List] = "inline-flex items-center gap-1 text-sm",
            [s => s.Link] = "inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] cursor-pointer h-9 px-3 border bg-background shadow-xs dark:bg-input/30 dark:border-input hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 rounded-md",
            [s => s.LinkCurrent] = "inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] cursor-pointer h-9 px-3 border bg-primary text-primary-foreground shadow-xs hover:bg-primary/90 rounded-md aria-[current=page]:z-10",
            [s => s.LinkDisabled] = "inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] cursor-pointer h-9 px-3 border bg-background shadow-xs dark:bg-input/30 dark:border-input opacity-50 cursor-not-allowed rounded-md",
            [s => s.Ellipsis] = "inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] cursor-pointer h-9 px-3 border bg-background shadow-xs dark:bg-input/30 dark:border-input select-none rounded-md"
        }
    );
}
</file>

<file path="Components/DataTable/RzTable/Styling/TableRowStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the slots available for styling in the TableRow component.
/// </summary>
public sealed partial class TableRowSlots : ISlots
{
    /// <summary>
    /// The base slot for the `&lt;tr&gt;` element.
    /// </summary>
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the TableRow component.
/// </summary>
public static class TableRowStyles
{
    /// <summary>
    /// The default TvDescriptor for the TableRow component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<TableRowSlots>, TableRowSlots> DefaultDescriptor = new(
        @base: "border-b transition-colors",
        variants: new()
        {
            [c => ((IHasTableRowStylingProperties)c).IsEven] = new Variant<bool, TableRowSlots>
            {
                [true] = "bg-secondary",
                [false] = "bg-background"
            },
            [c => ((IHasTableRowStylingProperties)c).IsHoverable] = new Variant<bool, TableRowSlots>
            {
                [true] = "hover:bg-muted/50"
            }
        }
    );
}
</file>

<file path="Components/DataTable/RzTable/TableBody.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent<TableBodySlots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" hx-indicator="@EffectiveHxIndicatorSelector">
    @if (EffectiveItems.Any())
    {
        int rowIndex = (this.ParentRzTable?.CurrentPaginationState.CurrentPage-1) * this.ParentRzTable?.CurrentPaginationState.PageSize ?? 0;
        foreach (var item in EffectiveItems)
        {
            <CascadingValue Value="rowIndex" Name="RowIndex" IsFixed="false">
                @RowTemplate(item)
            </CascadingValue>
            rowIndex++;
        }
    }
    else if (EmptyTemplate != null)
    {
        <tr> 
            <TableCell TItem="@TItem" Colspan="@ColumnCount"> 
                @EmptyTemplate
            </TableCell>
        </tr>
    }
    else
    {
        <tr>
            <TableCell TItem="@TItem" Colspan="@ColumnCount">
                @Localizer["RzTable.DefaultEmptyMessage"]
            </TableCell>
        </tr>
    }
    <RzSpinner Id="@SpinnerId" Size="Size.Small" class="htmx-indicator absolute top-2.5 left-1/2 -translate-x-1/2"/>
</HtmlElement>
</file>

<file path="Components/DataTable/RzTable/TableBody.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the body (`&lt;tbody&gt;`) of an <see cref="RzTable{TItem}"/>, responsible for rendering rows of data.
/// </summary>
/// <typeparam name="TItem">The type of data item for each row.</typeparam>
public partial class TableBody<TItem> : RzComponent<TableBodySlots>
{
    /// <summary>
    /// Gets or sets the parent <see cref="RzTable{TItem}"/> component.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Gets or sets the collection of items to render. If not provided, it falls back to the items from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    /// <summary>
    /// Gets or sets the template for rendering each row. This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<TItem> RowTemplate { get; set; } = default!;
    /// <summary>
    /// Gets or sets the template to display when there are no items to render.
    /// </summary>
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    /// <summary>
    /// Gets the effective collection of items to be rendered.
    /// </summary>
    protected IEnumerable<TItem> EffectiveItems => Items ?? ParentRzTable?.Items ?? Enumerable.Empty<TItem>();
    /// <summary>
    /// Gets the number of columns in the table, used for colspan in the empty template.
    /// </summary>
    protected int ColumnCount => ParentRzTable?.ColumnCount ?? 1;
    /// <summary>
    /// Gets the unique ID for the loading spinner element.
    /// </summary>
    protected string SpinnerId => $"{Id}-spinner";
    /// <summary>
    /// Gets the effective CSS selector for the HTMX loading indicator.
    /// </summary>
    protected string? EffectiveHxIndicatorSelector
    {
        get
        {
            if (AdditionalAttributes?.TryGetValue("hx-indicator", out var indicator) == true && indicator is string indicatorStr)
            {
                return indicatorStr;
            }
            return ParentRzTable?.HxIndicatorSelector ?? $"#{SpinnerId}";
        }
    }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "tbody";
        if (ParentRzTable == null)
        {
            throw new InvalidOperationException($"{GetType().Name} must be used within an RzTable.");
        }
        ParentRzTable.RegisterTableBodyId(Id);
        AdditionalAttributes ??= new Dictionary<string, object>();
        AdditionalAttributes[$"data-rztable-body-for"] = ParentRzTable.Id;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<TableBodySlots>, TableBodySlots> GetDescriptor() => Theme.TableBody;
}
</file>

<file path="Components/DataTable/RzTable/TableCell.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent<TableCellSlots>

<HtmlElement Element="@EffectiveElement" @attributes="CombinedAttributes" id="@Id" class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/DataTable/RzTable/TableCell.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a single cell (`&lt;td&gt;`) within a <see cref="TableRow{TItem}"/>.
/// </summary>
/// <typeparam name="TItem">The type of data item for the row.</typeparam>
public partial class TableCell<TItem> : RzComponent<TableCellSlots>
{
    /// <summary>
    /// Gets or sets the parent <see cref="RzTable{TItem}"/> component.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Gets or sets the parent <see cref="TableRow{TItem}"/> component.
    /// </summary>
    [CascadingParameter(Name = "ParentTableRow")]
    protected TableRow<TItem>? ParentRzTableRow { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the cell.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the number of columns this cell should span.
    /// </summary>
    [Parameter] public int? Colspan { get; set; }
    /// <summary>
    /// Gets or sets a unique key for the column, used for identification.
    /// </summary>
    [Parameter] public string? ColumnKey { get; set; }
    /// <summary>
    /// Gets the combined attributes for the cell, including any `colspan`.
    /// </summary>
    protected Dictionary<string, object> CombinedAttributes
    {
        get
        {
            var attributes = new Dictionary<string, object>(AdditionalAttributes ?? new Dictionary<string, object>());
            if (Colspan.HasValue)
            {
                attributes["colspan"] = Colspan.Value.ToString();
            }
            return attributes;
        }
    }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "td";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<TableCellSlots>, TableCellSlots> GetDescriptor() => Theme.TableCell;
}
</file>

<file path="Components/DataTable/RzTable/TableHeaderCell.razor">
@namespace RizzyUI
@using Blazicons

@typeparam TItem
@inherits RzComponent<TableHeaderCellSlots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" aria-sort="@_ariaSortValue">
    @if (Sortable)
    {
        <button type="button"
                class="@SlotClasses.GetSortableButton()"
                aria-label="@_sortButtonAriaLabel"
                @attributes="GetEffectiveHxAttributes()">
            <span class="@SlotClasses.GetTitleSpan()">@ChildContent</span>
            @if (SortIndicatorIcon != null)
            {
                <div class="@SlotClasses.GetSortIndicator()">
                    <Blazicon Svg="SortIndicatorIcon" />
                </div>
                
            }
        </button>
    }
    else
    {
        <span class="@SlotClasses.GetTitleSpan()">@ChildContent</span>
    }
</HtmlElement>
</file>

<file path="Components/DataTable/RzTable/TableHeaderCell.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component representing a header cell in a data table
/// </summary>
/// <typeparam name="TItem">The type of data item in the table</typeparam>
public partial class TableHeaderCell<TItem> : RzComponent<TableHeaderCellSlots>, IHasTableHeaderCellStylingProperties
{
    private string? _columnKeyInternal;
    private string? _effectiveHxGetUrl;
    private SortDirection _currentSortDirection = SortDirection.Unset;
    private SortDirection _nextSortDirection = SortDirection.Ascending;
    private string _ariaSortValue = "none";
    private string _sortButtonAriaLabel = string.Empty;
    /// <summary>
    /// Gets or sets the parent RzTable component that contains this header cell
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Gets or sets the expression used to bind the column to a property of TItem
    /// </summary>
    [Parameter] public Expression<Func<TItem, object?>>? For { get; set; }
    /// <summary>
    /// Gets or sets the unique key for the column
    /// </summary>
    [Parameter] public string? ColumnKey { get; set; }
    /// <summary>
    /// Gets or sets whether the column can be sorted
    /// </summary>
    [Parameter] public bool Sortable { get; set; }
    /// <summary>
    /// Gets or sets the initial sort direction for the column
    /// </summary>
    [Parameter] public SortDirection InitialSortDirection { get; set; } = SortDirection.Unset;
    /// <summary>
    /// Gets or sets the content to be displayed in the header cell
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets additional HTMX attributes for the header cell
    /// </summary>
    [Parameter] public Dictionary<string, object>? HxAttributes { get; set; }
    /// <summary>
    /// Gets the effective column key used for identification.
    /// </summary>
    public string EffectiveColumnKey => _columnKeyInternal ?? "unknown_column";
    /// <summary>
    /// Gets the current sort direction of the column.
    /// </summary>
    public SortDirection CurrentSortDirection => _currentSortDirection;
    /// <summary>
    /// Gets the next sort direction that will be applied when the header is clicked
    /// </summary>
    protected SortDirection NextSortDirection => _nextSortDirection;
    /// <summary>
    /// Gets the ARIA sort value for accessibility
    /// </summary>
    protected string AriaSortValue => _ariaSortValue;
    /// <summary>
    /// Gets the ARIA label for the sort button
    /// </summary>
    protected string SortButtonAriaLabel => _sortButtonAriaLabel;
    /// <summary>
    /// Gets the appropriate sort indicator icon based on the current sort direction
    /// </summary>
    protected SvgIcon? SortIndicatorIcon => _currentSortDirection switch
    {
        SortDirection.Ascending => MdiIcon.ArrowUp,
        SortDirection.Descending => MdiIcon.ArrowDown,
        SortDirection.Unset => MdiIcon.ArrowUpDownBoldOutline,
        _ => null
    };
    /// <summary>
    /// Initializes the component and validates its parent context
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentRzTable == null)
        {
            throw new InvalidOperationException($"{GetType().Name} must be used within an RzTable.");
        }
        if (string.IsNullOrEmpty(Element))
            Element = "th";
        AdditionalAttributes ??= new Dictionary<string, object>();
        AdditionalAttributes.TryAdd("scope", "col");
        ResolveColumnKeyAndRegister();
    }
    /// <summary>
    /// Updates the component when parameters are set
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        UpdateSortStateAndHxUrl();
    }
    private void ResolveColumnKeyAndRegister()
    {
        string resolvedKey;
        if (!string.IsNullOrWhiteSpace(ColumnKey))
        {
            resolvedKey = ColumnKey;
        }
        else if (For?.Body is MemberExpression memberExpression)
        {
            resolvedKey = memberExpression.Member.Name;
        }
        else if (For?.Body is UnaryExpression { Operand: MemberExpression unaryMemberExpression })
        {
            resolvedKey = unaryMemberExpression.Member.Name;
        }
        else
        {
            resolvedKey = ChildContent.AsMarkupString().Trim().Replace(" ", "_") + "_" + IdGenerator.UniqueId("col");
            if (string.IsNullOrWhiteSpace(resolvedKey) || resolvedKey.StartsWith("_"))
            {
                resolvedKey = IdGenerator.UniqueId("col_anon_");
            }
        }
        _columnKeyInternal = resolvedKey;
        ParentRzTable!.AddColumnDefinition(new ColumnDefinition<TItem>(
            EffectiveColumnKey,
            ChildContent,
            Sortable,
            InitialSortDirection,
            For
        ));
    }
    private void UpdateSortStateAndHxUrl()
    {
        if (ParentRzTable == null) return;
        var currentRequest = ParentRzTable.CurrentTableRequest;
        _currentSortDirection = SortDirection.Unset;
        _nextSortDirection = Sortable ? (InitialSortDirection != SortDirection.Unset ? InitialSortDirection : SortDirection.Ascending) : SortDirection.Unset;
        _ariaSortValue = "none";
        _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionNone"]);
        if (Sortable && !string.IsNullOrWhiteSpace(_columnKeyInternal))
        {
            if (currentRequest.SortBy == _columnKeyInternal)
            {
                if (currentRequest.SortDir?.ToLowerInvariant() == "asc")
                {
                    _currentSortDirection = SortDirection.Ascending;
                    _nextSortDirection = SortDirection.Descending;
                    _ariaSortValue = "ascending";
                    _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionAscendingLong"]);
                }
                else if (currentRequest.SortDir?.ToLowerInvariant() == "desc")
                {
                    _currentSortDirection = SortDirection.Descending;
                    _nextSortDirection = SortDirection.Unset;
                    _ariaSortValue = "descending";
                    _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionDescendingLong"]);
                }
            }
            else
            {
                if (InitialSortDirection != SortDirection.Unset && string.IsNullOrEmpty(currentRequest.SortBy))
                {
                    _currentSortDirection = InitialSortDirection;
                    _ariaSortValue = InitialSortDirection == SortDirection.Ascending ? "ascending" : "descending";
                }
            }
            TableRequestModel nextRequestParameters;
            if (_nextSortDirection == SortDirection.Unset)
            {
                nextRequestParameters = currentRequest with { SortBy = null, SortDir = null, Page = 1 };
            }
            else
            {
                nextRequestParameters = currentRequest with
                {
                    SortBy = _columnKeyInternal,
                    SortDir = _nextSortDirection == SortDirection.Ascending ? "asc" : "desc",
                    Page = 1
                };
            }
            _effectiveHxGetUrl = $"{ParentRzTable.HxControllerUrl}{nextRequestParameters.ToQueryString()}";
        }
        else
        {
            _effectiveHxGetUrl = null;
        }
    }
    /// <summary>
    /// Gets the effective HTMX attributes for the header cell, including sorting functionality
    /// </summary>
    /// <returns>A dictionary containing the HTMX attributes</returns>
    protected Dictionary<string, object> GetEffectiveHxAttributes()
    {
        var defaultAttributes = new Dictionary<string, object>();
        if (Sortable && !string.IsNullOrEmpty(_effectiveHxGetUrl) && ParentRzTable != null)
        {
            defaultAttributes["hx-get"] = _effectiveHxGetUrl;
            defaultAttributes["hx-target"] = ParentRzTable.EffectiveHxTargetSelector;
            defaultAttributes["hx-swap"] = ParentRzTable.HxSwapMode;
            if (!string.IsNullOrEmpty(ParentRzTable.HxIndicatorSelector))
            {
                defaultAttributes["hx-indicator"] = ParentRzTable.HxIndicatorSelector;
            }
        }
        if (HxAttributes != null)
        {
            foreach (var attr in HxAttributes)
            {
                defaultAttributes[attr.Key] = attr.Value;
            }
        }
        return defaultAttributes;
    }
    /// <summary>
    /// Gets the theme descriptor for the table header cell
    /// </summary>
    /// <returns>The theme descriptor for styling the component</returns>
    protected override TvDescriptor<RzComponent<TableHeaderCellSlots>, TableHeaderCellSlots> GetDescriptor() => Theme.TableHeaderCell;
}
</file>

<file path="Components/DataTable/RzTable/TablePagination.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent<TablePaginationSlots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" aria-label="@NavigationAriaLabel">
    @if (EffectivePaginationState.TotalPages > 1) 
    {
        <ul class="@SlotClasses.GetList()">
            <li>
                @if (CanGoPrevious)
                {
                    <button type="button"
                            class="@SlotClasses.GetLink()"
                            aria-label="@PreviousButtonLabel"
                            @attributes="GetPageLinkHxAttributes(EffectivePaginationState.CurrentPage - 1)">
                        @PreviousButtonLabel
                    </button>
                }
                else
                {
                    <span class="@SlotClasses.GetLinkDisabled()" aria-disabled="true">
                        @PreviousButtonLabel
                    </span>
                }
            </li>

            @foreach (var link in GetPageLinks())
            {
                <li>
                    @if (link.IsEllipsis)
                    {
                        <span class="@SlotClasses.GetEllipsis()">@link.Text</span>
                    }
                    else
                    {
                        <button type="button"
                                class="@(link.IsCurrent ? SlotClasses.GetLinkCurrent() : SlotClasses.GetLink())"
                                aria-current="@(link.IsCurrent ? "page" : null)"
                                aria-label="@($"Go to page {link.PageNumber}")"
                                disabled="@link.IsCurrent" 
                                @attributes="link.IsCurrent ? null : GetPageLinkHxAttributes(link.PageNumber)">
                            @link.Text
                        </button>
                    }
                </li>
            }

            <li>
                @if (CanGoNext)
                {
                    <button type="button"
                            class="@SlotClasses.GetLink()"
                            aria-label="@NextButtonLabel"
                            @attributes="GetPageLinkHxAttributes(EffectivePaginationState.CurrentPage + 1)">
                        @NextButtonLabel
                    </button>
                }
                else
                {
                    <span class="@SlotClasses.GetLinkDisabled()" aria-disabled="true">
                        @NextButtonLabel
                    </span>
                }
            </li>
        </ul>
    }
    else if (EffectivePaginationState.TotalItems > 0 && EffectivePaginationState.TotalPages <= 1)
    {
        // Optionally show nothing or a minimal message if only one page or no items?
    }
</HtmlElement>
</file>

<file path="Components/DataTable/RzTable/TablePagination.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that renders pagination controls for an <see cref="RzTable{TItem}"/>.
/// It generates page links and previous/next buttons, with HTMX attributes for dynamic page loading.
/// </summary>
/// <typeparam name="TItem">The type of data item in the table.</typeparam>
[CascadingTypeParameter(nameof(TItem))]
public partial class TablePagination<TItem> : RzComponent<TablePaginationSlots>
{
    /// <summary>
    /// Gets or sets the parent <see cref="RzTable{TItem}"/> component.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Gets or sets the pagination state. If not provided, it's inherited from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public PaginationState? PaginationState { get; set; }
    /// <summary>
    /// Gets or sets the base URL for HTMX requests. If not provided, it's inherited from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public string? HxControllerUrl { get; set; }
    /// <summary>
    /// Gets or sets the CSS selector for the HTMX target. If not provided, it's inherited from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public string? HxTargetSelector { get; set; }
    /// <summary>
    /// Gets or sets the HTMX swap mode. If not provided, it's inherited from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public string? HxSwapMode { get; set; }
    /// <summary>
    /// Gets or sets the CSS selector for the HTMX loading indicator. If not provided, it's inherited from the parent <see cref="RzTable{TItem}"/>.
    /// </summary>
    [Parameter] public string? HxIndicatorSelector { get; set; }
    /// <summary>
    /// Gets or sets additional HTMX attributes to apply to each page link.
    /// </summary>
    [Parameter] public Dictionary<string, object>? HxPageLinkAttributes { get; set; }
    /// <summary>
    /// Gets or sets the maximum number of visible page links to display. Defaults to 7.
    /// </summary>
    [Parameter] public int MaxVisiblePageLinks { get; set; } = 7;
    /// <summary>
    /// Gets or sets the label for the 'Previous' button. Defaults to a localized value.
    /// </summary>
    [Parameter] public string? PreviousButtonLabel { get; set; }
    /// <summary>
    /// Gets or sets the label for the 'Next' button. Defaults to a localized value.
    /// </summary>
    [Parameter] public string? NextButtonLabel { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the pagination navigation container. Defaults to a localized value.
    /// </summary>
    [Parameter] public string? NavigationAriaLabel { get; set; }
    /// <summary>
    /// Gets the effective pagination state, falling back to the parent table's state if not directly provided.
    /// </summary>
    protected PaginationState EffectivePaginationState => PaginationState ?? ParentRzTable?.CurrentPaginationState ?? new PaginationState(1, 0, 10, 0);
    /// <summary>
    /// Gets the current table request model from the parent table.
    /// </summary>
    protected TableRequestModel CurrentTableRequest => ParentRzTable?.CurrentTableRequest ?? new TableRequestModel();
    /// <summary>
    /// Gets the effective controller URL for HTMX requests.
    /// </summary>
    protected string EffectiveHxControllerUrl => HxControllerUrl ?? ParentRzTable?.HxControllerUrl ?? string.Empty;
    /// <summary>
    /// Gets the effective CSS selector for the HTMX target.
    /// </summary>
    protected string EffectiveHxTargetSelector => HxTargetSelector ?? ParentRzTable?.EffectiveHxTargetSelector ?? $"#{(ParentRzTable?.TableBodyIdInternal ?? ParentRzTable?.Id + "-tbody-default")}";
    /// <summary>
    /// Gets the effective HTMX swap mode.
    /// </summary>
    protected string EffectiveHxSwapMode => HxSwapMode ?? ParentRzTable?.HxSwapMode ?? "innerHTML";
    /// <summary>
    /// Gets the effective CSS selector for the HTMX loading indicator.
    /// </summary>
    protected string? EffectiveHxIndicatorSelector => HxIndicatorSelector ?? ParentRzTable?.HxIndicatorSelector ?? $"#{(ParentRzTable?.TableBodyIdInternal ?? ParentRzTable?.Id + "-tbody-default")}-spinner";
    /// <summary>
    /// Gets a value indicating whether it's possible to navigate to a previous page.
    /// </summary>
    protected bool CanGoPrevious => EffectivePaginationState.CurrentPage > 1;
    /// <summary>
    /// Gets a value indicating whether it's possible to navigate to a next page.
    /// </summary>
    protected bool CanGoNext => EffectivePaginationState.CurrentPage < EffectivePaginationState.TotalPages;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav";
        if (ParentRzTable == null && (PaginationState == null || string.IsNullOrEmpty(HxControllerUrl)))
        {
            throw new InvalidOperationException($"{GetType().Name} requires either to be within an RzTable, or to have PaginationState and HxControllerUrl parameters provided.");
        }
        EnsureParameterDefaults();
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (MaxVisiblePageLinks < 5) MaxVisiblePageLinks = 5;
        EnsureParameterDefaults();
    }
    private void EnsureParameterDefaults()
    {
        PreviousButtonLabel ??= Localizer["RzPagination.PreviousButtonLabel"];
        NextButtonLabel ??= Localizer["RzPagination.NextButtonLabel"];
        NavigationAriaLabel ??= Localizer["RzPagination.NavigationAriaLabel"];
    }
    /// <summary>
    /// Generates the URL for a specific page number.
    /// </summary>
    /// <param name="pageNumber">The page number to generate the URL for.</param>
    /// <returns>The generated URL string.</returns>
    protected string GetPageUrl(int pageNumber)
    {
        if (string.IsNullOrEmpty(EffectiveHxControllerUrl) || pageNumber < 1) return "#";
        var requestParams = CurrentTableRequest with { Page = pageNumber, PageSize = EffectivePaginationState.PageSize };
        return $"{EffectiveHxControllerUrl}{requestParams.ToQueryString()}";
    }
    /// <summary>
    /// Generates the HTMX attributes for a page link button.
    /// </summary>
    /// <param name="pageNumber">The page number the link navigates to.</param>
    /// <returns>A dictionary of HTMX attributes.</returns>
    protected Dictionary<string, object> GetPageLinkHxAttributes(int pageNumber)
    {
        var defaultAttributes = new Dictionary<string, object>
        {
            { "hx-get", GetPageUrl(pageNumber) },
            { "hx-target", EffectiveHxTargetSelector },
            { "hx-swap", EffectiveHxSwapMode }
        };
        if (!string.IsNullOrEmpty(EffectiveHxIndicatorSelector))
        {
            defaultAttributes["hx-indicator"] = EffectiveHxIndicatorSelector;
        }
        if (HxPageLinkAttributes != null)
        {
            foreach (var attr in HxPageLinkAttributes)
            {
                defaultAttributes[attr.Key] = attr.Value;
            }
        }
        return defaultAttributes;
    }
    /// <summary>
    /// Generates the list of page links to be displayed in the pagination control.
    /// </summary>
    /// <returns>A list of <see cref="PageLink"/> records.</returns>
    protected List<PageLink> GetPageLinks()
    {
        var links = new List<PageLink>();
        var totalPages = EffectivePaginationState.TotalPages;
        var currentPage = EffectivePaginationState.CurrentPage;
        if (totalPages <= 0) return links;
        if (totalPages <= MaxVisiblePageLinks)
        {
            for (int i = 1; i <= totalPages; i++)
            {
                links.Add(new PageLink(i.ToString(), i, i == currentPage, false));
            }
        }
        else
        {
            int linksToShow = MaxVisiblePageLinks - 2;
            bool hasStartEllipsis = false;
            bool hasEndEllipsis = false;
            if (currentPage > linksToShow / 2 + 1 && totalPages > linksToShow)
            {
                hasStartEllipsis = true;
                linksToShow--;
            }
            if (currentPage < totalPages - linksToShow / 2 && totalPages > linksToShow)
            {
                hasEndEllipsis = true;
                linksToShow--;
            }
            links.Add(new PageLink("1", 1, currentPage == 1, false));
            if (hasStartEllipsis)
            {
                links.Add(new PageLink("...", -1, false, true));
            }
            int rangeStart = Math.Max(2, currentPage - (linksToShow / 2) + (hasStartEllipsis && !hasEndEllipsis && (MaxVisiblePageLinks % 2 == 0) ? 1 : 0));
            int rangeEnd = Math.Min(totalPages - 1, rangeStart + linksToShow - 1);
            if (rangeEnd == totalPages - 1 && (rangeEnd - rangeStart + 1) < linksToShow)
            {
                rangeStart = Math.Max(2, rangeEnd - linksToShow + 1);
            }
            for (int i = rangeStart; i <= rangeEnd; i++)
            {
                if (i == 1 && links.Any(l => l.PageNumber == 1)) continue;
                if (i == totalPages && links.Any(l => l.PageNumber == totalPages)) continue;
                links.Add(new PageLink(i.ToString(), i, i == currentPage, false));
            }
            if (hasEndEllipsis)
            {
                if (links.Last().PageNumber < totalPages - 1)
                    links.Add(new PageLink("...", -2, false, true));
            }
            if (totalPages > 1)
                links.Add(new PageLink(totalPages.ToString(), totalPages, totalPages == currentPage, false));
        }
        return links.GroupBy(l => l.PageNumber)
                    .Select(g => g.OrderBy(l => l.IsEllipsis).First())
                    .OrderBy(l => l.PageNumber == -2 ? totalPages - 0.5 : (l.PageNumber == -1 ? 1.5 : l.PageNumber))
                    .ToList();
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<TablePaginationSlots>, TablePaginationSlots> GetDescriptor() => Theme.TablePagination;
    /// <summary>
    /// Represents a single link in the pagination control.
    /// </summary>
    /// <param name="Text">The text to display for the link.</param>
    /// <param name="PageNumber">The page number this link navigates to.</param>
    /// <param name="IsCurrent">Indicates if this is the current page.</param>
    /// <param name="IsEllipsis">Indicates if this is an ellipsis placeholder.</param>
    protected record PageLink(string Text, int PageNumber, bool IsCurrent, bool IsEllipsis);
}
</file>

<file path="Components/DataTable/RzTable/TableRow.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent<TableRowSlots>

<CascadingValue Value="this" Name="ParentTableRow" IsFixed="true">
	<tr @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
			@ChildContent
	</tr>	
</CascadingValue>
</file>

<file path="Components/DataTable/RzTable/TableRow.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a TableRow component.
/// </summary>
public interface IHasTableRowStylingProperties
{
    /// <summary>
    /// Gets a value indicating whether the row is even-numbered, for striped styling.
    /// </summary>
    public bool IsEven { get; }
    /// <summary>
    /// Gets a value indicating whether the row should have a hover effect.
    /// </summary>
    public bool IsHoverable { get; }
}
/// <summary>
/// Represents a single row (`&lt;tr&gt;`) within an <see cref="RzTable{TItem}"/>.
/// </summary>
/// <typeparam name="TItem">The type of data item for the row.</typeparam>
[CascadingTypeParameter(nameof(TItem))]
public partial class TableRow<TItem> : RzComponent<TableRowSlots>, IHasTableRowStylingProperties
{
    /// <summary>
    /// Gets or sets the parent <see cref="RzTable{TItem}"/> component.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Gets or sets the zero-based index of the row within the current page.
    /// </summary>
    [CascadingParameter(Name = "RowIndex")]
    protected int? RowIndex { get; set; }
    /// <summary>
    /// Gets or sets the data item associated with this row.
    /// </summary>
    [Parameter] public TItem? Item { get; set; }
    /// <summary>
    /// Gets or sets the content of the row, typically a series of <see cref="TableCell{TItem}"/> components.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets a value indicating whether the row is even, for applying striped styling.
    /// </summary>
    public bool IsEven => ParentRzTable?.Striped == true && RowIndex.HasValue && RowIndex.Value % 2 != 0;
    /// <summary>
    /// Gets a value indicating whether the row should have a hover effect.
    /// </summary>
    public bool IsHoverable => ParentRzTable?.Hoverable ?? false;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "tr";
        if (ParentRzTable != null)
        {
            Id = $"{ParentRzTable.TableBodyIdInternal}-row";
            if (RowIndex != null)
                Id += "-" + RowIndex;
            else
            {
                Id = IdGenerator.UniqueId(Id);
            }
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<TableRowSlots>, TableRowSlots> GetDescriptor() => Theme.TableRow;
}
</file>

<file path="Components/Display/RzAvatar/AvatarFallback.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

@if (_shouldRender)
{
	<HtmlElement Element="@EffectiveElement"
	             @attributes="AdditionalAttributes"
	             id="@Id" 
	             class="@(ChildContent != null ? ParentAvatar?.SlotClasses.GetInitialsContainer() : ParentAvatar?.SlotClasses.GetPlaceholderContainer())">
		@if (ChildContent != null)
		{
			@ChildContent
		}
		else
		{
			<svg class="@ParentAvatar?.SlotClasses.GetPlaceholderIcon()"
			     fill="currentColor"
			     viewBox="0 0 20 20"
			     xmlns="http://www.w3.org/2000/svg"
			     aria-hidden="true">
				<path fill-rule="evenodd"
				      d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"
				      clip-rule="evenodd"/>
			</svg>
		}
	</HtmlElement>
}
</file>

<file path="Components/Display/RzAvatar/AvatarFallback.razor.cs">
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
/// Represents the fallback content for an <see cref="RzAvatar"/>, typically displaying initials or a generic placeholder.
/// This component renders only if a sibling <see cref="AvatarImage"/> does not have a valid image source.
/// It must be a child of <see cref="RzAvatar"/>.
/// </summary>
public partial class AvatarFallback : RzComponent
{
    private bool _shouldRender;
    /// <summary>
    /// Gets or sets the parent <see cref="RzAvatar"/> component.
    /// </summary>
    [CascadingParameter]
    public RzAvatar? ParentAvatar { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as fallback, typically initials.
    /// If null or empty, a default SVG placeholder icon will be rendered.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentAvatar == null)
        {
            throw new InvalidOperationException($"{nameof(AvatarFallback)} must be used within an {nameof(RzAvatar)} component.");
        }
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _shouldRender = ParentAvatar != null && !ParentAvatar.HasImage;
    }
}
</file>

<file path="Components/Display/RzAvatar/AvatarImage.razor">
@namespace RizzyUI
@inherits RzComponent

@if (_renderImage)
{
	<img src="@ImageSource" alt="@EffectiveAlternateText" @attributes="AdditionalAttributes" class="@ParentAvatar?.SlotClasses.GetImage()" id="@Id" />
}
</file>

<file path="Components/Display/RzAvatar/AvatarImage.razor.cs">
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
/// Represents the image part of an <see cref="RzAvatar"/>. 
/// It renders an `&lt;img&gt;` tag if <see cref="ImageSource"/> is provided and valid.
/// This component must be a child of <see cref="RzAvatar"/>.
/// </summary>
public partial class AvatarImage : RzComponent
{
    private bool _renderImage;
    /// <summary>
    /// Gets or sets the parent <see cref="RzAvatar"/> component.
    /// </summary>
    [CascadingParameter]
    public RzAvatar? ParentAvatar { get; set; }
    /// <summary>
    /// Gets or sets the source URL for the avatar image.
    /// </summary>
    [Parameter] public string? ImageSource { get; set; }
    /// <summary>
    /// Gets or sets the alternate text for the avatar image, used for accessibility.
    /// If not provided, it will default to "User Avatar" or the parent RzAvatar's AriaLabel if available.
    /// </summary>
    [Parameter] public string? AlternateText { get; set; }
    /// <summary>
    /// Gets the effective alternate text for the image.
    /// </summary>
    protected string EffectiveAlternateText => AlternateText ?? ParentAvatar?.EffectiveAriaLabel ?? Localizer["RzAvatar.DefaultAriaLabel"];
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentAvatar == null)
        {
            throw new InvalidOperationException($"{nameof(AvatarImage)} must be used within an {nameof(RzAvatar)} component.");
        }
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _renderImage = !string.IsNullOrWhiteSpace(ImageSource) || AdditionalAttributes?.ContainsKey(":src") == true;
        ParentAvatar?.SetImageStatus(_renderImage);
    }
}
</file>

<file path="Components/Display/RzAvatar/RzAvatar.razor">
@namespace RizzyUI
@using TailwindVariants.NET
@inherits RzComponent<RzAvatar.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             role="img"
	             aria-label="@EffectiveAriaLabel"
	             @attributes="@AdditionalAttributes"
                 id="@Id"
                 class="@(SlotClasses.GetBase())">
        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Display/RzAvatar/RzAvatar.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container component for displaying an avatar. It coordinates child components 
/// <see cref="AvatarImage"/> and <see cref="AvatarFallback"/> to render an image or a fallback representation.
/// It also serves as an anchor for an optional <see cref="RzIndicator"/> child component.
/// Styling for the container (shape, size, border) is determined by its parameters and the active <see cref="RzTheme"/>.
/// </summary>
public partial class RzAvatar : RzComponent<RzAvatar.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzAvatar component and its children slots.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative inline-flex items-center justify-center shrink-0 aspect-square object-cover overflow-hidden align-middle",
        slots: new()
        {
            [s => s.Image] = "inline-block aspect-square object-cover w-full h-full",
            [s => s.InitialsContainer] = "inline-flex items-center justify-center bg-muted text-foreground w-full h-full",
            [s => s.PlaceholderContainer] = "inline-flex items-center justify-center bg-muted text-muted-foreground w-full h-full",
            [s => s.PlaceholderIcon] = "inline-block"
        },
        variants: new()
        {
            [a => ((RzAvatar)a).Shape] = new Variant<AvatarShape, Slots>
            {
                [AvatarShape.Circle] = new()
                {
                    [s => s.Base] = "rounded-full",
                    [s => s.Image] = "rounded-full",
                    [s => s.InitialsContainer] = "rounded-full",
                    [s => s.PlaceholderContainer] = "rounded-full"
                },
                [AvatarShape.Square] = new()
                {
                    [s => s.Base] = "rounded-lg",
                    [s => s.Image] = "rounded-lg",
                    [s => s.InitialsContainer] = "rounded-lg",
                    [s => s.PlaceholderContainer] = "rounded-lg"
                }
            },
            [a => ((RzAvatar)a).Size] = new Variant<Size, Slots>
            {
                [Size.ExtraSmall] = new() { [s => s.Base] = "size-6", [s => s.InitialsContainer] = "text-xs", [s => s.PlaceholderIcon] = "size-3/5" },
                [Size.Small] = new() { [s => s.Base] = "size-8", [s => s.InitialsContainer] = "text-sm", [s => s.PlaceholderIcon] = "size-3/5" },
                [Size.Medium] = new() { [s => s.Base] = "size-10", [s => s.InitialsContainer] = "text-base", [s => s.PlaceholderIcon] = "size-3/5" },
                [Size.Large] = new() { [s => s.Base] = "size-12", [s => s.InitialsContainer] = "text-lg", [s => s.PlaceholderIcon] = "size-3/5" },
                [Size.ExtraLarge] = new() { [s => s.Base] = "size-16", [s => s.InitialsContainer] = "text-xl", [s => s.PlaceholderIcon] = "size-3/5" }
            },
            [a => ((RzAvatar)a).Border] = new Variant<bool, Slots>
            {
                [true] = "border-2 border-background ring-2 ring-border"
            }
        }
    );
    private bool _hasImage;
    /// <summary>
    /// Gets or sets the shape of the avatar. Defaults to <see cref="AvatarShape.Circle"/>.
    /// </summary>
    [Parameter] public AvatarShape Shape { get; set; } = AvatarShape.Circle;
    /// <summary>
    /// Gets or sets the size of the avatar. Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter] public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets a value indicating whether the avatar has a border.
    /// Note: Default themes may not include border styling; custom themes or classes might be needed.
    /// </summary>
    [Parameter] public bool Border { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the avatar container.
    /// If not set, a default localized label "Avatar" will be used.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the avatar container. 
    /// This typically includes an <see cref="AvatarImage"/>, an <see cref="AvatarFallback"/>,
    /// and optionally an <see cref="RzIndicator"/>.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets a value indicating whether a child <see cref="AvatarImage"/> with a valid source is present.
    /// This is used by <see cref="AvatarFallback"/> to determine if it should render.
    /// </summary>
    internal bool HasImage => _hasImage;
    /// <summary>
    /// Gets the effective ARIA label, using the provided <see cref="AriaLabel"/> or a localized default.
    /// </summary>
    internal string EffectiveAriaLabel => AriaLabel ?? Localizer["RzAvatar.DefaultAriaLabel"];
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzAvatar.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzAvatar.DefaultAriaLabel"];
    }
    /// <summary>
    /// Internal method called by <see cref="AvatarImage"/> to update the image status.
    /// </summary>
    /// <param name="hasImage">True if the AvatarImage has a valid source, false otherwise.</param>
    internal void SetImageStatus(bool hasImage)
    {
        if (_hasImage != hasImage)
        {
            _hasImage = hasImage;
            StateHasChanged();
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzAvatar;
    /// <summary>
    /// Defines the slots available for styling in the RzAvatar component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main avatar container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the `&lt;img&gt;` element.
        /// </summary>
        public string? Image { get; set; }
        /// <summary>
        /// The slot for the container that displays initials.
        /// </summary>
        public string? InitialsContainer { get; set; }
        /// <summary>
        /// The slot for the container of the default placeholder icon.
        /// </summary>
        public string? PlaceholderContainer { get; set; }
        /// <summary>
        /// The slot for the default placeholder SVG icon.
        /// </summary>
        public string? PlaceholderIcon { get; set; }
    }
}
</file>

<file path="Components/Display/RzBadge/RzBadge.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzBadge.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="badge">
    <span class="@SlotClasses.GetInnerSpan()">
	    <span class="flex items-center gap-1"> 
		    @if (Icon != null)
		    {
			    <Blazicon Svg="Icon"/>
		    }
		    @ChildContent @Label
	    </span>
	</span>
</HtmlElement>
</file>

<file path="Components/Display/RzBadge/RzBadge.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
///     A badge component for displaying labels with various styles and colors, determined by the active
///     <see cref="RzTheme" />.
/// </summary>
public partial class RzBadge : RzComponent<RzBadge.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzBadge component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 gap-1 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
        slots: new()
        {
            [s => s.InnerSpan] = "flex items-center gap-1"
        },
        variants: new()
        {
            [b => ((RzBadge)b).Variant] = new Variant<ThemeVariant, Slots>(), // Variants are handled by compound variants
            [b => ((RzBadge)b).Soft] = new Variant<bool, Slots>()
        },
        compoundVariants: new()
        {
            // --- Solid Variants ---
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Default) { Class = "border-input bg-input text-foreground hover:bg-input/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Primary) { Class = "border-transparent bg-primary text-primary-foreground hover:bg-primary/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Secondary) { Class = "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Destructive) { Class = "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Accent) { Class = "border-transparent bg-accent text-accent-foreground hover:bg-accent/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Information) { Class = "border-transparent bg-info text-info-foreground hover:bg-info/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Success) { Class = "border-transparent bg-success text-success-foreground hover:bg-success/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Warning) { Class = "border-transparent bg-warning text-warning-foreground hover:bg-warning/80" },
            new(b => !((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Inverse) { Class = "border-transparent bg-foreground text-background hover:bg-foreground/80" },
            new(b => ((RzBadge)b).Variant == ThemeVariant.Ghost) { Class = "border-transparent bg-transparent text-foreground hover:bg-accent hover:text-accent-foreground" },
            // --- Soft Variants ---
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Default) { Class = "border-input/50 bg-input/50 text-foreground hover:bg-input/80" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Primary) { Class = "border-primary/20 bg-primary/10 text-primary hover:bg-primary/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Secondary) { Class = "border-secondary/20 bg-secondary/10 text-secondary-foreground hover:bg-secondary/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Destructive) { Class = "border-destructive/20 bg-destructive/10 text-destructive hover:bg-destructive/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Accent) { Class = "border-accent/20 bg-accent/10 text-accent-foreground hover:bg-accent/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Information) { Class = "border-info/20 bg-info/10 text-info hover:bg-info/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Success) { Class = "border-success/20 bg-success/10 text-success hover:bg-success/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Warning) { Class = "border-warning/20 bg-warning/10 text-warning hover:bg-warning/20" },
            new(b => ((RzBadge)b).Soft && ((RzBadge)b).Variant == ThemeVariant.Inverse) { Class = "border-foreground/10 bg-foreground/10 text-foreground hover:bg-foreground/20" },
        }
    );
    /// <summary> 
    /// The theme variant of the badge. Defaults to <see cref="ThemeVariant.Default"/>. 
    /// </summary>
    [Parameter]
    public ThemeVariant Variant { get; set; } = ThemeVariant.Default;
    /// <summary> When set to true, applies a softer styling to the badge. </summary>
    [Parameter]
    public bool Soft { get; set; }
    /// <summary> Optional icon to display within the badge. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Optional text label for the badge. Used if ChildContent is not provided. </summary>
    [Parameter]
    public string Label { get; set; } = string.Empty;
    /// <summary> Child content for the badge, allowing for text and additional elements. Overrides Label if set. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Initializes the component, setting the default element type if not specified.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "span"; // Default element for a badge
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzBadge;
    /// <summary>
    /// Defines the slots available for styling in the RzBadge component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("badge")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner span that wraps the content.
        /// </summary>
        [Slot("inner-span")]
        public string? InnerSpan { get; set; }
    }
}
</file>

<file path="Components/Display/RzIndicator/IndicatorPosition.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the position of an RzIndicator relative to its conceptual parent or anchor point.
/// Mirrors the options available in AnchorPoint.
/// </summary>
public enum IndicatorPosition
{
    /// <summary>
    /// Position at the top-start (e.g., top-left).
    /// </summary>
    TopStart,
    /// <summary>
    /// Position at the top, centered horizontally.
    /// </summary>
    Top,
    /// <summary>
    /// Position at the top-end (e.g., top-right). This is often the default for status indicators.
    /// </summary>
    TopEnd,
    /// <summary>
    /// Position at the left-start (e.g., top-left, vertically aligned).
    /// </summary>
    LeftStart,
    /// <summary>
    /// Position at the left, centered vertically.
    /// </summary>
    Left,
    /// <summary>
    /// Position at the left-end (e.g., bottom-left, vertically aligned).
    /// </summary>
    LeftEnd,
    /// <summary>
    /// Position at the right-start (e.g., top-right, vertically aligned).
    /// </summary>
    RightStart,
    /// <summary>
    /// Position at the right, centered vertically.
    /// </summary>
    Right,
    /// <summary>
    /// Position at the right-end (e.g., bottom-right, vertically aligned).
    /// </summary>
    RightEnd,
    /// <summary>
    /// Position at the bottom-start (e.g., bottom-left).
    /// </summary>
    BottomStart,
    /// <summary>
    /// Position at the bottom, centered horizontally.
    /// </summary>
    Bottom,
    /// <summary>
    /// Position at the bottom-end (e.g., bottom-right).
    /// </summary>
    BottomEnd,
    /// <summary>
    /// Position in the center of its conceptual parent.
    /// </summary>
    Center
}
</file>

<file path="Components/Display/RzIndicator/RzIndicator.razor">
@namespace RizzyUI
@inherits RzComponent<RzIndicator.Slots>

<div x-data="rzIndicator"
     @attributes="@AdditionalAttributes"
     data-alpine-root="@Id"
     id="@Id"
     class="@SlotClasses.GetBase()"
     aria-label="@EffectiveAriaLabel"
     :aria-hidden="notVisible"
     x-show="visible"
     data-visible="@Visible.ToString().ToLowerInvariant()"
     x-cloak>
</div>
</file>

<file path="Components/Display/RzIndicator/RzIndicator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A small visual indicator component, often used to denote status or notifications.
/// Its position, size, and color can be customized.
/// </summary>
public partial class RzIndicator : RzComponent<RzIndicator.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzIndicator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute rounded-full border-2 border-background",
        variants: new()
        {
            [i => ((RzIndicator)i).Position] = new Variant<IndicatorPosition, Slots>
            {
                [IndicatorPosition.TopStart] = "top-0 left-0",
                [IndicatorPosition.TopEnd] = "top-0 right-0",
                [IndicatorPosition.BottomStart] = "bottom-0 left-0",
                [IndicatorPosition.BottomEnd] = "bottom-0 right-0",
                [IndicatorPosition.Top] = "top-0 left-1/2 transform -translate-x-1/2",
                [IndicatorPosition.Bottom] = "bottom-0 left-1/2 transform -translate-x-1/2",
                [IndicatorPosition.Left] = "left-0 top-1/2 transform -translate-y-1/2",
                [IndicatorPosition.Right] = "right-0 top-1/2 transform -translate-y-1/2",
                [IndicatorPosition.Center] = "top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2",
                [IndicatorPosition.LeftStart] = "left-0 top-0",
                [IndicatorPosition.LeftEnd] = "left-0 bottom-0",
                [IndicatorPosition.RightStart] = "right-0 top-0",
                [IndicatorPosition.RightEnd] = "right-0 bottom-0"
            },
            [i => ((RzIndicator)i).Size] = new Variant<Size, Slots>
            {
                [Size.ExtraSmall] = "size-2",
                [Size.Small] = "size-2.5",
                [Size.Medium] = "size-3",
                [Size.Large] = "size-3.5",
                [Size.ExtraLarge] = "size-4"
            },
            [i => ((RzIndicator)i).Color] = new Variant<SemanticColor, Slots>
            {
                [SemanticColor.Primary] = "bg-primary",
                [SemanticColor.Secondary] = "bg-secondary",
                [SemanticColor.Success] = "bg-success",
                [SemanticColor.Warning] = "bg-warning",
                [SemanticColor.Destructive] = "bg-destructive",
                [SemanticColor.Info] = "bg-info",
                [SemanticColor.Muted] = "bg-muted",
                [SemanticColor.None] = "bg-foreground"
            }
        }
    );
    /// <summary>
    /// Gets or sets the position of the indicator.
    /// Defaults to <see cref="IndicatorPosition.TopEnd"/>.
    /// </summary>
    [Parameter] public IndicatorPosition Position { get; set; } = IndicatorPosition.TopEnd;
    /// <summary>
    /// Gets or sets the size of the indicator.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter] public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets a value indicating whether the indicator is visible.
    /// Defaults to true.
    /// </summary>
    [Parameter] public bool Visible { get; set; } = true;
    /// <summary>
    /// Gets or sets the color of the indicator.
    /// Defaults to <see cref="SemanticColor.Destructive"/>.
    /// </summary>
    [Parameter] public Color Color { get; set; } = Colors.Red.L500;
    /// <summary>
    /// Gets or sets the ARIA label for the indicator, providing an accessible name.
    /// If not set, a default localized label "Indicator" will be used.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }
    /// <summary>
    /// Gets the effective ARIA label, using the provided AriaLabel or a localized default.
    /// </summary>
    protected string EffectiveAriaLabel => AriaLabel ?? Localizer["RzIndicator.DefaultAriaLabel"];
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzIndicator.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzIndicator.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzIndicator;
    /// <summary>
    /// Defines the slots available for styling in the RzIndicator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Display/RzProgress/RzProgress.razor">
@namespace RizzyUI
@inherits RzComponent<RzProgress.Slots>

<HtmlElement Element="div"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()">

	             <div x-data="rzProgress"
	                  data-alpine-root="@Id"
	                  data-label="@Label"
	                  data-current-val="@CurrentValue"
	                  data-min-val="@MinValue"
	                  data-max-val="@MaxValue"
	                  role="progressbar"
	                  aria-label="@AriaLabel"
	                  aria-valuenow="@CurrentValue"
	                  aria-valuemin="@MinValue"
	                  aria-valuemax="@MaxValue"
	                  data-progress="true">
		             
		             @if (LabelPosition == ProgressLabelPosition.Outside && !string.IsNullOrEmpty(Label))
		             {
			             <div class="@SlotClasses.GetOutsideLabelContainer()">
				             <div class="grow"></div>
				             <div class="@SlotClasses.GetOutsideLabelText()"><span x-text="buildLabel"></span></div>
			             </div>
		             }
		             <div class="@SlotClasses.GetOuterBar()">
			             <div class="@SlotClasses.GetInnerBar()" x-ref="progressBar" nonce="@Nonce">
				             @if (LabelPosition == ProgressLabelPosition.Inside && !string.IsNullOrEmpty(Label))
				             {
					             <div class="@SlotClasses.GetInsideLabelContainer()" x-ref="progressBarLabel" :class="getLabelCss">
						             <span class="@SlotClasses.GetInsideLabelText()" x-ref="innerLabel"></span>
					             </div>
				             }
			             </div>
		             </div>

	             </div>
</HtmlElement>
</file>

<file path="Components/Display/RzProgress/RzProgress.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
///     Represents a Progress bar component that visually indicates the completion status of a task.
///     Supports labels inside or outside the bar and various status colors.
///     Styling and calculation logic is handled via the active <see cref="RzTheme" /> and Alpine.js.
/// </summary>
public partial class RzProgress : RzComponent<RzProgress.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzProgress component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "w-full",
        slots: new()
        {
            [s => s.OutsideLabelContainer] = "mb-2 flex items-center",
            [s => s.OutsideLabelText] = "text-foreground",
            [s => s.OuterBar] = "relative flex w-full overflow-hidden rounded-md bg-outline",
            [s => s.InnerBar] = "p-0.5 text-center text-xs font-semibold leading-none transition-all",
            [s => s.InsideLabelContainer] = "absolute",
            [s => s.InsideLabelText] = null
        },
        variants: new()
        {
            [p => ((RzProgress)p).LabelPosition] = new Variant<ProgressLabelPosition, Slots>
            {
                [ProgressLabelPosition.Inside] = new() { [s => s.OuterBar] = "h-4" },
                [ProgressLabelPosition.Outside] = new() { [s => s.OuterBar] = "h-2.5" }
            },
            [p => ((RzProgress)p).Variant] = new Variant<StatusColor, Slots>
            {
                [StatusColor.Primary] = new() { [s => s.InnerBar] = "h-full rounded-md bg-primary text-primary-foreground" },
                [StatusColor.Secondary] = new() { [s => s.InnerBar] = "h-full rounded-md bg-secondary text-secondary-foreground" },
                [StatusColor.Success] = new() { [s => s.InnerBar] = "h-full rounded-md bg-success dark:bg-success text-success-foreground dark:text-success-foreground" },
                [StatusColor.Info] = new() { [s => s.InnerBar] = "h-full rounded-md bg-info dark:bg-info text-info-foreground dark:text-info-foreground" },
                [StatusColor.Warning] = new() { [s => s.InnerBar] = "h-full rounded-md bg-warning dark:bg-warning text-warning-foreground dark:text-warning-foreground" },
                [StatusColor.Destructive] = new() { [s => s.InnerBar] = "h-full rounded-md bg-destructive dark:bg-destructive text-destructive-foreground dark:text-destructive-foreground" }
            }
        }
    );
    /// <summary> Gets or sets the current value of the progress bar. </summary>
    [Parameter]
    public int CurrentValue { get; set; }
    /// <summary> Gets or sets the minimum value of the progress bar. Defaults to 0. </summary>
    [Parameter]
    public int MinValue { get; set; }
    /// <summary> Gets or sets the maximum value of the progress bar. Defaults to 100. </summary>
    [Parameter]
    public int MaxValue { get; set; } = 100;
    /// <summary> Gets or sets the label text for the progress bar. Supports '{percent}' placeholder. </summary>
    [Parameter]
    public string? Label { get; set; }
    /// <summary> Gets or sets the position of the label (Inside or Outside). Defaults to Outside. </summary>
    [Parameter]
    public ProgressLabelPosition LabelPosition { get; set; } = ProgressLabelPosition.Outside;
    /// <summary> Gets or sets the status color variant of the progress bar. Defaults to Primary. </summary>
    [Parameter]
    public StatusColor Variant { get; set; } = StatusColor.Primary;
    /// <summary> Gets or sets the aria-label for accessibility. Defaults to "Progress Bar". </summary>
    [Parameter]
    public string AriaLabel { get; set; } = "Progress Bar";
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzProgress;
    /// <summary>
    /// Defines the slots available for styling in the RzProgress component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the container of the label when positioned outside.
        /// </summary>
        public string? OutsideLabelContainer { get; set; }
        /// <summary>
        /// The slot for the text of the label when positioned outside.
        /// </summary>
        public string? OutsideLabelText { get; set; }
        /// <summary>
        /// The slot for the outer bar of the progress indicator.
        /// </summary>
        public string? OuterBar { get; set; }
        /// <summary>
        /// The slot for the inner bar that represents the progress.
        /// </summary>
        public string? InnerBar { get; set; }
        /// <summary>
        /// The slot for the container of the label when positioned inside.
        /// </summary>
        public string? InsideLabelContainer { get; set; }
        /// <summary>
        /// The slot for the text of the label when positioned inside.
        /// </summary>
        public string? InsideLabelText { get; set; }
    }
}
</file>

<file path="Components/Display/RzSeparator/RzSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<RzSeparator.Slots>

<HtmlElement Element="@EffectiveElement" role="separator" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Display/RzSeparator/RzSeparator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
///     A component that renders a horizontal or vertical divider line, optionally with centered or aligned text/content.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </summary>
public partial class RzSeparator : RzComponent<RzSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex items-center text-sm text-outline",
        variants: new()
        {
            [s => ((RzSeparator)s).HasContent] = new Variant<bool, Slots>(),
            [s => ((RzSeparator)s).Orientation] = new Variant<Orientation, Slots>
            {
                [Orientation.Horizontal] = "w-full",
                [Orientation.Vertical] = "inline-flex flex-col h-full"
            },
            [s => ((RzSeparator)s).Style] = new Variant<SeparatorStyle, Slots>
            {
                [SeparatorStyle.Solid] = "before:border-solid after:border-solid",
                [SeparatorStyle.Dashed] = "before:border-dashed after:border-dashed",
                [SeparatorStyle.Dotted] = "before:border-dotted after:border-dotted"
            },
            [s => ((RzSeparator)s).LabelAlignment] = new Variant<Align, Slots>()
        },
        compoundVariants: new()
        {
            // No Content Variants
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).Style == SeparatorStyle.Solid) { Class = "my-4 border-t border-border w-full border-solid" },
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).Style == SeparatorStyle.Dashed) { Class = "my-4 border-t border-border w-full border-dashed" },
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).Style == SeparatorStyle.Dotted) { Class = "my-4 border-t border-border w-full border-dotted" },
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).Style == SeparatorStyle.Solid) { Class = "mx-4 border-r border-border h-full border-solid" },
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).Style == SeparatorStyle.Dashed) { Class = "mx-4 border-r border-border h-full border-dashed" },
            new(s => !((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).Style == SeparatorStyle.Dotted) { Class = "mx-4 border-r border-border h-full border-dotted" },
            // With Content Variants - Horizontal
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).LabelAlignment == Align.Start) { Class = "after:flex-1 after:border-t after:border-border after:ms-6" },
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).LabelAlignment == Align.Center) { Class = "before:flex-1 before:border-t before:border-border before:me-6 after:flex-1 after:border-t after:border-border after:ms-6" },
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Horizontal && ((RzSeparator)s).LabelAlignment == Align.End) { Class = "before:flex-1 before:border-t before:border-border before:me-6" },
            // With Content Variants - Vertical
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).LabelAlignment == Align.Start) { Class = "after:flex-1 after:w-px after:border-r after:border-border after:mt-2" },
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).LabelAlignment == Align.Center) { Class = "before:flex-1 before:w-px before:border-r before:border-border before:mb-2 after:flex-1 after:w-px after:border-r after:border-border after:mt-2" },
            new(s => ((RzSeparator)s).HasContent && ((RzSeparator)s).Orientation == Orientation.Vertical && ((RzSeparator)s).LabelAlignment == Align.End) { Class = "before:flex-1 before:w-px before:border-r before:border-border before:mb-2" }
        }
    );
    /// <summary> The style of the dividing line (Solid, Dashed, Dotted). Defaults to Solid. </summary>
    [Parameter] public SeparatorStyle Style { get; set; } = SeparatorStyle.Solid;
    /// <summary>
    ///     The alignment of the child content within the divider (Start, Center, End). Only used if
    ///     <see cref="ChildContent" /> is provided. Defaults to Center.
    /// </summary>
    [Parameter] public Align LabelAlignment { get; set; } = Align.Center;
    /// <summary>
    /// Gets or sets the orientation of the separator (Horizontal or Vertical).
    /// Defaults to <see cref="Orientation.Horizontal"/>.
    /// </summary>
    [Parameter] public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <summary>
    ///     Optional content to display within the divider (e.g., text or an icon). If null, a simple divider line is
    ///     rendered.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// A protected property to expose the presence of ChildContent to the TvDescriptor.
    /// </summary>
    protected bool HasContent => ChildContent != null;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSeparator;
    /// <summary>
    /// Defines the slots available for styling in the RzSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Document/Models/HeadingItem.cs">
namespace RizzyUI;
/// <summary>
///     Represents a heading item with level, title, and ID.
/// </summary>
public class HeadingItem
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="HeadingItem" /> class.
    /// </summary>
    /// <param name="level">The heading level.</param>
    /// <param name="title">The title of the heading.</param>
    /// <param name="id">The unique ID of the heading element.</param>
    public HeadingItem(HeadingLevel level, string title, string id)
    {
        Level = level;
        Title = title;
        Id = id;
    }
    /// <summary>
    ///     The heading level.
    /// </summary>
    public HeadingLevel Level { get; }
    /// <summary>
    ///     The title of the heading.
    /// </summary>
    public string Title { get; }
    /// <summary>
    ///     The unique ID of the heading element.
    /// </summary>
    public string Id { get; }
}
</file>

<file path="Components/Document/RzArticle/RzArticle.razor">
@namespace RizzyUI
@inherits RzComponent<RzArticle.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
	<div class="@SlotClasses.GetInnerContainer()">
		<article class="@SlotClasses.GetArticle()">
			@MainContent
		</article>

		@if (SideContent != null)
		{
			<aside class="@SlotClasses.GetAside()" aria-label="@AsideAriaLabel">
				@SideContent
			</aside>
		}
	</div>
</HtmlElement>
</file>

<file path="Components/Document/RzArticle/RzArticle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A layout component rendering a responsive two-column layout, typically for main article content
///     and a side navigation or information panel (&lt;see cref="RzQuickReference" /&gt;).
///     Styling and layout details are determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzArticle : RzComponent<RzArticle.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzArticle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-full justify-between pr-0 text-foreground dark:text-foreground",
        slots: new()
        {
            [s => s.InnerContainer] = "mx-auto flex max-w-7xl grow flex-col overflow-x-auto overflow-y-hidden",
            [s => s.Article] = "prose",
            [s => s.Aside] = "hidden shrink-0 flex-col gap-2 overflow-y-auto p-8 pl-0 text-sm xl:flex"
        },
        variants: new()
        {
            [a => ((RzArticle)a).ProseWidth] = new Variant<ProseWidth, Slots>
            {
                [ProseWidth.Compact] = new() { [s => s.Article] = "prose-compact" },
                [ProseWidth.Comfortable] = new() { [s => s.Article] = "prose-comfortable" },
                [ProseWidth.Relaxed] = new() { [s => s.Article] = "prose-relaxed" },
                [ProseWidth.Wide] = new() { [s => s.Article] = "prose-wide" },
                [ProseWidth.UltraWide] = new() { [s => s.Article] = "prose-ultrawide" },
                [ProseWidth.Full] = new() { [s => s.Article] = "prose-full" }
            },
            [a => ((RzArticle)a).ColumnWidth] = new Variant<Size, Slots>
            {
                [Size.ExtraSmall] = new() { [s => s.Base] = "xl:pr-48", [s => s.Aside] = "w-48" },
                [Size.Small] = new() { [s => s.Base] = "xl:pr-56", [s => s.Aside] = "w-56" },
                [Size.Medium] = new() { [s => s.Base] = "xl:pr-64", [s => s.Aside] = "w-64" },
                [Size.Large] = new() { [s => s.Base] = "xl:pr-72", [s => s.Aside] = "w-72" },
                [Size.ExtraLarge] = new() { [s => s.Base] = "xl:pr-80", [s => s.Aside] = "w-80" }
            },
            [a => ((RzArticle)a).IsSideFixed] = new Variant<bool, Slots>
            {
                [true] = new() { [s => s.Aside] = "h-fill fixed right-3 top-16 z-0" }
            }
        }
    );
    /// <summary> Gets or sets the maximum character width of the main article content area. Defaults to Full. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Full;
    /// <summary> Gets or sets the width of the side column. Defaults to Large. </summary>
    [Parameter]
    public Size ColumnWidth { get; set; } = Size.Large;
    /// <summary> Gets or sets the content to render in the side column (e.g., QuickReference). </summary>
    [Parameter]
    public RenderFragment? SideContent { get; set; }
    /// <summary> Gets or sets the main content to render in the primary article area. Required. </summary>
    [Parameter]
    [EditorRequired]
    public required RenderFragment MainContent { get; set; }
    /// <summary>
    ///     Gets or sets a value indicating whether the side column should be fixed-positioned on larger screens.
    ///     Defaults to true.
    /// </summary>
    [Parameter]
    public bool IsSideFixed { get; set; } = true;
    /// <summary>
    /// Gets or sets the aria-label for the aside element, providing context for screen readers.
    /// If not set, defaults to a localized "Supplementary Content". Consider providing a more specific label based on the content
    /// (e.g., "On this page navigation", "Related links").
    /// </summary>
    [Parameter]
    public string? AsideAriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AsideAriaLabel ??= Localizer["RzArticle.DefaultAsideAriaLabel"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AsideAriaLabel ??= Localizer["RzArticle.DefaultAsideAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzArticle;
    /// <summary>
    /// Defines the slots available for styling in the RzArticle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner container that holds the article and aside.
        /// </summary>
        public string? InnerContainer { get; set; }
        /// <summary>
        /// The slot for the main article content.
        /// </summary>
        public string? Article { get; set; }
        /// <summary>
        /// The slot for the aside (side content).
        /// </summary>
        public string? Aside { get; set; }
    }
}
</file>

<file path="Components/Document/RzBrowser/RzBrowser.razor">
@namespace RizzyUI
@inherits RzComponent<RzBrowser.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
    <div x-data="rzBrowser" data-alpine-root="@Id">
        
        <div class="@SlotClasses.GetTopBar()">
            <div class="@SlotClasses.GetTrafficLightsContainer()" aria-hidden="true">
                <div class="@SlotClasses.GetTrafficLightRed()"></div>
                <div class="@SlotClasses.GetTrafficLightYellow()"></div>
                <div class="@SlotClasses.GetTrafficLightGreen()"></div>
            </div>
            <div class="@SlotClasses.GetScreenSizeControlsContainer()">
                <div class="@SlotClasses.GetScreenSizeButtonGroup()" role="group" aria-label="@Localizer["RzBrowser.ScreenSizeGroupAriaLabel"]">
                    <button type="button" aria-label="@Localizer["RzBrowser.DesktopScreenTitle"]" title="@Localizer["RzBrowser.DesktopScreenTitle"]" x-on:click="setDesktopScreenSize" class="@SlotClasses.GetScreenSizeButton()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getDesktopScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M0 4s0-2 2-2h12s2 0 2 2v6s0 2-2 2h-4c0 .667.083 1.167.25 1.5H11a.5.5 0 0 1 0 1H5a.5.5 0 0 1 0-1h.75c.167-.333.25-.833.25-1.5H2s-2 0-2-2V4zm1.398-.855a.758.758 0 0 0-.254.302A1.46 1.46 0 0 0 1 4.01V10c0 .325.078.502.145.602.07.105.17.188.302.254a1.464 1.464 0 0 0 .538.143L2.01 11H14c.325 0 .502-.078.602-.145a.758.758 0 0 0 .254-.302 1.464 1.464 0 0 0 .143-.538L15 9.99V4c0-.325-.078-.502-.145-.602a.757.757 0 0 0-.302-.254A1.46 1.46 0 0 0 13.99 3H2c-.325 0-.502.078-.602.145z"></path>
                        </svg>
                    </button>
                    <button type="button" x-on:click="setTabletScreenSize" aria-label="@Localizer["RzBrowser.TabletScreenTitle"]" title="@Localizer["RzBrowser.TabletScreenTitle"]" class="@SlotClasses.GetScreenSizeButton()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getTabletScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M12 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h8zM4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4z"></path>
                            <path d="M8 14a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path>
                        </svg>
                    </button>
                    <button type="button" x-on:click="setPhoneScreenSize" aria-label="@Localizer["RzBrowser.PhoneScreenTitle"]" title="@Localizer["RzBrowser.PhoneScreenTitle"]" class="@SlotClasses.GetScreenSizeButton()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getPhoneScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M11 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h6zM5 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H5z"></path>
                            <path d="M8 14a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <div class="@SlotClasses.GetContentArea()">
            <div class="@SlotClasses.GetPreviewContainer()" :class="getBrowserBorderCss">
                @if (Layout != null)
                {
                    <RzEmbeddedPreview Layout="@Layout" IFrameTitle="@PreviewIFrameTitle">
                        @ChildContent
                    </RzEmbeddedPreview>
                }
                else
                {
                    @ChildContent
                }

            </div>
        </div>
    </div>    
</HtmlElement>
</file>

<file path="Components/Document/RzBrowser/RzBrowser.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
///     A component that simulates a browser window, useful for previewing components or content.
/// </summary>
public partial class RzBrowser : RzComponent<RzBrowser.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzBrowser component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "mt-2 card p-0 overflow-hidden border border-outline rounded-lg",
        slots: new()
        {
            [s => s.TopBar] = "bg-secondary w-full px-4 py-3 lg:py-1.5 pr-0 flex items-center justify-between border-b",
            [s => s.TrafficLightsContainer] = "flex gap-1.5",
            [s => s.TrafficLightRed] = "size-3 rounded-full bg-red-500",
            [s => s.TrafficLightYellow] = "size-3 rounded-full bg-yellow-500",
            [s => s.TrafficLightGreen] = "size-3 rounded-full bg-green-500",
            [s => s.ScreenSizeControlsContainer] = "text-foreground hidden items-center justify-center gap-4 lg:flex",
            [s => s.ScreenSizeButtonGroup] = "bg-secondary border-outline flex items-center gap-1 rounded-full px-4",
            [s => s.ScreenSizeButton] = "rounded-full p-1 transition hover:bg-secondary/10 focus:outline-none focus-visible:bg-secondary/10 dark:hover-bg-background/10 dark:focus-visible-bg-background/10",
            [s => s.ContentArea] = "grid-pattern bg-background flex justify-center",
            [s => s.PreviewContainer] = "bg-background border-outline relative w-full overflow-hidden transition-all"
        }
    );
    /// <summary>
    ///     The content to be displayed within the browser preview area.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Optional layout for rendering <see cref="ChildContent" /> inside an iframe via <see cref="RzEmbeddedPreview"/>.
    /// </summary>
    [Parameter] public Type? Layout { get; set; }
    /// <summary>
    /// Gets or sets the title attribute for the iframe when a layout is used.
    /// Defaults to a localized "Component Preview". Provides context for screen reader users.
    /// </summary>
    [Parameter] public string? PreviewIFrameTitle { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        PreviewIFrameTitle ??= Localizer["RzBrowser.PreviewIFrameTitle"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        PreviewIFrameTitle ??= Localizer["RzBrowser.PreviewIFrameTitle"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzBrowser;
    /// <summary>
    /// Defines the slots available for styling in the RzBrowser component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the top bar of the browser window.
        /// </summary>
        public string? TopBar { get; set; }
        /// <summary>
        /// The slot for the container of the traffic light buttons.
        /// </summary>
        public string? TrafficLightsContainer { get; set; }
        /// <summary>
        /// The slot for the red traffic light button.
        /// </summary>
        public string? TrafficLightRed { get; set; }
        /// <summary>
        /// The slot for the yellow traffic light button.
        /// </summary>
        public string? TrafficLightYellow { get; set; }
        /// <summary>
        /// The slot for the green traffic light button.
        /// </summary>
        public string? TrafficLightGreen { get; set; }
        /// <summary>
        /// The slot for the container of the screen size control buttons.
        /// </summary>
        public string? ScreenSizeControlsContainer { get; set; }
        /// <summary>
        /// The slot for the button group of screen size controls.
        /// </summary>
        public string? ScreenSizeButtonGroup { get; set; }
        /// <summary>
        /// The slot for an individual screen size control button.
        /// </summary>
        public string? ScreenSizeButton { get; set; }
        /// <summary>
        /// The slot for the main content area of the browser.
        /// </summary>
        public string? ContentArea { get; set; }
        /// <summary>
        /// The slot for the container of the preview content.
        /// </summary>
        public string? PreviewContainer { get; set; }
    }
}
</file>

<file path="Components/Document/RzCodeViewer/CodeLanguage.cs">
namespace RizzyUI;
/// <summary>
///     Provides constants for language aliases supported by Highlight.js.
/// </summary>
public static class CodeLanguage
{
    /// <summary>
    ///     1C Enterprise language.
    /// </summary>
    public const string OneC = "1c";
    /// <summary>
    ///     4D programming language.
    /// </summary>
    public const string FourD = "4d";
    /// <summary>
    ///     ABAP (Advanced Business Application Programming).
    /// </summary>
    public const string Abap = "sap-abap";
    /// <summary>
    ///     ABNF (Augmented BackusNaur Form).
    /// </summary>
    public const string Abnf = "abnf";
    /// <summary>
    ///     Access logs.
    /// </summary>
    public const string AccessLog = "accesslog";
    /// <summary>
    ///     Ada programming language.
    /// </summary>
    public const string Ada = "ada";
    /// <summary>
    ///     Apex programming language.
    /// </summary>
    public const string Apex = "apex";
    /// <summary>
    ///     Arduino (C++ with Arduino libraries).
    /// </summary>
    public const string Arduino = "arduino";
    /// <summary>
    ///     ARM assembler.
    /// </summary>
    public const string ArmAsm = "armasm";
    /// <summary>
    ///     AVR assembler.
    /// </summary>
    public const string AvrAsm = "avrasm";
    /// <summary>
    ///     ActionScript language.
    /// </summary>
    public const string ActionScript = "actionscript";
    /// <summary>
    ///     Alan Interactive Fiction language.
    /// </summary>
    public const string AlanIf = "alan";
    /// <summary>
    ///     Alan programming language.
    /// </summary>
    public const string Alan = "ln";
    /// <summary>
    ///     AngelScript language.
    /// </summary>
    public const string AngelScript = "angelscript";
    /// <summary>
    ///     Apache configuration files.
    /// </summary>
    public const string Apache = "apache";
    /// <summary>
    ///     AppleScript language.
    /// </summary>
    public const string AppleScript = "applescript";
    /// <summary>
    ///     Esri Arcade scripting language.
    /// </summary>
    public const string Arcade = "arcade";
    /// <summary>
    ///     AsciiDoc markup language.
    /// </summary>
    public const string AsciiDoc = "asciidoc";
    /// <summary>
    ///     AspectJ programming language.
    /// </summary>
    public const string AspectJ = "aspectj";
    /// <summary>
    ///     AutoHotkey scripting language.
    /// </summary>
    public const string AutoHotkey = "autohotkey";
    /// <summary>
    ///     AutoIt scripting language.
    /// </summary>
    public const string AutoIt = "autoit";
    /// <summary>
    ///     AWK scripting language.
    /// </summary>
    public const string Awk = "awk";
    /// <summary>
    ///     Ballerina programming language.
    /// </summary>
    public const string Ballerina = "ballerina";
    /// <summary>
    ///     Bash shell scripting language.
    /// </summary>
    public const string Bash = "bash";
    /// <summary>
    ///     BASIC programming language.
    /// </summary>
    public const string Basic = "basic";
    /// <summary>
    ///     BBCode markup language.
    /// </summary>
    public const string BBCode = "bbcode";
    /// <summary>
    ///     Blade templating engine (Laravel).
    /// </summary>
    public const string Blade = "blade";
    /// <summary>
    ///     BackusNaur Form grammar.
    /// </summary>
    public const string Bnf = "bnf";
    /// <summary>
    ///     BQN programming language.
    /// </summary>
    public const string Bqn = "bqn";
    /// <summary>
    ///     Brainfuck esoteric programming language.
    /// </summary>
    public const string Brainfuck = "brainfuck";
    /// <summary>
    ///     C# programming language.
    /// </summary>
    public const string CSharp = "csharp";
    /// <summary>
    ///     C programming language.
    /// </summary>
    public const string C = "c";
    /// <summary>
    ///     C++ programming language.
    /// </summary>
    public const string Cpp = "cpp";
    /// <summary>
    ///     C/AL language.
    /// </summary>
    public const string CAL = "cal";
    /// <summary>
    ///     C3 programming language.
    /// </summary>
    public const string C3 = "c3";
    /// <summary>
    ///     Cach Object Script.
    /// </summary>
    public const string CacheObjectScript = "cos";
    /// <summary>
    ///     Candid language.
    /// </summary>
    public const string Candid = "candid";
    /// <summary>
    ///     CMake scripting language.
    /// </summary>
    public const string CMake = "cmake";
    /// <summary>
    ///     COBOL programming language.
    /// </summary>
    public const string Cobol = "cobol";
    /// <summary>
    ///     CODEOWNERS file format.
    /// </summary>
    public const string Codeowners = "codeowners";
    /// <summary>
    ///     Coq proof assistant language.
    /// </summary>
    public const string Coq = "coq";
    /// <summary>
    ///     CSP (Communicating Sequential Processes).
    /// </summary>
    public const string Csp = "csp";
    /// <summary>
    ///     Cascading Style Sheets.
    /// </summary>
    public const string Css = "css";
    /// <summary>
    ///     Capn Proto serialization language.
    /// </summary>
    public const string CapnProto = "capnproto";
    /// <summary>
    ///     Chaos programming language.
    /// </summary>
    public const string Chaos = "chaos";
    /// <summary>
    ///     Chapel programming language.
    /// </summary>
    public const string Chapel = "chapel";
    /// <summary>
    ///     Cisco CLI configuration.
    /// </summary>
    public const string CiscoCli = "cisco";
    /// <summary>
    ///     Clojure programming language.
    /// </summary>
    public const string Clojure = "clojure";
    /// <summary>
    ///     CoffeeScript programming language.
    /// </summary>
    public const string CoffeeScript = "coffeescript";
    /// <summary>
    ///     CpcdosC+ programming language.
    /// </summary>
    public const string CpcdosCPlus = "cpc";
    /// <summary>
    ///     Crmsh (Cluster Resource Manager Shell).
    /// </summary>
    public const string Crmsh = "crmsh";
    /// <summary>
    ///     Crystal programming language.
    /// </summary>
    public const string Crystal = "crystal";
    /// <summary>
    ///     cURL command-line tool.
    /// </summary>
    public const string Curl = "curl";
    /// <summary>
    ///     Cypher query language (Neo4j).
    /// </summary>
    public const string Cypher = "cypher";
    /// <summary>
    ///     D programming language.
    /// </summary>
    public const string D = "d";
    /// <summary>
    ///     Dafny programming language.
    /// </summary>
    public const string Dafny = "dafny";
    /// <summary>
    ///     Dart programming language.
    /// </summary>
    public const string Dart = "dart";
    /// <summary>
    ///     Delphi programming language.
    /// </summary>
    public const string Delphi = "dpr";
    /// <summary>
    ///     Diff syntax for differences between files.
    /// </summary>
    public const string Diff = "diff";
    /// <summary>
    ///     Django templating language.
    /// </summary>
    public const string Django = "django";
    /// <summary>
    ///     DNS Zone file format.
    /// </summary>
    public const string DnsZoneFile = "dns";
    /// <summary>
    ///     Dockerfile format.
    /// </summary>
    public const string Dockerfile = "dockerfile";
    /// <summary>
    ///     DOS batch file scripting.
    /// </summary>
    public const string Dos = "dos";
    /// <summary>
    ///     dsconfig format.
    /// </summary>
    public const string Dsconfig = "dsconfig";
    /// <summary>
    ///     Device Tree Source.
    /// </summary>
    public const string Dts = "dts";
    /// <summary>
    ///     Dust templating language.
    /// </summary>
    public const string Dust = "dust";
    /// <summary>
    ///     Dylan programming language.
    /// </summary>
    public const string Dylan = "dylan";
    /// <summary>
    ///     EBNF (Extended BackusNaur Form) grammar.
    /// </summary>
    public const string Ebnf = "ebnf";
    /// <summary>
    ///     Elixir programming language.
    /// </summary>
    public const string Elixir = "elixir";
    /// <summary>
    ///     Elm programming language.
    /// </summary>
    public const string Elm = "elm";
    /// <summary>
    ///     Erlang programming language.
    /// </summary>
    public const string Erlang = "erlang";
    /// <summary>
    ///     Excel formula language.
    /// </summary>
    public const string Excel = "excel";
    /// <summary>
    ///     Extempore programming language.
    /// </summary>
    public const string Extempore = "extempore";
    /// <summary>
    ///     F# programming language.
    /// </summary>
    public const string FSharp = "fsharp";
    /// <summary>
    ///     FIX (Financial Information Exchange) protocol.
    /// </summary>
    public const string Fix = "fix";
    /// <summary>
    ///     Flix programming language.
    /// </summary>
    public const string Flix = "flix";
    /// <summary>
    ///     Fortran programming language.
    /// </summary>
    public const string Fortran = "fortran";
    /// <summary>
    ///     FunC programming language.
    /// </summary>
    public const string FunC = "func";
    /// <summary>
    ///     G-code for CNC machines.
    /// </summary>
    public const string GCode = "gcode";
    /// <summary>
    ///     GAMS (General Algebraic Modeling System).
    /// </summary>
    public const string Gams = "gams";
    /// <summary>
    ///     GAUSS Mathematical and Statistical System.
    /// </summary>
    public const string Gauss = "gauss";
    /// <summary>
    ///     GDScript for Godot Engine.
    /// </summary>
    public const string GdScript = "godot";
    /// <summary>
    ///     Gherkin language for Cucumber testing.
    /// </summary>
    public const string Gherkin = "gherkin";
    /// <summary>
    ///     Glimmer and EmberJS templates.
    /// </summary>
    public const string Glimmer = "hbs";
    /// <summary>
    ///     GN meta-build system files.
    /// </summary>
    public const string Gn = "gn";
    /// <summary>
    ///     Go programming language.
    /// </summary>
    public const string Go = "go";
    /// <summary>
    ///     Grammatical Framework language.
    /// </summary>
    public const string GrammaticalFramework = "gf";
    /// <summary>
    ///     Golo programming language.
    /// </summary>
    public const string Golo = "golo";
    /// <summary>
    ///     Gradle build scripts.
    /// </summary>
    public const string Gradle = "gradle";
    /// <summary>
    ///     GraphQL query language.
    /// </summary>
    public const string GraphQL = "graphql";
    /// <summary>
    ///     Groovy programming language.
    /// </summary>
    public const string Groovy = "groovy";
    /// <summary>
    ///     GSQL query language.
    /// </summary>
    public const string GSQL = "gsql";
    /// <summary>
    ///     HTML, XML languages.
    /// </summary>
    public const string Html = "xml";
    /// <summary>
    ///     HTTP request and response messages.
    /// </summary>
    public const string Http = "http";
    /// <summary>
    ///     Haml templating language.
    /// </summary>
    public const string Haml = "haml";
    /// <summary>
    ///     Handlebars templating language.
    /// </summary>
    public const string Handlebars = "handlebars";
    /// <summary>
    ///     Haskell programming language.
    /// </summary>
    public const string Haskell = "haskell";
    /// <summary>
    ///     Haxe programming language.
    /// </summary>
    public const string Haxe = "haxe";
    /// <summary>
    ///     High-Level Shading Language.
    /// </summary>
    public const string Hlsl = "hlsl";
    /// <summary>
    ///     Hy programming language.
    /// </summary>
    public const string Hy = "hy";
    /// <summary>
    ///     INI configuration files.
    /// </summary>
    public const string Ini = "ini";
    /// <summary>
    ///     Inform 7 programming language.
    /// </summary>
    public const string Inform7 = "inform7";
    /// <summary>
    ///     IRPF90 language.
    /// </summary>
    public const string Irpf90 = "irpf90";
    /// <summary>
    ///     Iptables configuration.
    /// </summary>
    public const string Iptables = "iptables";
    /// <summary>
    ///     JSON (JavaScript Object Notation).
    /// </summary>
    public const string Json = "json";
    /// <summary>
    ///     JSONata query and transformation language.
    /// </summary>
    public const string Jsonata = "jsonata";
    /// <summary>
    ///     Java programming language.
    /// </summary>
    public const string Java = "java";
    /// <summary>
    ///     JavaScript programming language.
    /// </summary>
    public const string JavaScript = "javascript";
    /// <summary>
    ///     Jolie programming language.
    /// </summary>
    public const string Jolie = "jolie";
    /// <summary>
    ///     Julia programming language.
    /// </summary>
    public const string Julia = "julia";
    /// <summary>
    ///     Julia REPL sessions.
    /// </summary>
    public const string JuliaRepl = "julia-repl";
    /// <summary>
    ///     Kotlin programming language.
    /// </summary>
    public const string Kotlin = "kotlin";
    /// <summary>
    ///     LaTeX document preparation system.
    /// </summary>
    public const string Latex = "tex";
    /// <summary>
    ///     Leaf templating language.
    /// </summary>
    public const string Leaf = "leaf";
    /// <summary>
    ///     Lean theorem prover language.
    /// </summary>
    public const string Lean = "lean";
    /// <summary>
    ///     Lasso programming language.
    /// </summary>
    public const string Lasso = "lasso";
    /// <summary>
    ///     Less CSS preprocessor.
    /// </summary>
    public const string Less = "less";
    /// <summary>
    ///     LDIF (LDAP Data Interchange Format).
    /// </summary>
    public const string Ldif = "ldif";
    /// <summary>
    ///     Lisp programming language.
    /// </summary>
    public const string Lisp = "lisp";
    /// <summary>
    ///     LiveCode Server scripting language.
    /// </summary>
    public const string LiveCodeServer = "livecodeserver";
    /// <summary>
    ///     LiveScript programming language.
    /// </summary>
    public const string LiveScript = "livescript";
    /// <summary>
    ///     LookML (Looker Modeling Language).
    /// </summary>
    public const string LookMl = "lookml";
    /// <summary>
    ///     Lua programming language.
    /// </summary>
    public const string Lua = "lua";
    /// <summary>
    ///     Luau programming language.
    /// </summary>
    public const string Luau = "luau";
    /// <summary>
    ///     Macaulay2 algebra system language.
    /// </summary>
    public const string Macaulay2 = "macaulay2";
    /// <summary>
    ///     Makefile build automation tool.
    /// </summary>
    public const string Makefile = "makefile";
    /// <summary>
    ///     Markdown markup language.
    /// </summary>
    public const string Markdown = "markdown";
    /// <summary>
    ///     Mathematica symbolic computation language.
    /// </summary>
    public const string Mathematica = "mathematica";
    /// <summary>
    ///     MATLAB programming language.
    /// </summary>
    public const string Matlab = "matlab";
    /// <summary>
    ///     Maxima computer algebra system.
    /// </summary>
    public const string Maxima = "maxima";
    /// <summary>
    ///     Maya Embedded Language.
    /// </summary>
    public const string MayaEmbeddedLanguage = "mel";
    /// <summary>
    ///     Mercury programming language.
    /// </summary>
    public const string Mercury = "mercury";
    /// <summary>
    ///     MetaPost language.
    /// </summary>
    public const string MetaPost = "metapost";
    /// <summary>
    ///     MIPS assembler.
    /// </summary>
    public const string MipsAsm = "mips";
    /// <summary>
    ///     Mint programming language.
    /// </summary>
    public const string Mint = "mint";
    /// <summary>
    ///     Mirth scripting language.
    /// </summary>
    public const string Mirth = "mirth";
    /// <summary>
    ///     mIRC scripting language.
    /// </summary>
    public const string Mirc = "mirc";
    /// <summary>
    ///     Mizar language.
    /// </summary>
    public const string Mizar = "mizar";
    /// <summary>
    ///     MKB (Makefiles and Builders).
    /// </summary>
    public const string Mkb = "mkb";
    /// <summary>
    ///     MLIR (Multi-Level Intermediate Representation).
    /// </summary>
    public const string Mlir = "mlir";
    /// <summary>
    ///     Mojolicious Perl framework.
    /// </summary>
    public const string Mojolicious = "mojolicious";
    /// <summary>
    ///     Monkey programming language.
    /// </summary>
    public const string Monkey = "monkey";
    /// <summary>
    ///     MoonScript programming language.
    /// </summary>
    public const string MoonScript = "moonscript";
    /// <summary>
    ///     Motoko programming language.
    /// </summary>
    public const string Motoko = "motoko";
    /// <summary>
    ///     N1QL query language.
    /// </summary>
    public const string N1ql = "n1ql";
    /// <summary>
    ///     NSIS (Nullsoft Scriptable Install System).
    /// </summary>
    public const string Nsis = "nsis";
    /// <summary>
    ///     Never programming language.
    /// </summary>
    public const string Never = "never";
    /// <summary>
    ///     Nginx configuration files.
    /// </summary>
    public const string Nginx = "nginx";
    /// <summary>
    ///     Nim programming language.
    /// </summary>
    public const string Nim = "nim";
    /// <summary>
    ///     Nix programming language.
    /// </summary>
    public const string Nix = "nix";
    /// <summary>
    ///     Oak programming language.
    /// </summary>
    public const string Oak = "oak";
    /// <summary>
    ///     Object Constraint Language.
    /// </summary>
    public const string Ocl = "ocl";
    /// <summary>
    ///     OCaml programming language.
    /// </summary>
    public const string OCaml = "ocaml";
    /// <summary>
    ///     Objective-C programming language.
    /// </summary>
    public const string ObjectiveC = "objectivec";
    /// <summary>
    ///     Odin programming language.
    /// </summary>
    public const string Odin = "odin";
    /// <summary>
    ///     OpenGL Shading Language.
    /// </summary>
    public const string OpenGLShadingLanguage = "glsl";
    /// <summary>
    ///     OpenSCAD scripting language.
    /// </summary>
    public const string OpenScad = "openscad";
    /// <summary>
    ///     Oracle Rules Language.
    /// </summary>
    public const string OracleRulesLanguage = "ruleslanguage";
    /// <summary>
    ///     Oxygene programming language.
    /// </summary>
    public const string Oxygene = "oxygene";
    /// <summary>
    ///     PF firewall configuration files.
    /// </summary>
    public const string Pf = "pf";
    /// <summary>
    ///     PHP scripting language.
    /// </summary>
    public const string Php = "php";
    /// <summary>
    ///     Papyrus scripting language.
    /// </summary>
    public const string Papyrus = "papyrus";
    /// <summary>
    ///     Parser3 scripting language.
    /// </summary>
    public const string Parser3 = "parser3";
    /// <summary>
    ///     Perl programming language.
    /// </summary>
    public const string Perl = "perl";
    /// <summary>
    ///     Phix programming language.
    /// </summary>
    public const string Phix = "phix";
    /// <summary>
    ///     Pine Script for financial analysis.
    /// </summary>
    public const string PineScript = "pine";
    /// <summary>
    ///     Plaintext format.
    /// </summary>
    public const string Plaintext = "plaintext";
    /// <summary>
    ///     Pony programming language.
    /// </summary>
    public const string Pony = "pony";
    /// <summary>
    ///     PostgreSQL and PL/pgSQL.
    /// </summary>
    public const string PostgreSQL = "pgsql";
    /// <summary>
    ///     PowerOn programming language.
    /// </summary>
    public const string PowerOn = "poweron";
    /// <summary>
    ///     PowerShell scripting language.
    /// </summary>
    public const string PowerShell = "powershell";
    /// <summary>
    ///     Processing programming language.
    /// </summary>
    public const string Processing = "processing";
    /// <summary>
    ///     Prolog programming language.
    /// </summary>
    public const string Prolog = "prolog";
    /// <summary>
    ///     Properties file format.
    /// </summary>
    public const string Properties = "properties";
    /// <summary>
    ///     Protocol Buffers.
    /// </summary>
    public const string ProtocolBuffers = "proto";
    /// <summary>
    ///     Puppet configuration management language.
    /// </summary>
    public const string Puppet = "puppet";
    /// <summary>
    ///     Python programming language.
    /// </summary>
    public const string Python = "python";
    /// <summary>
    ///     Python REPL sessions.
    /// </summary>
    public const string PythonRepl = "python-repl";
    /// <summary>
    ///     Q# programming language.
    /// </summary>
    public const string QSharp = "qsharp";
    /// <summary>
    ///     Q/K programming language.
    /// </summary>
    public const string Q = "k";
    /// <summary>
    ///     QML language.
    /// </summary>
    public const string Qml = "qml";
    /// <summary>
    ///     R programming language.
    /// </summary>
    public const string R = "r";
    /// <summary>
    ///     Raku programming language.
    /// </summary>
    public const string Raku = "raku";
    /// <summary>
    ///     RakuDoc documentation format.
    /// </summary>
    public const string RakuDoc = "pod6";
    /// <summary>
    ///     Raku quoting constructs.
    /// </summary>
    public const string RakuQuoting = "rakuquoting";
    /// <summary>
    ///     Raku regexes.
    /// </summary>
    public const string RakuRegexe = "rakuregexe";
    /// <summary>
    ///     Razor (cshtml-razor) for ASP.NET web pages.
    /// </summary>
    public const string Razor = "cshtml-razor";
    /// <summary>
    ///     ReasonML programming language.
    /// </summary>
    public const string Reasonml = "reasonml";
    /// <summary>
    ///     Rebol and Red programming languages.
    /// </summary>
    public const string RebolAndRed = "redbol";
    /// <summary>
    ///     RenderMan RIB file format.
    /// </summary>
    public const string RenderManRib = "rib";
    /// <summary>
    ///     RenderMan RSL shader language.
    /// </summary>
    public const string RenderManRsl = "rsl";
    /// <summary>
    ///     ReScript programming language.
    /// </summary>
    public const string Rescript = "rescript";
    /// <summary>
    ///     RiScript language.
    /// </summary>
    public const string RiScript = "risc";
    /// <summary>
    ///     RISC-V Assembly language.
    /// </summary>
    public const string RiscVAssembly = "riscv";
    /// <summary>
    ///     Roboconf graph files.
    /// </summary>
    public const string Roboconf = "graph";
    /// <summary>
    ///     Robot Framework test data.
    /// </summary>
    public const string RobotFramework = "robot";
    /// <summary>
    ///     RPM spec files.
    /// </summary>
    public const string RpmSpecfile = "rpm-specfile";
    /// <summary>
    ///     Ruby programming language.
    /// </summary>
    public const string Ruby = "ruby";
    /// <summary>
    ///     Rust programming language.
    /// </summary>
    public const string Rust = "rust";
    /// <summary>
    ///     RVT Script language.
    /// </summary>
    public const string RvtScript = "rvt";
    /// <summary>
    ///     SAS programming language.
    /// </summary>
    public const string SAS = "SAS";
    /// <summary>
    ///     SCSS (Sassy CSS) language.
    /// </summary>
    public const string Scss = "scss";
    /// <summary>
    ///     SQL (Structured Query Language).
    /// </summary>
    public const string Sql = "sql";
    /// <summary>
    ///     STEP Part 21 files.
    /// </summary>
    public const string StepPart21 = "p21";
    /// <summary>
    ///     Scala programming language.
    /// </summary>
    public const string Scala = "scala";
    /// <summary>
    ///     Scheme programming language.
    /// </summary>
    public const string Scheme = "scheme";
    /// <summary>
    ///     Scilab programming language.
    /// </summary>
    public const string Scilab = "scilab";
    /// <summary>
    ///     SFZ format.
    /// </summary>
    public const string Sfz = "sfz";
    /// <summary>
    ///     Shape Expressions (ShExC).
    /// </summary>
    public const string ShapeExpressions = "shexc";
    /// <summary>
    ///     Shell scripting language.
    /// </summary>
    public const string Shell = "shell";
    /// <summary>
    ///     Smali assembly language for Dalvik VM.
    /// </summary>
    public const string Smali = "smali";
    /// <summary>
    ///     Smalltalk programming language.
    /// </summary>
    public const string Smalltalk = "smalltalk";
    /// <summary>
    ///     Standard ML programming language.
    /// </summary>
    public const string Sml = "sml";
    /// <summary>
    ///     Solidity programming language.
    /// </summary>
    public const string Solidity = "solidity";
    /// <summary>
    ///     Splunk SPL (Search Processing Language).
    /// </summary>
    public const string SplunkSpl = "spl";
    /// <summary>
    ///     Stan programming language.
    /// </summary>
    public const string Stan = "stan";
    /// <summary>
    ///     Stata statistical software.
    /// </summary>
    public const string Stata = "stata";
    /// <summary>
    ///     Structured Text (IEC 61131-3).
    /// </summary>
    public const string StructuredText = "iecst";
    /// <summary>
    ///     Stylus CSS preprocessor.
    /// </summary>
    public const string Stylus = "stylus";
    /// <summary>
    ///     SubUnit test result format.
    /// </summary>
    public const string SubUnit = "subunit";
    /// <summary>
    ///     SuperCollider programming language.
    /// </summary>
    public const string Supercollider = "supercollider";
    /// <summary>
    ///     Svelte component framework.
    /// </summary>
    public const string Svelte = "svelte";
    /// <summary>
    ///     Swift programming language.
    /// </summary>
    public const string Swift = "swift";
    /// <summary>
    ///     Tcl scripting language.
    /// </summary>
    public const string Tcl = "tcl";
    /// <summary>
    ///     Terraform (HCL) configuration language.
    /// </summary>
    public const string Terraform = "terraform";
    /// <summary>
    ///     Test Anything Protocol.
    /// </summary>
    public const string Tap = "tap";
    /// <summary>
    ///     Thrift interface definition language.
    /// </summary>
    public const string Thrift = "thrift";
    /// <summary>
    ///     Toit programming language.
    /// </summary>
    public const string Toit = "toit";
    /// <summary>
    ///     TP language.
    /// </summary>
    public const string Tp = "tp";
    /// <summary>
    ///     Transact-SQL language.
    /// </summary>
    public const string TransactSql = "tsql";
    /// <summary>
    ///     TTCN-3 testing language.
    /// </summary>
    public const string TtcnThree = "ttcn";
    /// <summary>
    ///     Twig templating language.
    /// </summary>
    public const string Twig = "twig";
    /// <summary>
    ///     TypeScript programming language.
    /// </summary>
    public const string TypeScript = "typescript";
    /// <summary>
    ///     Unicorn Rails log files.
    /// </summary>
    public const string UnicornRailsLog = "unicorn-rails-log";
    /// <summary>
    ///     Unison programming language.
    /// </summary>
    public const string Unison = "unison";
    /// <summary>
    ///     VB.NET programming language.
    /// </summary>
    public const string VbNet = "vbnet";
    /// <summary>
    ///     VBA (Visual Basic for Applications).
    /// </summary>
    public const string Vba = "vba";
    /// <summary>
    ///     VBScript scripting language.
    /// </summary>
    public const string VbScript = "vbscript";
    /// <summary>
    ///     VHDL hardware description language.
    /// </summary>
    public const string Vhdl = "vhdl";
    /// <summary>
    ///     Vala programming language.
    /// </summary>
    public const string Vala = "vala";
    /// <summary>
    ///     Verilog hardware description language.
    /// </summary>
    public const string Verilog = "verilog";
    /// <summary>
    ///     Vim script.
    /// </summary>
    public const string VimScript = "vim";
    /// <summary>
    ///     WebGPU Shading Language (WGSL).
    /// </summary>
    public const string Wgsl = "wgsl";
    /// <summary>
    ///     X# programming language.
    /// </summary>
    public const string XSharp = "xsharp";
    /// <summary>
    ///     X++ programming language (Axapta).
    /// </summary>
    public const string Axapta = "axapta";
    /// <summary>
    ///     x86 Assembly language.
    /// </summary>
    public const string X86Asm = "x86asm";
    /// <summary>
    ///     x86 Assembly (AT&amp;T syntax).
    /// </summary>
    public const string X86AsmAtt = "x86asmatt";
    /// <summary>
    ///     XL programming language.
    /// </summary>
    public const string Xl = "xl";
    /// <summary>
    ///     XQuery and XPath.
    /// </summary>
    public const string XQuery = "xquery";
    /// <summary>
    ///     YAML Ain't Markup Language.
    /// </summary>
    public const string Yaml = "yml";
    /// <summary>
    ///     ZenScript scripting language.
    /// </summary>
    public const string ZenScript = "zenscript";
    /// <summary>
    ///     Zephir programming language.
    /// </summary>
    public const string Zephir = "zephir";
    /// <summary>
    ///     Zig programming language.
    /// </summary>
    public const string Zig = "zig";
    /// <summary>
    ///     Gets the full language class with the "language-" prefix.
    /// </summary>
    /// <param name="language">The language alias to append.</param>
    /// <returns>A string representing the full language class for Highlight.js.</returns>
    public static string GetLanguageClass(string language)
    {
        return $"language-{language}";
    }
}
</file>

<file path="Components/Document/RzCodeViewer/RzCodeViewer.razor">
@namespace RizzyUI
@inherits RzComponent<RzCodeViewer.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">

    <div data-alpine-root="@Id" data-assets="@_assets"
         data-codeid="@CodeId"
         data-nonce="@Nonce"
         data-copy-title="@CopyButtonTitle"
         data-copied-title="@CopiedButtonTitle"
         x-data="rzCodeViewer">
    
        <div class="@SlotClasses.GetHeader()">
            <span class="@SlotClasses.GetHeaderTitle()">@ViewerTitle</span>
            <div class="@SlotClasses.GetCopyButtonContainer()">
                <button type="button" aria-label="@Localizer["RzCodeViewer.CopyButtonAriaLabel"]" role="button" :title="getCopiedTitle" x-on:click="copyHTML"
                        class="@SlotClasses.GetCopyButton()" :class="getCopiedCss" x-on:click.away="disableCopied"
                        data-target="cardDefault">
                    <svg x-show="notCopied" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                         stroke-width="1.5" stroke="currentColor" class="@SlotClasses.GetCopyIconDefault()"
                         x-transition:enter="transition duration-200 ease-out motion-reduce:transition-none" x-transition:enter-start="opacity-0"
                         x-transition:enter-end="opacity-100"
                         aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"></path>
                    </svg>
                    <svg x-show="copied" x-transition:enter="transition duration-200 ease-out motion-reduce:transition-none"
                         x-transition:enter-start="translate-y-2 opacity-0"
                         x-transition:enter-end="translate-y-0 opacity-100" xmlns="http://www.w3.org/2000/svg" fill="none"
                         viewBox="0 0 24 24" stroke-width="1.3" stroke="currentColor" class="@SlotClasses.GetCopyIconCopied()"
                         aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75"></path>
                    </svg>
                </button>
            </div>            
        </div>

        <div class="@SlotClasses.GetCodeContainer()">

            <div class="@SlotClasses.GetPreWrapper()" :class="getExpandCss">
                <pre x-ref="codeBlock" class="@SlotClasses.GetPreElement()" data-slot="@RzCodeViewer.SlotNames.NameOf(SlotTypes.PreElement)" tabindex="0">
                    <code class="@LanguageClass" id="@CodeId">@CodeContent</code>
                </pre>
            </div>
        </div>

        <button type="button" aria-label="@Localizer["RzCodeViewer.ExpandButtonAriaLabel"]" class="@SlotClasses.GetExpandButton()" x-on:click="toggleExpand">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"
                class="@SlotClasses.GetExpandIcon()" :class="getExpandButtonCss" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path>
            </svg>
        </button>
    </div>
</HtmlElement>
</file>

<file path="Components/Document/RzCodeViewer/RzCodeViewer.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Options;
using Rizzy.Utility;
using RizzyUI.Extensions;
using System.Text.Json;
using System.Web;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Displays code snippets with syntax highlighting (using Highlight.js), copy-to-clipboard functionality,
///     and an expand/collapse feature. Styling is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzCodeViewer : RzComponent<RzCodeViewer.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCodeViewer component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "mt-2 overflow-auto card p-0 rounded-lg",
        slots: new()
        {
            [s => s.Header] = "border-b-0 border-outline bg-secondary flex flex-col items-start justify-between gap-4 rounded-md rounded-b-none border px-4 py-1 text-sm text-secondary-foreground md:flex-row md:items-center md:gap-2",
            [s => s.HeaderTitle] = "text-foreground",
            [s => s.CodeContainer] = "border-outline w-full overflow-y-auto transition-all !rounded-b-none rounded-b-xl border",
            [s => s.CopyButtonContainer] = "flex justify-between",
            [s => s.CopyButton] = "my-auto ml-auto mr-2 overflow-hidden rounded-full p-1 hover:bg-background/10 focus:outline-none focus:outline-offset-0 focus-visible:outline-2 active:-outline-offset-2",
            [s => s.CopyIconDefault] = "text-foreground font-bold size-6 cursor-pointer",
            [s => s.CopyIconCopied] = "size-6 text-success",
            [s => s.PreWrapper] = "relative overflow-y-auto",
            [s => s.PreElement] = "not-prose text-sm overflow-x-auto p-8 m-0 border-none",
            [s => s.ExpandButton] = "border-t-0 border-outline bg-secondary text-foreground flex w-full items-center justify-center gap-2 rounded-md rounded-t-none border p-2 focus:outline-none focus-visible:rounded-t-none focus-visible:border-2 focus-visible:border-primary dark:focus-visible:border-primary",
            [s => s.ExpandIcon] = "rotate-0 h-5 w-5 transition"
        }
    );
    private string _assets = string.Empty;
    private string CodeId { get; } = IdGenerator.UniqueId("rzcode");
    private string CodeContent { get; set; } = string.Empty;
    [Inject]
    private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    /// <summary>
    ///     Optional array of asset keys (from <see cref="RizzyUIConfig.AssetUrls"/>) to load, primarily for Highlight.js and themes.
    ///     Defaults to keys for Highlight.js core and the Razor plugin.
    /// </summary>
    [Parameter] public string[] ComponentAssetKeys { get; set; } = ["HighlightJsCore", "HighlightJsRazor"];
    /// <summary>
    ///     The language alias for Highlight.js syntax highlighting (e.g., "csharp", "html", "css"). See
    ///     <see cref="CodeLanguage" /> constants. Defaults to "html".
    /// </summary>
    [Parameter] public string Language { get; set; } = CodeLanguage.Html;
    /// <summary> The code content provided as a RenderFragment. Used if <see cref="Source" /> is null or empty. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary> The code content provided as a string. Takes precedence over <see cref="ChildContent" />. </summary>
    [Parameter] public string? Source { get; set; }
    /// <summary> The title displayed in the header of the code viewer card. Defaults to localized "Source". </summary>
    [Parameter] public string? ViewerTitle { get; set; }
    /// <summary> Gets the title text for the copy button before copying. </summary>
    protected string CopyButtonTitle => Localizer["RzCodeViewer.CopyButtonTitleCopy"];
    /// <summary> Gets the title text for the copy button after copying. </summary>
    protected string CopiedButtonTitle => Localizer["RzCodeViewer.CopyButtonTitleCopied"];
    /// <summary> Gets the full language class name for Highlight.js. </summary>
    protected string LanguageClass => CodeLanguage.GetLanguageClass(Language);
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        ViewerTitle ??= Localizer["RzCodeViewer.DefaultViewerTitle"];
        UpdateAssets();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        ViewerTitle ??= Localizer["RzCodeViewer.DefaultViewerTitle"];
        SetCodeContent();
        UpdateAssets();
    }
    private void UpdateAssets()
    {
        var assetUrls = ComponentAssetKeys
            .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
            .Where(url => !string.IsNullOrEmpty(url))
            .ToList();
        _assets = JsonSerializer.Serialize(assetUrls);
    }
    private void SetCodeContent()
    {
        string rawContent;
        if (!string.IsNullOrEmpty(Source))
        {
            rawContent = Source;
        }
        else if (ChildContent != null)
        {
            rawContent = ChildContent.AsMarkupString();
            rawContent = HttpUtility.HtmlDecode(rawContent);
        }
        else
        {
            rawContent = string.Empty;
        }
        CodeContent = rawContent.TrimEmptyLines().Outdent();
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCodeViewer;
    /// <summary>
    /// Defines the slots available for styling in the RzCodeViewer component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the header section.
        /// </summary>
        public string? Header { get; set; }
        /// <summary>
        /// The slot for the title in the header.
        /// </summary>
        public string? HeaderTitle { get; set; }
        /// <summary>
        /// The slot for the container of the code block.
        /// </summary>
        public string? CodeContainer { get; set; }
        /// <summary>
        /// The slot for the container of the copy button.
        /// </summary>
        public string? CopyButtonContainer { get; set; }
        /// <summary>
        /// The slot for the copy button.
        /// </summary>
        public string? CopyButton { get; set; }
        /// <summary>
        /// The slot for the default copy icon.
        /// </summary>
        public string? CopyIconDefault { get; set; }
        /// <summary>
        /// The slot for the "copied" state icon.
        /// </summary>
        public string? CopyIconCopied { get; set; }
        /// <summary>
        /// The slot for the wrapper around the `pre` element.
        /// </summary>
        public string? PreWrapper { get; set; }
        /// <summary>
        /// The slot for the `pre` element itself.
        /// </summary>
        public string? PreElement { get; set; }
        /// <summary>
        /// The slot for the expand/collapse button.
        /// </summary>
        public string? ExpandButton { get; set; }
        /// <summary>
        /// The slot for the icon inside the expand/collapse button.
        /// </summary>
        public string? ExpandIcon { get; set; }
    }
}
</file>

<file path="Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor">
@namespace RizzyUI
@inherits RzComponent<RzEmbeddedPreview.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" class="@SlotClasses.GetBase()">
	<iframe x-data="rzEmbeddedPreview"
	        id="@Id"
	        data-alpine-root="@Id"
	        class="@SlotClasses.GetIFrame()"
	        srcdoc="@_content"
	        x-ref="iframe"
			title="@IFrameTitle">
	</iframe>
</HtmlElement>
</file>

<file path="Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Renders child content within an isolated iframe, optionally applying a specified Blazor layout component.
///     Useful for previewing components or content in a sandboxed environment. Includes Alpine.js logic
///     for dynamic iframe resizing and dark mode synchronization.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzEmbeddedPreview : RzComponent<RzEmbeddedPreview.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzEmbeddedPreview component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "w-full",
        slots: new()
        {
            [s => s.IFrame] = "w-full transition-all min-h-28"
        }
    );
    private string? _content;
    /// <summary> ServiceProvider reference needed to render components to string correctly. </summary>
    [Inject] private IServiceProvider ServiceProvider { get; set; } = default!;
    /// <summary> The content (markup or components) to render inside the iframe. Required. </summary>
    [Parameter][EditorRequired] public required RenderFragment ChildContent { get; set; }
    /// <summary> An optional Blazor layout component type to wrap the <see cref="ChildContent" /> within the iframe. </summary>
    [Parameter] public Type? Layout { get; set; }
    /// <summary>
    /// Gets or sets the title attribute for the iframe, providing context for screen readers.
    /// If not set, defaults to a localized "Embedded Content Preview".
    /// </summary>
    [Parameter] public string? IFrameTitle { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        IFrameTitle ??= Localizer["RzEmbeddedPreview.DefaultIFrameTitle"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        IFrameTitle ??= Localizer["RzEmbeddedPreview.DefaultIFrameTitle"];
    }
    /// <inheritdoc />
    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        RenderFragment fragment = builder =>
        {
            if (Layout != null)
            {
                builder.OpenComponent(0, Layout);
                builder.AddAttribute(1, nameof(LayoutComponentBase.Body), ChildContent);
                builder.CloseComponent();
            }
            else
            {
                builder.AddContent(2, ChildContent);
            }
        };
        _content = await fragment.RenderHtmlAsync(ServiceProvider);
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzEmbeddedPreview;
    /// <summary>
    /// Defines the slots available for styling in the RzEmbeddedPreview component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the `&lt;iframe&gt;` element.
        /// </summary>
        public string? IFrame { get; set; }
    }
}
</file>

<file path="Components/Document/RzMarkdown/RzMarkdown.razor">
@namespace RizzyUI
@inherits RzComponent<RzMarkdown.Slots>

<HtmlElement Element="div" @attributes="@AdditionalAttributes" class="@SlotClasses.GetBase()" id="@Id">
	<div data-alpine-root="@Id" data-assets="@_assets" data-nonce="@Nonce" x-data="rzMarkdown">
	@OutputHtml
	</div>
</HtmlElement>
</file>

<file path="Components/Document/RzMarkdown/RzMarkdown.razor.cs">
using Markdig;
using Markdig.Renderers.Html;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Options;
using Rizzy.Utility;
using RizzyUI.Extensions;
using System.Text;
using System.Text.Json;
using System.Web;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A component that converts Markdown text (provided as ChildContent or Content parameter) into HTML using Markdig.
///     It supports GitHub Flavored Markdown extensions and integrates with Highlight.js for syntax highlighting.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt; and Tailwind Typography plugin.
/// </xmldoc>
public partial class RzMarkdown : RzComponent<RzMarkdown.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzMarkdown component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "prose dark:prose-invert text-foreground max-w-none",
        variants: new()
        {
            [m => ((RzMarkdown)m).ProseWidth] = new Variant<ProseWidth, Slots>
            {
                [ProseWidth.Compact] = "prose-compact",
                [ProseWidth.Comfortable] = "prose-comfortable",
                [ProseWidth.Relaxed] = "prose-relaxed",
                [ProseWidth.Wide] = "prose-wide",
                [ProseWidth.UltraWide] = "prose-ultrawide",
                [ProseWidth.Full] = "prose-full"
            }
        }
    );
    private string _assets = string.Empty;
    [Inject]
    private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <summary>
    /// Gets or sets the Markdig pipeline to use for rendering. If null, a default pipeline with advanced extensions is used.
    /// </summary>
    [Parameter]
    public MarkdownPipeline? Pipeline { get; set; }
    /// <summary>
    /// Gets or sets the Markdown content as a RenderFragment. This is used if the `Content` parameter is not set.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the Markdown content as a string. This takes precedence over `ChildContent`.
    /// </summary>
    [Parameter]
    public string? Content { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets the maximum width of the rendered prose content.
    /// </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Comfortable;
    /// <summary>
    ///     Optional array of asset keys (from <see cref="RizzyUIConfig.AssetUrls"/>) to load, primarily for syntax highlighting.
    ///     Defaults to keys for Highlight.js core and the Razor plugin.
    /// </summary>
    [Parameter]
    public string[] ComponentAssetKeys { get; set; } = ["HighlightJsCore", "HighlightJsRazor"];
    /// <summary>
    /// Gets the rendered HTML output as a MarkupString.
    /// </summary>
    protected MarkupString? OutputHtml { get; private set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Pipeline ??= new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseRizzySyntaxHighlighting()
            .Build();
        UpdateAssets();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        RenderMarkdownContent();
        UpdateAssets();
    }
    private void UpdateAssets()
    {
        var assetUrls = ComponentAssetKeys
            .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
            .Where(url => !string.IsNullOrEmpty(url))
            .ToList();
        _assets = JsonSerializer.Serialize(assetUrls);
    }
    private void RenderMarkdownContent()
    {
        if (OutputHtml != null)
            return;
        string markdownText;
        if (!string.IsNullOrEmpty(Content))
        {
            markdownText = Content;
        }
        else if (ChildContent != null)
        {
            markdownText = ChildContent.AsMarkupString().Outdent();
            markdownText = HttpUtility.HtmlDecode(markdownText);
        }
        else
        {
            markdownText = string.Empty;
        }
        var html = RenderOutput(markdownText);
        OutputHtml = new MarkupString(html);
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzMarkdown;
    private string RenderOutput(string markdownText)
    {
        var document = Markdown.Parse(markdownText, Pipeline);
        if (QuickReferenceContainer != null)
            foreach (var block in document)
                if (block is HeadingBlock heading)
                {
                    var level = heading.Level;
                    var headingText = ExtractPlainText(heading.Inline);
                    var attributes = heading.GetAttributes();
                    attributes.Id ??= IdGenerator.UniqueId("heading");
                    attributes.AddProperty("x-data", "rzHeading");
                    var headingLevel = level switch
                    {
                        1 => HeadingLevel.H1,
                        2 => HeadingLevel.H2,
                        3 => HeadingLevel.H3,
                        _ => HeadingLevel.H4
                    };
                    QuickReferenceContainer.RegisterHeading(headingLevel, headingText, attributes.Id);
                }
        return document.ToHtml(Pipeline);
    }
    private string ExtractPlainText(ContainerInline? inline)
    {
        if (inline == null) return string.Empty;
        var sb = new StringBuilder();
        foreach (var child in inline)
            if (child is LiteralInline literal)
                sb.Append(literal.Content.Text.Substring(literal.Content.Start, literal.Content.Length));
            else if (child is ContainerInline container) sb.Append(ExtractPlainText(container));
        return sb.ToString().Trim();
    }
    /// <summary>
    /// Defines the slots available for styling in the RzMarkdown component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Document/RzQuickReference/RzQuickReference.razor">
@namespace RizzyUI
@inherits RzComponent<RzQuickReference.Slots>

<nav aria-label="@AriaLabel" @attributes="@AdditionalAttributes" class="@SlotClasses.GetBase()" id="@Id">
    <p class="@SlotClasses.GetTitle()">
        @Title
    </p>
    <ul class="@SlotClasses.GetList()">
        @foreach (var heading in _headings)
        {
            <li class="@(SlotClasses.GetListItem() + " " + GetIndentationClass(heading.Level))">
                <a href="#@heading.Id"
                   class="@SlotClasses.GetLink()"
                   data-headingid="@heading.Id"
                   :class="getSelectedCss"
                   :aria-current="getSelectedAriaCurrent"
                   x-on:click="handleHeadingClick">
                    @heading.Title
                </a>
            </li>
        }
    </ul>
</nav>
</file>

<file path="Components/Document/RzQuickReference/RzQuickReference.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Renders an "on this page" style navigation outline based on headings registered
///     with the parent &lt;see cref="RzQuickReferenceContainer" /&gt;. Interacts with Alpine.js
///     to highlight the currently visible heading and set `aria-current`.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzQuickReference : RzComponent<RzQuickReference.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzQuickReference component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-foreground",
        slots: new()
        {
            [s => s.Title] = "mb-4 font-bold",
            [s => s.List] = "flex flex-col gap-2",
            [s => s.ListItem] = "",
            [s => s.Link] = ""
        }
    );
    private IReadOnlyList<HeadingItem> _headings = new List<HeadingItem>().AsReadOnly();
    /// <summary> Gets the parent container which holds the heading data. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <summary> The title displayed above the quick reference list. Defaults to localized "On this page". </summary>
    [Parameter]
    public string? Title { get; set; }
    /// <summary>
    /// The aria-label for the navigation element. Defaults to localized "On this page navigation".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (QuickReferenceContainer == null)
            throw new InvalidOperationException(
                $"{GetType()} must be placed within an {nameof(RzQuickReferenceContainer)}.");
        _headings = QuickReferenceContainer.GetHeadingItems();
        Title ??= Localizer["RzQuickReference.DefaultTitle"];
        AriaLabel ??= Localizer["RzQuickReference.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (QuickReferenceContainer != null) _headings = QuickReferenceContainer.GetHeadingItems();
        Title ??= Localizer["RzQuickReference.DefaultTitle"];
        AriaLabel ??= Localizer["RzQuickReference.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzQuickReference;
    /// <summary> Gets the CSS class for indentation based on the heading level. </summary>
    protected string GetIndentationClass(HeadingLevel level)
    {
        var relativeLevel = (int)level - (int)(QuickReferenceContainer?.MinimumHeadingLevel ?? HeadingLevel.H2);
        return relativeLevel switch
        {
            0 => "ml-0",
            1 => "ml-4",
            2 => "ml-8",
            3 => "ml-12",
            _ => "ml-0"
        };
    }
    /// <summary>
    /// Defines the slots available for styling in the RzQuickReference component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the title element.
        /// </summary>
        public string? Title { get; set; }
        /// <summary>
        /// The slot for the list (`&lt;ul&gt;`) element.
        /// </summary>
        public string? List { get; set; }
        /// <summary>
        /// The slot for each list item (`&lt;li&gt;`) element.
        /// </summary>
        public string? ListItem { get; set; }
        /// <summary>
        /// The slot for each link (`&lt;a&gt;`) element.
        /// </summary>
        public string? Link { get; set; }
    }
}
</file>

<file path="Components/Document/RzQuickReference/RzQuickReferenceContainer.razor">
@namespace RizzyUI
@inherits RzComponent<RzQuickReferenceContainer.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
	<div data-alpine-root="@Id" data-headings="@_headingItemsSerialized"
	     data-currentheadingid="@(_currentHeadingId)"
	     x-data="rzQuickReferenceContainer">
		<CascadingValue Value="this" IsFixed="true">
			@ChildContent
		</CascadingValue>		
	</div>
</HtmlElement>
</file>

<file path="Components/Document/RzQuickReference/RzQuickReferenceContainer.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Text.Json;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A container component that collects heading information from child components (like &lt;see cref="RzHeading" /&gt;)
///     and makes it available to &lt;see cref="RzQuickReference" /&gt; for building an "on this page" navigation.
///     Interacts with Alpine.js to manage the currently highlighted heading.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzQuickReferenceContainer : RzComponent<RzQuickReferenceContainer.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzQuickReferenceContainer component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: ""
    );
    private readonly List<HeadingItem> _headingItems = new();
    private string _currentHeadingId = string.Empty;
    private string _headingItemsSerialized = "[]";
    /// <summary> The lowest heading level (e.g., H2) to include in the quick reference outline. Defaults to H2. </summary>
    [Parameter]
    public HeadingLevel MinimumHeadingLevel { get; set; } = HeadingLevel.H2;
    /// <summary> The highest heading level (e.g., H4) to include in the quick reference outline. Defaults to H4. </summary>
    [Parameter]
    public HeadingLevel MaximumHeadingLevel { get; set; } = HeadingLevel.H4;
    /// <summary>
    ///     The child content of the container, which should include headings and potentially an
    ///     &lt;see cref="RzQuickReference" /&gt; component.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Registers a heading with this container. Called by child &lt;see cref="RzHeading" /&gt; components. </summary>
    internal void RegisterHeading(HeadingLevel level, string title, string id)
    {
        if (level >= MinimumHeadingLevel && level <= MaximumHeadingLevel)
            _headingItems.Add(new HeadingItem(level, title, id));
        UpdateSerializedHeadings();
        StateHasChanged();
    }
    private void UpdateSerializedHeadings()
    {
        _headingItemsSerialized = JsonSerializer.Serialize(_headingItems.Select(x => x.Id).ToList());
        _currentHeadingId = _headingItems.FirstOrDefault()?.Id ?? string.Empty;
    }
    /// <summary> Gets the list of registered heading items. </summary>
    public IReadOnlyList<HeadingItem> GetHeadingItems() => _headingItems.AsReadOnly();
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzQuickReferenceContainer;
    /// <summary>
    /// Defines the slots available for styling in the RzQuickReferenceContainer component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzAlert/AlertDescription.razor">
@namespace RizzyUI
@inherits RzComponent<AlertDescription.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" data-slot="alert-description" class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzAlert/AlertDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the descriptive content (&lt;c&gt;p&lt;/c&gt; tag by default) within an <see cref="RzAlert" /> component.
///     Provides supplementary information to the <see cref="AlertTitle" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class AlertDescription : RzComponent<AlertDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the AlertDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-sm text-foreground [&_p]:leading-relaxed [&_ul]:list-inside [&_ul]:list-disc"
    );
    /// <summary> The descriptive content to be rendered. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.AlertDescription;
    /// <summary>
    /// Defines the slots available for styling in the AlertDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzAlert/AlertTitle.razor">
@namespace RizzyUI
@inherits RzComponent<AlertTitle.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="@SlotNames.NameOf(SlotTypes.Base)">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzAlert/AlertTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the title section (defaults to &lt;c&gt;h3&lt;/c&gt;) for an <see cref="RzAlert" /> component.
///     Its text color is determined by the parent alert's variant and the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class AlertTitle : RzComponent<AlertTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the AlertTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "font-medium tracking-tight line-clamp-1",
        variants: new()
        {
            [c => ((AlertTitle)c).EffectiveVariant] = new Variant<ThemeVariant, Slots>
            {
                [ThemeVariant.Default] = "text-inherit",
                [ThemeVariant.Inverse] = "text-inherit",
                [ThemeVariant.Accent] = "text-accent-foreground",
                [ThemeVariant.Primary] = "text-primary",
                [ThemeVariant.Secondary] = "text-secondary-foreground",
                [ThemeVariant.Information] = "text-info",
                [ThemeVariant.Success] = "text-success",
                [ThemeVariant.Warning] = "text-warning",
                [ThemeVariant.Destructive] = "text-destructive",
                [ThemeVariant.Ghost] = "text-foreground"
            }
        }
    );
    /// <summary> Gets the parent <see cref="RzAlert" /> component to determine the variant. </summary>
    [CascadingParameter]
    public RzAlert? AlertParent { get; set; }
    /// <summary> 
    /// The variant of the alert title. If not set, it defaults to the variant of the parent RzAlert.
    /// This allows for overriding the parent's variant for specific styling needs.
    /// </summary>
    [Parameter]
    public ThemeVariant? Variant { get; set; }
    /// <summary> The content to be rendered inside the alert title (typically text). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the effective variant for styling, prioritizing the local `Variant` parameter
    /// and falling back to the parent `RzAlert`'s variant.
    /// </summary>
    protected ThemeVariant EffectiveVariant => Variant ?? AlertParent?.Variant ?? ThemeVariant.Accent;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "h3";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.AlertTitle;
    /// <summary>
    /// Defines the slots available for styling in the AlertTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("alert-title")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzAlert/RzAlert.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzAlert.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             role="alert"
	             aria-live="assertive"
                 @attributes="@AdditionalAttributes"
                 id="@Id"
                 class="@SlotClasses.GetBase()">
	    <div aria-atomic="true"
	         x-cloak
	         x-data="rzAlert" x-show="showAlert"
	         x-transition:enter="transition ease-out duration-200 motion-reduce:transition-none"
	         x-transition:enter-start="opacity-0"
	         x-transition:enter-end="opacity-100"
	         x-transition:leave="transition ease-in duration-100 motion-reduce:transition-none"
	         x-transition:leave-start="opacity-100"
	         x-transition:leave-end="opacity-0"
	         data-alpine-root="@Id">
	         <div class="@SlotClasses.GetInnerContainer()">
		         @if (Icon != null)
		         {
			         <div class="@SlotClasses.GetIconContainer()" aria-hidden="true">
				         @if (Pulse)
				         {
					         <div class="@SlotClasses.GetIconPulse()"></div>
				         }
				         <Blazicon Svg="Icon"></Blazicon>
			         </div>
		         }
		         <div class="@SlotClasses.GetContentContainer()">
			         @ChildContent
		         </div>

		         @if (Dismissable)
		         {
			         <button
				         type="button"
				         x-on:click="dismiss"
				         aria-label="@Localizer["RzAlert.CloseButtonAriaLabel"]"
				         class="@SlotClasses.GetCloseButton()">
				         <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" stroke="currentColor"
				              fill="none" stroke-width="2.5" class="@SlotClasses.GetCloseButtonIcon()">
					         <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
				         </svg>
			         </button>
		         }
	         </div>
         </div>        
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Feedback/RzAlert/RzAlert.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
///     Represents an alert component that displays a message with optional icon, variant, and dismiss functionality.
///     Styling is handled by the active theme. Content within the alert is implicitly announced by assistive technologies
///     due to the `role="alert"` attribute on the container.
/// </summary>
public partial class RzAlert : RzComponent<RzAlert.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzAlert component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "not-prose relative w-full overflow-hidden rounded-lg border text-sm",
        slots: new()
        {
            [s => s.InnerContainer] = "flex w-full items-start gap-x-3 px-4 py-3",
            [s => s.IconContainer] = "relative flex size-6 shrink-0 text-2xl translate-y-0.5",
            [s => s.IconPulse] = "absolute animate-ping motion-reduce:animate-none size-6 aspect-square rounded-full",
            [s => s.ContentContainer] = "flex flex-col flex-1 gap-y-0.5 translate-y-0.5",
            [s => s.CloseButton] = "ml-auto self-start p-1 rounded-full opacity-70 hover:opacity-100 focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ring dark:focus-visible:ring-offset-background transition-opacity text-foreground",
            [s => s.CloseButtonIcon] = "size-4 shrink-0"
        },
        variants: new()
        {
            [b => ((RzAlert)b).Variant] = new Variant<ThemeVariant, Slots>
            {
                // Default
                [ThemeVariant.Default] = new() { [s => s.Base] = "bg-input text-foreground border-input", [s => s.IconContainer] = "text-foreground", [s => s.IconPulse] = "bg-foreground/15", [s => s.CloseButton] = "text-foreground/70 hover:text-foreground" },
                // Inverse
                [ThemeVariant.Inverse] = new() { [s => s.Base] = "bg-foreground text-background border-foreground", [s => s.IconContainer] = "text-background", [s => s.IconPulse] = "bg-background/15", [s => s.CloseButton] = "text-background hover:opacity-100 opacity-90" },
                // Standard Variants
                [ThemeVariant.Primary] = new() { [s => s.Base] = "border-primary/50 bg-primary/10 text-primary", [s => s.IconContainer] = "text-primary", [s => s.IconPulse] = "bg-primary/15" },
                [ThemeVariant.Secondary] = new() { [s => s.Base] = "border-secondary/50 bg-secondary/10 text-secondary-foreground", [s => s.IconContainer] = "text-secondary-foreground", [s => s.IconPulse] = "bg-secondary/15" },
                [ThemeVariant.Accent] = new() { [s => s.Base] = "border-accent/50 bg-accent/10 text-accent-foreground", [s => s.IconContainer] = "text-accent-foreground", [s => s.IconPulse] = "bg-accent/15" },
                [ThemeVariant.Information] = new() { [s => s.Base] = "border-info bg-info/10 text-info-foreground dark:bg-info/15", [s => s.IconContainer] = "text-info", [s => s.IconPulse] = "bg-info/15" },
                [ThemeVariant.Success] = new() { [s => s.Base] = "border-success bg-success/10 text-success-foreground dark:bg-success/15", [s => s.IconContainer] = "text-success", [s => s.IconPulse] = "bg-success/15" },
                [ThemeVariant.Warning] = new() { [s => s.Base] = "border-warning bg-warning/10 text-warning-foreground dark:bg-warning/15", [s => s.IconContainer] = "text-warning", [s => s.IconPulse] = "bg-warning/15" },
                [ThemeVariant.Destructive] = new() { [s => s.Base] = "border-destructive bg-destructive/10 text-destructive dark:bg-destructive/15", [s => s.IconContainer] = "text-destructive", [s => s.IconPulse] = "bg-destructive/15" },
                // Ghost
                [ThemeVariant.Ghost] = new() { [s => s.Base] = "border-transparent bg-transparent text-foreground", [s => s.IconContainer] = "text-foreground", [s => s.IconPulse] = "bg-muted/50" }
            }
        }
    );
    /// <summary> Gets or sets the variant of the alert. Defaults to <see cref="ThemeVariant.Default"/>. </summary>
    [Parameter]
    public ThemeVariant Variant { get; set; } = ThemeVariant.Default;
    /// <summary> Gets or sets the icon displayed in the alert. If null, a default icon based on the variant may be shown. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Gets or sets a value indicating whether the alert can be dismissed via a close button. </summary>
    [Parameter]
    public bool Dismissable { get; set; }
    /// <summary> Gets or sets the content to be displayed inside the alert, typically including <see cref="AlertTitle"/> and <see cref="AlertDescription"/>. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets whether to display a pulsing animation behind the icon for emphasis. </summary>
    [Parameter]
    public bool Pulse { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        SetDefaultIcon();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        SetDefaultIcon();
    }
    private void SetDefaultIcon()
    {
        if (Icon == null)
            Icon = Variant switch
            {
                ThemeVariant.Information => MdiIcon.InformationSlabCircle,
                ThemeVariant.Success => MdiIcon.CheckCircle,
                ThemeVariant.Warning => MdiIcon.AlertCircle,
                ThemeVariant.Destructive => MdiIcon.CloseCircle,
                // Default icons for other variants if desired
                ThemeVariant.Default => MdiIcon.InformationSlabCircle,
                ThemeVariant.Inverse => MdiIcon.InformationSlabCircle,
                ThemeVariant.Primary => MdiIcon.InformationSlabCircle,
                ThemeVariant.Secondary => MdiIcon.InformationSlabCircle,
                ThemeVariant.Accent => MdiIcon.InformationSlabCircle,
                ThemeVariant.Ghost => null,
                _ => null
            };
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzAlert;
    /// <summary>
    /// Defines the slots available for styling in the RzAlert component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("alert")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner container that holds the icon and content.
        /// </summary>
        [Slot("inner-container")]
        public string? InnerContainer { get; set; }
        /// <summary>
        /// The slot for the icon container.
        /// </summary>
        [Slot("icon-container")]
        public string? IconContainer { get; set; }
        /// <summary>
        /// The slot for the pulsing animation element behind the icon.
        /// </summary>
        [Slot("icon-pulse")]
        public string? IconPulse { get; set; }
        /// <summary>
        /// The slot for the main content container (title and description).
        /// </summary>
        [Slot("content-container")]
        public string? ContentContainer { get; set; }
        /// <summary>
        /// The slot for the close button.
        /// </summary>
        [Slot("close-button")]
        public string? CloseButton { get; set; }
        /// <summary>
        /// The slot for the icon inside the close button.
        /// </summary>
        [Slot("close-button-icon")]
        public string? CloseButtonIcon { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogClose.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<DialogClose.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Feedback/RzDialog/DialogClose.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive element that closes its parent <see cref="RzDialog"/>.
/// It can be rendered as a button or merge its behavior into a child element.
/// </summary>
public partial class DialogClose : RzAsChildComponent<DialogClose.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogClose component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzDialog"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDialog? ParentDialog { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDialog == null)
        {
            throw new InvalidOperationException($"{nameof(DialogClose)} must be used within an {nameof(RzDialog)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["x-on:click"] = "closeModal",
            ["data-slot"] = "dialog-close"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.DialogClose;
    /// <summary>
    /// Defines the slots available for styling in the DialogClose component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogContent.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<DialogContent.Slots>

<template x-teleport="body">
	<div class="contents">
		<div x-cloak
		     x-show="modalOpen"
		     x-transition:enter="ease-in-out duration-500"
		     x-transition:enter-start="opacity-0"
		     x-transition:enter-end="opacity-100"
		     x-transition:leave="ease-in-out duration-300"
		     x-transition:leave-start="opacity-100"
		     x-transition:leave-end="opacity-0"
		     class="@SlotClasses.GetBackdrop()">
		</div>

		<HtmlElement Element="div" @attributes="AdditionalAttributes"
		             x-cloak
		             x-show="modalOpen"
		             x-transition:enter="ease-out duration-300"
		             x-transition:enter-start="opacity-0 scale-95"
		             x-transition:enter-end="opacity-100 scale-100"
		             x-transition:leave="ease-in duration-200"
		             x-transition:leave-start="opacity-100 scale-100"
		             x-transition:leave-end="opacity-0 scale-95"
		             x-trap.inert="modalOpen"
		             x-on:click.outside="handleClickOutside"
		             role="document"
		             class="@SlotClasses.GetBase()">

			@ChildContent

			@if (ShowCloseButton)
			{
				<button x-on:click="closeModal"
				        type="button"
				        aria-label="@Localizer["RzDialog.CloseButtonAriaLabel"]"
				        class="@SlotClasses.GetCloseButton()">
					<Blazicon Svg="Lucide.X" class="@SlotClasses.GetCloseButtonIcon()"/>
				</button>
			}
		</HtmlElement>
	</div>
</template>
</file>

<file path="Components/Feedback/RzDialog/DialogContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The main content panel of a <see cref="RzDialog"/> that appears when triggered.
/// </summary>
public partial class DialogContent : RzComponent<DialogContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        slots: new()
        {
            [s => s.Backdrop] = "fixed inset-0 z-50 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
            [s => s.CloseButton] = "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none",
            [s => s.CloseButtonIcon] = "[&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
        },
        variants: new()
        {
            [c => ((DialogContent)c).Size] = new Variant<ModalSize, Slots>
            {
                [ModalSize.ExtraSmall] = new() { [s => s.Base] = "sm:max-w-xs" },
                [ModalSize.Small] = new() { [s => s.Base] = "sm:max-w-sm" },
                [ModalSize.Medium] = new() { [s => s.Base] = "sm:max-w-md" },
                [ModalSize.Large] = new() { [s => s.Base] = "sm:max-w-lg" },
                [ModalSize.ExtraLarge] = new() { [s => s.Base] = "sm:max-w-xl" },
                [ModalSize.TwoXL] = new() { [s => s.Base] = "sm:max-w-2xl" },
                [ModalSize.ThreeXL] = new() { [s => s.Base] = "sm:max-w-3xl" },
                [ModalSize.FourXL] = new() { [s => s.Base] = "sm:max-w-4xl" },
                [ModalSize.FiveXL] = new() { [s => s.Base] = "sm:max-w-5xl" },
                [ModalSize.SixXL] = new() { [s => s.Base] = "sm:max-w-6xl" },
                [ModalSize.SevenXL] = new() { [s => s.Base] = "sm:max-w-7xl" }
            }
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzDialog"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDialog? ParentDialog { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the dialog panel. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets whether to show the default close button in the top-right corner.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool ShowCloseButton { get; set; } = true;
    /// <summary>
    /// Gets or sets the size variant of the dialog, controlling its maximum width.
    /// Defaults to <see cref="ModalSize.Large"/>.
    /// </summary>
    [Parameter]
    public ModalSize Size { get; set; } = ModalSize.Large;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDialog == null)
        {
            throw new InvalidOperationException($"{nameof(DialogContent)} must be used within an {nameof(RzDialog)}.");
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DialogContent;
    /// <summary>
    /// Defines the slots available for styling in the DialogContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main dialog panel.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the backdrop overlay.
        /// </summary>
        public string? Backdrop { get; set; }
        /// <summary>
        /// The slot for the close button.
        /// </summary>
        public string? CloseButton { get; set; }
        /// <summary>
        /// The slot for the icon inside the close button.
        /// </summary>
        public string? CloseButtonIcon { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogDescription.razor">
@namespace RizzyUI
@inherits RzComponent<DialogDescription.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="dialog-description">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzDialog/DialogDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying descriptive text within a <see cref="DialogHeader"/>.
/// </summary>
public partial class DialogDescription : RzComponent<DialogDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground text-sm"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the description.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "p";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DialogDescription;
    /// <summary>
    /// Defines the slots available for styling in the DialogDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogFooter.razor">
@namespace RizzyUI
@inherits RzComponent<DialogFooter.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="dialog-footer">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzDialog/DialogFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the footer content of a <see cref="DialogContent"/>, typically for action buttons.
/// </summary>
public partial class DialogFooter : RzComponent<DialogFooter.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogFooter component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the footer.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DialogFooter;
    /// <summary>
    /// Defines the slots available for styling in the DialogFooter component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogHeader.razor">
@namespace RizzyUI
@inherits RzComponent<DialogHeader.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="dialog-header">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzDialog/DialogHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the header content of a <see cref="DialogContent"/>, typically containing a <see cref="DialogTitle"/> and <see cref="DialogDescription"/>.
/// </summary>
public partial class DialogHeader : RzComponent<DialogHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col gap-2 text-center sm:text-left"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the header.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DialogHeader;
    /// <summary>
    /// Defines the slots available for styling in the DialogHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogTitle.razor">
@namespace RizzyUI
@inherits RzComponent<DialogTitle.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@ParentDialog?.AriaLabelId" class="@SlotClasses.GetBase()" data-slot="dialog-title">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzDialog/DialogTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the title within a <see cref="DialogHeader"/>.
/// </summary>
public partial class DialogTitle : RzComponent<DialogTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-lg leading-none font-semibold"
    );
    /// <summary>
    /// Gets or sets the parent <see cref="RzDialog"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDialog? ParentDialog { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the title.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "h2";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DialogTitle;
    /// <summary>
    /// Defines the slots available for styling in the DialogTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/DialogTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<DialogTrigger.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Feedback/RzDialog/DialogTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The interactive element that triggers the opening of a <see cref="RzDialog"/>.
/// It can be rendered as a button or merge its behavior into a child element.
/// </summary>
public partial class DialogTrigger : RzAsChildComponent<DialogTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the DialogTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzDialog"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDialog? ParentDialog { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDialog == null)
        {
            throw new InvalidOperationException($"{nameof(DialogTrigger)} must be used within an {nameof(RzDialog)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["onclick"] = $"window.dispatchEvent(new CustomEvent('{ParentDialog?.EventTriggerName}'))",
            ["data-slot"] = "dialog-trigger"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.DialogTrigger;
    /// <summary>
    /// Defines the slots available for styling in the DialogTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzDialog/RzDialog.razor">
@namespace RizzyUI
@inherits RzComponent<RzDialog.Slots>

<CascadingValue Value="this" IsFixed="true">
	@{
		// If trying to use x-ref on a modal we'll drop in an inert placeholder to allow them to use
		// Rizzy.$data() to get the actual Modal data
		if (AdditionalAttributes?.TryGetValue("x-ref", out var attribute) is true)
		{
			<rz-proxy id="rz-ref-@Id" x-ref="@(attribute)" data-for="@Id"></rz-proxy>
		}
	}	
	<div x-data="rzDialog"
	     id="@Id"
	     data-alpine-root="@Id"
	     data-modal-id="@Id"
	     data-body-id="@BodyId"
	     data-footer-id="@FooterId"
	     data-nonce="@Nonce"
	     data-event-trigger-name="@EventTriggerName"
	     data-close-event-name="@CloseEventName"
	     data-close-on-escape="@(CloseOnEscape.ToString().ToLowerInvariant())"
	     data-close-on-click-outside="@(CloseOnClickOutside.ToString().ToLowerInvariant())">
		@ChildContent
	</div>
</CascadingValue>
</file>

<file path="Components/Feedback/RzDialog/RzDialog.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The root component for a dialog system. It provides context for its children,
/// including trigger, content, and other parts. Interactivity is managed by an Alpine.js component.
/// </summary>
public partial class RzDialog : RzComponent<RzDialog.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzDialog component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new();
    /// <summary>
    /// Gets the unique identifier for the `aria-labelledby` attribute, linking the dialog to its title.
    /// </summary>
    internal string AriaLabelId { get; } = IdGenerator.UniqueId("rzdlgttl");
    /// <summary>
    /// Gets the unique identifier for the dialog body container, usable as an HTMX target ID.
    /// </summary>
    public string BodyId { get; } = IdGenerator.UniqueId("rzdlgbody");
    /// <summary>
    /// Gets the unique identifier for the dialog footer container, usable as an HTMX target ID.
    /// </summary>
    public string FooterId { get; } = IdGenerator.UniqueId("rzdlgfoot");
    /// <summary>
    /// Gets or sets the content of the dialog, which should include a <see cref="DialogTrigger"/>
    /// and a <see cref="DialogContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the name of the window event that will trigger this dialog to open.
    /// If empty, a unique name will be generated.
    /// </summary>
    [Parameter]
    public string EventTriggerName { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets the name of the window event that will trigger this dialog to close.
    /// Defaults to the value defined in <see cref="Constants.Events.DialogClose"/>.
    /// </summary>
    [Parameter]
    public string CloseEventName { get; set; } = Constants.Events.DialogClose;
    /// <summary>
    /// Gets or sets whether the dialog should close when the Escape key is pressed.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;
    /// <summary>
    /// Gets or sets whether the dialog should close when a click occurs on the backdrop.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(EventTriggerName))
        {
            EventTriggerName = $"show-dialog-{Id}";
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzDialog;
    /// <summary>
    /// Defines the slots available for styling in the RzDialog component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyContent.razor">
@namespace RizzyUI
@inherits RzComponent<EmptyContent.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/EmptyContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for supplementary content within an <see cref="RzEmpty"/> component, such as action buttons.
/// </summary>
public partial class EmptyContent : RzComponent<EmptyContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the EmptyContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance"
    );
    /// <summary>
    /// Gets or sets the content to be rendered.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.EmptyContent;
    /// <summary>
    /// Defines the slots available for styling in the EmptyContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyDescription.razor">
@namespace RizzyUI
@inherits RzComponent<EmptyDescription.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty-description">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/EmptyDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying descriptive text within an <see cref="EmptyHeader"/>.
/// </summary>
public partial class EmptyDescription : RzComponent<EmptyDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the EmptyDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground [&>a:hover]:text-primary text-sm/relaxed [&>a]:underline [&>a]:underline-offset-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the description.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "p";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.EmptyDescription;
    /// <summary>
    /// Defines the slots available for styling in the EmptyDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyHeader.razor">
@namespace RizzyUI
@inherits RzComponent<EmptyHeader.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty-header">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/EmptyHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the header section of an <see cref="RzEmpty"/> component, typically holding the media, title, and description.
/// </summary>
public partial class EmptyHeader : RzComponent<EmptyHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the EmptyHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex max-w-sm flex-col items-center gap-2 text-center"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the header.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.EmptyHeader;
    /// <summary>
    /// Defines the slots available for styling in the EmptyHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyMedia.razor">
@namespace RizzyUI
@inherits RzComponent<EmptyMedia.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty-media"
             data-variant="@Variant.ToString().ToLowerInvariant()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/EmptyMedia.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for an icon or image within an <see cref="EmptyHeader"/>.
/// </summary>
public partial class EmptyMedia : RzComponent<EmptyMedia.Slots>
{
    /// <summary>
    /// Defines the default styling for the EmptyMedia component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex shrink-0 items-center justify-center mb-2 [&_svg]:pointer-events-none [&_svg]:shrink-0",
        variants: new()
        {
            [c => ((EmptyMedia)c).Variant] = new Variant<EmptyMediaVariant, Slots>
            {
                [EmptyMediaVariant.Icon] = "bg-muted text-foreground flex size-10 text-2xl shrink-0 items-center justify-center rounded-lg [&_svg:not([class*='size-'])]:size-6",
                [EmptyMediaVariant.Default] = "bg-transparent"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content to be rendered, typically an icon or image.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the visual variant of the media container.
    /// Defaults to <see cref="EmptyMediaVariant.Default"/>.
    /// </summary>
    [Parameter]
    public EmptyMediaVariant Variant { get; set; } = EmptyMediaVariant.Default;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.EmptyMedia;
    /// <summary>
    /// Defines the slots available for styling in the EmptyMedia component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyMediaVariant.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the visual variant for the EmptyMedia component.
/// </summary>
public enum EmptyMediaVariant
{
    /// <summary>
    /// Default variant, typically for custom images or complex content.
    /// </summary>
    Default,
    /// <summary>
    /// Icon variant, which provides a styled background for an icon.
    /// </summary>
    Icon
}
</file>

<file path="Components/Feedback/RzEmpty/EmptyTitle.razor">
@namespace RizzyUI
@inherits RzComponent<EmptyTitle.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty-title">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/EmptyTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the title within an <see cref="EmptyHeader"/>.
/// </summary>
public partial class EmptyTitle : RzComponent<EmptyTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the EmptyTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-lg font-medium tracking-tight"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the title.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.EmptyTitle;
    /// <summary>
    /// Defines the slots available for styling in the EmptyTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzEmpty/RzEmpty.razor">
@namespace RizzyUI
@inherits RzComponent<RzEmpty.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="empty"
             aria-label="@AriaLabel">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzEmpty/RzEmpty.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for displaying an empty state. It centers its content and provides a styled placeholder.
/// </summary>
public partial class RzEmpty : RzComponent<RzEmpty.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzEmpty component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg p-6 text-center text-balance md:p-12"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the empty state container.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the empty state container.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzEmpty.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzEmpty.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzEmpty;
    /// <summary>
    /// Defines the slots available for styling in the RzEmpty component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzPopover/AnchorStrategy.cs">
// src/RizzyUI/Components/Feedback/RzPopover/AnchorStrategy.cs
namespace RizzyUI;
/// <summary>
/// Specifies the positioning strategy for floating elements like popovers.
/// </summary>
public enum AnchorStrategy
{
    /// <summary>
    /// Positions the element relative to its offset parent. This is the default and most common strategy.
    /// </summary>
    Absolute,
    /// <summary>
    /// Positions the element relative to the viewport. Use this when the trigger is inside a scrollable container.
    /// </summary>
    Fixed
}
</file>

<file path="Components/Feedback/RzPopover/PopoverContent.razor">
@namespace RizzyUI
@inherits RzComponent<PopoverContent.Slots>

<div @attributes="AdditionalAttributes"
     x-ref="content"
     id="@ContentId"
     data-popover
     x-show="open"
     x-cloak
     x-transition:enter="transition ease-out duration-200"
     x-transition:enter-start="opacity-0 translate-y-1"
     x-transition:enter-end="opacity-100 translate-y-0"
     x-transition:leave="transition ease-in duration-150"
     x-transition:leave-start="opacity-100 translate-y-0"
     x-transition:leave-end="opacity-0 translate-y-1"
     x-trap.inert="open"
     role="dialog"
     aria-modal="true"
     aria-labelledby="@TriggerId"
     class="@SlotClasses.GetBase()"
     data-slot="popover-content">
	@ChildContent
</div>
</file>

<file path="Components/Feedback/RzPopover/PopoverContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The content panel of a <see cref="RzPopover"/> that appears when the trigger is activated.
/// </summary>
public partial class PopoverContent : RzComponent<PopoverContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the PopoverContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none"
    );
    /// <summary>
    /// Gets the parent <see cref="RzPopover"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzPopover? ParentPopover { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the popover panel. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets the ID for the content element.
    /// </summary>
    protected string ContentId => $"{ParentPopover?.Id}-content";
    /// <summary>
    /// Gets the ID of the trigger element that controls this content.
    /// </summary>
    protected string TriggerId => $"{ParentPopover?.Id}-trigger";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentPopover == null)
        {
            throw new InvalidOperationException($"{nameof(PopoverContent)} must be used within an {nameof(RzPopover)}.");
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.PopoverContent;
    /// <summary>
    /// Defines the slots available for styling in the PopoverContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzPopover/PopoverTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<PopoverTrigger.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Feedback/RzPopover/PopoverTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The interactive element that triggers the opening of a <see cref="RzPopover"/>.
/// It can be rendered as a button or merge its behavior into a child element using the AsChild pattern.
/// </summary>
public partial class PopoverTrigger : RzAsChildComponent<PopoverTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the PopoverTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzPopover"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzPopover? ParentPopover { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets the ID for the trigger element.
    /// </summary>
    protected string TriggerId => $"{ParentPopover?.Id}-trigger";
    /// <summary>
    /// Gets the ID of the content element this trigger controls.
    /// </summary>
    protected string ContentId => $"{ParentPopover?.Id}-content";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentPopover == null)
        {
            throw new InvalidOperationException($"{nameof(PopoverTrigger)} must be used within an {nameof(RzPopover)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = TriggerId,
            ["class"] = SlotClasses.GetBase(),
            ["x-ref"] = "trigger",
            ["x-on:click"] = "toggle",
            ["aria-haspopup"] = "dialog",
            ["aria-controls"] = ContentId,
            ["x-bind:aria-expanded"] = "ariaExpanded",
            ["data-slot"] = "popover-trigger"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.PopoverTrigger;
    /// <summary>
    /// Defines the slots available for styling in the PopoverTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzPopover/RzPopover.razor">
@namespace RizzyUI
@inherits RzComponent<RzPopover.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             id="@Id"
	             class="@SlotClasses.GetBase()"
	             @attributes="@AdditionalAttributes"
	             x-data="rzPopover"
	             data-alpine-root="@Id"
	             data-anchor="@Anchor.ToString().ToKebabCase()"
	             data-offset="@Offset"
	             data-cross-axis-offset="@CrossAxisOffset"
	             data-alignment-axis-offset="@AlignmentAxisOffset"
	             data-strategy="@Strategy.ToString().ToLowerInvariant()"
	             data-enable-flip="@EnableFlip.ToString().ToLowerInvariant()"
	             data-enable-shift="@EnableShift.ToString().ToLowerInvariant()"
	             data-shift-padding="@ShiftPadding"
	             x-on:keydown.escape.window="handleWindowEscape"
	             x-on:click.outside="handleOutsideClick"
	             aria-label="@AriaLabel"
                 data-slot="popover">
		@ChildContent
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Feedback/RzPopover/RzPopover.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that displays a pop-up box of content when a trigger element is activated.
/// Positioning is handled by floating-ui and interactivity by Alpine.js.
/// </summary>
public partial class RzPopover : RzComponent<RzPopover.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzPopover component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative inline-block text-left"
    );
    /// <summary>
    /// Gets or sets the content of the popover, which should include a <see cref="PopoverTrigger"/>
    /// and a <see cref="PopoverContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the preferred position of the popover relative to the trigger.
    /// Defaults to <see cref="AnchorPoint.BottomStart"/>.
    /// </summary>
    [Parameter]
    public AnchorPoint Anchor { get; set; } = AnchorPoint.BottomStart;
    /// <summary>
    /// Gets or sets the main axis offset in pixels from the anchor point.
    /// Defaults to 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;
    /// <summary>
    /// Gets or sets the cross-axis offset in pixels from the anchor point.
    /// Defaults to 0.
    /// </summary>
    [Parameter]
    public int CrossAxisOffset { get; set; } = 0;
    /// <summary>
    /// Gets or sets the alignment axis offset in pixels from the anchor point.
    /// Defaults to 0.
    /// </summary>
    [Parameter]
    public int AlignmentAxisOffset { get; set; } = 0;
    /// <summary>
    /// Gets or sets the positioning strategy for the popover ('absolute' or 'fixed').
    /// Defaults to <see cref="AnchorStrategy.Absolute"/>.
    /// </summary>
    [Parameter]
    public AnchorStrategy Strategy { get; set; } = AnchorStrategy.Absolute;
    /// <summary>
    /// Gets or sets whether to enable the 'flip' middleware, which flips the popover to the opposite side to keep it in view.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool EnableFlip { get; set; } = true;
    /// <summary>
    /// Gets or sets whether to enable the 'shift' middleware, which shifts the popover along the axes to keep it in view.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool EnableShift { get; set; } = true;
    /// <summary>
    /// Gets or sets the padding (in pixels) between the popover and the edge of the viewport when shifting.
    /// Defaults to 8.
    /// </summary>
    [Parameter]
    public int ShiftPadding { get; set; } = 8;
    /// <summary>
    /// Gets or sets the ARIA label for the popover container, providing an accessible name.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzPopover.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzPopover.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzPopover;
    /// <summary>
    /// Defines the slots available for styling in the RzPopover component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/RzSheet.razor">
@namespace RizzyUI
@inherits RzComponent<RzSheet.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement" 
                 @attributes="AdditionalAttributes" 
                 id="@Id" 
                 class="@SlotClasses.GetBase()"
                 data-slot="sheet"
                 x-data="rzSheet"
                 data-alpine-root="@Id"
                 data-default-open="@DefaultOpen.ToString().ToLowerInvariant()">
        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Feedback/RzSheet/RzSheet.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A root component that manages the state for a sheet panel that slides in from the edge of the screen.
/// It provides context for its child components like <see cref="SheetTrigger"/> and <see cref="SheetContent"/>.
/// </summary>
public partial class RzSheet : RzComponent<RzSheet.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSheet component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "contents"
    );
    /// <summary>
    /// Gets or sets the content of the sheet, which should include a <see cref="SheetTrigger"/>
    /// and a <see cref="SheetContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the initial open state of the sheet. This is an uncontrolled property.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSheet;
    /// <summary>
    /// Defines the slots available for styling in the RzSheet component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetClose.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<SheetClose.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Feedback/RzSheet/SheetClose.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive element that closes its parent <see cref="RzSheet"/>.
/// It can be rendered as a button or merge its behavior into a child element.
/// </summary>
public partial class SheetClose : RzAsChildComponent<SheetClose.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetClose component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzSheet"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzSheet? ParentSheet { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSheet == null)
        {
            throw new InvalidOperationException($"{nameof(SheetClose)} must be used within an {nameof(RzSheet)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["x-on:click"] = "close",
            ["data-slot"] = "sheet-close"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.SheetClose;
    /// <summary>
    /// Defines the slots available for styling in the SheetClose component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetContent.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<SheetContent.Slots>

<template x-teleport="body">
	<div x-show="open" x-cloak>
		<div class="@SlotClasses.GetOverlay()" 
             x-on:click="close" 
             x-bind:data-state="state"
		     x-transition:enter="ease-in-out duration-500"
		     x-transition:enter-start="opacity-0"
		     x-transition:enter-end="opacity-100"
		     x-transition:leave="ease-in-out duration-300"
		     x-transition:leave-start="opacity-100"
		     x-transition:leave-end="opacity-0"></div>
		<div @attributes="AdditionalAttributes"
		     id="@Id"
		     class="@SlotClasses.GetBase()"
		     data-slot="sheet-content"
		     x-trap.inert="open"
		     x-bind:data-state="state"
             x-transition:enter="transition ease-in-out duration-500"
             x-transition:leave="transition ease-in-out duration-300">
			@ChildContent
			<button type="button" class="@SlotClasses.GetCloseButton()" x-on:click="close">
				<Blazicon Svg="Lucide.X" class="@SlotClasses.GetCloseButtonIcon()" />
				<span class="sr-only">@Localizer["RzSheet.CloseButtonText"]</span>
			</button>
		</div>
	</div>
</template>
</file>

<file path="Components/Feedback/RzSheet/SheetContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The main panel of the sheet that slides into view. It contains the sheet's content,
/// header, and footer, along with a default close button.
/// </summary>
public partial class SheetContent : RzComponent<SheetContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "fixed z-50 flex flex-col gap-4 bg-background shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out",
        slots: new()
        {
            [s => s.Overlay] = "fixed inset-0 z-50 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
            [s => s.CloseButton] = "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-none disabled:pointer-events-none",
            [s => s.CloseButtonIcon] = "size-4"
        },
        variants: new()
        {
            [c => ((SheetContent)c).Side] = new Variant<SheetSide, Slots>
            {
                [SheetSide.Top] = new() { [s => s.Base] = "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top" },
                [SheetSide.Bottom] = new() { [s => s.Base] = "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom" },
                [SheetSide.Left] = new() { [s => s.Base] = "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm" },
                [SheetSide.Right] = new() { [s => s.Base] = "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm" }
            }
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzSheet"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzSheet? ParentSheet { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the sheet panel. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the side from which the sheet will appear.
    /// Defaults to <see cref="SheetSide.Right"/>.
    /// </summary>
    [Parameter]
    public SheetSide Side { get; set; } = SheetSide.Right;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSheet == null)
        {
            throw new InvalidOperationException($"{nameof(SheetContent)} must be used within an {nameof(RzSheet)}.");
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SheetContent;
    /// <summary>
    /// Defines the slots available for styling in the SheetContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main sheet panel.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the backdrop overlay.
        /// </summary>
        public string? Overlay { get; set; }
        /// <summary>
        /// The slot for the close button.
        /// </summary>
        public string? CloseButton { get; set; }
        /// <summary>
        /// The slot for the icon inside the close button.
        /// </summary>
        public string? CloseButtonIcon { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetDescription.razor">
@namespace RizzyUI
@inherits RzComponent<SheetDescription.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sheet-description">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzSheet/SheetDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying descriptive text within a <see cref="SheetHeader"/>.
/// </summary>
public partial class SheetDescription : RzComponent<SheetDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-sm text-muted-foreground"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the description.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "p";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SheetDescription;
    /// <summary>
    /// Defines the slots available for styling in the SheetDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetFooter.razor">
@namespace RizzyUI
@inherits RzComponent<SheetFooter.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sheet-footer">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzSheet/SheetFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the footer content of a <see cref="SheetContent"/>, typically aligned to the bottom.
/// </summary>
public partial class SheetFooter : RzComponent<SheetFooter.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetFooter component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "mt-auto flex flex-col gap-2 p-6"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the footer.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "footer";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SheetFooter;
    /// <summary>
    /// Defines the slots available for styling in the SheetFooter component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetHeader.razor">
@namespace RizzyUI
@inherits RzComponent<SheetHeader.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sheet-header">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzSheet/SheetHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the header content of a <see cref="SheetContent"/>, typically containing a <see cref="SheetTitle"/> and <see cref="SheetDescription"/>.
/// </summary>
public partial class SheetHeader : RzComponent<SheetHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col gap-1.5 p-6 text-center sm:text-left"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the header.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SheetHeader;
    /// <summary>
    /// Defines the slots available for styling in the SheetHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetSide.cs">
// src/RizzyUI/Components/Feedback/RzSheet/SheetSide.cs
namespace RizzyUI;
/// <summary>
/// Specifies the side from which the Sheet component will appear.
/// </summary>
public enum SheetSide
{
    /// <summary>
    /// The sheet appears from the top of the viewport.
    /// </summary>
    Top,
    /// <summary>
    /// The sheet appears from the right of the viewport.
    /// </summary>
    Right,
    /// <summary>
    /// The sheet appears from the bottom of the viewport.
    /// </summary>
    Bottom,
    /// <summary>
    /// The sheet appears from the left of the viewport.
    /// </summary>
    Left
}
</file>

<file path="Components/Feedback/RzSheet/SheetTitle.razor">
@namespace RizzyUI
@inherits RzComponent<SheetTitle.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sheet-title">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzSheet/SheetTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the title within a <see cref="SheetHeader"/>.
/// </summary>
public partial class SheetTitle : RzComponent<SheetTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-lg font-semibold text-foreground"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the title.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "h2";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SheetTitle;
    /// <summary>
    /// Defines the slots available for styling in the SheetTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSheet/SheetTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<SheetTrigger.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Feedback/RzSheet/SheetTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive element that opens its parent <see cref="RzSheet"/>.
/// It can be rendered as a button or merge its behavior into a child element.
/// </summary>
public partial class SheetTrigger : RzAsChildComponent<SheetTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the SheetTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzSheet"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzSheet? ParentSheet { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSheet == null)
        {
            throw new InvalidOperationException($"{nameof(SheetTrigger)} must be used within an {nameof(RzSheet)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["x-on:click"] = "show",
            ["data-slot"] = "sheet-trigger"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.SheetTrigger;
    /// <summary>
    /// Defines the slots available for styling in the SheetTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Feedback/RzSpinner/RzSpinner.razor">
@namespace RizzyUI
@inherits RzComponent<RzSpinner.Slots>

<HtmlElement Element="div" @attributes="AdditionalAttributes" id="@Id">
	<svg xmlns="http://www.w3.org/2000/svg"
	     viewBox="0 0 24 24"
	     aria-hidden="true"
	     role="status"
	     aria-label="@AriaLabel"
	     class="@SlotClasses.GetBase()">
		<path d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25" />
		<path d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z" />
	</svg>	
</HtmlElement>
</file>

<file path="Components/Feedback/RzSpinner/RzSpinner.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
/// Renders an SVG spinning animation to indicate loading or processing.
/// Styling (size and color) is determined by parameters and the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSpinner : RzComponent<RzSpinner.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSpinner component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "motion-safe:animate-spin",
        variants: new()
        {
            [s => ((RzSpinner)s).Size] = new Variant<Size, Slots>
            {
                [Size.ExtraSmall] = "size-4",
                [Size.Small] = "size-5",
                [Size.Medium] = "size-6",
                [Size.Large] = "size-7",
                [Size.ExtraLarge] = "size-8"
            },
            [s => ((RzSpinner)s).Color] = new Variant<SemanticColor, Slots>
            {
                [SemanticColor.None] = "fill-foreground",
                [SemanticColor.Primary] = "fill-primary",
                [SemanticColor.Secondary] = "fill-secondary",
                [SemanticColor.Success] = "fill-success",
                [SemanticColor.Info] = "fill-info",
                [SemanticColor.Warning] = "fill-warning",
                [SemanticColor.Destructive] = "fill-destructive",
                // Add other semantic colors as needed
            }
        }
    );
    /// <summary>
    /// Gets or sets the size of the spinner.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets the semantic color of the spinner.
    /// Defaults to <see cref="SemanticColor.None"/>, which results in the theme's default 'Foreground' fill color being used.
    /// </summary>
    [Parameter]
    public SemanticColor Color { get; set; } = SemanticColor.None;
    /// <summary>
    /// Gets or sets the accessible label for the spinner, describing what is loading.
    /// Defaults to a localized "Loading...".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzSpinner.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSpinner.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSpinner;
    /// <summary>
    /// Defines the slots available for styling in the RzSpinner component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/_Imports.razor">
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using Rizzy.Configuration;
@using Rizzy.Components
</file>

<file path="Components/Form/Enum/Orientation.cs">
namespace RizzyUI;
/// <summary>
///     Specifies the layout orientation for components or form fields.
///     This enum is used to define whether elements should be arranged horizontally or vertically.
/// </summary>
public enum Orientation
{
    /// <summary>
    ///     Indicates that elements should be arranged in a horizontal layout.
    /// </summary>
    Horizontal,
    /// <summary>
    ///     Indicates that elements should be arranged in a vertical layout.
    /// </summary>
    Vertical
}
</file>

<file path="Components/Form/Enum/SectionLayout.cs">
namespace RizzyUI;
/// <summary>
///     Layout for section
/// </summary>
public enum SectionLayout
{
    /// <summary>
    ///     Title and description appear in a format stacked on top of form
    /// </summary>
    Stacked,
    /// <summary>
    ///     Title and description appear in a left column with form on right
    /// </summary>
    TwoColumn
}
</file>

<file path="Components/Form/Enum/TextRole.cs">
namespace RizzyUI;
/// <summary>
///     Specifies the semantic role of a text input field within a form. This enumeration determines the behavior and
///     styling
///     applied to text inputs, such as standard text, password, email, URL, search, or telephone inputs.
/// </summary>
public enum TextRole
{
    /// <summary>
    ///     Represents a standard text input field.
    /// </summary>
    Text,
    /// <summary>
    ///     Represents a password input field, which obscures user input for privacy.
    /// </summary>
    Password,
    /// <summary>
    ///     Represents an email input field, optimized for entering email addresses.
    /// </summary>
    Email,
    /// <summary>
    ///     Represents a URL input field, optimized for entering web addresses.
    /// </summary>
    Url,
    /// <summary>
    ///     Represents a search input field, typically styled for search functionality.
    /// </summary>
    Search,
    /// <summary>
    ///     Represents a telephone input field, optimized for entering phone numbers.
    /// </summary>
    Tel
}
</file>

<file path="Components/Form/Field/Field.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<FieldSlots>

<HtmlElement Element="@EffectiveElement" 
             role="group" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field"
             data-orientation="@Orientation.ToString().ToKebabCase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/Field.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A layout component for a single form field, controlling the orientation of its parts (label, content, description).
/// </summary>
public partial class Field : RzComponent<FieldSlots>, IHasFieldStylingProperties
{
    /// <summary>
    /// Gets or sets the content of the field, typically a `FieldLabel`, `FieldContent`, and `FieldDescription`.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the layout orientation of the field's children.
    /// Defaults to <see cref="FieldOrientation.Vertical"/>.
    /// </summary>
    [Parameter]
    public FieldOrientation Orientation { get; set; } = FieldOrientation.Vertical;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<FieldSlots>, FieldSlots> GetDescriptor() => Theme.Field;
}
/// <summary>
/// Specifies the layout orientation for a Field component.
/// </summary>
public enum FieldOrientation
{
    /// <summary>
    /// Arranges field elements vertically.
    /// </summary>
    Vertical,
    /// <summary>
    /// Arranges field elements horizontally.
    /// </summary>
    Horizontal,
    /// <summary>
    /// Arranges field elements vertically on small screens and horizontally on larger screens.
    /// </summary>
    Responsive
}
</file>

<file path="Components/Form/Field/FieldContent.razor">
@namespace RizzyUI
@inherits RzComponent<FieldContent.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/FieldContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the main input control within a `Field`, such as an input, select, or textarea.
/// </summary>
public partial class FieldContent : RzComponent<FieldContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/field-content flex flex-1 flex-col gap-1.5 leading-snug"
    );
    /// <summary>
    /// Gets or sets the content to be rendered, typically a form input control.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldContent;
    /// <summary>
    /// Defines the slots available for styling in the FieldContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-content")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/FieldDescription.razor">
@namespace RizzyUI
@inherits RzComponent<FieldDescription.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-description">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/FieldDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying additional, descriptive text for a form field.
/// </summary>
public partial class FieldDescription : RzComponent<FieldDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5 [&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the description.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldDescription;
    /// <summary>
    /// Defines the slots available for styling in the FieldDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-description")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/FieldError.razor">
@namespace RizzyUI
@inherits RzComponent<FieldError.Slots>

@if (Content is not null)
{
    <HtmlElement Element="@EffectiveElement" 
                 role="alert" 
                 @attributes="AdditionalAttributes" 
                 id="@Id" 
                 class="@SlotClasses.GetBase()" 
                 data-slot="field-error">
        @Content
    </HtmlElement>
}
</file>

<file path="Components/Form/Field/FieldError.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying validation error messages for a form field.
/// </summary>
public partial class FieldError : RzComponent<FieldError.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldError component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-destructive text-sm font-normal"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the error message container.
    /// If provided, this will be used instead of processing the `Errors` collection.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets a collection of error messages to display.
    /// If more than one unique error message is provided, they will be rendered as an unordered list.
    /// </summary>
    [Parameter]
    public IEnumerable<string>? Errors { get; set; }
    /// <summary>
    /// Gets the final renderable content for the error message(s).
    /// </summary>
    protected RenderFragment? Content { get; private set; }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        BuildContent();
    }
    private void BuildContent()
    {
        if (ChildContent is not null)
        {
            Content = ChildContent;
            return;
        }
        var uniqueErrors = Errors?.Where(e => !string.IsNullOrWhiteSpace(e)).Distinct().ToList();
        if (uniqueErrors is null || uniqueErrors.Count == 0)
        {
            Content = null;
            return;
        }
        if (uniqueErrors.Count == 1)
        {
            Content = builder => builder.AddContent(0, uniqueErrors[0]);
        }
        else
        {
            Content = builder =>
            {
                builder.OpenElement(0, "ul");
                builder.AddAttribute(1, "class", "ml-4 flex list-disc flex-col gap-1");
                for (int i = 0; i < uniqueErrors.Count; i++)
                {
                    builder.OpenElement(2, "li");
                    builder.AddContent(3, uniqueErrors[i]);
                    builder.CloseElement();
                }
                builder.CloseElement();
            };
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldError;
    /// <summary>
    /// Defines the slots available for styling in the FieldError component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-error")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/FieldLabel.razor">
@namespace RizzyUI
@inherits RzComponent<FieldLabelSlots>
@typeparam TValue

<label for="@_for" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="field-label">
    @if (ChildContent != null)
    {
        @ChildContent
    }
    else if (!string.IsNullOrEmpty(_effectiveDisplayName))
    {
        @_effectiveDisplayName        
    }
</label>
</file>

<file path="Components/Form/Field/FieldLabel.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.AspNetCore.Http;
using Rizzy.Htmx;
using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using System.Reflection;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the label for a form field, with support for automatically inferring the text and `for` attribute from a model expression.
/// </summary>
public partial class FieldLabel<TValue> : RzComponent<FieldLabelSlots>, IHasFieldLabelStylingProperties
{
    private string? _effectiveDisplayName;
    private string _for = string.Empty;
    [CascadingParameter] private HttpContext? HttpContext { get; set; }
    [CascadingParameter] private EditContext? EditContext { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the label. If set, this will be rendered instead of any text inferred from `DisplayName` or `For`.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the expression that identifies the bound value, used to determine the `for` attribute and infer the display name.
    /// </summary>
    [Parameter]
    public Expression<Func<TValue>>? For { get; set; }
    /// <summary>
    /// Gets or sets the display name for the label. If not set, it's inferred from the `For` expression's `DisplayAttribute` or property name.
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "label";
        if (EditContext == null && For != null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm when using the 'For' parameter.");
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        SetEffectiveDisplayName();
        SetForAttribute();
        base.OnParametersSet();
    }
    private void SetEffectiveDisplayName()
    {
        if (!string.IsNullOrEmpty(DisplayName))
        {
            _effectiveDisplayName = DisplayName;
            return;
        }
        if (For == null)
        {
            _effectiveDisplayName = null;
            return;
        }
        if (For.Body is MemberExpression memberExpression)
        {
            var displayAttribute = memberExpression.Member.GetCustomAttribute<DisplayAttribute>(true);
            _effectiveDisplayName = displayAttribute?.GetName() ?? memberExpression.Member.Name;
        }
        else
        {
            _effectiveDisplayName = For.ToString();
        }
    }
    private void SetForAttribute()
    {
        _for = string.Empty;
        if (For != null && HttpContext != null && EditContext != null)
        {
            try
            {
                var field = FieldIdentifier.Create(For);
                var fieldMap = HttpContext.GetOrAddFieldMapping(EditContext);
                if (fieldMap != null && fieldMap.TryGetValue(field, out var map) && map != null)
                    _for = map.Id;
            }
            catch (ArgumentException)
            {
                // Handle cases where For expression is not suitable for FieldIdentifier
            }
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<FieldLabelSlots>, FieldLabelSlots> GetDescriptor() => Theme.FieldLabel;
}
</file>

<file path="Components/Form/Field/FieldLegend.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<FieldLegend.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-legend"
             data-variant="@Variant.ToString().ToKebabCase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/FieldLegend.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the legend for a `RzFieldSet`, providing a caption for the grouped fields.
/// </summary>
public partial class FieldLegend : RzComponent<FieldLegend.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldLegend component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "mb-3 font-medium",
        variants: new()
        {
            [c => ((FieldLegend)c).Variant] = new Variant<FieldLegendVariant, Slots>
            {
                [FieldLegendVariant.Legend] = "text-base",
                [FieldLegendVariant.Label] = "text-sm"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the legend.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the visual variant of the legend, affecting its text size.
    /// Defaults to <see cref="FieldLegendVariant.Legend"/>.
    /// </summary>
    [Parameter]
    public FieldLegendVariant Variant { get; set; } = FieldLegendVariant.Legend;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "legend";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldLegend;
    /// <summary>
    /// Defines the slots available for styling in the FieldLegend component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-legend")]
        public string? Base { get; set; }
    }
}
/// <summary>
/// Specifies the visual variant for a FieldLegend.
/// </summary>
public enum FieldLegendVariant
{
    /// <summary>
    /// Standard legend styling with base text size.
    /// </summary>
    Legend,
    /// <summary>
    /// Label-like styling with smaller text size.
    /// </summary>
    Label
}
</file>

<file path="Components/Form/Field/FieldSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<FieldSeparator.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-separator"
             data-content="@(ChildContent != null)">
    <RzSeparator class="@SlotClasses.GetSeparator()" />
    @if (ChildContent != null)
    {
        <span class="@SlotClasses.GetContent()" data-slot="field-separator-content">
            @ChildContent
        </span>
    }
</HtmlElement>
</file>

<file path="Components/Form/Field/FieldSeparator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A visual separator for use within a `RzFieldGroup`, which can optionally contain text.
/// </summary>
public partial class FieldSeparator : RzComponent<FieldSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2",
        slots: new()
        {
            [s => s.Separator] = "absolute inset-0 top-1/2",
            [s => s.Content] = "bg-background text-muted-foreground relative mx-auto block w-fit px-2"
        }
    );
    /// <summary>
    /// Gets or sets the optional content to be rendered in the middle of the separator line.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldSeparator;
    /// <summary>
    /// Defines the slots available for styling in the FieldSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-separator")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the separator line.
        /// </summary>
        [Slot("separator")]
        public string? Separator { get; set; }
        /// <summary>
        /// The slot for the content span.
        /// </summary>
        [Slot("content")]
        public string? Content { get; set; }
    }
}
</file>

<file path="Components/Form/Field/FieldTitle.razor">
@namespace RizzyUI
@inherits RzComponent<FieldTitle.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-label">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/FieldTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the title or label text for a field, styled as a `div`.
/// </summary>
public partial class FieldTitle : RzComponent<FieldTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the FieldTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the title.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldTitle;
    /// <summary>
    /// Defines the slots available for styling in the FieldTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-label")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/RzFieldGroup.razor">
@namespace RizzyUI
@inherits RzComponent<RzFieldGroup.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-group">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/RzFieldGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for grouping multiple `Field` components together, providing consistent spacing.
/// </summary>
public partial class RzFieldGroup : RzComponent<RzFieldGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzFieldGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the group, typically one or more `Field` components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.FieldGroup;
    /// <summary>
    /// Defines the slots available for styling in the RzFieldGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-group")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/RzFieldSet.razor">
@namespace RizzyUI
@inherits RzComponent<RzFieldSet.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="field-set">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Field/RzFieldSet.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that groups a set of related form fields, typically within a form. It renders as a `fieldset` element.
/// </summary>
public partial class RzFieldSet : RzComponent<RzFieldSet.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzFieldSet component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col gap-6 has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the fieldset, which can include a `FieldLegend` and multiple `RzFieldGroup` or `Field` components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "fieldset";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzFieldSet;
    /// <summary>
    /// Defines the slots available for styling in the RzFieldSet component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("field-set")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Field/Styling/FieldLabelStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a FieldLabel component.
/// </summary>
public interface IHasFieldLabelStylingProperties { }
/// <summary>
/// Defines the slots available for styling in the FieldLabel component.
/// </summary>
public sealed partial class FieldLabelSlots : ISlots
{
    /// <summary>
    /// The base slot for the component's root element.
    /// </summary>
    [Slot("field-label")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the FieldLabel component.
/// </summary>
public static class FieldLabelStyles
{
    /// <summary>
    /// The default TvDescriptor for the FieldLabel component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<FieldLabelSlots>, FieldLabelSlots> DefaultDescriptor = new(
        @base: "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
    );
}
</file>

<file path="Components/Form/Field/Styling/FieldStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a Field component.
/// </summary>
public interface IHasFieldStylingProperties
{
    /// <summary>
    /// Gets the orientation of the field.
    /// </summary>
    public FieldOrientation Orientation { get; }
}
/// <summary>
/// Defines the slots available for styling in the Field component.
/// </summary>
public sealed partial class FieldSlots : ISlots
{
    /// <summary>
    /// The base slot for the main field container.
    /// </summary>
    [Slot("field")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the Field component.
/// </summary>
public static class FieldStyles
{
    /// <summary>
    /// The default TvDescriptor for the Field component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<FieldSlots>, FieldSlots> DefaultDescriptor = new(
        @base: "group/field flex w-full gap-3 data-[invalid=true]:text-destructive",
        variants: new()
        {
            [c => ((IHasFieldStylingProperties)c).Orientation] = new Variant<FieldOrientation, FieldSlots>
            {
                [FieldOrientation.Vertical] = "flex-col [&>*]:w-full [&>.sr-only]:w-auto",
                [FieldOrientation.Horizontal] = "flex-row items-center [&>[data-slot=field-label]]:flex-auto has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px",
                [FieldOrientation.Responsive] = "flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto @md/field-group:[&>[data-slot=field-label]]:flex-auto @md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px"
            }
        }
    );
}
</file>

<file path="Components/Form/InputBase.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
public abstract partial class InputBase<TValue, TSlots> : RzComponent<TSlots>
    where TSlots : ISlots, new()
{
    [Parameter, EditorRequired]
    public required Expression<Func<TValue>> For { get; set; }
    [Parameter]
    public TValue? Value { get; set; }
    [Parameter]
    public string? DisplayName { get; set; }
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    private FieldIdentifier _fieldIdentifier;
    protected bool IsInvalid => EditContext?.GetValidationMessages(_fieldIdentifier).Any() ?? false;
    protected Dictionary<string, object?> InputAttributes
    {
        get
        {
            var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase);
            if (IsInvalid)
            {
                attributes["aria-invalid"] = "true";
            }
            return attributes;
        }
    }
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
    }
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (For != null)
        {
            _fieldIdentifier = FieldIdentifier.Create(For);
        }
    }
}
</file>

<file path="Components/Form/InputGroup/InputGroupAddon.razor">
@namespace RizzyUI
@inherits RzComponent<InputGroupAddonSlots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="input-group-addon"
             role="group"
             data-align="@Align.ToString().ToKebabCase()"
             x-data="rzInputGroupAddon"
             x-on:click="handleClick">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/InputGroup/InputGroupAddon.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for prepending or appending content to an input within an `RzInputGroup`.
/// </summary>
public partial class InputGroupAddon : RzComponent<InputGroupAddonSlots>, IHasInputGroupAddonStylingProperties
{
    private string _effectiveInpoutGroupAddonAlign = "inline-start";
    /// <summary>
    /// Gets or sets the content to be rendered inside the addon.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the alignment and position of the addon relative to the input.
    /// Defaults to <see cref="InputGroupAddonAlign.InlineStart"/>.
    /// </summary>
    [Parameter]
    public InputGroupAddonAlign Align { get; set; } = InputGroupAddonAlign.InlineStart;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "div";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<InputGroupAddonSlots>, InputGroupAddonSlots> GetDescriptor() => Theme.InputGroupAddon;
}
/// <summary>
/// Specifies the alignment for an InputGroupAddon.
/// </summary>
public enum InputGroupAddonAlign
{
    /// <summary>
    /// Aligned to the start of the input, inside the border.
    /// </summary>
    InlineStart,
    /// <summary>
    /// Aligned to the end of the input, inside the border.
    /// </summary>
    InlineEnd,
    /// <summary>
    /// Aligned above the input.
    /// </summary>
    BlockStart,
    /// <summary>
    /// Aligned below the input.
    /// </summary>
    BlockEnd
}
</file>

<file path="Components/Form/InputGroup/InputGroupButton.razor">
@namespace RizzyUI
@inherits RzComponent<InputGroupButtonSlots>

<RzButton @attributes="AdditionalAttributes"
          Id="@Id"
          Variant="@Variant"
          Outline=@Outline
          class="@SlotClasses.GetBase()"
          data-slot="input-group-button"
          data-size="@Size.ToString().ToLowerInvariant()">
    @ChildContent
</RzButton>
</file>

<file path="Components/Form/InputGroup/InputGroupButton.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A button specifically styled for use within an `InputGroupAddon`.
/// </summary>
public partial class InputGroupButton : RzComponent<InputGroupButtonSlots>, IHasInputGroupButtonStylingProperties
{
    /// <summary>
    /// Gets or sets the content to be rendered inside the button.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the visual style variant of the button.
    /// Defaults to <see cref="ThemeVariant.Ghost"/>.
    /// </summary>
    [Parameter]
    public ThemeVariant Variant { get; set; } = ThemeVariant.Ghost;
    /// <summary>
    /// Gets or sets a value indicating whether the button should have an outline style. Defaults to false.
    /// </summary>
    [Parameter]
    public bool Outline { get; set; }
    /// <summary>
    /// Gets or sets the size of the button, specific to the input group context.
    /// Defaults to <see cref="InputGroupButtonSize.ExtraSmall"/>.
    /// </summary>
    [Parameter]
    public InputGroupButtonSize Size { get; set; } = InputGroupButtonSize.ExtraSmall;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<InputGroupButtonSlots>, InputGroupButtonSlots> GetDescriptor() => Theme.InputGroupButton;
}
/// <summary>
/// Specifies the size for an InputGroupButton.
/// </summary>
public enum InputGroupButtonSize
{
    /// <summary>
    /// Extra small button size.
    /// </summary>
    ExtraSmall,
    /// <summary>
    /// Small button size.
    /// </summary>
    Small,
    /// <summary>
    /// Extra small icon-only button size.
    /// </summary>
    IconExtraSmall,
    /// <summary>
    /// Small icon-only button size.
    /// </summary>
    IconSmall
}
</file>

<file path="Components/Form/InputGroup/InputGroupInput.razor">
@namespace RizzyUI
@using Rizzy.Components
@using Rizzy
@inherits RzComponent<InputGroupInput.Slots>

<RzInputText @attributes="AdditionalAttributes" 
             For="@For" 
             class="@SlotClasses.GetBase()" 
             data-slot="input-group-control" />
</file>

<file path="Components/Form/InputGroup/InputGroupInput.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A styled text input for use within an `RzInputGroup`, inheriting from `RzInputText`.
/// </summary>
public partial class InputGroupInput : RzComponent<InputGroupInput.Slots>
{
    /// <summary>
    /// Defines the default styling for the InputGroupInput component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex-1 rounded-none border-0 bg-transparent shadow-none focus-visible:ring-0 dark:bg-transparent"
    );
    /// <summary>
    /// Gets or sets the expression that identifies the bound value. This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired]
    public Expression<Func<string>> For { get; set; } = default!;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.InputGroupInput;
    /// <summary>
    /// Defines the slots available for styling in the InputGroupInput component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("input-group-input")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/InputGroup/InputGroupText.razor">
@namespace RizzyUI
@inherits RzComponent<InputGroupText.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="input-group-text">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/InputGroup/InputGroupText.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying plain text or icons within an `InputGroupAddon`.
/// </summary>
public partial class InputGroupText : RzComponent<InputGroupText.Slots>
{
    /// <summary>
    /// Defines the default styling for the InputGroupText component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground flex items-center gap-2 text-sm [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered, typically text or an icon.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "span";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.InputGroupText;
    /// <summary>
    /// Defines the slots available for styling in the InputGroupText component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("input-group-text")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/InputGroup/InputGroupTextarea.razor">
@namespace RizzyUI
@using Rizzy.Components
@using Rizzy
@inherits RzComponent<InputGroupTextarea.Slots>

<RzInputTextArea @attributes="AdditionalAttributes" 
                 For="@For" 
                 class="@SlotClasses.GetBase()" 
                 data-slot="input-group-control" />
</file>

<file path="Components/Form/InputGroup/InputGroupTextarea.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A styled textarea for use within an `RzInputGroup`, inheriting from `RzInputTextArea`.
/// </summary>
public partial class InputGroupTextarea : RzComponent<InputGroupTextarea.Slots>
{
    /// <summary>
    /// Defines the default styling for the InputGroupTextarea component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex-1 w-full resize-none rounded-none border-0 bg-transparent py-3 shadow-none focus-visible:ring-0 dark:bg-transparent"
    );
    /// <summary>
    /// Gets or sets the expression that identifies the bound value. This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired]
    public Expression<Func<string>> For { get; set; } = default!;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.InputGroupTextarea;
    /// <summary>
    /// Defines the slots available for styling in the InputGroupTextarea component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("input-group-textarea")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/InputGroup/RzInputGroup.razor">
@namespace RizzyUI
@inherits RzComponent<RzInputGroup.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="input-group"
             role="group">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/InputGroup/RzInputGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container that groups an input with addons like text, icons, or buttons.
/// </summary>
public partial class RzInputGroup : RzComponent<RzInputGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzInputGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/input-group border-input dark:bg-input/30 relative flex w-full items-center rounded-md border shadow-xs transition-[color,box-shadow] outline-none h-9 min-w-0 has-[>textarea]:h-auto has-[>[data-align=inline-start]]:[&>input]:pl-2 has-[>[data-align=inline-end]]:[&>input]:pr-2 has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3 has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3 has-[[data-slot=input-group-control]:focus-visible]:border-ring has-[[data-slot=input-group-control]:focus-visible]:ring-ring/50 has-[[data-slot=input-group-control]:focus-visible]:ring-[3px] has-[[data-slot][aria-invalid=true]]:ring-destructive/20 has-[[data-slot][aria-invalid=true]]:border-destructive dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the input group.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "div";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzInputGroup;
    /// <summary>
    /// Defines the slots available for styling in the RzInputGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("input-group")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/InputGroup/Styling/InputGroupAddonStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for an InputGroupAddon component.
/// </summary>
public interface IHasInputGroupAddonStylingProperties
{
    /// <summary>
    /// Gets the alignment of the addon.
    /// </summary>
    public InputGroupAddonAlign Align { get; }
}
/// <summary>
/// Defines the slots available for styling in the InputGroupAddon component.
/// </summary>
public sealed partial class InputGroupAddonSlots : ISlots
{
    /// <summary>
    /// The base slot for the main addon container.
    /// </summary>
    [Slot("input-group-addon")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the InputGroupAddon component.
/// </summary>
public static class InputGroupAddonStyles
{
    /// <summary>
    /// The default TvDescriptor for the InputGroupAddon component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<InputGroupAddonSlots>, InputGroupAddonSlots> DefaultDescriptor = new(
        @base: "text-muted-foreground flex h-auto cursor-text items-center justify-center gap-2 py-1.5 text-sm font-medium select-none [&>svg:not([class*='size-'])]:size-4 [&>kbd]:rounded-[calc(var(--radius)-5px)] group-data-[disabled=true]/input-group:opacity-50",
        variants: new()
        {
            [c => ((IHasInputGroupAddonStylingProperties)c).Align] = new Variant<InputGroupAddonAlign, InputGroupAddonSlots>
            {
                [InputGroupAddonAlign.InlineStart] = "order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]",
                [InputGroupAddonAlign.InlineEnd] = "order-last pr-3 has-[>button]:mr-[-0.45rem] has-[>kbd]:mr-[-0.35rem]",
                [InputGroupAddonAlign.BlockStart] = "order-first w-full justify-start px-3 pt-3 [.border-b]:pb-3 group-has-[>input]/input-group:pt-2.5",
                [InputGroupAddonAlign.BlockEnd] = "order-last w-full justify-start px-3 pb-3 [.border-t]:pt-3 group-has-[>input]/input-group:pb-2.5"
            }
        }
    );
}
</file>

<file path="Components/Form/InputGroup/Styling/InputGroupButtonStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for an InputGroupButton component.
/// </summary>
public interface IHasInputGroupButtonStylingProperties
{
    /// <summary>
    /// Gets the size of the button.
    /// </summary>
    public InputGroupButtonSize Size { get; }
}
/// <summary>
/// Defines the slots available for styling in the InputGroupButton component.
/// </summary>
public sealed partial class InputGroupButtonSlots : ISlots
{
    /// <summary>
    /// The base slot for the button element.
    /// </summary>
    [Slot("input-group-button")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the InputGroupButton component.
/// </summary>
public static class InputGroupButtonStyles
{
    /// <summary>
    /// The default TvDescriptor for the InputGroupButton component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<InputGroupButtonSlots>, InputGroupButtonSlots> DefaultDescriptor = new(
        @base: "text-sm shadow-none flex gap-2 items-center",
        variants: new()
        {
            [c => ((IHasInputGroupButtonStylingProperties)c).Size] = new Variant<InputGroupButtonSize, InputGroupButtonSlots>
            {
                [InputGroupButtonSize.ExtraSmall] = "h-6 gap-1 px-2 rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-3.5 has-[>svg]:px-2",
                [InputGroupButtonSize.Small] = "h-8 px-2.5 gap-1.5 rounded-md has-[>svg]:px-2.5",
                [InputGroupButtonSize.IconExtraSmall] = "size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0",
                [InputGroupButtonSize.IconSmall] = "size-8 p-0 has-[>svg]:p-0"
            }
        }
    );
}
</file>

<file path="Components/Form/Label/Label.razor">
@namespace RizzyUI
@inherits RzComponent<Label.Slots>

<HtmlElement Element="@EffectiveElement"
             id="@Id"
             for="@For"
             class="@SlotClasses.GetBase()"
             data-slot="label"
             @attributes="@AdditionalAttributes">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/Label/Label.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that renders a &lt;label> element with styling for form inputs, enhancing accessibility and consistency.
/// </summary>
public partial class Label : RzComponent<Label.Slots>
{
    /// <summary>
    /// Defines the default styling for the Label component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the label.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the `for` attribute of the label, which should match the `id` of a form control.
    /// </summary>
    [Parameter]
    public string? For { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "label";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.Label;
    /// <summary>
    /// Defines the slots available for styling in the Label component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("label")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/Models/CalendarOptions.cs">
#nullable enable
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
namespace RizzyUI;
// --- Enums for All Discrete Options ---
/// <summary>
/// Defines the type of calendar to display.
/// </summary>
[JsonConverter(typeof(CamelCaseEnumValueConverter<CalendarType>))]
public enum CalendarType
{
    /// <summary>Displays a single month view. This is the default calendar type.</summary>
    Default,
    /// <summary>Displays multiple months side-by-side, allowing for broader date selection.</summary>
    Multiple,
    /// <summary>Displays a view to select a month within a year, hiding the day-to-day view.</summary>
    Month,
    /// <summary>Displays a view to select a year from a range of years.</summary>
    Year
}
/// <summary>
/// Defines the date selection mode. Can be disabled to prevent date selection.
/// </summary>
[JsonConverter(typeof(SelectionDatesModeConverter))]
public enum SelectionDatesMode
{
    /// <summary>Date selection is disabled.</summary>
    Disabled,
    /// <summary>Only a single date can be selected at a time.</summary>
    Single,
    /// <summary>Multiple, non-consecutive dates can be selected.</summary>
    Multiple,
    /// <summary>A range of dates can be selected by picking a start and end date.</summary>
    MultipleRanged
}
/// <summary>
/// Defines the position of the calendar relative to an input element.
/// </summary>
[JsonConverter(typeof(PositionConverter))]
public enum Position
{
    /// <summary>Automatically determine the best position based on available space. Serializes to "auto".</summary>
    Auto,
    /// <summary>Positioned below, aligned to the left. Serializes to the string "left".</summary>
    Left,
    /// <summary>Positioned below, aligned to the center. Serializes to the string "center".</summary>
    Center,
    /// <summary>Positioned below, aligned to the right. Serializes to the string "right".</summary>
    Right,
    /// <summary>Positioned above, aligned to the left. Serializes to ["top", "left"].</summary>
    TopLeft,
    /// <summary>Positioned above, aligned to the center. Serializes to ["top", "center"].</summary>
    TopCenter,
    /// <summary>Positioned above, aligned to the right. Serializes to ["top", "right"].</summary>
    TopRight,
    /// <summary>Positioned below, aligned to the left. Serializes to ["bottom", "left"].</summary>
    BottomLeft,
    /// <summary>Positioned below, aligned to the center. Serializes to ["bottom", "center"].</summary>
    BottomCenter,
    /// <summary>Positioned below, aligned to the right. Serializes to ["bottom", "right"].</summary>
    BottomRight
}
/// <summary>
/// Defines the behavior for month or year selection.
/// </summary>
[JsonConverter(typeof(SelectionModeConverter))]
public enum SelectionMode
{
    /// <summary>Selection is fully enabled (by clicking the title and using arrows).</summary>
    Enabled,
    /// <summary>Selection is completely disabled. The month/year cannot be changed.</summary>
    Disabled,
    /// <summary>Selection is only possible via the navigation arrows; clicking the title is disabled.</summary>
    OnlyArrows
}
/// <summary>
/// Defines the time selection format.
/// </summary>
[JsonConverter(typeof(TimeModeConverter))]
public enum TimeMode
{
    /// <summary>Time selection is disabled.</summary>
    Disabled,
    /// <summary>Time is selected using a 12-hour format with AM/PM.</summary>
    TwelveHour,
    /// <summary>Time is selected using a 24-hour format.</summary>
    TwentyFourHour
}
/// <summary>
/// Defines the available controls for the time picker.
/// </summary>
[JsonConverter(typeof(CamelCaseEnumValueConverter<TimeControl>))]
public enum TimeControl
{
    /// <summary>All controls (input fields and range sliders) are enabled.</summary>
    All,
    /// <summary>Only the range sliders are enabled for time selection.</summary>
    Range
}
// --- Nested Configuration Records ---
/// <summary>
/// Represents a popup with information for a specific day.
/// </summary>
public record Popup
{
    /// <summary>
    /// A space-separated string of CSS classes to apply to the date.
    /// </summary>
    [JsonPropertyName("modifier")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Modifier { get; init; }
    /// <summary>
    /// Plain text or HTML markup for formatting the popup content.
    /// </summary>
    [JsonPropertyName("html")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Html { get; init; }
}
/// <summary>
/// Defines the ARIA labels for calendar navigation arrows.
/// </summary>
public record ArrowLabels
{
    /// <summary>The ARIA label for the "next month" arrow.</summary>
    [JsonPropertyName("month")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Month { get; init; }
    /// <summary>The ARIA label for the "next year" arrow in the year view.</summary>
    [JsonPropertyName("year")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Year { get; init; }
}
/// <summary>
/// Defines all ARIA labels for accessibility.
/// </summary>
public record Labels
{
    /// <summary>The top-level application label.</summary>
    [JsonPropertyName("application")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Application { get; init; }
    /// <summary>The label for the main navigation toolbar.</summary>
    [JsonPropertyName("navigation")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Navigation { get; init; }
    /// <summary>Labels for the "next" navigation arrows.</summary>
    [JsonPropertyName("arrowNext")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public ArrowLabels? ArrowNext { get; init; }
    /// <summary>Labels for the "previous" navigation arrows.</summary>
    [JsonPropertyName("arrowPrev")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public ArrowLabels? ArrowPrev { get; init; }
    /// <summary>Label for the month selection button.</summary>
    [JsonPropertyName("month")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Month { get; init; }
    /// <summary>Label for the list of months view.</summary>
    [JsonPropertyName("months")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Months { get; init; }
    /// <summary>Label for the year selection button.</summary>
    [JsonPropertyName("year")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Year { get; init; }
    /// <summary>Label for the list of years view.</summary>
    [JsonPropertyName("years")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Years { get; init; }
    /// <summary>Label for the row of weekdays.</summary>
    [JsonPropertyName("week")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Week { get; init; }
    /// <summary>Label for the week numbers column.</summary>
    [JsonPropertyName("weekNumber")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? WeekNumber { get; init; }
    /// <summary>Label for the grid of dates.</summary>
    [JsonPropertyName("dates")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Dates { get; init; }
    /// <summary>Label for the time selection group.</summary>
    [JsonPropertyName("selectingTime")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? SelectingTime { get; init; }
    /// <summary>Label for the hour input field.</summary>
    [JsonPropertyName("inputHour")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? InputHour { get; init; }
    /// <summary>Label for the minute input field.</summary>
    [JsonPropertyName("inputMinute")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? InputMinute { get; init; }
    /// <summary>Label for the hour range slider.</summary>
    [JsonPropertyName("rangeHour")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? RangeHour { get; init; }
    /// <summary>Label for the minute range slider.</summary>
    [JsonPropertyName("rangeMinute")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? RangeMinute { get; init; }
    /// <summary>Label for the AM/PM toggle button.</summary>
    [JsonPropertyName("btnKeeping")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? BtnKeeping { get; init; }
}
/// <summary>
/// Defines custom HTML layouts for different calendar views.
/// </summary>
public record Layouts
{
    /// <summary>The layout for the default single-month view.</summary>
    [JsonPropertyName("default")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Default { get; init; }
    /// <summary>The layout for the multiple-month view.</summary>
    [JsonPropertyName("multiple")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Multiple { get; init; }
    /// <summary>The layout for the month selection view.</summary>
    [JsonPropertyName("month")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Month { get; init; }
    /// <summary>The layout for the year selection view.</summary>
    [JsonPropertyName("year")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Year { get; init; }
}
/// <summary>
/// Provides overrides for the CSS classes used to style the calendar.
/// </summary>
public record Styles
{
    /// <summary>CSS class for the main calendar container.</summary>
    [JsonPropertyName("calendar")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? Calendar { get; init; }
    // Add other style properties as needed...
}
/// <summary>
/// Represents a value that can be a specific date or the string "today".
/// </summary>
[JsonConverter(typeof(DateAnyConverter))]
public readonly struct DateAny
{
    private readonly object _value;
    private DateAny(object value) => _value = value;
    /// <summary>Represents the current date.</summary>
    public static readonly DateAny Today = new("today");
    /// <summary>Creates a DateAny from a DateOnly value.</summary>
    public static implicit operator DateAny(DateOnly date) => new(date);
    /// <summary>Creates a DateAny from a DateTime value (time part is ignored).</summary>
    public static implicit operator DateAny(DateTime date) => new(DateOnly.FromDateTime(date));
}
// --- Main Options Record ---
/// <summary>
/// Represents the complete set of options for initializing a Vanilla Calendar Pro instance.
/// </summary>
public record VanillaCalendarOptions
{
    private static readonly string[] TwelveHourAcceptFormats = { "hh:mm tt", "h:mm tt", "hh:mmtt", "h:mmtt" };
    private static readonly string[] TwentyFourAcceptFormats = { "HH:mm", "H:mm" };
    /// <summary>
    /// The primary constructor used for deserialization.
    /// </summary>
    [JsonConstructor]
    public VanillaCalendarOptions(
        TimeMode selectionTimeMode,
        string? selectedTime)
    {
        this.SelectionTimeMode = selectionTimeMode;
        this.SelectedTime = ParseSelectedTime(selectedTime, selectionTimeMode);
    }
    /// <summary>
    /// Default constructor for creating new options in code.
    /// </summary>
    public VanillaCalendarOptions() { }
    private static TimeOnly? ParseSelectedTime(string? timeStr, TimeMode mode)
    {
        if (string.IsNullOrWhiteSpace(timeStr)) return null;
        if (mode == TimeMode.TwelveHour &&
            TimeOnly.TryParseExact(timeStr.Trim(), TwelveHourAcceptFormats, CultureInfo.InvariantCulture, DateTimeStyles.None, out var time12))
        {
            return time12;
        }
        if (mode == TimeMode.TwentyFourHour &&
            TimeOnly.TryParseExact(timeStr.Trim(), TwentyFourAcceptFormats, CultureInfo.InvariantCulture, DateTimeStyles.None, out var time24))
        {
            return time24;
        }
        return null;
    }
    /// <summary>
    /// Sets the time that will be displayed when the calendar is initialized.
    /// This property is for use in C# code and is ignored during JSON serialization.
    /// The actual serialized value is determined by the <see cref="SelectedTimeJson"/> property.
    /// </summary>
    [JsonIgnore]
    public TimeOnly? SelectedTime { get; init; }
    /// <summary>
    /// Defines the type of calendar displayed. Defaults to <see cref="CalendarType.Default"/>.
    /// </summary>
    [JsonPropertyName("type")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public CalendarType Type { get; init; } = CalendarType.Default;
    /// <summary>
    /// If true, the calendar is attached to an input element and appears as a popup. Defaults to false.
    /// </summary>
    [JsonPropertyName("inputMode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool InputMode { get; init; } = false;
    /// <summary>
    /// Defines the position of the calendar relative to the input when <see cref="InputMode"/> is true. Defaults to <see cref="Position.Left"/>.
    /// </summary>
    [JsonPropertyName("positionToInput")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public Position PositionToInput { get; init; } = Position.Left;
    /// <summary>
    /// Sets the first day of the week. Defaults to <see cref="DayOfWeek.Monday"/>.
    /// </summary>
    [JsonPropertyName("firstWeekday")]
    [JsonConverter(typeof(DayOfWeekNumberConverter))]
    public DayOfWeek FirstWeekday { get; init; } = DayOfWeek.Sunday;
    /// <summary>
    /// The number of months to jump when navigating with the arrows. Defaults to 1.
    /// </summary>
    [JsonPropertyName("monthsToSwitch")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int MonthsToSwitch { get; init; } = 1;
    /// <summary>
    /// A CSS selector for an element attribute that holds the theme name (e.g., "html[data-theme]"). Defaults to "html[data-theme]".
    /// </summary>
    [JsonPropertyName("themeAttrDetect")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public string ThemeAttrDetect { get; init; } = "html[data-theme]";
    /// <summary>
    /// Sets the language localization of the calendar using a BCP 47 language tag (e.g., "en-US", "de-AT"). Defaults to "en".
    /// </summary>
    [JsonPropertyName("locale")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public string Locale { get; init; } = "en";
    /// <summary>
    /// Defines which day is considered "today". Can be a specific date or <see cref="DateAny.Today"/>. Defaults to <see cref="DateAny.Today"/>.
    /// </summary>
    [JsonPropertyName("dateToday")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public DateAny DateToday { get; init; } = DateAny.Today;
    /// <summary>
    /// The absolute minimum date the calendar can render. Defaults to 1970-01-01.
    /// </summary>
    [JsonPropertyName("dateMin")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public DateAny DateMin { get; init; } = new DateOnly(1970, 1, 1);
    /// <summary>
    /// The absolute maximum date the calendar can render. Defaults to 2470-12-31.
    /// </summary>
    [JsonPropertyName("dateMax")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public DateAny DateMax { get; init; } = new DateOnly(2470, 12, 31);
    /// <summary>
    /// The minimum date that can be selected by the user.
    /// </summary>
    [JsonPropertyName("displayDateMin")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public DateAny? DisplayDateMin { get; init; }
    /// <summary>
    /// The maximum date that can be selected by the user.
    /// </summary>
    [JsonPropertyName("displayDateMax")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public DateAny? DisplayDateMax { get; init; }
    /// <summary>
    /// If true, shows dates from the previous and next months in the current month's view. Defaults to true.
    /// </summary>
    [JsonPropertyName("displayDatesOutside")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisplayDatesOutside { get; init; } = true;
    /// <summary>
    /// If true, renders disabled dates within the calendar's absolute min/max range. Defaults to false.
    /// </summary>
    [JsonPropertyName("displayDisabledDates")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisplayDisabledDates { get; init; } = false;
    /// <summary>
    /// The number of months to display. Defaults to 1 to match default CalendarType.Default.
    /// Use values > 1 when Type is Multiple.
    /// </summary>
    [JsonPropertyName("displayMonthsCount")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int DisplayMonthsCount { get; init; } = 1;
    /// <summary>
    /// A list of dates to disable.
    /// </summary>
    [JsonPropertyName("disableDates")]
    [JsonConverter(typeof(DateOnlyRangeListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DateOnly>? DisableDates { get; init; }
    /// <summary>
    /// If true, disables all dates, intended to be used with <see cref="EnableDates"/> to create an "allow-list". Defaults to false.
    /// </summary>
    [JsonPropertyName("disableAllDates")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisableAllDates { get; init; } = false;
    /// <summary>
    /// If true, disables all dates in the past. Defaults to false.
    /// </summary>
    [JsonPropertyName("disableDatesPast")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisableDatesPast { get; init; } = false;
    /// <summary>
    /// If true, prevents selecting a date range that includes a disabled date. Defaults to false.
    /// </summary>
    [JsonPropertyName("disableDatesGaps")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisableDatesGaps { get; init; } = false;
    /// <summary>
    /// A list of weekdays to disable.
    /// </summary>
    [JsonPropertyName("disableWeekdays")]
    [JsonConverter(typeof(DayOfWeekListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DayOfWeek>? DisableWeekdays { get; init; }
    /// <summary>
    /// If true, removes the special styling for the "today" date. Defaults to false.
    /// </summary>
    [JsonPropertyName("disableToday")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool DisableToday { get; init; } = false;
    /// <summary>
    /// A list of dates to enable, typically used when <see cref="DisableAllDates"/> is true.
    /// </summary>
    [JsonPropertyName("enableDates")]
    [JsonConverter(typeof(DateOnlyRangeListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DateOnly>? EnableDates { get; init; }
    /// <summary>
    /// If true, when selecting a range, the `selectedDates` array will only contain the start and end dates. Defaults to true.
    /// </summary>
    [JsonPropertyName("enableEdgeDatesOnly")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableEdgeDatesOnly { get; init; } = true;
    /// <summary>
    /// If true, clicking a selected date will deselect it. Defaults to true.
    /// </summary>
    [JsonPropertyName("enableDateToggle")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableDateToggle { get; init; } = true;
    /// <summary>
    /// If true, displays the week number column. Defaults to false.
    /// </summary>
    [JsonPropertyName("enableWeekNumbers")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableWeekNumbers { get; init; } = false;
    /// <summary>
    /// If true, clicking a date from an outside month will switch to that month. Defaults to true.
    /// </summary>
    [JsonPropertyName("enableMonthChangeOnDayClick")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableMonthChangeOnDayClick { get; init; } = true;
    /// <summary>
    /// If true, the calendar will open to the month of the first selected date. Defaults to false.
    /// </summary>
    [JsonPropertyName("enableJumpToSelectedDate")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool EnableJumpToSelectedDate { get; init; } = false;
    /// <summary>
    /// Determines whether selecting one or multiple days is allowed. Defaults to <see cref="SelectionDatesMode.Single"/>.
    /// </summary>
    [JsonPropertyName("selectionDatesMode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public SelectionDatesMode SelectionDatesMode { get; init; } = SelectionDatesMode.Single;
    /// <summary>
    /// Allows disabling month selection or restricting it to arrows only. Defaults to <see cref="SelectionMode.Enabled"/>.
    /// </summary>
    [JsonPropertyName("selectionMonthsMode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public SelectionMode SelectionMonthsMode { get; init; } = SelectionMode.Enabled;
    /// <summary>
    /// Allows disabling year selection or restricting it to arrows only. Defaults to <see cref="SelectionMode.Enabled"/>.
    /// </summary>
    [JsonPropertyName("selectionYearsMode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public SelectionMode SelectionYearsMode { get; init; } = SelectionMode.Enabled;
    /// <summary>
    /// Enables time selection and sets the format (12-hour or 24-hour). Defaults to <see cref="TimeMode.Disabled"/>.
    /// </summary>
    [JsonPropertyName("selectionTimeMode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public TimeMode SelectionTimeMode { get; init; } = TimeMode.Disabled;
    /// <summary>
    /// A list of dates that will be selected when the calendar is initialized.
    /// </summary>
    [JsonPropertyName("selectedDates")]
    [JsonConverter(typeof(DateOnlyRangeListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DateOnly>? SelectedDates { get; init; }
    /// <summary>
    /// The month to display on initialization (0-11). If not set, defaults to the current month or the month of a selected date.
    /// </summary>
    [JsonPropertyName("selectedMonth")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? SelectedMonth { get; init; }
    /// <summary>
    /// The year to display on initialization. If not set, defaults to the current year or the year of a selected date.
    /// </summary>
    [JsonPropertyName("selectedYear")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public int? SelectedYear { get; init; }
    /// <summary>
    /// A list of dates to style as holidays.
    /// </summary>
    [JsonPropertyName("selectedHolidays")]
    [JsonConverter(typeof(DateOnlyRangeListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DateOnly>? SelectedHolidays { get; init; }
    /// <summary>
    /// The days of the week to style as weekends. Defaults to Saturday and Sunday.
    /// </summary>
    [JsonPropertyName("selectedWeekends")]
    [JsonConverter(typeof(DayOfWeekListConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyList<DayOfWeek>? SelectedWeekends { get; init; }
    /// <summary>
    /// The theme to apply to the calendar. Can be "light", "dark", "system", or a custom theme name. Defaults to "system".
    /// </summary>
    [JsonPropertyName("selectedTheme")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public string SelectedTheme { get; init; } = "system";
    /// <summary>
    /// The minimum hour that can be selected (0-23). Defaults to 0.
    /// </summary>
    [JsonPropertyName("timeMinHour")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeMinHour { get; init; } = 0;
    /// <summary>
    /// The maximum hour that can be selected (0-23). Defaults to 23.
    /// </summary>
    [JsonPropertyName("timeMaxHour")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeMaxHour { get; init; } = 23;
    /// <summary>
    /// The minimum minute that can be selected (0-59). Defaults to 0.
    /// </summary>
    [JsonPropertyName("timeMinMinute")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeMinMinute { get; init; } = 0;
    /// <summary>
    /// The maximum minute that can be selected (0-59). Defaults to 59.
    /// </summary>
    [JsonPropertyName("timeMaxMinute")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeMaxMinute { get; init; } = 59;
    /// <summary>
    /// The type of controls to show for time selection. Defaults to <see cref="TimeControl.All"/>.
    /// </summary>
    [JsonPropertyName("timeControls")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public TimeControl TimeControls { get; init; } = TimeControl.All;
    /// <summary>
    /// The step increment for the hour slider. Defaults to 1.
    /// </summary>
    [JsonPropertyName("timeStepHour")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeStepHour { get; init; } = 1;
    /// <summary>
    /// The step increment for the minute slider. Defaults to 1.
    /// </summary>
    [JsonPropertyName("timeStepMinute")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public int TimeStepMinute { get; init; } = 1;
    /// <summary>
    /// A dictionary of popups to display on hover for specific dates.
    /// </summary>
    [JsonPropertyName("popups")]
    [JsonConverter(typeof(PopupsConverter))]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public IReadOnlyDictionary<DateOnly, Popup>? Popups { get; init; }
    /// <summary>
    /// Overrides for ARIA labels for accessibility.
    /// </summary>
    [JsonPropertyName("labels")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Labels? Labels { get; init; }
    /// <summary>
    /// Overrides for the HTML structure of the calendar views.
    /// </summary>
    [JsonPropertyName("layouts")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Layouts? Layouts { get; init; }
    /// <summary>
    /// Overrides for the CSS classes used to style the calendar components.
    /// </summary>
    [JsonPropertyName("styles")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public Styles? Styles { get; init; }
    /// <summary>
    /// This property is used exclusively for JSON serialization. It formats the <see cref="SelectedTime"/>
    /// into the correct string representation based on the current <see cref="SelectionTimeMode"/>.
    /// It is not intended for direct use in C# code.
    /// </summary>
    [JsonPropertyName("selectedTime")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public string? SelectedTimeJson =>
        SelectedTime is null
            ? null
            : SelectionTimeMode switch
            {
                TimeMode.TwelveHour => SelectedTime.Value.ToString("hh:mm tt", CultureInfo.InvariantCulture),
                TimeMode.TwentyFourHour => SelectedTime.Value.ToString("HH:mm", CultureInfo.InvariantCulture),
                _ => null
            };
    /// <summary>
    /// Settings object for deeper configuration.
    /// </summary>
    [JsonPropertyName("settings")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    public object? Settings { get; init; }
    /// <summary>
    /// Validates the options object, throwing an <see cref="InvalidOperationException"/> if any rules are violated.
    /// This should be called before serialization to catch configuration errors early.
    /// </summary>
    public void Validate()
    {
        if (SelectionTimeMode == TimeMode.Disabled && SelectedTime is not null)
        {
            throw new InvalidOperationException($"Cannot set {nameof(SelectedTime)} when {nameof(SelectionTimeMode)} is {nameof(TimeMode.Disabled)}.");
        }
        if (SelectionDatesMode == SelectionDatesMode.Single && (SelectedDates?.Count ?? 0) > 1)
        {
            throw new InvalidOperationException($"When {nameof(SelectionDatesMode)} is {nameof(SelectionDatesMode.Single)}, {nameof(SelectedDates)} should contain at most one date.");
        }
    }
}
// --- Custom JSON Converters ---
#region Converters
/// <summary>
/// Converts a C# <see cref="DayOfWeek"/> enum to the integer index expected by Vanilla Calendar (0=Sunday, 6=Saturday).
/// </summary>
public sealed class DayOfWeekNumberConverter : JsonConverter<DayOfWeek>
{
    private static int ToJs(DayOfWeek d) => (int)d;
    private static DayOfWeek FromJs(int n)
    {
        if (n < 0 || n > 6) throw new JsonException($"Invalid weekday index: {n}. Expected a value between 0 (Sunday) and 6 (Saturday).");
        return (DayOfWeek)n;
    }
    /// <inheritdoc />
    public override DayOfWeek Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        => FromJs(reader.GetInt32());
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, DayOfWeek value, JsonSerializerOptions options)
        => writer.WriteNumberValue(ToJs(value));
}
/// <summary>
/// Converts a list of C# <see cref="DayOfWeek"/> enums to a JSON array of integers.
/// </summary>
public sealed class DayOfWeekListConverter : JsonConverter<IReadOnlyList<DayOfWeek>>
{
    /// <inheritdoc />
    public override IReadOnlyList<DayOfWeek> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartArray) throw new JsonException("Expected an array of numbers for DayOfWeek list.");
        var intList = JsonSerializer.Deserialize<List<int>>(ref reader, options);
        if (intList == null) return new List<DayOfWeek>();
        foreach (var i in intList)
        {
            if (i < 0 || i > 6) throw new JsonException($"Invalid weekday index: {i}. Expected 0..6.");
        }
        return intList.Select(i => (DayOfWeek)i).ToList();
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, IReadOnlyList<DayOfWeek> value, JsonSerializerOptions options)
    {
        writer.WriteStartArray();
        foreach (var day in value)
        {
            writer.WriteNumberValue((int)day);
        }
        writer.WriteEndArray();
    }
}
/// <summary>
/// Converts a list of C# <see cref="DateOnly"/> objects to a JSON array of strings.
/// This converter provides an ergonomic benefit by automatically grouping consecutive dates into the "YYYY-MM-DD:YYYY-MM-DD" range format,
/// which is supported by the Vanilla Calendar library.
/// </summary>
public sealed class DateOnlyRangeListConverter : JsonConverter<IReadOnlyList<DateOnly>>
{
    private static string Pad2(string s) => s.Length == 1 ? "0" + s : s;
    /// <inheritdoc />
    public override IReadOnlyList<DateOnly> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartArray) throw new JsonException("Expected an array of strings for DateOnly list.");
        var stringList = JsonSerializer.Deserialize<List<string>>(ref reader, options);
        if (stringList == null) return new List<DateOnly>();
        var results = new List<DateOnly>();
        foreach (var entry in stringList)
        {
            if (string.IsNullOrWhiteSpace(entry)) continue;
            var nums = Regex.Split(entry, @"\D+").Where(s => !string.IsNullOrEmpty(s)).ToArray();
            if (nums.Length == 6) // YYYY, M, D, YYYY, M, D
            {
                var startStr = $"{nums[0]}-{Pad2(nums[1])}-{Pad2(nums[2])}";
                var endStr = $"{nums[3]}-{Pad2(nums[4])}-{Pad2(nums[5])}";
                if (DateOnly.TryParseExact(startStr, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var start) &&
                    DateOnly.TryParseExact(endStr, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var end))
                {
                    if (end < start) throw new JsonException($"Invalid date range: end date '{endStr}' is before start date '{startStr}'.");
                    for (var d = start; d <= end; d = d.AddDays(1)) results.Add(d);
                    continue;
                }
            }
            else if (nums.Length == 3) // YYYY, M, D
            {
                var singleStr = $"{nums[0]}-{Pad2(nums[1])}-{Pad2(nums[2])}";
                if (DateOnly.TryParseExact(singleStr, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var singleDate))
                {
                    results.Add(singleDate);
                    continue;
                }
            }
            if (DateOnly.TryParseExact(entry.Trim(), "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var exactDate))
            {
                results.Add(exactDate);
            }
        }
        return results;
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, IReadOnlyList<DateOnly> value, JsonSerializerOptions options)
    {
        var sortedDates = value.Distinct().OrderBy(d => d).ToList();
        writer.WriteStartArray();
        for (int i = 0; i < sortedDates.Count; i++)
        {
            var rangeStart = sortedDates[i];
            var rangeEnd = rangeStart;
            while (i + 1 < sortedDates.Count && sortedDates[i + 1] == rangeEnd.AddDays(1))
            {
                rangeEnd = sortedDates[i + 1];
                i++;
            }
            if (rangeStart == rangeEnd)
            {
                writer.WriteStringValue(rangeStart.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture));
            }
            else
            {
                writer.WriteStringValue($"{rangeStart.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)}:{rangeEnd.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture)}");
            }
        }
        writer.WriteEndArray();
    }
}
/// <summary>
/// Converts a C# <see cref="Position"/> enum to the JSON string or string array required by Vanilla Calendar.
/// </summary>
public sealed class PositionConverter : JsonConverter<Position>
{
    /// <inheritdoc />
    public override Position Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
        {
            string? val = reader.GetString()?.Trim().ToLowerInvariant();
            return val switch
            {
                "auto" => Position.Auto,
                "left" => Position.Left,
                "center" => Position.Center,
                "right" => Position.Right,
                _ => throw new JsonException($"Invalid string value for Position: '{val}'. Expected 'auto', 'left', 'center', or 'right'.")
            };
        }
        if (reader.TokenType == JsonTokenType.StartArray)
        {
            var arr = JsonSerializer.Deserialize<string[]>(ref reader, options);
            if (arr?.Length == 2)
            {
                var key = $"{arr[0].Trim().ToLowerInvariant()}-{arr[1].Trim().ToLowerInvariant()}";
                return key switch
                {
                    "top-left" => Position.TopLeft,
                    "top-center" => Position.TopCenter,
                    "top-right" => Position.TopRight,
                    "bottom-left" => Position.BottomLeft,
                    "bottom-center" => Position.BottomCenter,
                    "bottom-right" => Position.BottomRight,
                    _ => throw new JsonException($"Invalid array value for Position: ['{arr[0]}','{arr[1]}'].")
                };
            }
        }
        throw new JsonException("Expected a string or a two-element string array for Position.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, Position value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case Position.Auto: writer.WriteStringValue("auto"); return;
            case Position.Left: writer.WriteStringValue("left"); return;
            case Position.Center: writer.WriteStringValue("center"); return;
            case Position.Right: writer.WriteStringValue("right"); return;
            case Position.TopLeft: writer.WriteStartArray(); writer.WriteStringValue("top"); writer.WriteStringValue("left"); writer.WriteEndArray(); return;
            case Position.TopCenter: writer.WriteStartArray(); writer.WriteStringValue("top"); writer.WriteStringValue("center"); writer.WriteEndArray(); return;
            case Position.TopRight: writer.WriteStartArray(); writer.WriteStringValue("top"); writer.WriteStringValue("right"); writer.WriteEndArray(); return;
            case Position.BottomLeft: writer.WriteStartArray(); writer.WriteStringValue("bottom"); writer.WriteStringValue("left"); writer.WriteEndArray(); return;
            case Position.BottomCenter: writer.WriteStartArray(); writer.WriteStringValue("bottom"); writer.WriteStringValue("center"); writer.WriteEndArray(); return;
            case Position.BottomRight: writer.WriteStartArray(); writer.WriteStringValue("bottom"); writer.WriteStringValue("right"); writer.WriteEndArray(); return;
            default: throw new JsonException($"Invalid Position enum value: {value}");
        }
    }
}
/// <summary>
/// Converts a C# <see cref="SelectionMode"/> enum to the JSON boolean or string required by Vanilla Calendar.
/// </summary>
public sealed class SelectionModeConverter : JsonConverter<SelectionMode>
{
    /// <inheritdoc />
    public override SelectionMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.True) return SelectionMode.Enabled;
        if (reader.TokenType == JsonTokenType.False) return SelectionMode.Disabled;
        if (reader.TokenType == JsonTokenType.String && string.Equals(reader.GetString(), "only-arrows", StringComparison.OrdinalIgnoreCase)) return SelectionMode.OnlyArrows;
        throw new JsonException("Invalid value for SelectionMode. Expected true, false, or 'only-arrows'.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, SelectionMode value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case SelectionMode.Enabled: writer.WriteBooleanValue(true); break;
            case SelectionMode.Disabled: writer.WriteBooleanValue(false); break;
            case SelectionMode.OnlyArrows: writer.WriteStringValue("only-arrows"); break;
            default: throw new JsonException($"Invalid SelectionMode enum value: {value}");
        }
    }
}
/// <summary>
/// Converts a C# <see cref="TimeMode"/> enum to the JSON boolean or number required by Vanilla Calendar.
/// </summary>
public sealed class TimeModeConverter : JsonConverter<TimeMode>
{
    /// <inheritdoc />
    public override TimeMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.False) return TimeMode.Disabled;
        if (reader.TokenType == JsonTokenType.Number)
        {
            int val = reader.GetInt32();
            return val switch
            {
                12 => TimeMode.TwelveHour,
                24 => TimeMode.TwentyFourHour,
                _ => throw new JsonException($"Invalid number value for TimeMode: {val}. Expected 12 or 24.")
            };
        }
        throw new JsonException("Invalid value for TimeMode. Expected false, 12, or 24.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, TimeMode value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case TimeMode.Disabled: writer.WriteBooleanValue(false); break;
            case TimeMode.TwelveHour: writer.WriteNumberValue(12); break;
            case TimeMode.TwentyFourHour: writer.WriteNumberValue(24); break;
            default: throw new JsonException($"Invalid TimeMode enum value: {value}");
        }
    }
}
/// <summary>
/// Converts a C# dictionary with <see cref="DateOnly"/> keys to a JSON object with "YYYY-MM-DD" string keys.
/// </summary>
public sealed class PopupsConverter : JsonConverter<IReadOnlyDictionary<DateOnly, Popup>>
{
    /// <inheritdoc />
    public override IReadOnlyDictionary<DateOnly, Popup> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var stringKeyDict = JsonSerializer.Deserialize<Dictionary<string, Popup>>(ref reader, options);
        if (stringKeyDict == null) return new Dictionary<DateOnly, Popup>();
        var result = new Dictionary<DateOnly, Popup>();
        foreach (var (key, value) in stringKeyDict)
        {
            if (!DateOnly.TryParseExact(key, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var date))
            {
                throw new JsonException($"Invalid popup date key '{key}'. Expected 'yyyy-MM-dd'.");
            }
            result[date] = value;
        }
        return result;
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, IReadOnlyDictionary<DateOnly, Popup> value, JsonSerializerOptions options)
    {
        var stringKeyDict = value.ToDictionary(
            kvp => kvp.Key.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture),
            kvp => kvp.Value
        );
        JsonSerializer.Serialize(writer, stringKeyDict, options);
    }
}
/// <summary>
/// Converts a C# enum to its camelCase string representation.
/// </summary>
public sealed class CamelCaseEnumValueConverter<T> : JsonConverter<T> where T : struct, Enum
{
    private readonly JsonNamingPolicy _namingPolicy = JsonNamingPolicy.CamelCase;
    /// <inheritdoc />
    public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        string? enumString = reader.GetString();
        if (enumString == null) throw new JsonException($"Cannot convert null to {typeof(T).Name}.");
        foreach (var memberName in Enum.GetNames<T>())
        {
            if (string.Equals(_namingPolicy.ConvertName(memberName), enumString, StringComparison.OrdinalIgnoreCase))
            {
                return Enum.Parse<T>(memberName);
            }
        }
        throw new JsonException($"Unable to convert \"{enumString}\" to enum {typeof(T).Name}.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
    {
        writer.WriteStringValue(_namingPolicy.ConvertName(value.ToString()));
    }
}
/// <summary>
/// Converts the <see cref="SelectionDatesMode"/> enum to its JSON representation, handling the special 'multiple-ranged' kebab-case and 'Disabled' as boolean false.
/// </summary>
public sealed class SelectionDatesModeConverter : JsonConverter<SelectionDatesMode>
{
    /// <inheritdoc />
    public override SelectionDatesMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.False) return SelectionDatesMode.Disabled;
        if (reader.TokenType != JsonTokenType.String) throw new JsonException("Expected a string or boolean false for SelectionDatesMode.");
        string? value = reader.GetString();
        if (string.Equals(value, "multiple-ranged", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(value, "multipleRanged", StringComparison.OrdinalIgnoreCase))
        {
            return SelectionDatesMode.MultipleRanged;
        }
        if (Enum.TryParse<SelectionDatesMode>(value, ignoreCase: true, out var result)) return result;
        throw new JsonException($"Invalid string value for SelectionDatesMode: '{value}'.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, SelectionDatesMode value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case SelectionDatesMode.Disabled:
                writer.WriteBooleanValue(false);
                break;
            case SelectionDatesMode.MultipleRanged:
                writer.WriteStringValue("multiple-ranged");
                break;
            default:
                writer.WriteStringValue(JsonNamingPolicy.CamelCase.ConvertName(value.ToString()));
                break;
        }
    }
}
/// <summary>
/// Converts a C# <see cref="DateAny"/> struct to the JSON string required by Vanilla Calendar.
/// </summary>
public sealed class DateAnyConverter : JsonConverter<DateAny>
{
    /// <inheritdoc />
    public override DateAny Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var str = reader.GetString();
        if (string.Equals(str, "today", StringComparison.OrdinalIgnoreCase)) return DateAny.Today;
        if (DateOnly.TryParseExact(str, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out var date)) return date;
        throw new JsonException($"Invalid value for DateAny: '{str}'. Expected 'today' or a 'yyyy-MM-dd' date string.");
    }
    /// <inheritdoc />
    public override void Write(Utf8JsonWriter writer, DateAny value, JsonSerializerOptions options)
    {
        var val = typeof(DateAny).GetField("_value", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(value);
        if (val is string s) writer.WriteStringValue(s);
        else if (val is DateOnly d) writer.WriteStringValue(d.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture));
    }
}
#endregion
/// <summary>
/// Provides a source-generated JSON context for serializing <see cref="VanillaCalendarOptions"/>.
/// Using this context improves performance and is required for AOT (Ahead-Of-Time) compilation scenarios like Blazor WebAssembly.
/// </summary>
[JsonSourceGenerationOptions(
    WriteIndented = false, 
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault
)]
[JsonSerializable(typeof(RizzyUI.VanillaCalendarOptions))]
internal partial class VanillaCalendarJsonContext : JsonSerializerContext { }
</file>

<file path="Components/Form/Models/FlatpickrOptions.cs">
using Jalex.UI.Components.Form.Converters;
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
///     Specifies the selection mode for the date picker.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum Mode
{
    /// <summary>
    ///     Single date selection mode.
    /// </summary>
    Single,
    /// <summary>
    ///     Multiple date selection mode.
    /// </summary>
    Multiple,
    /// <summary>
    ///     Range selection mode, allowing a start and end date.
    /// </summary>
    Range,
    /// <summary>
    ///     Time-only selection mode, hiding the calendar.
    /// </summary>
    Time
}
/// <summary>
///     Defines how the month selector in the calendar is displayed.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MonthSelectorType
{
    /// <summary>
    ///     Displays the month selector as a dropdown.
    /// </summary>
    Dropdown,
    /// <summary>
    ///     Displays the month selector as a static list.
    /// </summary>
    Static
}
/// <summary>
///     Specifies the positioning strategy for the Flatpickr calendar.
/// </summary>
[JsonConverter(typeof(CalendarPositionConverter))]
public enum CalendarPosition
{
    /// <summary>
    ///     Automatic positioning based on available space.
    /// </summary>
    Auto,
    /// <summary>
    ///     Force the calendar to appear above the input.
    /// </summary>
    Above,
    /// <summary>
    ///     Force the calendar to appear below the input.
    /// </summary>
    Below,
    /// <summary>
    ///     Automatic placement with left alignment.
    /// </summary>
    AutoLeft,
    /// <summary>
    ///     Automatic placement with center alignment.
    /// </summary>
    AutoCenter,
    /// <summary>
    ///     Automatic placement with right alignment.
    /// </summary>
    AutoRight,
    /// <summary>
    ///     Force the calendar above and aligned to the left.
    /// </summary>
    AboveLeft,
    /// <summary>
    ///     Force the calendar above and centered horizontally.
    /// </summary>
    AboveCenter,
    /// <summary>
    ///     Force the calendar above and aligned to the right.
    /// </summary>
    AboveRight,
    /// <summary>
    ///     Force the calendar below and aligned to the left.
    /// </summary>
    BelowLeft,
    /// <summary>
    ///     Force the calendar below and centered horizontally.
    /// </summary>
    BelowCenter,
    /// <summary>
    ///     Force the calendar below and aligned to the right.
    /// </summary>
    BelowRight
}
/// <summary>
///     Represents a date range used to enable or disable selection in the date picker.
/// </summary>
public class CalendarDateRange
{
    /// <summary>
    ///     Gets or sets the starting date for this range.
    /// </summary>
    public DateTime From { get; set; }
    /// <summary>
    ///     Gets or sets the ending date for this range. May be null if only a single date is used.
    /// </summary>
    public DateTime? To { get; set; }
}
/// <summary>
///     Configuration options for Flatpickr date/time picker.
/// </summary>
public class FlatpickrOptions
{
    /// <summary>
    ///     Allows the user to enter a date directly into the input field. By default, direct entry is disabled.
    /// </summary>
    [JsonPropertyName("allowInput")]
    public bool? AllowInput { get; set; }
    /// <summary>
    ///     Allows preloading of an invalid date. Useful when you're using date strings as default values, or if the input
    ///     element is optional.
    /// </summary>
    [JsonPropertyName("allowInvalidPreload")]
    public bool? AllowInvalidPreload { get; set; }
    /// <summary>
    ///     Exactly the same as date format, but for the altInput field.
    /// </summary>
    [JsonPropertyName("altFormat")]
    public string? AltFormat { get; set; }
    /// <summary>
    ///     Show the user a readable date (as per altFormat), but return something totally different to the server.
    /// </summary>
    [JsonPropertyName("altInput")]
    public bool? AltInput { get; set; }
    /// <summary>
    ///     This class will be added to the input element created by the altInput option. Note that altInput already inherits
    ///     classes from the original input.
    /// </summary>
    [JsonPropertyName("altInputClass")]
    public string? AltInputClass { get; set; }
    /// <summary>
    ///     Whether to enable animations, such as month transitions.
    /// </summary>
    [JsonPropertyName("animate")]
    public bool? Animate { get; set; }
    /// <summary>
    ///     Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat.
    ///     Defaults to "F j, Y".
    /// </summary>
    [JsonPropertyName("ariaDateFormat")]
    public string? AriaDateFormat { get; set; }
    /// <summary>
    ///     Whether the default time should be auto-filled when the input is empty and gains or loses focus. Defaults to true.
    /// </summary>
    [JsonPropertyName("autoFillDefaultTime")]
    public bool? AutoFillDefaultTime { get; set; }
    /// <summary>
    ///     Whether clicking on the input should open the picker. Set it to false if you only want to open the calendar
    ///     programmatically.
    /// </summary>
    [JsonPropertyName("clickOpens")]
    public bool? ClickOpens { get; set; }
    /// <summary>
    ///     Whether calendar should close after date selection. By default, the calendar stays open unless the user clicks
    ///     outside of it.
    /// </summary>
    [JsonPropertyName("closeOnSelect")]
    public bool? CloseOnSelect { get; set; }
    /// <summary>
    ///     If "mode" is "multiple", this string will be used to join selected dates together for the date input value.
    /// </summary>
    [JsonPropertyName("conjunction")]
    public string? Conjunction { get; set; }
    /// <summary>
    ///     A string of characters which are used to define how the date will be displayed in the input box.
    /// </summary>
    [JsonPropertyName("dateFormat")]
    public string? DateFormat { get; set; }
    /// <summary>
    ///     The initial selected date(s).
    /// </summary>
    [JsonPropertyName("defaultDate")]
    public string? DefaultDate { get; set; }
    /// <summary>
    ///     Initial value of the hour element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultHour")]
    public int? DefaultHour { get; set; }
    /// <summary>
    ///     Initial value of the minute element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultMinute")]
    public int? DefaultMinute { get; set; }
    /// <summary>
    ///     Initial value of the seconds element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultSeconds")]
    public int? DefaultSeconds { get; set; }
    /// <summary>
    ///     Disables certain dates, preventing them from being selected.
    /// </summary>
    [JsonPropertyName("disable")]
    public List<CalendarDateRange>? Disable { get; set; }
    /// <summary>
    ///     Set this to true to always use the non-native picker on mobile devices.
    ///     By default, Flatpickr utilizes native datetime widgets unless certain options (e.g., disable) are used.
    /// </summary>
    [JsonPropertyName("disableMobile")]
    public bool? DisableMobile { get; set; }
    /// <summary>
    ///     Disables all dates except for those specified.
    /// </summary>
    [JsonPropertyName("enable")]
    public List<CalendarDateRange>? Enable { get; set; }
    /// <summary>
    ///     Enables seconds selection in the time picker.
    /// </summary>
    [JsonPropertyName("enableSeconds")]
    public bool? EnableSeconds { get; set; }
    /// <summary>
    ///     Enables the time picker.
    /// </summary>
    [JsonPropertyName("enableTime")]
    public bool? EnableTime { get; set; }
    /// <summary>
    ///     Adjusts the step for the hour input (incl. scrolling).
    /// </summary>
    [JsonPropertyName("hourIncrement")]
    public int? HourIncrement { get; set; }
    /// <summary>
    ///     Displays the calendar inline.
    /// </summary>
    [JsonPropertyName("inline")]
    public bool? Inline { get; set; }
    /// <summary>
    ///     The locale, either as a string (e.g., "ru", "en") or as an object.
    /// </summary>
    [JsonPropertyName("locale")]
    public string? Locale { get; set; }
    /// <summary>
    ///     The maximum date that a user can pick to (inclusive).
    /// </summary>
    [JsonPropertyName("maxDate")]
    public DateTime? MaxDate { get; set; }
    /// <summary>
    ///     The maximum time that a user can pick to (inclusive).
    /// </summary>
    [JsonPropertyName("maxTime")]
    public DateTime? MaxTime { get; set; }
    /// <summary>
    ///     The minimum date that a user can start picking from (inclusive).
    /// </summary>
    [JsonPropertyName("minDate")]
    public DateTime? MinDate { get; set; }
    /// <summary>
    ///     The minimum time that a user can start picking from (inclusive).
    /// </summary>
    [JsonPropertyName("minTime")]
    public DateTime? MinTime { get; set; }
    /// <summary>
    ///     Adjusts the step for the minute input (incl. scrolling). Defaults to 5.
    /// </summary>
    [JsonPropertyName("minuteIncrement")]
    public int? MinuteIncrement { get; set; }
    /// <summary>
    ///     Date selection mode, defaults to "single".
    /// </summary>
    [JsonPropertyName("mode")]
    public Mode? Mode { get; set; }
    /// <summary>
    ///     How the month selector in the calendar should be shown. Can be set to "dropdown" to display a dropdown
    ///     menu for month selection, or "static" to display the months as a static list.
    /// </summary>
    [JsonPropertyName("monthSelectorType")]
    public MonthSelectorType? MonthSelectorType { get; set; }
    /// <summary>
    ///     HTML for the right arrow icon, used to switch months.
    /// </summary>
    [JsonPropertyName("nextArrow")]
    public string? NextArrow { get; set; }
    /// <summary>
    ///     Hides the day selection in the calendar. Use it along with "enableTime" to create a time picker.
    /// </summary>
    [JsonPropertyName("noCalendar")]
    public bool? NoCalendar { get; set; }
    /// <summary>
    ///     How the calendar should be positioned with regards to the input. Can accept multiple positioning options like
    ///     "auto", "above", "below", "auto left", "auto right", etc.
    /// </summary>
    [JsonPropertyName("position")]
    public CalendarPosition? CalendarPosition { get; set; }
    /// <summary>
    ///     HTML for the left arrow icon, used to switch months.
    /// </summary>
    [JsonPropertyName("prevArrow")]
    public string? PrevArrow { get; set; }
    /// <summary>
    ///     Whether to display the current month name in shorthand mode, e.g., "Sep" instead of "September".
    /// </summary>
    [JsonPropertyName("shorthandCurrentMonth")]
    public bool? ShorthandCurrentMonth { get; set; }
    /// <summary>
    ///     Creates a wrapper to position the calendar. Useful if the input is inside a scrollable element or you need the
    ///     calendar to be positioned in a specific way relative to the input.
    /// </summary>
    [JsonPropertyName("static")]
    public bool? Static { get; set; }
    /// <summary>
    ///     Sets the number of months to show in the calendar. Useful for displaying multiple months at once.
    /// </summary>
    [JsonPropertyName("showMonths")]
    public int? ShowMonths { get; set; }
    /// <summary>
    ///     Displays time picker in 24-hour mode without AM/PM selection when enabled.
    /// </summary>
    [JsonPropertyName("time_24hr")]
    public bool? Time24Hr { get; set; }
    /// <summary>
    ///     Display week numbers to the left of the calendar.
    /// </summary>
    [JsonPropertyName("weekNumbers")]
    public bool? WeekNumbers { get; set; }
    /// <summary>
    ///     See https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements. Allows the flatpickr calendar to wrap
    ///     around a custom input and open/close the calendar when this input is focused or clicked.
    /// </summary>
    [JsonPropertyName("wrap")]
    public bool? Wrap { get; set; }
}
</file>

<file path="Components/Form/RzButton/RzButton.razor">
@namespace RizzyUI
@inherits RzComponent<RzButton.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             aria-label="@EffectiveAssistiveLabel"
             data-slot="button">
    @if (ChildContent != null)
    {
        @ChildContent
    }
    else
    {
        @Label
    }
</HtmlElement>
</file>

<file path="Components/Form/RzButton/RzButton.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a clickable button with customizable styling, variant, and size. Styling is handled by the active theme.
/// </summary>
public partial class RzButton : RzComponent<RzButton.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzButton component.
    /// This is used by themes as the base definition and can be overridden.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive cursor-pointer rounded-md",
        variants: new()
        {
            [b => ((RzButton)b).EffectiveVariant] = new Variant<ThemeVariant, Slots>
            {
                [ThemeVariant.Default] = "bg-input text-foreground border border-input shadow-sm hover:bg-accent hover:text-accent-foreground",
                [ThemeVariant.Primary] = "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
                [ThemeVariant.Secondary] = "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/90",
                [ThemeVariant.Destructive] = "bg-destructive text-white shadow-xs hover:bg-destructive/90",
                [ThemeVariant.Ghost] = "shadow-none hover:bg-accent hover:text-accent-foreground",
                [ThemeVariant.Accent] = "bg-accent text-accent-foreground shadow-xs hover:bg-accent/90",
                [ThemeVariant.Inverse] = "bg-foreground text-background shadow-xs hover:bg-foreground/90",
                [ThemeVariant.Information] = "bg-info text-info-foreground shadow-xs hover:bg-info/90",
                [ThemeVariant.Warning] = "bg-warning text-warning-foreground shadow-xs hover:bg-warning/90",
                [ThemeVariant.Success] = "bg-success text-success-foreground shadow-xs hover:bg-success/90"
            },
            [b => ((RzButton)b).Size] = new Variant<Size, Slots>
            {
                [Size.ExtraSmall] = "gap-1 h-7 px-2.5 text-xs",
                [Size.Small] = "gap-1.5 h-8 px-3",
                [Size.Medium] = "gap-2 h-9 px-4 py-2",
                [Size.Large] = "gap-2 h-10 px-6",
                [Size.ExtraLarge] = "gap-2.5 h-12 px-8 text-lg"
            },
            [b => ((RzButton)b).Animate] = new Variant<bool, Slots>
            {
                [true] = "transform active:scale-95 motion-reduce:transition-none transition-transform"
            }
        },
        compoundVariants: new()
        {
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Default) { Class = "border border-input text-foreground bg-transparent hover:bg-accent hover:text-accent-foreground" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Primary) { Class = "border border-primary text-primary bg-transparent hover:bg-primary/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Secondary) { Class = "border border-secondary text-foreground bg-transparent hover:bg-secondary/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Destructive) { Class = "border border-destructive text-destructive bg-transparent hover:bg-destructive/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Accent) { Class = "border border-accent text-foreground bg-transparent hover:bg-accent/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Inverse) { Class = "border border-foreground text-foreground bg-transparent hover:bg-foreground/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Information) { Class = "border border-info text-info bg-transparent hover:bg-info/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Warning) { Class = "border border-warning text-warning bg-transparent hover:bg-warning/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Success) { Class = "border border-success text-success bg-transparent hover:bg-success/10" },
            new(b => ((RzButton)b).Outline && ((RzButton)b).EffectiveVariant == ThemeVariant.Ghost) { Class = "border border-transparent" }
        }
    );
    /// <summary>
    /// Gets the variant cascaded from a parent RzButtonGroup, if any.
    /// </summary>
    [CascadingParameter(Name = "GroupVariant")]
    protected ThemeVariant? GroupVariant { get; set; }
    /// <summary>
    /// Gets or sets the accessible label for the button, used for screen readers.
    /// If not provided, it defaults to a localized value.
    /// </summary>
    [Parameter]
    public string? AssistiveLabel { get; set; }
    /// <summary>
    /// Gets or sets the visual style variant of the button.
    /// If not set, it falls back to <see cref="GroupVariant"/> or <see cref="ThemeVariant.Default"/>.
    /// </summary>
    [Parameter]
    public ThemeVariant? Variant { get; set; }
    /// <summary>
    /// Gets or sets the size of the button. Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets a value indicating whether the button should have an outline style. Defaults to false.
    /// </summary>
    [Parameter]
    public bool Outline { get; set; }
    /// <summary>
    /// Gets or sets the text label displayed on the button. Used if <see cref="ChildContent"/> is not provided.
    /// </summary>
    [Parameter]
    public string Label { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets a value indicating whether to enable the button's click animation. Defaults to true.
    /// </summary>
    [Parameter]
    public bool Animate { get; set; } = true;
    /// <summary>
    /// Gets or sets the optional content to be rendered inside the button element. Overrides the <see cref="Label"/> property.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the effective assistive label for the `aria-label` attribute.
    /// </summary>
    protected string EffectiveAssistiveLabel => AssistiveLabel ?? Localizer["RzButton.AssistiveLabelDefault"];
    /// <summary>
    /// Gets the effective variant, prioritizing the explicit Variant parameter, then the GroupVariant, and defaulting to Default.
    /// </summary>
    public ThemeVariant EffectiveVariant => Variant ?? GroupVariant ?? ThemeVariant.Default;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "button";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzButton;
    /// <summary>
    /// Defines the slots available for styling in the RzButton component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root element of the button.
        /// </summary>
        [Slot("button")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzButtonGroup/ButtonGroupSeparator.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<ButtonGroupSeparator.Slots>

<RzSeparator Orientation="@Orientation"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="button-group-separator"
             data-orientation="@Orientation.ToString().ToKebabCase()" />
</file>

<file path="Components/Form/RzButtonGroup/ButtonGroupSeparator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A separator component specifically designed for use within a <see cref="RzButtonGroup"/>.
/// It visually divides buttons within the group.
/// </summary>
public partial class ButtonGroupSeparator : RzComponent<ButtonGroupSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the ButtonGroupSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto"
    );
    /// <summary>
    /// Gets or sets the orientation of the separator. Defaults to Vertical.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ButtonGroupSeparator;
    /// <summary>
    /// Defines the slots available for styling in the ButtonGroupSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("button-group-separator")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzButtonGroup/ButtonGroupText.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<ButtonGroupText.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Form/RzButtonGroup/ButtonGroupText.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component to display text within a <see cref="RzButtonGroup"/>.
/// Can be rendered as a div or merged onto a child element.
/// </summary>
public partial class ButtonGroupText : RzAsChildComponent<ButtonGroupText.Slots>
{
    /// <summary>
    /// Defines the default styling for the ButtonGroupText component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the text component.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
        {
            Element = "div";
        }
    }
    /// <inheritdoc />
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc />
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["data-slot"] = "button-group-text"
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.ButtonGroupText;
    /// <summary>
    /// Defines the slots available for styling in the ButtonGroupText component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("button-group-text")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzButtonGroup/RzButtonGroup.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<RzButtonGroup.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="group"
             data-slot="button-group"
             data-orientation="@Orientation.ToString().ToKebabCase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/RzButtonGroup/RzButtonGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container that groups related buttons together with consistent styling.
/// Supports horizontal and vertical orientations and manages border/radius merging for children.
/// </summary>
public partial class RzButtonGroup : RzComponent<RzButtonGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzButtonGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-fit items-stretch [&>*]:shadow-none [&>*]:focus-visible:z-10 [&>*]:focus-visible:relative [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md has-[>[data-slot=button-group]]:gap-2",
        variants: new()
        {
            [c => ((RzButtonGroup)c).Orientation] = new Variant<Orientation, Slots>
            {
                [Orientation.Horizontal] = "[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none",
                [Orientation.Vertical] = "flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content of the button group.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the orientation of the button group. Defaults to Horizontal.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <summary>
    /// Gets or sets the theme variant to be cascaded to child buttons.
    /// If set, child buttons with no explicit Variant will use this value.
    /// </summary>
    [Parameter]
    public ThemeVariant? GroupVariant { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
        {
            Element = "div";
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzButtonGroup;
    /// <summary>
    /// Defines the slots available for styling in the RzButtonGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the button group container.
        /// </summary>
        [Slot("button-group")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzCalendar/RzCalendar.razor">
@namespace RizzyUI
@using Rizzy.Utility
@inherits RzComponent<RzCalendar.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()"
             data-slot="calendar">
    
	<div x-data="rzCalendar"
	     id="@CalendarId"
	     data-alpine-root="@Id"
	     data-config-id="@ConfigScriptId"
	     data-assets="@_assets"
	     data-nonce="@Nonce"
	     class="@SlotClasses.GetCalendarContainer()">
         
		<script type="application/json" id="@ConfigScriptId" nonce="@Nonce">
            @((MarkupString)_serializedConfig)
        </script>

		<div x-ref="calendarEl" class="@SlotClasses.GetRoot()"></div>
	</div>

</HtmlElement>
</file>

<file path="Components/Form/RzCalendar/RzCalendar.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Options;
using System.Text.Json;
using System.Text.Json.Serialization;
using Blazicons;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A calendar component for selecting dates, ranges, and times.
/// Replicates shadcn/ui visual style while using Vanilla Calendar Pro for logic.
/// </summary>
public partial class RzCalendar : RzComponent<RzCalendar.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCalendar component.
    /// Matches shadcn/ui calendar styles by overriding VCP class names and targeting VCP data attributes.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "p-3",
        slots: new()
        {
            // Root container
            // Use !important to override VCP's default theme styles since we are hijacking them with CSS vars
            [s => s.Root] = "w-fit !bg-card border !border-border rounded-md shadow-sm p-3 !text-card-foreground",
            // Header & Navigation
            [s => s.Header] = "flex justify-center pt-1 relative items-center gap-1 mb-4",
            [s => s.HeaderContent] = "text-sm font-medium", 
            [s => s.Month] = "text-sm font-medium hover:bg-accent hover:text-accent-foreground rounded-md px-2 py-1 cursor-pointer transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
            [s => s.Year] = "text-sm font-medium hover:bg-accent hover:text-accent-foreground rounded-md px-2 py-1 cursor-pointer transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
            // Arrows (Absolute positioning to match Shadcn)
            [s => s.ArrowPrev] = $"absolute left-1 top-0 h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100 flex items-center justify-center rounded-md border border-input hover:bg-accent hover:text-accent-foreground transition-colors z-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring rizzy-vc-arrow",
            [s => s.ArrowNext] = $"absolute right-1 top-0 h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100 flex items-center justify-center rounded-md border border-input hover:bg-accent hover:text-accent-foreground transition-colors z-10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring rizzy-vc-arrow",
            // Grid Layouts
            [s => s.Grid] = "w-full border-collapse space-y-1",
            [s => s.Weekdays] = "flex",
            [s => s.Weekday] = "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem] flex justify-center items-center",
            [s => s.Dates] = "grid grid-cols-7 gap-y-1 w-full",
            [s => s.Months] = "grid grid-cols-3 gap-2 w-full sm:w-64",
            [s => s.Years] = "grid grid-cols-4 gap-2 w-full sm:w-64",
            // Day Cell (Wrapper)
            // 'group' class allows the button to style itself based on this cell's attributes (e.g. data-vc-date-today)
            [s => s.DayCell] = "group relative p-0 text-center text-sm focus-within:relative focus-within:z-20", // " [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md",
            // Day Button (Interactive)
            // We use group-data-* modifiers to target the attributes VCP applies to the parent DayCell or self
            [s => s.DayButton] = 
                // Base
                "h-9 w-9 p-0 font-normal aria-selected:opacity-100 inline-flex items-center justify-center rounded-md transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 " +
                // Hover (when not selected)
                "hover:bg-accent hover:text-accent-foreground " +
                // Today (parent has data-vc-date-today)
                "group-data-[vc-date-today]:bg-accent group-data-[vc-date-today]:text-accent-foreground " +
                // Selected (self has aria-selected="true")
                "aria-selected:bg-primary aria-selected:text-primary-foreground aria-selected:hover:bg-primary aria-selected:hover:text-primary-foreground aria-selected:focus:bg-primary aria-selected:focus:text-primary-foreground " +
                // Outside Month (parent has data-vc-date-month="prev" or "next")
                "group-data-[vc-date-month=prev]:text-muted-foreground group-data-[vc-date-month=prev]:opacity-50 " +
                "group-data-[vc-date-month=next]:text-muted-foreground group-data-[vc-date-month=next]:opacity-50 " +
                // Disabled
                "group-data-[vc-date-disabled]:text-muted-foreground group-data-[vc-date-disabled]:opacity-50 group-data-[vc-date-disabled]:line-through " +
                // Range Middle
                "group-data-[vc-date-selected=middle]:bg-accent group-data-[vc-date-selected=middle]:text-accent-foreground group-data-[vc-date-selected=middle]:rounded-none " +
                // Range Start/End
                "group-data-[vc-date-selected=first]:bg-primary group-data-[vc-date-selected=first]:text-primary-foreground group-data-[vc-date-selected=first]:rounded-l-md group-data-[vc-date-selected=first]:rounded-r-none " +
                "group-data-[vc-date-selected=last]:bg-primary group-data-[vc-date-selected=last]:text-primary-foreground group-data-[vc-date-selected=last]:rounded-r-md group-data-[vc-date-selected=last]:rounded-l-none " + 
                "group-data-[vc-date-selected=first-and-last]:rounded-md",
            // Months/Years View Items
            [s => s.MonthsMonth] = "flex items-center justify-center p-2 rounded-md hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring text-sm aria-selected:bg-primary aria-selected:text-primary-foreground",
            [s => s.YearsYear] = "flex items-center justify-center p-2 rounded-md hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring text-sm aria-selected:bg-primary aria-selected:text-primary-foreground",
            // Time Picker
            [s => s.Time] = "flex flex-col items-center justify-center border-t border-border mt-3 pt-3 gap-2",
            [s => s.TimeContent] = "flex items-center gap-1",
            [s => s.TimeHour] = "bg-transparent p-1 rounded-md border border-input focus:ring-1 focus:ring-ring text-sm w-8 text-center appearance-none",
            [s => s.TimeMinute] = "bg-transparent p-1 rounded-md border border-input focus:ring-1 focus:ring-ring text-sm w-8 text-center appearance-none",
            [s => s.TimeKeeping] = "ml-2 px-2 py-1 rounded-md bg-secondary text-secondary-foreground text-xs font-medium cursor-pointer hover:bg-secondary/80",
            [s => s.TimeRanges] = "w-full space-y-2",
            [s => s.TimeRange] = "w-full accent-primary h-2 bg-secondary rounded-lg appearance-none cursor-pointer"
        }
    );
    [Inject] private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    private string _serializedConfig = "{}";
    private string _assets = "[]";
    private readonly string _calendarId = IdGenerator.UniqueId("vc");
    protected string CalendarId => _calendarId;
    protected string ConfigScriptId => $"{Id}-config";
    [Parameter] public SelectionDatesMode Mode { get; set; } = SelectionDatesMode.Single;
    [Parameter] public DateOnly? Value { get; set; }
    [Parameter] public EventCallback<DateOnly?> ValueChanged { get; set; }
    [Parameter] public List<DateOnly>? Values { get; set; }
    [Parameter] public EventCallback<List<DateOnly>> ValuesChanged { get; set; }
    [Parameter] public CalendarDateRange? Range { get; set; }
    [Parameter] public EventCallback<CalendarDateRange?> RangeChanged { get; set; }
    [Parameter] public bool? ShowOutsideDays { get; set; }
    [Parameter] public DateOnly? MinDate { get; set; }
    [Parameter] public DateOnly? MaxDate { get; set; }
    [Parameter] public CalendarType Type { get; set; } = CalendarType.Default;
    [Parameter] public VanillaCalendarOptions? Options { get; set; }
    [Parameter] public string[] ComponentAssetKeys { get; set; } = ["VanillaCalendarPro", "VanillaCalendarCss"];
    [Parameter] public string? AriaLabel { get; set; }
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzCalendar.DefaultAriaLabel"];
    }
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzCalendar.DefaultAriaLabel"];
        var config = new VanillaCalendarOptions
        {
            Type = Type,
            InputMode = false,
            SelectionDatesMode = SelectionDatesMode.Single,
            DisplayDatesOutside = true,
            // FORCE light theme mode to prevent VCP from using its own OS detection.
            // Our CSS variables will handle the actual light/dark switching because 
            // RizzyUI themes update CSS variables on the :root/.dark element.
            SelectedTheme = "light", 
            ThemeAttrDetect = "" 
        };
        if (Options != null)
        {
            if (Options.Type != CalendarType.Default) config = config with { Type = Options.Type };
            if (Options.SelectionDatesMode != SelectionDatesMode.Single) config = config with { SelectionDatesMode = Options.SelectionDatesMode };
            if (Options.DisplayMonthsCount > 1) config = config with { DisplayMonthsCount = Options.DisplayMonthsCount };
            if (Options.FirstWeekday != DayOfWeek.Sunday) config = config with { FirstWeekday = Options.FirstWeekday };
            if (!string.IsNullOrEmpty(Options.Locale)) config = config with { Locale = Options.Locale };
            if (Options.DisableWeekdays != null) config = config with { DisableWeekdays = Options.DisableWeekdays };
            if (Options.EnableWeekNumbers) config = config with { EnableWeekNumbers = Options.EnableWeekNumbers };
            if (!string.IsNullOrEmpty(Options.SelectedTheme)) config = config with { SelectedTheme = Options.SelectedTheme };
            if (!string.IsNullOrEmpty(Options.ThemeAttrDetect)) config = config with { ThemeAttrDetect = Options.ThemeAttrDetect };
        }
        config = config with { SelectionDatesMode = Mode };
        if (ShowOutsideDays.HasValue) 
            config = config with { DisplayDatesOutside = ShowOutsideDays.Value };
        if (MinDate.HasValue) 
            config = config with { DateMin = MinDate.Value };
        if (MaxDate.HasValue) 
            config = config with { DateMax = MaxDate.Value };
        var selectedDates = new List<DateOnly>();
        if (Mode == SelectionDatesMode.Single && Value.HasValue)
        {
            selectedDates.Add(Value.Value);
        }
        else if (Mode == SelectionDatesMode.Multiple && Values != null)
        {
            selectedDates.AddRange(Values);
        }
        else if (Mode == SelectionDatesMode.MultipleRanged && Range != null)
        {
            selectedDates.Add(DateOnly.FromDateTime(Range.From));
            if (Range.To.HasValue)
            {
                var end = DateOnly.FromDateTime(Range.To.Value);
                selectedDates.Add(end); 
            }
        }
        if (selectedDates.Count > 0)
        {
            config = config with { SelectedDates = selectedDates };
        }
        if (config.Type == CalendarType.Multiple)
        {
            if (config.DisplayMonthsCount < 2 && Options?.DisplayMonthsCount == null)
                config = config with { DisplayMonthsCount = 2 };
        }
        config.Validate();
        // Map Styling to VCP CSSClasses using the SlotClasses
        // These keys match the VCP `styles.ts` source exactly
        var cssClasses = new Dictionary<string, string?>
        {
            { "calendar", SlotClasses.GetRoot() },
            { "header", SlotClasses.GetHeader() },
            { "headerContent", SlotClasses.GetHeaderContent() },
            { "month", SlotClasses.GetMonth() },
            { "year", SlotClasses.GetYear() },
            { "arrowPrev", SlotClasses.GetArrowPrev() },
            { "arrowNext", SlotClasses.GetArrowNext() },
            { "grid", SlotClasses.GetGrid() },
            { "weekdays", SlotClasses.GetWeekdays() },
            { "weekday", SlotClasses.GetWeekday() },
            { "dates", SlotClasses.GetDates() }, // Renamed from Days to Dates to match VCP
            { "date", SlotClasses.GetDayCell() },
            { "dateBtn", SlotClasses.GetDayButton() },
            { "months", SlotClasses.GetMonths() },
            { "monthsMonth", SlotClasses.GetMonthsMonth() },
            { "years", SlotClasses.GetYears() },
            { "yearsYear", SlotClasses.GetYearsYear() },
            // Time Picker
            { "time", SlotClasses.GetTime() },
            { "timeContent", SlotClasses.GetTimeContent() },
            { "timeHour", SlotClasses.GetTimeHour() },
            { "timeMinute", SlotClasses.GetTimeMinute() },
            { "timeKeeping", SlotClasses.GetTimeKeeping() },
            { "timeRanges", SlotClasses.GetTimeRanges() },
            { "timeRange", SlotClasses.GetTimeRange() }
        };
        var cleanCssClasses = cssClasses.Where(kv => !string.IsNullOrEmpty(kv.Value))
                                        .ToDictionary(kv => kv.Key, kv => kv.Value);
        var configWrapper = new { 
            options = config, 
            styles = cleanCssClasses // Renamed from cssClasses to styles to match VCP config structure
        };
        _serializedConfig = JsonSerializer.Serialize(configWrapper, new JsonSerializerOptions 
        { 
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        });
        var assetUrls = ComponentAssetKeys
            .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
            .Where(url => !string.IsNullOrEmpty(url))
            .ToList();
        _assets = JsonSerializer.Serialize(assetUrls);
    }
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCalendar;
    public sealed partial class Slots : ISlots
    {
        [Slot("calendar")]
        public string? Base { get; set; }
        [Slot("calendar-container")]
        public string? CalendarContainer { get; set; }
        // --- VCP Mapped Slots ---
        [Slot("root")]
        public string? Root { get; set; }
        [Slot("header")]
        public string? Header { get; set; }
        [Slot("header-content")]
        public string? HeaderContent { get; set; }
        [Slot("month")]
        public string? Month { get; set; }
        [Slot("year")]
        public string? Year { get; set; }
        [Slot("arrow-prev")]
        public string? ArrowPrev { get; set; }
        [Slot("arrow-next")]
        public string? ArrowNext { get; set; }
        [Slot("grid")]
        public string? Grid { get; set; }
        [Slot("weekdays")]
        public string? Weekdays { get; set; }
        [Slot("weekday")]
        public string? Weekday { get; set; }
        [Slot("dates")]
        public string? Dates { get; set; } // "vc-dates"
        [Slot("day-cell")]
        public string? DayCell { get; set; } // "vc-date"
        [Slot("day-button")]
        public string? DayButton { get; set; } // "vc-date__btn"
        [Slot("months")]
        public string? Months { get; set; }
        [Slot("months-month")]
        public string? MonthsMonth { get; set; }
        [Slot("years")]
        public string? Years { get; set; }
        [Slot("years-year")]
        public string? YearsYear { get; set; }
        // --- Time Picker ---
        [Slot("time")]
        public string? Time { get; set; }
        [Slot("time-content")]
        public string? TimeContent { get; set; }
        [Slot("time-hour")]
        public string? TimeHour { get; set; }
        [Slot("time-minute")]
        public string? TimeMinute { get; set; }
        [Slot("time-keeping")]
        public string? TimeKeeping { get; set; }
        [Slot("time-ranges")]
        public string? TimeRanges { get; set; }
        [Slot("time-range")]
        public string? TimeRange { get; set; }
    }
}
</file>

<file path="Components/Form/RzCheckboxGroup/CheckboxGroupItemIndicator.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<CheckboxGroupItemIndicator.Slots>

@if (ShowIndicators)
{
    <div @attributes="AdditionalAttributes" class="@SlotClasses.GetBase()" data-slot="@CheckboxGroupItemIndicator.SlotNames.NameOf(SlotTypes.Base)">
        @if (ChildContent is null)
        {
            <Blazicon Svg="@(CheckedIcon ?? MdiIcon.CheckBold)" class="@SlotClasses.GetIcon()" />
        }
        else
        {
            <div class="@SlotClasses.GetCustomContentWrapper()" data-slot="@CheckboxGroupItemIndicator.SlotNames.NameOf(SlotTypes.CustomContentWrapper)">
                @ChildContent
            </div>
        }
    </div>
}
</file>

<file path="Components/Form/RzCheckboxGroup/CheckboxGroupItemIndicator.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Renders the visual indicator for a <see cref="RzCheckboxGroupItem"/>.
/// </summary>
public partial class CheckboxGroupItemIndicator : RzComponent<CheckboxGroupItemIndicator.Slots>
{
    [CascadingParameter] private ICheckboxGroupItem? ParentItem { get; set; }
    [CascadingParameter(Name = "ShowIndicators")] private bool ShowIndicators { get; set; } = true;
    /// <summary>
    /// Gets or sets custom content to display as the indicator when checked.
    /// If not provided, a default icon is used.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the icon to display when checked. Overrides the parent group's icon if set.
    /// </summary>
    [Parameter] public SvgIcon? CheckedIcon { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        ParentItem?.RegisterIndicator();
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CheckboxGroupItemIndicator;
    /// <summary>
    /// Defines the slots available for styling in the CheckboxGroupItemIndicator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the indicator's wrapper element.
        /// </summary>
        [Slot("indicator-wrapper")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the default checkmark icon.
        /// </summary>
        [Slot("indicator-icon")]
        public string? Icon { get; set; }
        /// <summary>
        /// The slot for the wrapper of custom indicator content.
        /// </summary>
        [Slot("custom-indicator")]
        public string? CustomContentWrapper { get; set; }
    }
}
</file>

<file path="Components/Form/RzCheckboxGroup/RzCheckboxGroup.razor">
@typeparam TValue
@namespace RizzyUI
@inherits RzComponent<RzCheckboxGroupSlots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="@RzCheckboxGroupSlotNames.NameOf(RzCheckboxGroupSlotTypes.Base)" 
             role="group"
             aria-labelledby="@_legendId">
    <legend id="@_legendId" class="sr-only">@DisplayName</legend>
    <CascadingValue Value="this" IsFixed="true">
        <CascadingValue Value="ShowIndicators" Name="ShowIndicators">
            @ChildContent
        </CascadingValue>
    </CascadingValue>
</HtmlElement>
</file>

<file path="Components/Form/RzCheckboxGroup/RzCheckboxGroup.razor.cs">
// src/RizzyUI/Components/Form/RzCheckboxGroup/RzCheckboxGroup.razor.cs
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Rizzy.Utility;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
// Interface for child items to discover the parent's icon
internal interface IHasCheckboxGroupIcon
{
    SvgIcon CheckedIcon { get; set; }
}
/// <xmldoc>
///     Represents a group of checkbox items (<see cref="RzCheckboxGroupItem{TValue}" />) that support multiple selection.
///     This component must be used within an EditForm.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCheckboxGroup<TValue> : RzComponent<RzCheckboxGroupSlots>, IHasCheckboxGroupStylingProperties, IHasCheckboxGroupIcon
{
    private readonly string _legendId = IdGenerator.UniqueId("rz-cbg-legend");
    private IList<TValue>? _currentValue;
    [CascadingParameter] private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the expression for the bound value, used for validation. </summary>
    [Parameter, EditorRequired] public Expression<Func<IList<TValue>>> For { get; set; } = default!;
    /// <summary> Gets or sets the child content, expected to be <see cref="RzCheckboxGroupItem{TValue}" /> components. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets the name attribute for the checkbox group inputs. If not set, it's inferred from the `For` expression. </summary>
    [Parameter] public string? Name { get; set; }
    /// <summary> Gets or sets the display name for the fieldset, rendered as a screen-reader-only legend. </summary>
    [Parameter] public string? DisplayName { get; set; }
    /// <summary> Gets or sets the orientation of the checkbox group (Vertical or Horizontal). Defaults to Vertical. </summary>
    [Parameter] public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary> Gets or sets the custom Blazicon SVG icon to display when a checkbox is checked. Defaults to MdiIcon.CheckBold. </summary>
    [Parameter] public SvgIcon CheckedIcon { get; set; } = MdiIcon.CheckBold;
    /// <summary> Gets or sets a value indicating whether to show the indicators for each checkbox item. Defaults to true. </summary>
    [Parameter] public bool ShowIndicators { get; set; } = true;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "fieldset";
        if (For == null) throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null) throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        var fieldIdentifier = FieldIdentifier.Create(For);
        if (string.IsNullOrEmpty(Name))
        {
            Name = fieldIdentifier.FieldName;
        }
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _currentValue = For!.Compile().Invoke();
    }
    /// <summary>
    /// Checks if a given value is currently selected.
    /// </summary>
    /// <param name="value">The value to check.</param>
    /// <returns>True if the value is selected, otherwise false.</returns>
    internal bool IsChecked(TValue? value)
    {
        return value is not null && _currentValue is not null && _currentValue.Contains(value);
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<RzCheckboxGroupSlots>, RzCheckboxGroupSlots> GetDescriptor() => Theme.RzCheckboxGroup;
}
</file>

<file path="Components/Form/RzCheckboxGroup/RzCheckboxGroupItem.razor">
@typeparam TValue
@namespace RizzyUI
@inherits RzComponent<RzCheckboxGroupItemSlots>

<label @attributes="AdditionalAttributes"
       id="@Id"
       class="@SlotClasses.GetBase()"
       data-slot="@RzCheckboxGroupItemSlotNames.NameOf(RzCheckboxGroupItemSlotTypes.Base)"
       aria-disabled=@Disabled>
    <input type="checkbox"
           name="@ParentGroup?.Name"
           value="@Value"
           checked="@(ParentGroup?.IsChecked(Value) ?? false)"
           class="@SlotClasses.GetInput()"
           data-slot="@RzCheckboxGroupItemSlotNames.NameOf(RzCheckboxGroupItemSlotTypes.Input)"
           disabled="@Disabled" />
    @if (!_hasExplicitIndicator)
    {
        if (ParentGroup is IHasCheckboxGroupIcon iconProvider)
        {
            CheckedIcon ??= iconProvider.CheckedIcon;
        }
        
        <CheckboxGroupItemIndicator CheckedIcon="@(CheckedIcon)" />
    }
    <CascadingValue Value="this" IsFixed="true">
        @ChildContent
    </CascadingValue>
</label>
</file>

<file path="Components/Form/RzCheckboxGroup/RzCheckboxGroupItem.razor.cs">
// src/RizzyUI/Components/Form/RzCheckboxGroup/RzCheckboxGroupItem.razor.cs
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
internal interface ICheckboxGroupItem
{
    void RegisterIndicator();
}
/// <summary>
/// Represents a single checkbox item within an <see cref="RzCheckboxGroup{TValue}"/>.
/// </summary>
public partial class RzCheckboxGroupItem<TValue> : RzComponent<RzCheckboxGroupItemSlots>, IHasCheckboxGroupItemStylingProperties, ICheckboxGroupItem
{
    private bool _hasExplicitIndicator = false;
    [CascadingParameter] protected RzCheckboxGroup<TValue>? ParentGroup { get; set; }
    /// <summary> Gets or sets the value associated with this checkbox item. </summary>
    [Parameter] public TValue? Value { get; set; }
    /// <summary> Gets or sets the content to be rendered inside the item's label. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets a value indicating whether this item is disabled. </summary>
    [Parameter] public bool Disabled { get; set; }
    /// <summary> Gets or sets a custom icon to display when checked, overriding the parent group's icon. </summary>
    [Parameter] public SvgIcon? CheckedIcon { get; set; }
    /// <summary>
    /// Internal method for child indicators to register their presence.
    /// </summary>
    public void RegisterIndicator()
    {
        if (!_hasExplicitIndicator)
        {
            _hasExplicitIndicator = true;
            StateHasChanged();
        }
    }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentGroup is null)
            throw new InvalidOperationException($"{GetType()} must be used within an RzCheckboxGroup.");
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<RzCheckboxGroupItemSlots>, RzCheckboxGroupItemSlots> GetDescriptor() => Theme.RzCheckboxGroupItem;
}
</file>

<file path="Components/Form/RzCheckboxGroup/RzInputCheckbox.razor">
@namespace RizzyUI
@inherits InputBase<bool, RzInputCheckbox.Slots>

<InputCheckbox
    @ref="_elem"
    ValueExpression="@For"
    Value="@Value"
    DisplayName="@DisplayName"
    @attributes="InputAttributes"
    class="@SlotClasses.GetBase()"
    id="@Id"
    data-slot="@RzInputCheckbox.SlotNames.NameOf(SlotTypes.Base)"
/>
</file>

<file path="Components/Form/RzCheckboxGroup/RzInputCheckbox.razor.cs">
// src/RizzyUI/Components/Form/RzCheckboxGroup/RzInputCheckbox.razor.cs
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A standalone checkbox component for binding to a boolean value.
/// </summary>
public partial class RzInputCheckbox : InputBase<bool, RzInputCheckbox.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzInputCheckbox component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50"
    );
    private InputCheckbox? _elem;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCheckbox;
    /// <summary>
    /// Defines the slots available for styling in the RzInputCheckbox component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the checkbox input element.
        /// </summary>
        [Slot("checkbox")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzCheckboxGroup/RzInputCheckboxGroupBase.cs">
// This is a new file
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <summary>
/// The internal base component that provides the core logic for a checkbox group,
/// inheriting from Blazor's InputBase to handle data binding and validation for a list of values.
/// </summary>
/// <typeparam name="TValue">The type of the values in the checkbox group.</typeparam>
public class RzInputCheckboxGroupBase<TValue> : InputBase<IList<TValue>>
{
    private readonly List<TValue> _selectedValues = new();
    /// <summary>
    /// The name to be assigned to each checkbox input in the group.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }
    /// <summary>
    /// The child content, which should contain the RzCheckboxGroupItem components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        _selectedValues.Clear();
        if (CurrentValue is not null)
        {
            _selectedValues.AddRange(CurrentValue);
        }
    }
    /// <summary>
    /// Toggles the selection of a value in the group.
    /// </summary>
    /// <param name="value">The value to toggle.</param>
    internal void ToggleValue(TValue? value)
    {
        if (value is null) return;
        if (_selectedValues.Contains(value))
        {
            _selectedValues.Remove(value);
        }
        else
        {
            _selectedValues.Add(value);
        }
        CurrentValue = new List<TValue>(_selectedValues);
    }
    /// <summary>
    /// Checks if a given value is currently selected.
    /// </summary>
    /// <param name="value">The value to check.</param>
    /// <returns>True if the value is selected, otherwise false.</returns>
    internal bool IsChecked(TValue? value)
    {
        return value is not null && _selectedValues.Contains(value);
    }
    /// <inheritdoc/>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        builder.OpenComponent<CascadingValue<RzInputCheckboxGroupBase<TValue>>>(0);
        builder.AddAttribute(1, "IsFixed", true);
        builder.AddAttribute(2, "Value", this);
        builder.AddAttribute(3, "ChildContent", ChildContent);
        builder.CloseComponent();
    }
    /// <inheritdoc/>
    protected override bool TryParseValueFromString(string? value, out IList<TValue> result, out string validationErrorMessage)
    {
        throw new NotSupportedException($"This component does not parse values from strings. Bind to the '{nameof(CurrentValue)}' property.");
    }
}
</file>

<file path="Components/Form/RzCheckboxGroup/Styling/CheckboxGroupItemIndicatorStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Provides the default styling descriptor for the CheckboxGroupItemIndicator component.
/// </summary>
public static class CheckboxGroupItemIndicatorStyles
{
    /// <summary>
    /// The default TvDescriptor for the CheckboxGroupItemIndicator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<CheckboxGroupItemIndicator.Slots>, CheckboxGroupItemIndicator.Slots> DefaultDescriptor = new(
        @base: "relative flex size-4 shrink-0 items-center justify-center rounded-sm border border-input bg-background group-has-[.peer:focus-visible]:ring-2 group-has-[.peer:focus-visible]:ring-ring group-has-[.peer:focus-visible]:ring-offset-2 group-has-[.peer:checked]:border-primary group-has-[.peer:checked]:bg-primary",
        slots: new()
        {
            [s => s.Icon] = "pointer-events-none size-3.5 bg-primary text-primary-foreground opacity-0 transition-opacity group-has-[.peer:checked]:opacity-100",
            [s => s.CustomContentWrapper] = "pointer-events-none absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 opacity-0 transition-opacity group-has-[.peer:checked]:opacity-100"
        }
    );
}
</file>

<file path="Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupFieldStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the slots available for styling in the RzCheckboxGroupField component.
/// </summary>
public sealed partial class RzCheckboxGroupFieldSlots : ISlots
{
    /// <summary>
    /// The base slot for the component's root element.
    /// </summary>
    [Slot("checkbox-group-field")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzCheckboxGroupField component.
/// </summary>
public static class RzCheckboxGroupFieldStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzCheckboxGroupField component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzCheckboxGroupFieldSlots>, RzCheckboxGroupFieldSlots> DefaultDescriptor = new();
}
</file>

<file path="Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupItemStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a CheckboxGroupItem component.
/// </summary>
public interface IHasCheckboxGroupItemStylingProperties
{
    /// <summary>
    /// Gets whether the item is disabled.
    /// </summary>
    public bool Disabled { get; }
}
/// <summary>
/// Defines the slots available for styling in the RzCheckboxGroupItem component.
/// </summary>
public sealed partial class RzCheckboxGroupItemSlots : ISlots
{
    /// <summary>
    /// The base slot for the main label container.
    /// </summary>
    [Slot("checkbox-group-item")]
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the hidden input element.
    /// </summary>
    [Slot("input")]
    public string? Input { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzCheckboxGroupItem component.
/// </summary>
public static class RzCheckboxGroupItemStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzCheckboxGroupItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzCheckboxGroupItemSlots>, RzCheckboxGroupItemSlots> DefaultDescriptor = new(
        @base: "group relative flex items-center gap-3 cursor-pointer",
        slots: new()
        {
            [s => s.Input] = "peer sr-only"
        },
        variants: new()
        {
            [c => ((IHasCheckboxGroupItemStylingProperties)c).Disabled] = new Variant<bool, RzCheckboxGroupItemSlots>
            {
                [true] = new() { [s => s.Base] = "cursor-not-allowed opacity-50" }
            }
        }
    );
}
</file>

<file path="Components/Form/RzCheckboxGroup/Styling/RzCheckboxGroupStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a CheckboxGroup component.
/// </summary>
public interface IHasCheckboxGroupStylingProperties
{
    /// <summary>
    /// Gets the orientation of the checkbox group.
    /// </summary>
    public Orientation Orientation { get; }
}
/// <summary>
/// Defines the slots available for styling in the RzCheckboxGroup component.
/// </summary>
public sealed partial class RzCheckboxGroupSlots : ISlots
{
    /// <summary>
    /// The base slot for the main fieldset container.
    /// </summary>
    [Slot("checkbox-group")]
    public string? Base { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzCheckboxGroup component.
/// </summary>
public static class RzCheckboxGroupStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzCheckboxGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzCheckboxGroupSlots>, RzCheckboxGroupSlots> DefaultDescriptor = new(
        @base: "gap-2",
        variants: new()
        {
            [c => ((IHasCheckboxGroupStylingProperties)c).Orientation] = new Variant<Orientation, RzCheckboxGroupSlots>
            {
                [Orientation.Horizontal] = new() { [s => s.Base] = "flex flex-row space-x-4" },
                [Orientation.Vertical] = new() { [s => s.Base] = "grid" },
            }
        }
    );
}
</file>

<file path="Components/Form/RzCombobox/Models/ComboboxOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Configuration options for the Tom Select instance used by RzCombobox.
/// </summary>
public class ComboboxOptions
{
    /// <summary>
    /// If true, allows the user to create new items not present in the list.
    /// </summary>
    [JsonPropertyName("create")]
    public bool Create { get; set; } = false;
    /// <summary>
    /// The string to separate selected items in the input (for multi-select copy/paste).
    /// </summary>
    [JsonPropertyName("delimiter")]
    public string Delimiter { get; set; } = ",";
    /// <summary>
    /// The maximum number of items the user can select. 1 for single select, null for unlimited.
    /// </summary>
    [JsonPropertyName("maxItems")]
    public int? MaxItems { get; set; } 
    /// <summary>
    /// If true, the dropdown will open when the control receives focus.
    /// </summary>
    [JsonPropertyName("openOnFocus")]
    public bool OpenOnFocus { get; set; } = true;
    /// <summary>
    /// If true, the original &lt;select&gt; or &lt;input&gt; element is retained in the DOM.
    /// </summary>
    [JsonPropertyName("persist")]
    public bool Persist { get; set; } = true;
    /// <summary>
    /// The placeholder text to display when no value is selected.
    /// </summary>
    [JsonPropertyName("placeholder")]
    public string? Placeholder { get; set; }
    /// <summary>
    /// The property on the data object to use as the value.
    /// </summary>
    [JsonPropertyName("valueField")]
    public string ValueField { get; set; } = "value";
    /// <summary>
    /// The property on the data object to use as the display label.
    /// </summary>
    [JsonPropertyName("labelField")]
    public string LabelField { get; set; } = "text";
    /// <summary>
    /// The property on the data object to use for searching.
    /// </summary>
    [JsonPropertyName("searchField")]
    public string[] SearchField { get; set; } = ["text"];
    /// <summary>
    /// A list of plugins to initialize with the instance.
    /// </summary>
    [JsonPropertyName("plugins")]
    public List<IComboboxPlugin> Plugins { get; set; } = new();
    /// <summary>
    /// Creates a shallow copy of the options, including a shallow copy of the plugin list.
    /// </summary>
    public ComboboxOptions Clone()
    {
        var clone = (ComboboxOptions)this.MemberwiseClone();
        clone.Plugins = new List<IComboboxPlugin>(this.Plugins);
        return clone;
    }
    /// <summary>
    /// Adds a plugin to the configuration if it is not already present.
    /// </summary>
    /// <param name="plugin">The plugin instance to add.</param>
    public void AddPlugin(IComboboxPlugin plugin)
    {
        if (!Plugins.Any(p => p.Name == plugin.Name))
        {
            Plugins.Add(plugin);
        }
    }
}
</file>

<file path="Components/Form/RzCombobox/Models/Plugins/IComboboxPlugin.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Represents the configuration options for a specific Tom Select plugin.
/// Implementations should be simple POCOs serializable to JSON.
/// </summary>
public interface IComboboxPluginOptions
{
    // Marker interface for type safety and serialization polymorphism
}
/// <summary>
/// Defines a plugin to be registered with the Combobox.
/// </summary>
public interface IComboboxPlugin
{
    /// <summary>
    /// The unique name of the plugin as recognized by Tom Select (e.g., "remove_button").
    /// </summary>
    [JsonPropertyName("name")]
    string Name { get; }
    /// <summary>
    /// The configuration options for this plugin instance.
    /// </summary>
    [JsonPropertyName("options")]
    IComboboxPluginOptions? Options { get; }
}
</file>

<file path="Components/Form/RzCombobox/Models/Plugins/PluginDefinitions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
// ----------------------------------------------------------------------------
// Generic Plugin Base
// ----------------------------------------------------------------------------
/// <summary>
/// Base implementation for strong-typed plugins.
/// </summary>
/// <typeparam name="TOptions">The type of options object this plugin uses.</typeparam>
public abstract class ComboboxPluginBase<TOptions> : IComboboxPlugin where TOptions : IComboboxPluginOptions
{
    /// <inheritdoc/>
    public abstract string Name { get; }
    /// <summary>
    /// The strongly-typed options for this plugin.
    /// </summary>
    [JsonIgnore]
    public TOptions? TypedOptions { get; set; }
    /// <inheritdoc/>
    public IComboboxPluginOptions? Options => TypedOptions;
    /// <summary>
    /// Initializes a new instance of the plugin with optional settings.
    /// </summary>
    protected ComboboxPluginBase(TOptions? options = default)
    {
        TypedOptions = options;
    }
}
// ----------------------------------------------------------------------------
// Checkbox Options
// ----------------------------------------------------------------------------
/// <summary>
/// Configuration for the Checkbox Options plugin.
/// </summary>
public class ComboboxCheckboxOptionsSettings : IComboboxPluginOptions
{
    /// <summary>Class name for the checkbox.</summary>
    [JsonPropertyName("className")]
    public string ClassName { get; set; } = "ts-checkbox";
    /// <summary>Classes to apply when checked.</summary>
    [JsonPropertyName("checkedClassNames")]
    public string[]? CheckedClassNames { get; set; }
    /// <summary>Classes to apply when unchecked.</summary>
    [JsonPropertyName("uncheckedClassNames")]
    public string[]? UncheckedClassNames { get; set; }
}
/// <summary>
/// Plugin to render checkboxes next to options in the dropdown.
/// </summary>
public class ComboboxCheckboxOptionsPlugin : ComboboxPluginBase<ComboboxCheckboxOptionsSettings>
{
    /// <inheritdoc/>
    public override string Name => "checkbox_options";
    public ComboboxCheckboxOptionsPlugin(ComboboxCheckboxOptionsSettings? options = null) : base(options) { }
}
// ----------------------------------------------------------------------------
// Clear Button
// ----------------------------------------------------------------------------
/// <summary>
/// Configuration for the Clear Button plugin.
/// </summary>
public class ComboboxClearButtonSettings : IComboboxPluginOptions
{
    /// <summary>Title attribute for the button.</summary>
    [JsonPropertyName("title")]
    public string Title { get; set; } = "Clear";
    /// <summary>Class name for the button.</summary>
    [JsonPropertyName("className")]
    public string ClassName { get; set; } = "clear-button";
    /// <summary>Label text for the button.</summary>
    [JsonPropertyName("label")]
    public string Label { get; set; } = "clear";
    /// <summary>
    /// HTML string for the button content. 
    /// Note: Passed as a string literal to JavaScript.
    /// </summary>
    [JsonPropertyName("html")]
    public string? Html { get; set; } 
}
/// <summary>
/// Plugin to add a clear button to the control.
/// </summary>
public class ComboboxClearButtonPlugin : ComboboxPluginBase<ComboboxClearButtonSettings>
{
    /// <inheritdoc/>
    public override string Name => "clear_button";
    public ComboboxClearButtonPlugin(ComboboxClearButtonSettings? options = null) : base(options) { }
}
// ----------------------------------------------------------------------------
// Remove Button
// ----------------------------------------------------------------------------
/// <summary>
/// Configuration for the Remove Button plugin.
/// </summary>
public class ComboboxRemoveButtonSettings : IComboboxPluginOptions
{
    /// <summary>Label for the remove button.</summary>
    [JsonPropertyName("label")]
    public string Label { get; set; } = "&times;";
    /// <summary>Title attribute.</summary>
    [JsonPropertyName("title")]
    public string Title { get; set; } = "Remove";
    /// <summary>CSS class.</summary>
    [JsonPropertyName("className")]
    public string ClassName { get; set; } = "remove";
}
/// <summary>
/// Plugin to add an 'x' button to selected items for removal.
/// </summary>
public class ComboboxRemoveButtonPlugin : ComboboxPluginBase<ComboboxRemoveButtonSettings>
{
    /// <inheritdoc/>
    public override string Name => "remove_button";
    public ComboboxRemoveButtonPlugin(ComboboxRemoveButtonSettings? options = null) : base(options) { }
}
// ----------------------------------------------------------------------------
// Virtual Scroll
// ----------------------------------------------------------------------------
/// <summary>
/// Configuration for the Virtual Scroll plugin.
/// </summary>
public class ComboboxVirtualScrollSettings : IComboboxPluginOptions
{
    /// <summary>Throttle time in milliseconds.</summary>
    [JsonPropertyName("throttle")]
    public int Throttle { get; set; } = 50;
}
/// <summary>
/// Plugin to enable virtual scrolling for large datasets.
/// </summary>
public class ComboboxVirtualScrollPlugin : ComboboxPluginBase<ComboboxVirtualScrollSettings>
{
    /// <inheritdoc/>
    public override string Name => "virtual_scroll";
    public ComboboxVirtualScrollPlugin(ComboboxVirtualScrollSettings? options = null) : base(options) { }
}
</file>

<file path="Components/Form/RzCombobox/RzCombobox.razor">
@namespace RizzyUI
@typeparam TItem
@typeparam TValue
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Mvc.Rendering
@using RizzyUI.Extensions
@inherits InputBase<TValue, RzComboboxSlots>

<HtmlElement Element="@EffectiveElement" 
             id="@($"{Id}-wrapper")" 
             class="@SlotClasses.GetBase()" 
             data-slot="@RzComboboxSlotNames.NameOf(RzComboboxSlotTypes.Base)"
             @attributes="@AdditionalAttributes">
    
    <div x-data="rzCombobox"
         id="@Id"
         data-alpine-root="@Id"
         data-config-id="@ConfigScriptId"
         data-assets="@_assets"
         data-nonce="@Nonce">

        <script type="application/json" id="@ConfigScriptId" nonce="@Nonce">
            @((MarkupString)_serializedConfig)
        </script>

        @if (OptionTemplate != null)
        {
            <template x-ref="optionTemplate">
                @OptionTemplate
            </template>
        }

        @if (ItemTemplate != null)
        {
            <template x-ref="itemTemplate">
                @ItemTemplate
            </template>
        }

        <select x-ref="selectInput"
                id="@SelectId"
                name="@NameAttributeValue"
                class="@SlotClasses.GetSelect()"
                data-slot="@RzComboboxSlotNames.NameOf(RzComboboxSlotTypes.Select)"
                multiple="@(Multiple ? "multiple" : null)"
                disabled="@Disabled"
                @attributes="InnerInputAttributes">
             
             @if (!Multiple && !string.IsNullOrEmpty(Placeholder))
             {
                 <option value="">@Placeholder</option>
             }

             @if (IsSelectListItem)
             {
                 var castItems = Items.Cast<SelectListItem>();
                 var grouped = castItems.GroupBy(x => x.Group);

                 foreach (var group in grouped)
                 {
                     if (group.Key != null && !string.IsNullOrEmpty(group.Key.Name))
                     {
                         <optgroup label="@group.Key.Name" disabled="@group.Key.Disabled">
                             @foreach (var item in group)
                             {
                                 @RenderOption(item, (TItem)(object)item)
                             }
                         </optgroup>
                     }
                     else
                     {
                         foreach (var item in group)
                         {
                             @RenderOption(item, (TItem)(object)item)
                         }
                     }
                 }
             }
             else if (Items != null)
             {
                 foreach (var item in Items)
                 {
                     @RenderOption(null, item)
                 }
             }
        </select>
    </div>
</HtmlElement>

@code {
    private RenderFragment RenderOption(SelectListItem? sli, TItem item)
    {
        var val = GetValue(item);
        var txt = GetText(item);
        var isDisabled = sli?.Disabled ?? false;
        
        return @<option value="@val" 
                        selected="@IsSelected(item, val)"
                        disabled="@isDisabled"
                        data-item="@SerializeItem(item)">
                    @txt
               </option>;
    }
}
</file>

<file path="Components/Form/RzCombobox/RzCombobox.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.Extensions.Options;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using RizzyUI.Extensions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A powerful, searchable combobox based on Tom Select.
/// Uses a native &lt;select&gt; element for robust data binding and SSR support.
/// Supports generic value binding and native support for ASP.NET Core SelectListItem.
/// </summary>
/// <typeparam name="TItem">The type of the items in the dropdown (e.g. SelectListItem or a custom POCO).</typeparam>
/// <typeparam name="TValue">The type of the bound value (string or IEnumerable&lt;string&gt;).</typeparam>
public partial class RzCombobox<TItem, TValue> : InputBase<TValue, RzComboboxSlots>, IHasRzComboboxStylingProperties
{
    [Inject] private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    private string ConfigScriptId => $"{Id}-config";
    private string SelectId => $"{Id}-select";
    private string _serializedConfig = "{}";
    private string _assets = "[]";
    private ComboboxOptions _effectiveOptions = new();
    private bool _isSelectListItem;
    /// <summary>
    /// Configuration options for the Tom Select instance.
    /// </summary>
    [Parameter] public ComboboxOptions Options { get; set; } = new();
    /// <summary>
    /// The data source for the combobox items.
    /// </summary>
    [Parameter] public IEnumerable<TItem> Items { get; set; } = Enumerable.Empty<TItem>();
    /// <summary>
    /// Whether multiple items can be selected.
    /// </summary>
    [Parameter] public bool Multiple { get; set; }
    /// <summary>
    /// The placeholder text displayed when empty.
    /// </summary>
    [Parameter] public string? Placeholder { get; set; }
    /// <summary>
    /// Whether the control is disabled.
    /// </summary>
    [Parameter] public bool Disabled { get; set; }
    /// <summary>
    /// The name attribute for the input. If null, derived from the For expression.
    /// </summary>
    [Parameter] public string? Name { get; set; }
    /// <summary>
    /// Function to extract the ID/Value string from an item. 
    /// Automatically set if TItem is SelectListItem.
    /// </summary>
    [Parameter] public Func<TItem, string>? ValueSelector { get; set; }
    /// <summary>
    /// Function to extract the display text from an item.
    /// Automatically set if TItem is SelectListItem.
    /// </summary>
    [Parameter] public Func<TItem, string>? TextSelector { get; set; }
    /// <summary>
    /// Custom template for rendering dropdown options.
    /// </summary>
    [Parameter] public RenderFragment? OptionTemplate { get; set; }
    /// <summary>
    /// Custom template for rendering selected items.
    /// </summary>
    [Parameter] public RenderFragment? ItemTemplate { get; set; }
    /// <summary>
    /// Keys for assets to load. Defaults to ["TomSelect"].
    /// </summary>
    [Parameter] public string[] ComponentAssetKeys { get; set; } = ["TomSelect"];
    private string NameAttributeValue => Name ?? (For != null ? FieldIdentifier.Create(For).FieldName : string.Empty);
    // Implements IHasRzComboboxStylingProperties via InputBase.IsInvalid
    bool IHasRzComboboxStylingProperties.Invalid => IsInvalid;
    /// <summary>
    /// True if TItem is Microsoft.AspNetCore.Mvc.Rendering.SelectListItem.
    /// </summary>
    protected bool IsSelectListItem => _isSelectListItem;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element)) Element = "div";
        Placeholder ??= Localizer["RzCombobox.DefaultPlaceholder"];
        _isSelectListItem = typeof(TItem) == typeof(SelectListItem);
        UpdateConfiguration();
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (_isSelectListItem)
        {
            ValueSelector ??= i => ((SelectListItem)(object)i!).Value ?? string.Empty;
            TextSelector ??= i => ((SelectListItem)(object)i!).Text ?? string.Empty;
        }
        _effectiveOptions = Options.Clone();
        _effectiveOptions.Placeholder = Placeholder;
        if (Multiple)
        {
            _effectiveOptions.AddPlugin(new ComboboxRemoveButtonPlugin());
            _effectiveOptions.AddPlugin(new ComboboxCheckboxOptionsPlugin());
        }
        UpdateConfiguration();
    }
    private void UpdateConfiguration()
    {
        var assetUrls = ComponentAssetKeys
            .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
            .Where(url => !string.IsNullOrEmpty(url))
            .ToList();
        _assets = JsonSerializer.Serialize(assetUrls);
        _effectiveOptions.ValueField = "value";
        _effectiveOptions.LabelField = "text";
        _effectiveOptions.SearchField = ["text"]; 
        _serializedConfig = JsonSerializer.Serialize(_effectiveOptions, new JsonSerializerOptions 
        { 
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull 
        });
    }
    /// <summary>
    /// Helper to get input attributes from base, filtered for the inner select element.
    /// </summary>
    protected Dictionary<string, object?> InnerInputAttributes
    {
        get
        {
            // InputAttributes from InputBase contains validation classes and Aria attributes.
            // We generally want to pass these to the select element.
            // However, we might want to exclude 'class' if we are controlling it via SlotClasses.
            var attrs = new Dictionary<string, object?>(InputAttributes);
            attrs.Remove("class");
            return attrs;
        }
    }
    private string GetValue(TItem item) => item == null ? "" : (ValueSelector?.Invoke(item) ?? item.ToString() ?? "");
    private string GetText(TItem item) => item == null ? "" : (TextSelector?.Invoke(item) ?? item.ToString() ?? "");
    /// <summary>
    /// Determines if an item is selected.
    /// Priority:
    /// 1. If Value (bound parameter) is set, use that.
    /// 2. If Value is null AND item is SelectListItem, use SelectListItem.Selected.
    /// </summary>
    private bool IsSelected(TItem item, string val)
    {
        if (Value != null)
        {
            if (Multiple && Value is System.Collections.IEnumerable enumerable)
            {
                foreach (var v in enumerable) 
                {
                    if (v?.ToString() == val) return true;
                }
                return false;
            }
            return Value.ToString() == val;
        }
        if (_isSelectListItem && item is SelectListItem sli)
        {
            return sli.Selected;
        }
        return false;
    }
    private string SerializeItem(TItem item) => JsonSerializer.Serialize(item, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<RzComboboxSlots>, RzComboboxSlots> GetDescriptor() => Theme.RzCombobox;
}
</file>

<file path="Components/Form/RzCombobox/Styling/RzComboboxStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for the RzCombobox component.
/// </summary>
public interface IHasRzComboboxStylingProperties
{
    /// <summary>
    /// Indicates if the combobox is in an invalid state (validation error).
    /// </summary>
    public bool Invalid { get; }
}
/// <summary>
/// Defines the slots available for styling in the RzCombobox component.
/// </summary>
public sealed partial class RzComboboxSlots : ISlots
{
    /// <summary>
    /// The base slot for the component wrapper.
    /// </summary>
    [Slot("combobox")]
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the inner select element.
    /// </summary>
    [Slot("select")]
    public string? Select { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzCombobox component.
/// </summary>
public static class RzComboboxStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzCombobox component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzComboboxSlots>, RzComboboxSlots> DefaultDescriptor = new(
        @base: "w-full relative group/combobox",
        slots: new()
        {
            [s => s.Select] = "w-full"
        },
        variants: new()
        {
            [c => ((IHasRzComboboxStylingProperties)c).Invalid] = new Variant<bool, RzComboboxSlots>
            {
                [true] = new() { [s => s.Base] = "[&_.ts-control]:!border-destructive [&_.ts-control]:!ring-destructive/20" }
            }
        }
    );
}
</file>

<file path="Components/Form/RzDateEdit/RzDateEdit.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzDateEdit.Slots>

<HtmlElement Element="div"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="group" aria-label="Date picker">
	
	<div x-data="rzDateEdit"
	     data-alpine-root="@Id"
	     data-config="@_serializedConfig"
	     data-uid="@_uid"
	     data-assets="@_assets"
	     data-nonce="@Nonce">

		<div class="@SlotClasses.GetInputWrapper()" x-data="rzPrependInput" x-ref="pickerWrapper">
			@if (!string.IsNullOrEmpty(PrependText) || PrependIcon != null)
			{
				<div x-ref="prependContainer" class="@SlotClasses.GetPrependElement()">
					@if (!string.IsNullOrEmpty(PrependText))
					{
						@PrependText
					}
					else if (PrependIcon != null)
					{
						<div class="@SlotClasses.GetPrependIconContainer()">
							<Blazicon Svg="PrependIcon"/>
						</div>
					}
				</div>
			}

			<input x-ref="textInput"
			       id="@_uidInputId"
			       type="text"
			       @bind="CurrentValue"
			       placeholder="@Placeholder"
			       class="@SlotClasses.GetInput()"
			       data-input
			       aria-label="Select date"/>
		</div>
	</div>	
</HtmlElement>
</file>

<file path="Components/Form/RzDateEdit/RzDateEdit.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.Extensions.Options;
using Rizzy.Utility;
using System.Globalization;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A date input component enhanced with the Flatpickr JavaScript library for a calendar popup.
///     Supports binding to nullable DateTime and configuration via &lt;see cref="FlatpickrOptions" /&gt;.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt;. Should be used within an EditForm.
/// </xmldoc>
public sealed partial class RzDateEdit : RzComponent<RzDateEdit.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzDateEdit component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "w-full",
        slots: new()
        {
            [s => s.InputWrapper] = "relative",
            [s => s.PrependElement] = "pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3 pr-2 text-muted-foreground",
            [s => s.PrependIconContainer] = "size-4",
            [s => s.Input] = "appearance-none file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flatpickr-input"
        }
    );
    private readonly string _uid = IdGenerator.UniqueId("rzdate");
    private string _assets = "[]";
    private DateTime? _currentValue;
    private FieldIdentifier _fieldIdentifier;
    private string _inputValue = string.Empty;
    private string _serializedConfig = "{}";
    [Inject]
    private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    [CascadingParameter] private EditContext? EditContext { get; set; }
    private string _uidInputId => $"{_uid}-input";
    /// <summary>
    /// Gets or sets the expression that identifies the bound value. This is a required parameter.
    /// </summary>
    [Parameter, EditorRequired] public Expression<Func<DateTime?>>? For { get; set; }
    /// <summary>
    /// Gets or sets the configuration options for the Flatpickr instance.
    /// </summary>
    [Parameter] public FlatpickrOptions Options { get; set; } = new() { Locale = "en" };
    /// <summary>
    /// Gets or sets the placeholder text for the input field.
    /// </summary>
    [Parameter] public string Placeholder { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets optional text to prepend inside the input field's visual container.
    /// </summary>
    [Parameter] public string? PrependText { get; set; }
    /// <summary>
    /// Gets or sets an optional Blazicon SVG icon to prepend inside the input field's visual container.
    /// </summary>
    [Parameter] public SvgIcon? PrependIcon { get; set; }
    /// <summary>
    /// Gets or sets an array of logical asset keys for required JavaScript/CSS files. Defaults to ["FlatpickrCore"].
    /// </summary>
    [Parameter] public string[] ComponentAssetKeys { get; set; } = ["FlatpickrCore"];
    private string CurrentValue
    {
        get => _inputValue;
        set
        {
            if (_inputValue == value) return;
            _inputValue = value;
            if (DateTime.TryParseExact(value, GetFlatpickrFormat(), CultureInfo.InvariantCulture, DateTimeStyles.None, out var parsedDate))
                UpdateValue(parsedDate);
            else if (string.IsNullOrEmpty(value))
                UpdateValue(null);
        }
    }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null) throw new InvalidOperationException($"{GetType()} requires a 'For' parameter.");
        if (EditContext == null) throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        _currentValue = For.Compile().Invoke();
        FormatInputValue();
        SerializeConfigAndAssets();
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        var modelValue = For?.Compile().Invoke();
        if (_currentValue != modelValue)
        {
            _currentValue = modelValue;
            FormatInputValue();
        }
        SerializeConfigAndAssets();
    }
    private void UpdateValue(DateTime? newValue)
    {
        var valueChanged = _currentValue != newValue;
        _currentValue = newValue;
        if (valueChanged) EditContext?.NotifyFieldChanged(_fieldIdentifier);
    }
    private void FormatInputValue()
    {
        if (_currentValue.HasValue)
            _inputValue = _currentValue.Value.ToString(GetFlatpickrFormat(), CultureInfo.InvariantCulture);
        else
            _inputValue = string.Empty;
    }
    private string GetFlatpickrFormat() => Options.DateFormat ?? "Y-m-d";
    private void SerializeConfigAndAssets()
    {
        if (string.IsNullOrEmpty(Options.DefaultDate) && _currentValue.HasValue)
            Options.DefaultDate = _currentValue.Value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
        var alpineData = new { options = Options, placeholder = Placeholder, prependText = PrependText ?? string.Empty };
        _serializedConfig = JsonSerializer.Serialize(alpineData, new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        var assetUrls = ComponentAssetKeys
            .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
            .Where(url => !string.IsNullOrEmpty(url))
            .ToList();
        _assets = JsonSerializer.Serialize(assetUrls);
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzDateEdit;
    /// <summary>
    /// Defines the slots available for styling in the RzDateEdit component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the wrapper around the input and prepend element.
        /// </summary>
        public string? InputWrapper { get; set; }
        /// <summary>
        /// The slot for the prepend element container.
        /// </summary>
        public string? PrependElement { get; set; }
        /// <summary>
        /// The slot for the icon within the prepend element.
        /// </summary>
        public string? PrependIconContainer { get; set; }
        /// <summary>
        /// The slot for the `&lt;input&gt;` element.
        /// </summary>
        public string? Input { get; set; }
    }
}
</file>

<file path="Components/Form/RzFormSection/RzFormSection.razor">
@namespace RizzyUI
@inherits RzComponent<RzFormSection.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" class="@SlotClasses.GetBase()" id="@Id">
	<div class="@SlotClasses.GetDescriptionContainer()">
		@if (!string.IsNullOrEmpty(Title))
		{
			<h2 class="@SlotClasses.GetTitle()">@Title</h2>
		}
		@if (Description != null)
		{
			<p class="@SlotClasses.GetDescription()">
				@Description
			</p>
		}
	</div>
	<div class="@SlotClasses.GetContentContainer()">
		@Content
	</div>
</HtmlElement>
</file>

<file path="Components/Form/RzFormSection/RzFormSection.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Organizes form content into sections with an optional title and description, supporting different layouts.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzFormSection : RzComponent<RzFormSection.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzFormSection component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        slots: new()
        {
            [s => s.Title] = "text-base/7 font-semibold text-foreground",
            [s => s.Description] = "text-sm text-foreground"
        },
        variants: new()
        {
            [s => ((RzFormSection)s).Layout] = new Variant<SectionLayout, Slots>
            {
                [SectionLayout.TwoColumn] = new()
                {
                    [s => s.Base] = "md:flex md:space-x-5",
                    [s => s.DescriptionContainer] = "md:w-1/3 md:flex-none",
                    [s => s.ContentContainer] = "space-y-6 md:w-1/2"
                },
                [SectionLayout.Stacked] = new()
                {
                    [s => s.Base] = "mb-5",
                    [s => s.DescriptionContainer] = "pb-5 mb-10 border-b border-outline"
                }
            }
        }
    );
    /// <summary> The title of the form section. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Title { get; set; } = string.Empty;
    /// <summary> Optional descriptive content for the section. </summary>
    [Parameter]
    public RenderFragment? Description { get; set; }
    /// <summary> The main content of the form section (e.g., input fields). </summary>
    [Parameter]
    public RenderFragment? Content { get; set; }
    /// <summary> The layout style for the section (Stacked or TwoColumn). Defaults to TwoColumn. </summary>
    [Parameter]
    public SectionLayout Layout { get; set; } = SectionLayout.TwoColumn;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzFormSection;
    /// <summary>
    /// Defines the slots available for styling in the RzFormSection component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main section container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the container of the title and description.
        /// </summary>
        public string? DescriptionContainer { get; set; }
        /// <summary>
        /// The slot for the title element.
        /// </summary>
        public string? Title { get; set; }
        /// <summary>
        /// The slot for the description element.
        /// </summary>
        public string? Description { get; set; }
        /// <summary>
        /// The slot for the main content container.
        /// </summary>
        public string? ContentContainer { get; set; }
    }
}
</file>

<file path="Components/Form/RzInputNumber/RzInputNumber.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@inherits InputBase<TValue, RzInputNumberSlots>

<RzInputNumberBase TValue="TValue"
    @ref="_elem"
    ValueExpression="@For"
    Value="@Value"
    DisplayName="@DisplayName"
    placeholder="@Placeholder"
    @attributes="InputAttributes"
    class="@SlotClasses.GetBase()"
    id="@Id"
    data-slot="@RzInputNumberSlotNames.NameOf(RzInputNumberSlotTypes.Base)"
/>
</file>

<file path="Components/Form/RzInputNumber/RzInputNumber.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
public partial class RzInputNumber<TValue> : InputBase<TValue, RzInputNumberSlots>, IHasInputNumberStylingProperties
{
    private RzInputNumberBase<TValue>? _elem;
    [Parameter] public string? Placeholder { get; set; }
    protected override TvDescriptor<RzComponent<RzInputNumberSlots>, RzInputNumberSlots> GetDescriptor() => Theme.RzInputNumber;
}
</file>

<file path="Components/Form/RzInputNumber/Styling/RzInputNumberStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
public interface IHasInputNumberStylingProperties { }
public sealed partial class RzInputNumberSlots : ISlots
{
    [Slot("input")]
    public string? Base { get; set; }
}
public static class RzInputNumberStyles
{
    public static readonly TvDescriptor<RzComponent<RzInputNumberSlots>, RzInputNumberSlots> DefaultDescriptor = new(
        extends: FormInputStyles.DefaultDescriptor
    );
}
</file>

<file path="Components/Form/RzInputText/RzInputText.razor">
@namespace RizzyUI
@using Rizzy
@inherits InputBase<string, RzInputText.Slots>

<RzInputTextBase
    @ref="_elem"
    ValueExpression="@For"
    Value="@Value"
    DisplayName="@DisplayName"
    type="@Role.ToString().ToLowerInvariant()"
    placeholder="@Placeholder"
    @attributes="InputAttributes"
    class="@SlotClasses.GetBase()"
    id="@Id"
    data-slot="@RzInputText.SlotNames.NameOf(SlotTypes.Base)"
/>
</file>

<file path="Components/Form/RzInputText/RzInputText.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
public partial class RzInputText : InputBase<string, RzInputText.Slots>
{
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor =
        new(extends: FormInputStyles.DefaultDescriptor);
    private RzInputTextBase? _elem;
    [Parameter] public TextRole Role { get; set; } = TextRole.Text;
    [Parameter] public string? Placeholder { get; set; }
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzInputText;
    public sealed partial class Slots : ISlots
    {
        [Slot("input")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzInputTextArea/RzInputTextArea.razor">
@namespace RizzyUI
@using Rizzy
@inherits InputBase<string, RzInputTextArea.Slots>

<RzInputTextAreaBase
    @ref="_elem"
    ValueExpression="@For"
    Value="@Value"
    DisplayName="@DisplayName"
    placeholder="@Placeholder"
    @attributes="InputAttributes"
    class="@SlotClasses.GetBase()"
    id="@Id"
    data-slot="@RzInputTextArea.SlotNames.NameOf(SlotTypes.Base)"
/>
</file>

<file path="Components/Form/RzInputTextArea/RzInputTextArea.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
public partial class RzInputTextArea : InputBase<string, RzInputTextArea.Slots>
{
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        extends: FormInputStyles.DefaultDescriptor,
        @base: "flex field-sizing-content min-h-16 resize-none"
    );
    private RzInputTextAreaBase? _elem;
    [Parameter] public string? Placeholder { get; set; }
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzInputTextArea;
    public sealed partial class Slots : ISlots
    {
        [Slot("textarea")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelect.razor">
@namespace RizzyUI
@typeparam TValue
@using Blazicons
@using Rizzy.Components
@inherits InputBase<TValue, RzNativeSelectSlots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@($"{Id}-wrapper")" class="@SlotClasses.GetBase()">
    <InputSelect TValue="TValue"
                 Value="@Value"
                 ValueChanged="@ValueChanged"
                 ValueExpression="@For"
                 @attributes="SanitizedInputAttributes"
                 class="@SlotClasses.GetSelect()"
                 id="@Id"
                 data-slot="native-select">
        @ChildContent
    </InputSelect>
    <Blazicon Svg="@Lucide.ChevronDown" class="@SlotClasses.GetIcon()" aria-hidden="true" data-slot="native-select-icon" />
</HtmlElement>
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelect.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A form component that renders a native &lt;select&gt; element with custom styling matching the design system.
/// Supports generic value binding.
/// </summary>
/// <typeparam name="TValue">The type of the value being bound (e.g., string, int, enum).</typeparam>
public partial class RzNativeSelect<TValue> : InputBase<TValue, RzNativeSelectSlots>, IHasRzNativeSelectStylingProperties
{
    /// <summary>
    /// Gets or sets the child content, typically <see cref="RzNativeSelectOption"/> or <see cref="RzNativeSelectOptGroup"/> components,
    /// or standard HTML &lt;option&gt; elements.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets an event callback that is invoked when the value changes.
    /// </summary>
    [Parameter] public EventCallback<TValue> ValueChanged { get; set; }
    /// <summary>
    /// Gets the input attributes with 'class' and 'style' removed to prevent duplication on the inner select element,
    /// as these are applied to the wrapper via AdditionalAttributes.
    /// </summary>
    protected Dictionary<string, object?> SanitizedInputAttributes
    {
        get
        {
            var attrs = new Dictionary<string, object?>(InputAttributes);
            attrs.Remove("class");
            attrs.Remove("style");
            return attrs;
        }
    }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // No specific AriaLabel default needed as InputBase doesn't enforce it, but we can set one if desired.
        // If specific ARIA handling is needed, it can be added here.
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<RzNativeSelectSlots>, RzNativeSelectSlots> GetDescriptor() => Theme.RzNativeSelect;
}
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelectOptGroup.razor">
@namespace RizzyUI
@inherits RzComponent

<optgroup @attributes="AdditionalAttributes" data-slot="native-select-optgroup">
    @ChildContent
</optgroup>
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelectOptGroup.razor.cs">
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
/// Represents a group of options within a <see cref="RzNativeSelect{TValue}"/>.
/// Renders a standard HTML &lt;optgroup&gt; tag with the appropriate data-slot attribute.
/// </summary>
public partial class RzNativeSelectOptGroup : RzComponent
{
    /// <summary>
    /// Gets or sets the content of the group (options).
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the label for the group.
    /// </summary>
    [Parameter] public string? Label { get; set; }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (Label != null)
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            AdditionalAttributes["label"] = Label;
        }
    }
}
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelectOption.razor">
@namespace RizzyUI
@inherits RzComponent

<option @attributes="AdditionalAttributes" data-slot="native-select-option">
    @ChildContent
</option>
</file>

<file path="Components/Form/RzNativeSelect/RzNativeSelectOption.razor.cs">
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
/// Represents an option within a <see cref="RzNativeSelect{TValue}"/>.
/// Renders a standard HTML &lt;option&gt; tag with the appropriate data-slot attribute.
/// </summary>
public partial class RzNativeSelectOption : RzComponent
{
    /// <summary>
    /// Gets or sets the content of the option.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the value of the option.
    /// </summary>
    [Parameter] public object? Value { get; set; }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (Value != null)
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            AdditionalAttributes["value"] = Value;
        }
    }
}
</file>

<file path="Components/Form/RzNativeSelect/Styling/RzNativeSelectStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a RzNativeSelect component.
/// </summary>
public interface IHasRzNativeSelectStylingProperties { }
/// <summary>
/// Defines the slots available for styling in the RzNativeSelect component.
/// </summary>
public sealed partial class RzNativeSelectSlots : ISlots
{
    /// <summary>
    /// The base slot for the wrapper div.
    /// </summary>
    [Slot("native-select-wrapper")]
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the select element.
    /// </summary>
    [Slot("native-select")]
    public string? Select { get; set; }
    /// <summary>
    /// The slot for the chevron icon.
    /// </summary>
    [Slot("native-select-icon")]
    public string? Icon { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzNativeSelect component.
/// </summary>
public static class RzNativeSelectStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzNativeSelect component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzNativeSelectSlots>, RzNativeSelectSlots> DefaultDescriptor = new(
        @base: "group/native-select relative w-fit has-[select:disabled]:opacity-50",
        slots: new()
        {
            [s => s.Select] = "border-input placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 dark:hover:bg-input/50 h-9 w-full min-w-0 appearance-none rounded-md border bg-transparent bg-none px-3 py-2 pr-9 text-sm shadow-xs transition-[color,box-shadow] outline-none disabled:pointer-events-none disabled:cursor-not-allowed focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
            [s => s.Icon] = "text-muted-foreground pointer-events-none absolute top-1/2 right-3.5 size-4 -translate-y-1/2 opacity-50 select-none"
        }
    );
}
</file>

<file path="Components/Form/RzRadioGroup/RadioGroupItem.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@using Rizzy.Components.Form
@inherits RzComponent<RadioGroupItemSlots>

<label @attributes="AdditionalAttributes"
       id="@Id"
       class="@SlotClasses.GetBase()"
       data-slot="@RadioGroupItemSlotNames.NameOf(RadioGroupItemSlotTypes.Base)"
       aria-disabled=@Disabled>
    <RzInputRadioBase TValue="TValue"
                      @ref="_elem"
                      Value="@Value"
                      class="@SlotClasses.GetInput()"
                      data-slot="@RadioGroupItemSlotNames.NameOf(RadioGroupItemSlotTypes.Input)"
                      disabled="@Disabled" />
    @if (!_hasExplicitIndicator)
    {
        <RadioGroupItemIndicator />
    }
    <CascadingValue Value="this" IsFixed="true">
        @ChildContent
    </CascadingValue>
</label>
</file>

<file path="Components/Form/RzRadioGroup/RadioGroupItem.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines the contract for a RadioGroupItem that an indicator can register with.
/// </summary>
internal interface IRadioGroupItem
{
    /// <summary>
    /// Allows a child indicator to notify the parent item of its existence.
    /// </summary>
    void RegisterIndicator();
}
public partial class RadioGroupItem<TValue> : RzComponent<RadioGroupItemSlots>, IHasRadioGroupItemStylingProperties, IRadioGroupItem
{
    private RzInputRadioBase<TValue>? _elem;
    private bool _hasExplicitIndicator = false;
    [Parameter] public TValue? Value { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether this item is disabled.
    /// </summary>
    [Parameter] public bool Disabled { get; set; }
    /// <summary>
    /// Internal method for child indicators to register their presence.
    /// </summary>
    public void RegisterIndicator()
    {
        if (!_hasExplicitIndicator)
        {
            _hasExplicitIndicator = true;
            StateHasChanged();
        }
    }
    protected override TvDescriptor<RzComponent<RadioGroupItemSlots>, RadioGroupItemSlots> GetDescriptor() => Theme.RadioGroupItem;
}
</file>

<file path="Components/Form/RzRadioGroup/RadioGroupItemIndicator.razor">
@namespace RizzyUI
@inherits RzComponent<RadioGroupItemIndicator.Slots>

@if (ShowIndicators)
{
    <div @attributes="AdditionalAttributes" class="@SlotClasses.GetBase()" data-slot="@RadioGroupItemIndicator.SlotNames.NameOf(SlotTypes.Base)">
        @if (ChildContent is null)
        {
            <div class="@SlotClasses.GetDot()" data-slot="@RadioGroupItemIndicator.SlotNames.NameOf(SlotTypes.Dot)"></div>
        }
        else
        {
            <div class="@SlotClasses.GetCustomContentWrapper()" data-slot="@RadioGroupItemIndicator.SlotNames.NameOf(SlotTypes.CustomContentWrapper)">
                @ChildContent
            </div>
        }
    </div>
}
</file>

<file path="Components/Form/RzRadioGroup/RadioGroupItemIndicator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
public partial class RadioGroupItemIndicator : RzComponent<RadioGroupItemIndicator.Slots>
{
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative flex size-4 shrink-0 items-center justify-center rounded-full border border-input bg-background group-has-[.peer:focus-visible]:ring-2 group-has-[.peer:focus-visible]:ring-ring group-has-[.peer:focus-visible]:ring-offset-2 group-has-[.peer:checked]:border-primary",
        slots: new()
        {
            [s => s.Dot] = "pointer-events-none absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 size-2 rounded-full bg-primary opacity-0 transition-opacity group-has-[.peer:checked]:opacity-100",
            [s => s.CustomContentWrapper] = "pointer-events-none absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 opacity-0 transition-opacity group-has-[.peer:checked]:opacity-100"
        }
    );
    [CascadingParameter] private IRadioGroupItem? ParentItem { get; set; }
    [CascadingParameter(Name = "ShowIndicators")] private bool ShowIndicators { get; set; } = true;
    /// <summary>
    /// Gets or sets the custom content to be rendered inside the indicator when the item is checked.
    /// If not provided, a default dot will be rendered.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    protected override void OnInitialized()
    {
        base.OnInitialized();
        ParentItem?.RegisterIndicator();
    }
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RadioGroupItemIndicator;
    public sealed partial class Slots : ISlots
    {
        [Slot("indicator-wrapper")]
        public string? Base { get; set; }
        [Slot("indicator")]
        public string? Dot { get; set; }
        [Slot("custom-indicator")]
        public string? CustomContentWrapper { get; set; }
    }
}
</file>

<file path="Components/Form/RzRadioGroup/RzRadioGroup.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@using Rizzy.Components.Form
@inherits RzComponent<RzRadioGroupSlots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@Id" 
             class="@SlotClasses.GetBase()" 
             data-slot="@RzRadioGroupSlotNames.NameOf(RzRadioGroupSlotTypes.Base)" 
             role="radiogroup"
             aria-labelledby="@_legendId">
    <legend id="@_legendId" class="sr-only">@DisplayName</legend>
    <CascadingValue Value="ShowIndicators" Name="ShowIndicators">
        <RzInputRadioGroupBase TValue="TValue"
                               ValueExpression="@For"
                               Value="CurrentValue"
                               Name="@Name">
            @ChildContent
        </RzInputRadioGroupBase>
    </CascadingValue>
</HtmlElement>
</file>

<file path="Components/Form/RzRadioGroup/RzRadioGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Rizzy.Utility;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
public partial class RzRadioGroup<TValue> : RzComponent<RzRadioGroupSlots>, IHasRadioGroupStylingProperties
{
    private TValue? _currentValue;
    private FieldIdentifier _fieldIdentifier;
    private readonly string _legendId = IdGenerator.UniqueId("rz-rg-legend");
    [CascadingParameter] private EditContext? EditContext { get; set; }
    [Parameter, EditorRequired] public Expression<Func<TValue>> For { get; set; } = default!;
    [Parameter] public TValue? Value { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public string Name { get; set; } = string.Empty;
    [Parameter] public string? DisplayName { get; set; }
    [Parameter] public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary>
    /// Gets or sets a value indicating whether to show the indicators for each radio item.
    /// Defaults to true.
    /// </summary>
    [Parameter] public bool ShowIndicators { get; set; } = true;
    protected TValue? CurrentValue
    {
        get => _currentValue;
        set
        {
            if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, value))
            {
                _currentValue = value;
            }
        }
    }
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "fieldset";
        if (For == null) throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null) throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        _currentValue = Value ?? For.Compile().Invoke();
        if (string.IsNullOrEmpty(Name))
        {
            Name = _fieldIdentifier.FieldName;
        }
    }
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        var newValue = Value ?? For!.Compile().Invoke();
        if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, newValue))
        {
            _currentValue = newValue;
        }
    }
    protected override TvDescriptor<RzComponent<RzRadioGroupSlots>, RzRadioGroupSlots> GetDescriptor() => Theme.RzRadioGroup;
}
</file>

<file path="Components/Form/RzRadioGroup/Styling/RadioGroupItemStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
public interface IHasRadioGroupItemStylingProperties
{
    public bool Disabled { get; }
}
public sealed partial class RadioGroupItemSlots : ISlots
{
    [Slot("radio-group-item")]
    public string? Base { get; set; }
    [Slot("input")]
    public string? Input { get; set; }
}
public static class RadioGroupItemStyles
{
    public static readonly TvDescriptor<RzComponent<RadioGroupItemSlots>, RadioGroupItemSlots> DefaultDescriptor = new(
        @base: "group relative flex items-center gap-3 cursor-pointer",
        slots: new()
        {
            [s => s.Input] = "peer sr-only"
        },
        variants: new()
        {
            [c => ((IHasRadioGroupItemStylingProperties)c).Disabled] = new Variant<bool, RadioGroupItemSlots>
            {
                [true] = new() { [s => s.Base] = "cursor-not-allowed opacity-50" }
            }
        }
    );
}
</file>

<file path="Components/Form/RzRadioGroup/Styling/RzRadioGroupStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
public interface IHasRadioGroupStylingProperties
{
    /// <summary>
    /// Orientation (horizontal or vertical) of radio group
    /// </summary>
    Orientation Orientation { get; set; }
}
public sealed partial class RzRadioGroupSlots : ISlots
{
    [Slot("radio-group")]
    public string? Base { get; set; }
}
public static class RzRadioGroupStyles
{
    public static readonly TvDescriptor<RzComponent<RzRadioGroupSlots>, RzRadioGroupSlots> DefaultDescriptor = new(
        @base: "gap-2",
        variants: new()
        {
            [c => ((IHasRadioGroupStylingProperties)c).Orientation] = new Variant<Orientation, RzRadioGroupSlots>
            {
                [Orientation.Horizontal] = new() { [s => s.Base] = "flex flex-row space-x-4" },
                [Orientation.Vertical] = new() { [s => s.Base] = "grid" },
            }
        }
    );
}
</file>

<file path="Components/Form/RzSwitch/RzSwitch.razor">
@namespace RizzyUI
@inherits InputBase<bool, RzSwitchSlots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@($"{Id}-wrapper")" class="@SlotClasses.GetBase()">
    <InputCheckbox
        ValueExpression="@For"
        Value="@Value"
        DisplayName="@DisplayName"
        @attributes="InputAttributes"
        class="@SlotClasses.GetInput()"
        id="@Id"
        role="switch"
        aria-label="@AriaLabel"
    />
    <label for="@Id" class="@SlotClasses.GetTrack()">
        <span class="@SlotClasses.GetThumb()"></span>
    </label>
</HtmlElement>
</file>

<file path="Components/Form/RzSwitch/RzSwitch.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using System.Linq.Expressions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A control that allows the user to toggle between checked and unchecked states.
/// </summary>
public partial class RzSwitch : InputBase<bool, RzSwitchSlots>, IHasRzSwitchStylingProperties
{
    /// <summary>
    /// Gets or sets the accessible label for the switch.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzSwitch.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSwitch.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<RzSwitchSlots>, RzSwitchSlots> GetDescriptor() => Theme.RzSwitch;
}
</file>

<file path="Components/Form/RzSwitch/Styling/RzSwitchStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines styling properties for a RzSwitch component.
/// </summary>
public interface IHasRzSwitchStylingProperties { }
/// <summary>
/// Defines the slots available for styling in the RzSwitch component.
/// </summary>
public sealed partial class RzSwitchSlots : ISlots
{
    /// <summary>
    /// The base slot for the main switch wrapper.
    /// </summary>
    [Slot("switch-wrapper")]
    public string? Base { get; set; }
    /// <summary>
    /// The slot for the hidden input element.
    /// </summary>
    [Slot("input")]
    public string? Input { get; set; }
    /// <summary>
    /// The slot for the visible track of the switch.
    /// </summary>
    [Slot("track")]
    public string? Track { get; set; }
    /// <summary>
    /// The slot for the thumb (the sliding part) of the switch.
    /// </summary>
    [Slot("thumb")]
    public string? Thumb { get; set; }
}
/// <summary>
/// Provides the default styling descriptor for the RzSwitch component.
/// </summary>
public static class RzSwitchStyles
{
    /// <summary>
    /// The default TvDescriptor for the RzSwitch component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<RzSwitchSlots>, RzSwitchSlots> DefaultDescriptor = new(
        @base: "group relative inline-flex items-center",
        slots: new()
        {
            [s => s.Input] = "peer sr-only",
            [s => s.Track] = 
                "cursor-pointer " +
                "inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none " +
                "bg-input dark:bg-input/80 " + // Default unchecked background
                "peer-checked:bg-primary " + // Checked background
                "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] " +
                "peer-disabled:cursor-not-allowed peer-disabled:opacity-50 " +
                // Thumb position logic applied to track to target child span
                "peer-checked:[&>span]:translate-x-[calc(100%-2px)] " +
                // Thumb dark mode color logic applied to track to target child span
                "dark:peer-checked:[&>span]:bg-primary-foreground",
            [s => s.Thumb] = 
                "pointer-events-none block size-4 rounded-full ring-0 shadow-sm transition-transform " +
                "bg-background dark:bg-foreground " + // Default thumb color
                "translate-x-0" // Default position
        }
    );
}
</file>

<file path="Components/Form/Styling/FormInputStyles.cs">
using TailwindVariants.NET;
namespace RizzyUI;
public interface IHasFormInputStylingProperties { }
public sealed partial class FormInputSlots : ISlots
{
    [Slot("input")]
    public string? Base { get; set; }
}
public static class FormInputStyles
{
    public static readonly TvDescriptor<RzComponent<FormInputSlots>, FormInputSlots> DefaultDescriptor = new(
        @base: "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive"
    );
}
</file>

<file path="Components/FragmentComponent.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <summary>
///     Component that encapsulates a RenderFragment for use as a partial or child component.
/// </summary>
public class FragmentComponent : ComponentBase
{
    /// <summary>
    ///     Fragment to render
    /// </summary>
    [Parameter]
    public RenderFragment? Fragment { get; set; }
    /// <summary>
    ///     Construct a component from a fragment
    /// </summary>
    /// <param name="builder">The <see cref="RenderTreeBuilder"/> to use for rendering.</param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        if (Fragment != null) builder.AddContent(0, Fragment);
    }
}
</file>

<file path="Components/HtmlElement.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <summary>
///     A generic Blazor component that renders a specified HTML element with optional content and attributes.
/// </summary>
public sealed class HtmlElement : ComponentBase
{
    /// <summary>
    ///     Specifies the root HTML element to render (e.g., "div", "a", "button").
    ///     If not set, defaults to "div".
    /// </summary>
    [Parameter]
    public string Element { get; set; } = "div";
    /// <summary>
    ///     Represents the content to be rendered inside the HTML element.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     A collection of additional attributes to apply to the HTML element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object>? AdditionalAttributes { get; set; }
    /// <summary>
    ///     Builds the component's render tree.
    /// </summary>
    /// <param name="builder">An instance of <see cref="RenderTreeBuilder" /> used to build the render tree.</param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        var elementName = Element ?? "div";
        builder.OpenElement(0, elementName);
        builder.AddMultipleAttributes(1, AdditionalAttributes);
        builder.AddContent(3, ChildContent);
        builder.CloseElement();
    }
}
</file>

<file path="Components/Interactivity/RzAlpineComponent.razor">
@namespace RizzyUI
@inherits RzAsChildComponent
@using System.Text.Json

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}

@if (Props is not null)
{
    <script type="application/json" id="@_propsScriptId" nonce="@Nonce">
        @((MarkupString)_serializedProps)
    </script>
}

@if (!string.IsNullOrEmpty(_modulePath))
{
    <script nonce="@Nonce">
        if (window.Rizzy) 
            window.Rizzy.registerAsyncComponent('@Name', '@_modulePath');
        else 
            document.addEventListener("rz:init", e => e.detail.Rizzy.registerAsyncComponent('@Name', '@_modulePath'), { once: true });
    </script>
}
</file>

<file path="Components/Interactivity/RzAlpineComponent.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Collections.Concurrent;
using System.Reflection;
using System.Text.Json;
namespace RizzyUI;
/// <xmldoc>
/// A component that bridges a server-rendered Blazor component with a co-located JavaScript module,
/// registering it as an `async-alpine` component. It can render as a wrapper `div` or, using the `AsChild` pattern,
/// merge its Alpine-related attributes directly onto its single child element.
/// </xmldoc>
/// <remarks>
/// This component is the cornerstone of RizzyUI's "Alpine Code-Behind" feature. It requires the Blazor component
/// specified in the `For` parameter to be decorated with the `[RzAlpineCodeBehind]` attribute.
/// </remarks>
public partial class RzAlpineComponent : RzAsChildComponent
{
    private static readonly ConcurrentDictionary<Type, string?> _pathCache = new();
    private string? _modulePath;
    private string _serializedProps = "{}";
    private string _propsScriptId = string.Empty;
    /// <summary>
    /// A reference to the Blazor component instance that has a co-located `.razor.js` file. This is required.
    /// </summary>
    [Parameter, EditorRequired] public object For { get; set; } = default!;
    /// <summary>
    /// The name to register the Alpine.js component with. This name will be used in the `x-data` attribute. This is required.
    /// </summary>
    [Parameter, EditorRequired] public string Name { get; set; } = string.Empty;
    /// <summary>
    /// An optional C# object that will be serialized to JSON and passed to the Alpine component's factory function.
    /// </summary>
    [Parameter] public object? Props { get; set; }
    /// <summary>
    /// An optional loading strategy for `async-alpine`, corresponding to the `x-load` attribute (e.g., "visible", "idle").
    /// </summary>
    [Parameter] public string? LoadStrategy { get; set; }
    /// <summary>
    /// The child content to be rendered within the Alpine-enabled element.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        _propsScriptId = $"{Id}-props";
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        if (For is null) throw new InvalidOperationException("'For' is required.");
        if (string.IsNullOrWhiteSpace(Name)) throw new InvalidOperationException("'Name' is required.");
        _modulePath = _pathCache.GetOrAdd(For.GetType(), GetComponentModulePath);
        if (Props is not null)
        {
            _serializedProps = JsonSerializer.Serialize(Props, new JsonSerializerOptions(JsonSerializerDefaults.Web));
        }
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = AdditionalAttributes?.GetValueOrDefault("class", string.Empty)?.ToString(),
            ["data-alpine-root"] = Id,
            ["x-data"] = Name,
            ["x-load"] = string.IsNullOrWhiteSpace(LoadStrategy) ? string.Empty : LoadStrategy,
        };
        if (Props is not null)
        {
            attributes["data-props-id"] = _propsScriptId;
        }
        return attributes;
    }
    private static string? GetComponentModulePath(Type componentType)
    {
        var assembly = componentType.Assembly;
        _ = typeof(AssemblyRzAlpineCodeBehindAttribute);
        var assemblyAttr = assembly.GetCustomAttribute<AssemblyRzAlpineCodeBehindAttribute>()
            ?? throw new InvalidOperationException($"[AssemblyRzAlpineCodeBehindAttribute] missing on '{assembly.FullName}'.");
        var componentAttr = componentType.GetCustomAttribute<RzAlpineCodeBehindAttribute>();
        if (componentAttr?.RazorFilePath is null) return null;
        var razorFilePath = componentAttr.RazorFilePath;
        var pathPrefix = assemblyAttr.CallerFileNamePathPrefix;
        if (!razorFilePath.StartsWith(pathPrefix, StringComparison.Ordinal))
            throw new InvalidOperationException($"Cannot compute relative path for '{componentType.FullName}'. File '{razorFilePath}' does not start with prefix '{pathPrefix}'.");
        var relative = razorFilePath.Substring(pathPrefix.Length);
        var jsPath = Path.ChangeExtension(relative, ".razor.js");
        var webPath = jsPath.Replace(Path.DirectorySeparatorChar, '/');
        return BuildAbsoluteUrl(assemblyAttr.StaticWebAssetBasePath, webPath);
    }
    private static string BuildAbsoluteUrl(string? basePath, string relativePath)
    {
        var b = (basePath ?? string.Empty).Trim('/');
        var r = relativePath.TrimStart('/');
        return "/" + (string.IsNullOrEmpty(b) ? r : $"{b}/{r}");
    }
}
</file>

<file path="Components/Layout/RzAccordion/AccordionItem.razor">
@namespace RizzyUI
@inherits RzComponent<AccordionItem.Slots>

<div x-data="accordionItem" @attributes="@AdditionalAttributes" x-ref="@SectionId" data-is-open="@((!Collapsed).ToString().ToLowerInvariant())"
     data-section-id="@SectionId"
     data-expanded-class="@SlotClasses.GetChevronIconExpanded()"
     class="@SlotClasses.GetBase()" data-slot="accordion-item">
	<button id="@ButtonId" type="button" class="@SlotClasses.GetButton()" aria-controls="@ContentId"
	        x-on:click="toggle" :aria-expanded="getAriaExpanded" data-slot="accordion-trigger">
		@if (AccordionTrigger != null)
		{
			@AccordionTrigger
		}
		else
		{
			@Title
		}
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-width="2"
		     stroke="currentColor" class="@SlotClasses.GetChevronIcon() motion-safe:transition-transform" aria-hidden="true"
		     :class="getExpandedCss">
			<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"/>
		</svg>
	</button>
	<div id="@ContentId" role="region" aria-labelledby="@ButtonId"
	     x-cloak x-show="open" x-collapse
         class="@SlotClasses.GetContentContainerWrapper()" data-slot="accordion-content">
		<div class="@SlotClasses.GetContentContainer()">
			@AccordionContent
		</div>
	</div>
</div>
</file>

<file path="Components/Layout/RzAccordion/AccordionItem.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents a section of an accordion component (<see cref="RzAccordion" />) that can be expanded or collapsed
///     to show or hide its content. Styling is managed by the active <see cref="RzTheme" />.
///     Interactivity is managed by the 'accordionItem' Alpine.js component.
/// </xmldoc>
public partial class AccordionItem : RzComponent<AccordionItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the AccordionItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "border-b last:border-b-0",
        slots: new()
        {
            [s => s.Button] = "flex flex-1 items-start justify-between gap-4 py-4 text-left text-sm font-medium hover:underline w-full focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] transition-all outline-none rounded-md",
            [s => s.ContentContainerWrapper] = "pb-4",
            [s => s.ContentContainer] = "text-sm",
            [s => s.ChevronIcon] = "text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200",
            [s => s.ChevronIconExpanded] = "group-open:rotate-180"
        }
    );
    private string SectionId { get; } = IdGenerator.UniqueId("rzaccsec");
    /// <summary> Gets the unique ID for the button element. </summary>
    protected string ButtonId => $"rzaccordion-button-{SectionId}";
    /// <summary> Gets the unique ID for the content container element. </summary>
    protected string ContentId => $"rzaccordion-content-{SectionId}";
    /// <summary> The title displayed in the clickable header of the accordion section (if AccordionTrigger is not defined). </summary>
    [Parameter]
    public string Title { get; set; } = string.Empty;
    /// <summary> Determines if the section is initially collapsed (true) or expanded (false). Defaults to true. </summary>
    [Parameter]
    public bool Collapsed { get; set; } = true;
    /// <summary> The content to be displayed inside the accordion (overrides Title if set). </summary>
    [Parameter]
    public RenderFragment? AccordionTrigger { get; set; }
    /// <summary> The content to be displayed inside the section when it is expanded. </summary>
    [Parameter]
    public RenderFragment? AccordionContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.AccordionItem;
    /// <summary>
    /// Defines the slots available for styling in the AccordionItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the trigger button.
        /// </summary>
        public string? Button { get; set; }
        /// <summary>
        /// The slot for the wrapper around the content container.
        /// </summary>
        public string? ContentContainerWrapper { get; set; }
        /// <summary>
        /// The slot for the main content container.
        /// </summary>
        public string? ContentContainer { get; set; }
        /// <summary>
        /// The slot for the chevron icon.
        /// </summary>
        public string? ChevronIcon { get; set; }
        /// <summary>
        /// The slot for the expanded state of the chevron icon.
        /// </summary>
        public string? ChevronIconExpanded { get; set; }
    }
}
</file>

<file path="Components/Layout/RzAccordion/RzAccordion.razor">
@namespace RizzyUI
@inherits RzComponent<RzAccordion.Slots>

<HtmlElement Element="div"
             @attributes="@AdditionalAttributes"
             class="@SlotClasses.GetBase()">
	<div x-data="rzAccordion" data-alpine-root="@Id" data-multiple="@(Type == AccordionType.Multiple ? "true" : "false")" data-slot="accordion">
		@ChildContent
	</div>
</HtmlElement>
</file>

<file path="Components/Layout/RzAccordion/RzAccordion.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents an accordion component that allows for collapsible sections. Styling is handled by the active theme.
///     Interactivity is managed by the 'rzAccordion' Alpine.js component.
/// </xmldoc>
public partial class RzAccordion : RzComponent<RzAccordion.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzAccordion component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "w-full"
    );
    /// <summary> When true, multiple sections may be open simultaneously. </summary>
    [Parameter]
    public AccordionType Type { get; set; }
    /// <summary> Child content containing one or more AccordionItem components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzAccordion;
    /// <summary>
    /// Defines the slots available for styling in the RzAccordion component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzAspectRatio/RzAspectRatio.razor">
@namespace RizzyUI
@using System.Globalization
@inherits RzComponent<RzAspectRatio.Slots>

<HtmlElement Element="@EffectiveElement"
             id="@Id"
             class="@SlotClasses.GetBase()"
             @attributes="@AdditionalAttributes"
             data-slot="aspect-ratio-wrapper"
             x-data="rzAspectRatio"
             data-alpine-root="@Id"
             data-ratio="@Ratio.ToString(CultureInfo.InvariantCulture)">
    <div class="@SlotClasses.GetInner()" data-slot="aspect-ratio-inner">
        @ChildContent
    </div>
</HtmlElement>
</file>

<file path="Components/Layout/RzAspectRatio/RzAspectRatio.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container that maintains a specific aspect ratio for its content.
/// </summary>
/// <remarks>
/// As a root-level component, its name is prefixed with 'Rz'.
/// </remarks>
public partial class RzAspectRatio : RzComponent<RzAspectRatio.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzAspectRatio component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative w-full",
        slots: new()
        {
            [s => s.Inner] = "absolute inset-0"
        }
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the aspect ratio container.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the desired aspect ratio, calculated as width / height.
    /// Defaults to 1 (a square).
    /// </summary>
    [Parameter] public double Ratio { get; set; } = 1;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzAspectRatio;
    /// <summary>
    /// Defines the slots available for styling in the RzAspectRatio component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner content wrapper.
        /// </summary>
        public string? Inner { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardAction.razor">
@namespace RizzyUI
@inherits RzComponent<CardAction.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-action">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardAction.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A container specifically for placing buttons within an <see cref="CardHeader" /> or <see cref="CardFooter" />.
///     Provides appropriate layout styling based on the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardAction : RzComponent<CardAction.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardAction component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "col-start-2 row-span-2 row-start-1 self-start justify-self-end"
    );
    /// <summary> The buttons or other action elements to be rendered within this container. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardAction;
    /// <summary>
    /// Defines the slots available for styling in the CardAction component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardContent.razor">
@namespace RizzyUI
@inherits RzComponent<CardContent.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-content">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the main content area of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardContent : RzComponent<CardContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "px-6"
    );
    /// <summary> The content to be rendered inside the card body. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "section";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardContent;
    /// <summary>
    /// Defines the slots available for styling in the CardContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardDescription.razor">
@namespace RizzyUI
@inherits RzComponent<CardDescription.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-description">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents a description within an <see cref="CardHeader" />. Typically renders as a p element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardDescription : RzComponent<CardDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground text-sm"
    );
    /// <summary> The text or content to be rendered as the card description. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p"; // Default element for a description
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardDescription;
    /// <summary>
    /// Defines the slots available for styling in the CardDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardFooter.razor">
@namespace RizzyUI
@inherits RzComponent<CardFooter.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-footer">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the footer section of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardFooter : RzComponent<CardFooter.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardFooter component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex items-center px-6 [.border-t]:pt-6"
    );
    /// <summary> The content to be rendered inside the card footer. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "footer";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardFooter;
    /// <summary>
    /// Defines the slots available for styling in the CardFooter component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardHeader.razor">
@namespace RizzyUI
@inherits RzComponent<CardHeader.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-header">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the header section of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardHeader : RzComponent<CardHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6"
    );
    /// <summary> The content to be rendered inside the card header. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "header";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardHeader;
    /// <summary>
    /// Defines the slots available for styling in the CardHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/CardTitle.razor">
@namespace RizzyUI
@inherits RzComponent<CardTitle.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-title">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/CardTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents the main title within an <see cref="CardHeader" />. Typically renders as an H2 element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class CardTitle : RzComponent<CardTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the CardTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "leading-none font-semibold"
    );
    /// <summary> The text or content to be rendered as the card title. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "h2"; // Default element for a title
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CardTitle;
    /// <summary>
    /// Defines the slots available for styling in the CardTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCard/RzCard.razor">
@namespace RizzyUI
@inherits RzComponent<RzCard.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="card-card">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCard.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A flexible container component for displaying content in a card format.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCard : RzComponent<RzCard.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCard component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col gap-6 rounded-xl border py-6 shadow-sm bg-card text-card-foreground"
    );
    /// <summary> The content to be rendered inside the card. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCard;
    /// <summary>
    /// Defines the slots available for styling in the RzCard component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCarousel/CarouselContent.razor">
@namespace RizzyUI
@inherits RzComponent<CarouselContent.Slots>

<div class="@SlotClasses.GetViewport()" x-ref="viewport">
    <HtmlElement Element="@EffectiveElement"
                 @attributes="AdditionalAttributes"
                 id="@Id"
                 class="@SlotClasses.GetBase()"
                 x-ref="container">
        @ChildContent
    </HtmlElement>
</div>
</file>

<file path="Components/Layout/RzCarousel/CarouselContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the carousel items. This component is the scrollable area managed by Embla Carousel.
/// </summary>
public partial class CarouselContent : RzComponent<CarouselContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the CarouselContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex",
        slots: new()
        {
            [s => s.Viewport] = "overflow-hidden"
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzCarousel"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCarousel? ParentCarousel { get; set; }
    /// <summary>
    /// Gets or sets the content of the carousel, which should be a series of <see cref="CarouselItem"/> components.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCarousel == null)
        {
            throw new InvalidOperationException($"{nameof(CarouselContent)} must be used within an {nameof(RzCarousel)}.");
        }
        Element = "div";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CarouselContent;
    /// <summary>
    /// Defines the slots available for styling in the CarouselContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main content container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the viewport wrapper.
        /// </summary>
        public string? Viewport { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCarousel/CarouselItem.razor">
@namespace RizzyUI
@inherits RzComponent<CarouselItem.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="group"
             aria-roledescription="slide">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCarousel/CarouselItem.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A wrapper for a single slide within the carousel.
/// </summary>
public partial class CarouselItem : RzComponent<CarouselItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the CarouselItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "min-w-0 shrink-0 grow-0 basis-full"
    );
    /// <summary>
    /// Gets or sets the content of the carousel item.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CarouselItem;
    /// <summary>
    /// Defines the slots available for styling in the CarouselItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCarousel/CarouselNext.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzAsChildComponent<CarouselNext.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @if (ChildContent is not null)
        {
            @ChildContent
        }
        else
        {
            <Blazicon Svg="Lucide.ArrowRight" class="@SlotClasses.GetButtonIcon()" />
            <span class="sr-only">@AriaLabel</span>
        }
    </HtmlElement>
}
</file>

<file path="Components/Layout/RzCarousel/CarouselNext.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A button to navigate to the next slide in the carousel.
/// </summary>
public partial class CarouselNext : RzAsChildComponent<CarouselNext.Slots>
{
    /// <summary>
    /// Defines the default styling for the CarouselNext component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute size-8 rounded-full top-1/2 -translate-y-1/2 right-0 inline-flex items-center justify-center border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50",
        slots: new()
        {
            [s => s.ButtonIcon] = "h-4 w-4"
        }
    );
    /// <summary>
    /// Gets or sets the content of the button. If not provided, a default icon is used.
    /// This is also the content that will be merged when AsChild is true.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the button, providing an accessible name.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "button";
        AriaLabel ??= Localizer["RzCarousel.NextButtonAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzCarousel.NextButtonAriaLabel"];
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["aria-label"] = AriaLabel,
            ["x-on:click"] = "scrollNext",
            [":disabled"] = "cannotScrollNext"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.CarouselNext;
    /// <summary>
    /// Defines the slots available for styling in the CarouselNext component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the button element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the icon inside the button.
        /// </summary>
        public string? ButtonIcon { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCarousel/CarouselPrevious.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzAsChildComponent<CarouselPrevious.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @if (ChildContent is not null)
        {
            @ChildContent
        }
        else
        {
            <Blazicon Svg="Lucide.ArrowLeft" class="@SlotClasses.GetButtonIcon()" />
            <span class="sr-only">@AriaLabel</span>
        }
    </HtmlElement>
}
</file>

<file path="Components/Layout/RzCarousel/CarouselPrevious.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A button to navigate to the previous slide in the carousel.
/// </summary>
public partial class CarouselPrevious : RzAsChildComponent<CarouselPrevious.Slots>
{
    /// <summary>
    /// Defines the default styling for the CarouselPrevious component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute size-8 rounded-full top-1/2 -translate-y-1/2 left-0 inline-flex items-center justify-center border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 outline-none focus-visible:ring-[3px] focus-visible:ring-ring/50",
        slots: new()
        {
            [s => s.ButtonIcon] = "h-4 w-4"
        }
    );
    /// <summary>
    /// Gets or sets the content of the button. If not provided, a default icon is used.
    /// This is also the content that will be merged when AsChild is true.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the button, providing an accessible name.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "button";
        AriaLabel ??= Localizer["RzCarousel.PreviousButtonAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzCarousel.PreviousButtonAriaLabel"];
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["aria-label"] = AriaLabel,
            ["x-on:click"] = "scrollPrev",
            [":disabled"] = "cannotScrollPrev"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.CarouselPrevious;
    /// <summary>
    /// Defines the slots available for styling in the CarouselPrevious component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the button element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the icon inside the button.
        /// </summary>
        public string? ButtonIcon { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/CarouselOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Represents the configuration options for the Embla Carousel instance.
/// </summary>
public class CarouselOptions
{
    /// <summary>
    /// Aligns the slides to the "start", "center", or "end" of the viewport.
    /// </summary>
    [JsonPropertyName("align")]
    public string? Align { get; set; }
    /// <summary>
    /// The axis of the carousel, either "x" for horizontal or "y" for vertical.
    /// </summary>
    [JsonPropertyName("axis")]
    public string? Axis { get; set; }
    /// <summary>
    /// Determines how to handle slides when they are larger than the viewport.
    /// "trimSnaps" removes snaps that are out of view, "keepSnaps" does not.
    /// </summary>
    [JsonPropertyName("containScroll")]
    public string? ContainScroll { get; set; }
    /// <summary>
    /// The direction of the carousel, "ltr" (left-to-right) or "rtl" (right-to-left).
    /// </summary>
    [JsonPropertyName("direction")]
    public string? Direction { get; set; }
    /// <summary>
    /// Enables "free-scrolling" mode where the carousel slides without snapping to a specific slide.
    /// </summary>
    [JsonPropertyName("dragFree")]
    public bool? DragFree { get; set; }
    /// <summary>
    /// Enables or disables dragging the carousel with a pointer.
    /// </summary>
    [JsonPropertyName("draggable")]
    public bool? Draggable { get; set; }
    /// <summary>
    /// The percentage of a slide that needs to be visible in the viewport to be considered "in view".
    /// </summary>
    [JsonPropertyName("inViewThreshold")]
    public double? InViewThreshold { get; set; }
    /// <summary>
    /// Enables looping, allowing the carousel to seamlessly scroll from the last slide to the first and vice-versa.
    /// </summary>
    [JsonPropertyName("loop")]
    public bool? Loop { get; set; }
    /// <summary>
    /// Allows the carousel to skip scroll snaps when scrolling with momentum.
    /// </summary>
    [JsonPropertyName("skipSnaps")]
    public bool? SkipSnaps { get; set; }
    /// <summary>
    /// The zero-based index of the slide to show on initialization.
    /// </summary>
    [JsonPropertyName("startIndex")]
    public int? StartIndex { get; set; }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoHeightPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Auto Height plugin.
/// Use this class to configure the carousel to automatically adjust its height to the visible slides.
/// </summary>
public class AutoHeightPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AutoHeightPlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the auto height plugin.</param>
    public AutoHeightPlugin(AutoHeightPluginOptions options)
    {
        Name = "EmblaCarouselAutoHeight";
        AssetKey = "EmblaAutoHeight";
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoHeightPluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Auto Height plugin.
/// </summary>
public class AutoHeightPluginOptions
{
    /// <summary>
    /// Gets or sets the alignment of the carousel content within the container when height is adjusted.
    /// Can be "top", "center", or "bottom". Defaults to "top".
    /// </summary>
    [JsonPropertyName("align")]
    public string Align { get; set; } = "top";
    /// <summary>
    /// Gets or sets the duration of the height adjustment animation in milliseconds.
    /// Defaults to 250.
    /// </summary>
    [JsonPropertyName("duration")]
    public int Duration { get; set; } = 250;
    /// <summary>
    /// Gets or sets the easing function for the height adjustment animation.
    /// This should be a valid CSS easing function string (e.g., "ease-in-out").
    /// Defaults to "ease-in-out".
    /// </summary>
    [JsonPropertyName("easing")]
    public string Easing { get; set; } = "ease-in-out";
    /// <summary>
    /// Gets or sets a value indicating whether to destroy the plugin when the carousel is destroyed.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("destroyHeight")]
    public bool DestroyHeight { get; set; } = true;
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoplayPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Autoplay plugin.
/// Use this class to configure and enable autoplay functionality for an <see cref="RzCarousel"/>.
/// </summary>
public class AutoplayPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AutoplayPlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the autoplay plugin.</param>
    public AutoplayPlugin(AutoplayPluginOptions options)
    {
        Name = "EmblaCarouselAutoplay"; // The JavaScript constructor name
        AssetKey = "EmblaAutoplay";      // The key to look up the asset URL in RizzyUIConfig
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoplayPluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Autoplay plugin.
/// </summary>
public class AutoplayPluginOptions
{
    /// <summary>
    /// Gets or sets the delay in milliseconds between slides.
    /// Defaults to 4000.
    /// </summary>
    [JsonPropertyName("delay")]
    public int Delay { get; set; } = 4000;
    /// <summary>
    /// Gets or sets a value indicating whether to jump to the first slide when the last slide is reached.
    /// This is only effective if `Loop` is false on the main `CarouselOptions`.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("jump")]
    public bool Jump { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to start playing the carousel automatically.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("playOnInit")]
    public bool PlayOnInit { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the autoplay when the carousel is interacted with.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("stopOnInteraction")]
    public bool StopOnInteraction { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the autoplay when the last slide is reached.
    /// This is only effective if `Loop` is false on the main `CarouselOptions`.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("stopOnLastSnap")]
    public bool StopOnLastSnap { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the autoplay when the carousel's root node is not visible in the viewport.
    /// Defaults to false.
    /// </summary>
    [JsonPropertyName("stopOnFocusIn")]
    public bool StopOnFocusIn { get; set; } = false;
    /// <summary>
    /// Gets or sets the direction of the autoplay.
    /// "forward" or "backward". Defaults to "forward".
    /// </summary>
    [JsonPropertyName("direction")]
    public string Direction { get; set; } = "forward";
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoScrollPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Auto Scroll plugin.
/// Use this class to configure the carousel to scroll automatically.
/// </summary>
public class AutoScrollPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="AutoScrollPlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the auto scroll plugin.</param>
    public AutoScrollPlugin(AutoScrollPluginOptions options)
    {
        Name = "EmblaCarouselAutoScroll";
        AssetKey = "EmblaAutoScroll";
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/AutoScrollPluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Auto Scroll plugin.
/// </summary>
public class AutoScrollPluginOptions
{
    /// <summary>
    /// Gets or sets the speed of the scroll in pixels per second.
    /// Defaults to 1000.
    /// </summary>
    [JsonPropertyName("speed")]
    public int Speed { get; set; } = 1000;
    /// <summary>
    /// Gets or sets a value indicating whether to start playing the auto scroll on initialization.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("playOnInit")]
    public bool PlayOnInit { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the auto scroll when the carousel is interacted with.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("stopOnInteraction")]
    public bool StopOnInteraction { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the auto scroll when the carousel's root node is not visible in the viewport.
    /// Defaults to false.
    /// </summary>
    [JsonPropertyName("stopOnFocusIn")]
    public bool StopOnFocusIn { get; set; } = false;
    /// <summary>
    /// Gets or sets a value indicating whether to stop the auto scroll when the last slide is reached.
    /// This is only effective if `Loop` is false on the main `CarouselOptions`.
    /// Defaults to true.
    /// </summary>
    [JsonPropertyName("stopOnLastSnap")]
    public bool StopOnLastSnap { get; set; } = true;
    /// <summary>
    /// Gets or sets the direction of the auto scroll.
    /// "forward" or "backward". Defaults to "forward".
    /// </summary>
    [JsonPropertyName("direction")]
    public string Direction { get; set; } = "forward";
    /// <summary>
    /// Gets or sets the start delay in milliseconds before the auto scroll begins.
    /// Defaults to 0.
    /// </summary>
    [JsonPropertyName("startDelay")]
    public int StartDelay { get; set; }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/ClassNamesPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Class Names plugin.
/// Use this class to add CSS classes to the carousel elements based on their state.
/// </summary>
public class ClassNamesPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="ClassNamesPlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the class names plugin.</param>
    public ClassNamesPlugin(ClassNamesPluginOptions options)
    {
        Name = "EmblaCarouselClassNames";
        AssetKey = "EmblaClassNames";
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/ClassNamesPluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Class Names plugin.
/// </summary>
public class ClassNamesPluginOptions
{
    /// <summary>
    /// Gets or sets the class name to add to the selected slide.
    /// Defaults to "is-selected".
    /// </summary>
    [JsonPropertyName("selected")]
    public string Selected { get; set; } = "is-selected";
    /// <summary>
    /// Gets or sets the class name to add to slides that are not selected.
    /// Defaults to "is-not-selected".
    /// </summary>
    [JsonPropertyName("notSelected")]
    public string NotSelected { get; set; } = "is-not-selected";
    /// <summary>
    /// Gets or sets the class name to add to the carousel container when it is being dragged.
    /// Defaults to "is-dragging".
    /// </summary>
    [JsonPropertyName("dragging")]
    public string Dragging { get; set; } = "is-dragging";
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/EmblaPlugin.cs">
namespace RizzyUI;
/// <summary>
/// Abstract base class for all Embla Carousel plugins.
/// This class provides the core properties needed to identify and configure a plugin on the client-side.
/// </summary>
public abstract class EmblaPlugin
{
    /// <summary>
    /// Gets or sets the name of the plugin's JavaScript constructor (e.g., "EmblaCarouselAutoplay").
    /// This is used by the client-side script to instantiate the correct plugin.
    /// </summary>
    public string Name { get; protected set; } = string.Empty;
    /// <summary>
    /// Gets or sets the logical key used to look up the plugin's asset URL from the central `RizzyUIConfig.AssetUrls` dictionary.
    /// </summary>
    public string AssetKey { get; protected set; } = string.Empty;
    /// <summary>
    /// Gets or sets the configuration options for the plugin. This object will be serialized to JSON
    /// and passed to the plugin's constructor on the client-side.
    /// </summary>
    public object Options { get; set; } = new();
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/FadePlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Fade plugin.
/// Use this class to create a fade transition effect between slides.
/// </summary>
public class FadePlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="FadePlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the fade plugin.</param>
    public FadePlugin(FadePluginOptions options)
    {
        Name = "EmblaCarouselFade";
        AssetKey = "EmblaFade";
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/FadePluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Fade plugin.
/// </summary>
public class FadePluginOptions
{
    /// <summary>
    /// Gets or sets the initial fade value.
    /// Defaults to 0.
    /// </summary>
    [JsonPropertyName("fade")]
    public int Fade { get; set; }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/GenericEmblaPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A generic implementation of <see cref="EmblaPlugin"/> that can be used to configure
/// Embla Carousel plugins that do not have a specific, strongly-typed class provided by RizzyUI.
/// This provides an "escape hatch" for users to integrate any Embla-compatible plugin.
/// </summary>
public class GenericEmblaPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="GenericEmblaPlugin"/> class.
    /// </summary>
    /// <param name="name">The JavaScript constructor name of the plugin (e.g., "SomeOtherPlugin").</param>
    /// <param name="assetKey">The key to look up the asset URL in `RizzyUIConfig.AssetUrls`.</param>
    /// <param name="options">An anonymous or strongly-typed object containing the plugin's configuration options.</param>
    public GenericEmblaPlugin(string name, string assetKey, object options)
    {
        Name = name;
        AssetKey = assetKey;
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/WheelGesturesPlugin.cs">
namespace RizzyUI;
/// <summary>
/// A strongly-typed representation of the Embla Carousel Wheel Gestures plugin.
/// Use this class to enable carousel interaction with mouse wheel gestures.
/// </summary>
public class WheelGesturesPlugin : EmblaPlugin
{
    /// <summary>
    /// Initializes a new instance of the <see cref="WheelGesturesPlugin"/> class with the specified options.
    /// </summary>
    /// <param name="options">The configuration options for the wheel gestures plugin.</param>
    public WheelGesturesPlugin(WheelGesturesPluginOptions options)
    {
        Name = "EmblaCarouselWheelGestures";
        AssetKey = "EmblaWheelGestures";
        Options = options;
    }
}
</file>

<file path="Components/Layout/RzCarousel/Models/Plugins/WheelGesturesPluginOptions.cs">
using System.Text.Json.Serialization;
namespace RizzyUI;
/// <summary>
/// Provides strongly-typed options for the Embla Carousel Wheel Gestures plugin.
/// </summary>
public class WheelGesturesPluginOptions
{
    /// <summary>
    /// Gets or sets a value indicating whether to force the wheel gestures on a specific axis.
    /// Can be "x" or "y". If not set, it will be inferred from the carousel's axis.
    /// </summary>
    [JsonPropertyName("forceWheelAxis")]
    public string? ForceWheelAxis { get; set; }
    /// <summary>
    /// Gets or sets the speed of the wheel gestures.
    /// Defaults to 1.
    /// </summary>
    [JsonPropertyName("speed")]
    public int Speed { get; set; } = 1;
}
</file>

<file path="Components/Layout/RzCarousel/RzCarousel.razor">
@namespace RizzyUI
@inherits RzComponent<RzCarousel.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             @attributes="@AdditionalAttributes"
	             id="@Id"
	             class="@SlotClasses.GetBase()"
	             role="region"
	             aria-roledescription="carousel"
	             aria-label="@AriaLabel">
		<script type="application/json" id="@Id-config">
			@((MarkupString)_serializedConfig)
		</script>
		<div x-data="rzCarousel"
		     data-config="@Id-config"
		     data-alpine-root="@Id"
		     data-assets="@_assets"
		     data-nonce="@Nonce"
		     class="@SlotClasses.GetWrapper()">
			@ChildContent
		</div>
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Layout/RzCarousel/RzCarousel.razor.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Options;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Serialization;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A carousel component for cycling through elements. This is the root component that provides context for its children.
/// </summary>
/// <remarks>
/// As a root-level component, its name is prefixed with 'Rz'. Interactivity is powered by Embla Carousel via an Alpine.js component.
/// </remarks>
public partial class RzCarousel : RzComponent<RzCarousel.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCarousel component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative",
        slots: new()
        {
            [s => s.Wrapper] = "relative"
        }
    );
    private static readonly JsonSerializerOptions _serializerOptions = new()
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };
    private string _serializedConfig = "{}";
    private string _assets = "[]";
    [Inject]
    private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
    /// <summary>
    /// Gets or sets the content of the carousel, which should include <see cref="CarouselContent"/> and optionally <see cref="CarouselPrevious"/> and <see cref="CarouselNext"/>.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the configuration options for the underlying Embla Carousel instance.
    /// </summary>
    [Parameter]
    public CarouselOptions Options { get; set; } = new();
    /// <summary>
    /// Gets or sets a collection of Embla Carousel plugins to initialize with the carousel.
    /// </summary>
    [Parameter]
    public IEnumerable<EmblaPlugin> Plugins { get; set; } = Enumerable.Empty<EmblaPlugin>();
    /// <summary>
    /// Gets or sets the ARIA label for the carousel, providing an accessible name for the region.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzCarousel.DefaultAriaLabel"];
        UpdateConfiguration();
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzCarousel.DefaultAriaLabel"];
        UpdateConfiguration();
    }
    private void UpdateConfiguration()
    {
        var combinedConfig = new
        {
            Options,
            Plugins
        };
        _serializedConfig = JsonSerializer.Serialize(combinedConfig, _serializerOptions);
        _assets = BuildAssetList();
    }
    private string BuildAssetList()
    {
        var assetUrls = new HashSet<string>();
        var configAssets = RizzyUIConfig.Value.AssetUrls;
        if (configAssets.TryGetValue("EmblaCore", out var coreUrl))
        {
            assetUrls.Add(coreUrl);
        }
        foreach (var plugin in Plugins)
        {
            if (!string.IsNullOrEmpty(plugin.AssetKey) && configAssets.TryGetValue(plugin.AssetKey, out var pluginUrl))
            {
                assetUrls.Add(pluginUrl);
            }
        }
        return JsonSerializer.Serialize(assetUrls);
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCarousel;
    /// <summary>
    /// Defines the slots available for styling in the RzCarousel component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main carousel container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner wrapper managed by Alpine.js.
        /// </summary>
        public string? Wrapper { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCollapsible/CollapsibleContent.razor">
@namespace RizzyUI
@inherits RzComponent<CollapsibleContent.Slots>

<HtmlElement Element="@EffectiveElement" 
             @attributes="AdditionalAttributes" 
             id="@($"{ParentCollapsible?.Id}-content")" 
             class="@SlotClasses.GetBase()"
             x-show="isOpen"
             x-cloak
             x-collapse
             x-bind:data-state="state"
             data-slot="collapsible-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCollapsible/CollapsibleContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The container for content that can be shown or hidden by a <see cref="CollapsibleTrigger"/>.
/// It must be a child of an <see cref="RzCollapsible"/> component.
/// </summary>
public partial class CollapsibleContent : RzComponent<CollapsibleContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the CollapsibleContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down"
    );
    /// <summary>
    /// Gets the parent <see cref="RzCollapsible"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCollapsible? ParentCollapsible { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the collapsible panel.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCollapsible == null)
        {
            throw new InvalidOperationException($"{nameof(CollapsibleContent)} must be used within an {nameof(RzCollapsible)}.");
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CollapsibleContent;
    /// <summary>
    /// Defines the slots available for styling in the CollapsibleContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCollapsible/CollapsibleTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<CollapsibleTrigger.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Layout/RzCollapsible/CollapsibleTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive element that toggles the visibility of its associated <see cref="CollapsibleContent"/>.
/// It must be a child of an <see cref="RzCollapsible"/> component.
/// </summary>
public partial class CollapsibleTrigger : RzAsChildComponent<CollapsibleTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the CollapsibleTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new();
    /// <summary>
    /// Gets the parent <see cref="RzCollapsible"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCollapsible? ParentCollapsible { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCollapsible == null)
        {
            throw new InvalidOperationException($"{nameof(CollapsibleTrigger)} must be used within an {nameof(RzCollapsible)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = $"{ParentCollapsible?.Id}-trigger",
            ["class"] = SlotClasses.GetBase(),
            ["x-on:click"] = "toggle",
            ["aria-controls"] = $"{ParentCollapsible?.Id}-content",
            ["x-bind:aria-expanded"] = "isOpen",
            ["x-bind:data-state"] = "state",
            ["data-slot"] = "collapsible-trigger"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.CollapsibleTrigger;
    /// <summary>
    /// Defines the slots available for styling in the CollapsibleTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzCollapsible/RzCollapsible.razor">
@namespace RizzyUI
@inherits RzComponent<RzCollapsible.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement" 
                 @attributes="@AdditionalAttributes" 
                 id="@Id" 
                 class="@SlotClasses.GetBase()"
                 x-data="rzCollapsible"
                 data-alpine-root="@Id"
                 data-default-open="@DefaultOpen.ToString().ToLowerInvariant()"
                 x-bind:data-state="state"
                 data-slot="collapsible">
        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Layout/RzCollapsible/RzCollapsible.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container component that manages the state for collapsible content,
/// allowing child <see cref="CollapsibleTrigger"/> and <see cref="CollapsibleContent"/>
/// components to coordinate their behavior.
/// </summary>
public partial class RzCollapsible : RzComponent<RzCollapsible.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCollapsible component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/collapsible"
    );
    /// <summary>
    /// Gets or sets the content of the collapsible component, which should include
    /// a <see cref="CollapsibleTrigger"/> and a <see cref="CollapsibleContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the initial open state of the collapsible content.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCollapsible;
    /// <summary>
    /// Defines the slots available for styling in the RzCollapsible component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemActions.razor">
@namespace RizzyUI
@inherits RzComponent<ItemActions.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-actions">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemActions.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for action elements, like buttons, within an <see cref="RzItem"/>.
/// </summary>
public partial class ItemActions : RzComponent<ItemActions.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemActions component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex items-center gap-2"
    );
    /// <summary>
    /// Gets or sets the content to be rendered, typically one or more buttons.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemActions;
    /// <summary>
    /// Defines the slots available for styling in the ItemActions component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemContent.razor">
@namespace RizzyUI
@inherits RzComponent<ItemContent.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The main content area of an <see cref="RzItem"/>, typically containing <see cref="ItemTitle"/> and <see cref="ItemDescription"/>.
/// </summary>
public partial class ItemContent : RzComponent<ItemContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none"
    );
    /// <summary>
    /// Gets or sets the content to be rendered.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemContent;
    /// <summary>
    /// Defines the slots available for styling in the ItemContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemDescription.razor">
@namespace RizzyUI
@inherits RzComponent<ItemDescription.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-description">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying descriptive text within an <see cref="ItemContent"/>.
/// </summary>
public partial class ItemDescription : RzComponent<ItemDescription.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemDescription component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-muted-foreground line-clamp-2 text-sm leading-normal font-normal text-balance [&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the description.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "p";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemDescription;
    /// <summary>
    /// Defines the slots available for styling in the ItemDescription component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemFooter.razor">
@namespace RizzyUI
@inherits RzComponent<ItemFooter.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-footer">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for footer content within an <see cref="RzItem"/>, spanning the full width.
/// </summary>
public partial class ItemFooter : RzComponent<ItemFooter.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemFooter component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex basis-full items-center justify-between gap-2"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the footer.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemFooter;
    /// <summary>
    /// Defines the slots available for styling in the ItemFooter component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemHeader.razor">
@namespace RizzyUI
@inherits RzComponent<ItemHeader.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-header">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for header content within an <see cref="RzItem"/>, spanning the full width.
/// </summary>
public partial class ItemHeader : RzComponent<ItemHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex basis-full items-center justify-between gap-2"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the header.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemHeader;
    /// <summary>
    /// Defines the slots available for styling in the ItemHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemMedia.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<ItemMedia.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-media"
             data-variant="@Variant.ToString().ToKebabCase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemMedia.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for media elements like icons or images within an <see cref="RzItem"/>.
/// </summary>
public partial class ItemMedia : RzComponent<ItemMedia.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemMedia component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none group-has-[[data-slot=item-description]]/item:translate-y-0.5",
        variants: new()
        {
            [m => ((ItemMedia)m).Variant] = new Variant<ItemMediaVariant, Slots>
            {
                [ItemMediaVariant.Icon] = "size-8 border rounded-sm bg-muted [&_svg:not([class*='size-'])]:size-4",
                [ItemMediaVariant.Image] = "size-10 rounded-sm overflow-hidden [&_img]:size-full [&_img]:object-cover",
                [ItemMediaVariant.Default] = "bg-transparent"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content of the media container.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the visual variant of the media container.
    /// Defaults to <see cref="ItemMediaVariant.Default"/>.
    /// </summary>
    [Parameter]
    public ItemMediaVariant Variant { get; set; } = ItemMediaVariant.Default;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemMedia;
    /// <summary>
    /// Defines the slots available for styling in the ItemMedia component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemTitle.razor">
@namespace RizzyUI
@inherits RzComponent<ItemTitle.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="item-title">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/ItemTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying the title within an <see cref="ItemContent"/>.
/// </summary>
public partial class ItemTitle : RzComponent<ItemTitle.Slots>
{
    /// <summary>
    /// Defines the default styling for the ItemTitle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-fit items-center gap-2 text-sm leading-snug font-medium"
    );
    /// <summary>
    /// Gets or sets the content to be rendered as the title.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.ItemTitle;
    /// <summary>
    /// Defines the slots available for styling in the ItemTitle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/ItemVariant.cs">
// src/RizzyUI/Components/Layout/RzItem/ItemVariant.cs
namespace RizzyUI;
/// <summary>
/// Specifies the visual variant for an RzItem.
/// </summary>
public enum ItemVariant
{
    /// <summary>
    /// Default transparent background.
    /// </summary>
    Default,
    /// <summary>
    /// A visible border.
    /// </summary>
    Outline,
    /// <summary>
    /// A muted background color.
    /// </summary>
    Muted
}
/// <summary>
/// Specifies the visual variant for an ItemMedia component.
/// </summary>
public enum ItemMediaVariant
{
    /// <summary>
    /// Default styling, typically for custom content.
    /// </summary>
    Default,
    /// <summary>
    /// Styled for containing an icon.
    /// </summary>
    Icon,
    /// <summary>
    /// Styled for containing an image.
    /// </summary>
    Image
}
</file>

<file path="Components/Layout/RzItem/RzItem.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<RzItem.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Layout/RzItem/RzItem.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A flexible container for displaying content in a list item format, with support for various styles and sizes.
/// </summary>
public partial class RzItem : RzAsChildComponent<RzItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzItem component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/item flex items-center border border-transparent text-sm rounded-md transition-colors [a]:hover:bg-accent/50 [a]:transition-colors duration-100 flex-wrap outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        variants: new()
        {
            [i => ((RzItem)i).Variant] = new Variant<ItemVariant, Slots>
            {
                [ItemVariant.Outline] = "border-border",
                [ItemVariant.Muted] = "bg-muted/50",
                [ItemVariant.Default] = "bg-transparent"
            },
            [i => ((RzItem)i).Size] = new Variant<Size, Slots>
            {
                [Size.Small] = "py-3 px-4 gap-2.5",
                [Size.Medium] = "p-4 gap-4"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the visual variant of the item.
    /// Defaults to <see cref="ItemVariant.Default"/>.
    /// </summary>
    [Parameter]
    public ItemVariant Variant { get; set; } = ItemVariant.Default;
    /// <summary>
    /// Gets or sets the size of the item, affecting padding and gap.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["data-slot"] = "item",
            ["data-variant"] = Variant.ToString().ToKebabCase(),
            ["data-size"] = Size == Size.Small ? "sm" : "default"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.RzItem;
    /// <summary>
    /// Defines the slots available for styling in the RzItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/RzItemGroup.razor">
@namespace RizzyUI
@inherits RzComponent<RzItemGroup.Slots>

<HtmlElement Element="@EffectiveElement"
             role="list"
             data-slot="item-group"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzItem/RzItemGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for grouping a list of <see cref="RzItem"/> components.
/// </summary>
public partial class RzItemGroup : RzComponent<RzItemGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzItemGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/item-group flex flex-col"
    );
    /// <summary>
    /// Gets or sets the content of the item group, which should be a series of <see cref="RzItem"/> components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzItemGroup;
    /// <summary>
    /// Defines the slots available for styling in the RzItemGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzItem/RzItemSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<RzItemSeparator.Slots>

<RzSeparator data-slot="item-separator"
             Orientation="Orientation.Horizontal"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()" />
</file>

<file path="Components/Layout/RzItem/RzItemSeparator.razor.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A visual separator for use within an <see cref="RzItemGroup"/>.
/// </summary>
public partial class RzItemSeparator : RzComponent<RzItemSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzItemSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "my-0"
    );
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzItemSeparator;
    /// <summary>
    /// Defines the slots available for styling in the RzItemSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Layout/RzSearchButton/RzSearchButton.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzSearchButton.Slots>

<HtmlElement Element="@EffectiveElement"
             type="button"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             aria-label="@Label">
	<div class="@SlotClasses.GetInnerContainer()">
		<span class="@SlotClasses.GetIconSpan()" aria-hidden="true">
			<Blazicon Svg="MdiIcon.Magnify"/>
		</span>
		@Label
	</div>
</HtmlElement>
</file>

<file path="Components/Layout/RzSearchButton/RzSearchButton.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents a search button styled consistently with the application's theme,
///     displaying a search icon and a configurable text label.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSearchButton : RzComponent<RzSearchButton.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSearchButton component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex h-10 w-full cursor-pointer items-center justify-between border-outline bg-secondary p-2 px-4 font-light transition-all duration-200 rounded-md border",
        slots: new()
        {
            [s => s.InnerContainer] = "flex items-center gap-2",
            [s => s.IconSpan] = "text-xl"
        }
    );
    /// <summary>
    /// Gets or sets the text label displayed on the button and used for the aria-label.
    /// Defaults to a localized "Search" value.
    /// </summary>
    [Parameter] public string? Label { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Label ??= Localizer["RzSearchButton.DefaultLabel"];
        if (string.IsNullOrEmpty(Element))
            Element = "button";
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Label ??= Localizer["RzSearchButton.DefaultLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSearchButton;
    /// <summary>
    /// Defines the slots available for styling in the RzSearchButton component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner container that holds the icon and label.
        /// </summary>
        public string? InnerContainer { get; set; }
        /// <summary>
        /// The slot for the span wrapping the search icon.
        /// </summary>
        public string? IconSpan { get; set; }
    }
}
</file>

<file path="Components/Layout/RzStep/RzStep.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <xmldoc>
///     Represents the data definition for a single step within an <see cref="RzSteps" /> component.
///     This component registers its parameters with the parent <see cref="RzSteps" /> component during initialization.
///     It does not render any HTML directly; the parent <see cref="RzSteps" /> component is responsible for rendering
///     based on the collected data.
/// </xmldoc>
public class RzStep : ComponentBase // Doesn't need RzComponent base as it renders nothing itself
{
    /// <summary> Gets or sets the main text label describing the step. Required. </summary>
    [Parameter, EditorRequired] public string Label { get; set; } = string.Empty;
    /// <summary> Gets or sets the current status of the step (Completed, Current, or Upcoming). Required. </summary>
    [Parameter, EditorRequired] public StepStatus Status { get; set; } = StepStatus.Upcoming;
    /// <summary>
    ///     Gets or sets an optional ARIA label for the step, providing more context for accessibility. If not provided,
    ///     the <see cref="Label" /> is typically used by the parent component.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }
    /// <summary>
    ///     Gets or sets optional caption text displayed below the step label (rendered by the parent
    ///     <see cref="RzSteps" /> component).
    /// </summary>
    [Parameter] public string? Caption { get; set; }
    /// <summary>
    ///     Gets or sets an optional Blazicon SVG icon to display within the step indicator instead of a number or
    ///     checkmark.
    /// </summary>
    [Parameter] public SvgIcon? Icon { get; set; }
    /// <summary> Gets the parent <see cref="RzSteps" /> component via cascading parameter. </summary>
    [CascadingParameter] private RzSteps? ParentSteps { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSteps is not null)
            // Create the StepData record from parameters and register it with the parent
            ParentSteps.RegisterStep(new StepData(Label, Status, AriaLabel, Caption, Icon));
        else
            // Ensure the component is used correctly within the hierarchy
            throw new InvalidOperationException(
                $"{nameof(RzStep)} must be used as a child of an {nameof(RzSteps)} component.");
    }
}
</file>

<file path="Components/Layout/RzStep/RzSteps.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzSteps.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" aria-label="@AriaLabel">

	<CascadingValue Value="this" IsFixed="true">
		@ChildContent
	</CascadingValue>

	@for (var i = 0; i < Items.Count; i++)
	{
		var step = Items[i];
		var isFirst = i == 0;
        var isLast = i == Items.Count - 1;
		var prevStep = isFirst ? null : Items[i - 1];
		var effectiveAriaLabel = string.IsNullOrEmpty(step.AriaLabel) ? step.Label : step.AriaLabel;
        var isCurrent = step.Status == StepStatus.Current;

		<li class="@GetStepItemCss(isFirst, isLast, step.Status)" 
            aria-label="@effectiveAriaLabel" 
            aria-current="@(isCurrent ? "step" : null)">

			@if (Orientation == Orientation.Horizontal && !isFirst && prevStep != null)
			{
				<span class="@GetConnectorCss(prevStep.Status)" aria-hidden="true"></span>
			}

			<div class="@SlotClasses.GetStepContentContainer()">
				@if (step.Status == StepStatus.Completed)
				{
					<span class="@GetCircleCompletedCss()">
						@if (step.Icon is not null)
						{
							<Blazicon Svg="step.Icon" class="@SlotClasses.GetCircleCompletedIcon()" aria-hidden="true"/>
						}
						else
						{
							<svg class="@SlotClasses.GetCircleCompletedIcon()" xmlns="http://www.w3.org/2000/svg" fill="none"
							     viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" aria-hidden="true">
								<path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5"/>
							</svg>
						}
                        <span class="@SlotClasses.GetCircleCompletedSrText()">@Localizer["RzSteps.CompletedStepSrText"]</span>
					</span>
				}
				else
				{
					<span class="@GetCircleDefaultCss(step.Status)">
						@if (step.Icon is not null)
						{
							<Blazicon Svg="step.Icon" class="@SlotClasses.GetCircleDefaultIcon()" aria-hidden="true"/>
						}
						else
						{
							@(i + 1)
						}
					</span>
				}
				<div>
					@if (ShowLabels && !string.IsNullOrEmpty(step.Label))
					{
						<p class="@GetLabelCss(step.Status)">@step.Label</p>
					}
					@if (!string.IsNullOrEmpty(step.Caption))
					{
						<p class="@SlotClasses.GetCaption()">@step.Caption</p>
					}
				</div>
			</div>
		</li>
	}
</HtmlElement>
</file>

<file path="Components/Layout/RzStep/RzSteps.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     A component that displays a sequence of steps, visually indicating progress through a process.
///     Child &lt;see cref="RzStep" /&gt; components automatically register their data.
///     Styling is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzSteps : RzComponent<RzSteps.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSteps component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex",
        slots: new()
        {
            [s => s.StepItem] = "relative flex items-center text-sm",
            [s => s.StepContentContainer] = "flex items-center gap-2",
            [s => s.CircleCompleted] = "flex size-6 items-center justify-center rounded-full border",
            [s => s.CircleCompletedIcon] = "size-4",
            [s => s.CircleCompletedSrText] = "sr-only",
            [s => s.CircleDefault] = "flex size-6 shrink-0 items-center justify-center rounded-full border",
            [s => s.CircleDefaultIcon] = "size-4",
            [s => s.Label] = "hidden w-max whitespace-nowrap sm:inline",
            [s => s.Caption] = "text-xs text-muted-foreground mt-1"
        },
        variants: new()
        {
            [s => ((RzSteps)s).Orientation] = new Variant<Orientation, Slots>
            {
                [Orientation.Horizontal] = new() { [s => s.Base] = "w-full items-start gap-2" },
                [Orientation.Vertical] = new() { [s => s.Base] = "w-min flex-col" }
            }
        }
    );
    /// <summary>
    /// Gets or sets the list of step data to display.
    /// </summary>
    [Parameter]
    public List<StepData> Items { get; set; } = new();
    /// <summary> Gets or sets the orientation (Horizontal or Vertical). Defaults to Horizontal. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <summary> Gets or sets a value indicating whether step labels are shown. Defaults to true. </summary>
    [Parameter]
    public bool ShowLabels { get; set; } = true;
    /// <summary> Gets or sets the ARIA label for the steps container. Defaults to localized "Steps progress indicator". </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <summary> Gets or sets the active color used for completed and current steps. Defaults to Primary. </summary>
    [Parameter]
    public StatusColor ActiveColor { get; set; } = StatusColor.Primary;
    /// <summary> The child content, expected to be &lt;see cref="RzStep" /&gt; components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzSteps.DefaultAriaLabel"];
        if (string.IsNullOrEmpty(Element))
            Element = "ol";
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSteps.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSteps;
    /// <summary> Registers step data. Called by child &lt;see cref="RzStep" /&gt; components. </summary>
    /// <param name="data">The step data to register.</param>
    internal void RegisterStep(StepData data)
    {
        if (!Items.Exists(i => i.Label == data.Label && i.Caption == data.Caption))
        {
            Items.Add(data);
            InvokeAsync(StateHasChanged);
        }
    }
    private string GetStepItemCss(bool isFirst, bool isLast, StepStatus stepStatus)
    {
        var classes = new List<string> { SlotClasses.GetStepItem() ?? "" };
        if (Orientation == Orientation.Vertical)
        {
            classes.Add("flex-1");
            if (!isLast)
            {
                var connectorColorClass = stepStatus == StepStatus.Completed ? GetActiveBackgroundClass(ActiveColor) : "bg-border";
                classes.Add($"after:content-[''] after:absolute after:left-3 after:-bottom-11 after:h-full after:w-0.5 after:{connectorColorClass}");
            }
        }
        else if (!isFirst)
        {
            classes.Add("w-full");
        }
        return string.Join(" ", classes);
    }
    private string GetConnectorCss(StepStatus stepStatus)
    {
        var colorClass = stepStatus == StepStatus.Completed ? GetActiveBackgroundClass(ActiveColor) : "bg-border";
        return $"h-0.5 flex-1 mx-2 {colorClass}";
    }
    private string GetCircleCompletedCss() =>
        $"{SlotClasses.GetCircleCompleted()} {GetActiveBorderClass(ActiveColor)} {GetActiveBackgroundClass(ActiveColor)} {GetActiveTextClass(ActiveColor)}";
    private string GetCircleDefaultCss(StepStatus status)
    {
        var baseClass = SlotClasses.GetCircleDefault();
        return status switch
        {
            StepStatus.Current => $"{baseClass} border {GetActiveBorderClass(ActiveColor)} {GetActiveBackgroundClass(ActiveColor)} font-bold {GetActiveTextClass(ActiveColor)} focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 {GetFocusRingClass(ActiveColor)} dark:focus-visible:ring-offset-background",
            _ => $"{baseClass} border border-border bg-muted font-medium text-muted-foreground focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ring dark:focus-visible:ring-offset-background",
        };
    }
    private string GetLabelCss(StepStatus status)
    {
        var baseClass = SlotClasses.GetLabel();
        return status switch
        {
            StepStatus.Completed => $"{baseClass} {GetActiveTextColorClass(ActiveColor)}",
            StepStatus.Current => $"{baseClass} font-bold {GetActiveTextColorClass(ActiveColor)}",
            _ => $"{baseClass} text-muted-foreground",
        };
    }
    private string GetActiveBackgroundClass(StatusColor color) => $"bg-{color.ToString().ToLowerInvariant()}";
    private string GetActiveBorderClass(StatusColor color) => $"border-{color.ToString().ToLowerInvariant()}";
    private string GetActiveTextClass(StatusColor color) => color switch
    {
        StatusColor.Primary => "text-primary-foreground",
        StatusColor.Secondary => "text-secondary-foreground",
        StatusColor.Success => "text-success-foreground",
        StatusColor.Info => "text-info-foreground",
        StatusColor.Warning => "text-warning-foreground",
        StatusColor.Destructive => "text-destructive-foreground",
        _ => "text-primary-foreground"
    };
    private string GetActiveTextColorClass(StatusColor color) => $"text-{color.ToString().ToLowerInvariant()}";
    private string GetFocusRingClass(StatusColor color) => $"focus-visible:ring-{color.ToString().ToLowerInvariant()}";
    /// <summary>
    /// Defines the slots available for styling in the RzSteps component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main container element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for each step item (`&lt;li&gt;`).
        /// </summary>
        public string? StepItem { get; set; }
        /// <summary>
        /// The slot for the container of a step's content.
        /// </summary>
        public string? StepContentContainer { get; set; }
        /// <summary>
        /// The slot for the circle of a completed step.
        /// </summary>
        public string? CircleCompleted { get; set; }
        /// <summary>
        /// The slot for the icon inside a completed step's circle.
        /// </summary>
        public string? CircleCompletedIcon { get; set; }
        /// <summary>
        /// The slot for the screen-reader-only text for a completed step.
        /// </summary>
        public string? CircleCompletedSrText { get; set; }
        /// <summary>
        /// The slot for the circle of a default (current or upcoming) step.
        /// </summary>
        public string? CircleDefault { get; set; }
        /// <summary>
        /// The slot for the icon inside a default step's circle.
        /// </summary>
        public string? CircleDefaultIcon { get; set; }
        /// <summary>
        /// The slot for the step's label.
        /// </summary>
        public string? Label { get; set; }
        /// <summary>
        /// The slot for the step's caption.
        /// </summary>
        public string? Caption { get; set; }
    }
}
</file>

<file path="Components/Layout/RzStep/StepColorExtensions.cs">
using RizzyUI;
/// <summary>
/// Helper extension methods for converting <see cref="StatusColor"/> values to Tailwind CSS classes.
/// </summary>
internal static class StepColorExtensions
{
    /// <summary>
    /// Converts a StatusColor to a background class string.
    /// </summary>
    /// <param name="color">The status color.</param>
    /// <returns>The Tailwind CSS background class.</returns>
	public static string ToBackgroundClass(this StatusColor color) => $"bg-{color.ToString().ToLowerInvariant()}";
    /// <summary>
    /// Converts a StatusColor to a border class string.
    /// </summary>
    /// <param name="color">The status color.</param>
    /// <returns>The Tailwind CSS border class.</returns>
    public static string ToBorderClass(this StatusColor color) => $"border-{color.ToString().ToLowerInvariant()}";
    /// <summary>
    /// Converts a StatusColor to a text class string.
    /// </summary>
    /// <param name="color">The status color.</param>
    /// <returns>The Tailwind CSS text class.</returns>
    public static string ToTextClass(this StatusColor color) => $"text-{color.ToString().ToLowerInvariant()}";
    /// <summary>
    /// Converts a StatusColor to a foreground text class string for use on a colored background.
    /// </summary>
    /// <param name="color">The status color.</param>
    /// <returns>The Tailwind CSS foreground text class.</returns>
    public static string ToOnColorTextClass(this StatusColor color) => color switch
    {
        StatusColor.Primary => "text-primary-foreground",
        StatusColor.Secondary => "text-secondary-foreground",
        StatusColor.Success => "text-success-foreground",
        StatusColor.Info => "text-info-foreground",
        StatusColor.Warning => "text-warning-foreground",
        StatusColor.Destructive => "text-destructive-foreground",
        _ => "text-primary-foreground"
    };
}
</file>

<file path="Components/Layout/RzStep/StepData.cs">
using Blazicons;
namespace RizzyUI;
/// <xmldoc>
///     Represents the data for a single step.
/// </xmldoc>
public record StepData
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="StepData" /> record.
    /// </summary>
    /// <param name="label">The label text for the step.</param>
    /// <param name="status">The status of the step.</param>
    /// <param name="ariaLabel">The optional ARIA label for accessibility.</param>
    /// <param name="caption">The optional caption displayed under the step.</param>
    /// <param name="icon">The optional icon to display in place of the step number.</param>
    public StepData(string label, StepStatus status, string? ariaLabel, string? caption, SvgIcon? icon)
    {
        Label = label;
        Status = status;
        AriaLabel = ariaLabel;
        Caption = caption;
        Icon = icon;
    }
    /// <summary>
    ///     Gets the label text for the step.
    /// </summary>
    public string Label { get; init; }
    /// <summary>
    ///     Gets the status of the step (Completed, Current, or Upcoming).
    /// </summary>
    public StepStatus Status { get; init; }
    /// <summary>
    ///     Gets the optional ARIA label for accessibility. If not provided, the Label is used.
    /// </summary>
    public string? AriaLabel { get; init; }
    /// <summary>
    ///     Gets the optional caption text (a small muted text displayed under the step).
    /// </summary>
    public string? Caption { get; init; }
    /// <summary>
    ///     Gets the optional icon to display instead of the step number.
    /// </summary>
    public SvgIcon? Icon { get; init; }
}
</file>

<file path="Components/Layout/RzStep/StepStatus.cs">
namespace RizzyUI;
/// <xmldoc>
///     Specifies the status of a step in the Steps component.
/// </xmldoc>
public enum StepStatus
{
    /// <summary>Step is complete.</summary>
    Completed,
    /// <summary>Step is the current active step.</summary>
    Current,
    /// <summary>Step is upcoming.</summary>
    Upcoming
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbEllipsis.razor">
@namespace RizzyUI
@inherits RzComponent<BreadcrumbEllipsis.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-ellipsis">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="@SlotClasses.GetIcon()">
        <circle cx="12" cy="12" r="1"></circle>
        <circle cx="19" cy="12" r="1"></circle>
        <circle cx="5" cy="12" r="1"></circle>
    </svg>
    <span class="sr-only">More</span>
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbEllipsis.razor.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Renders an ellipsis icon, typically used within a <see cref="BreadcrumbItem"/> to indicate
/// a collapsed menu of breadcrumb links.
/// </summary>
public partial class BreadcrumbEllipsis : RzComponent<BreadcrumbEllipsis.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbEllipsis component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex h-9 w-9 items-center justify-center",
        slots: new()
        {
            [s => s.Icon] = "size-4"
        }
    );
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "span";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbEllipsis;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbEllipsis component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `span` element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The icon slot for the ellipsis icon.
        /// </summary>
        public string? Icon { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbItem.razor">
@namespace RizzyUI
@inherits RzComponent<BreadcrumbItem.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-item">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbItem.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A list item (`&lt;li&gt;`) that wraps a breadcrumb link, page, or separator.
/// This component should be a child of <see cref="BreadcrumbList"/>.
/// </summary>
public partial class BreadcrumbItem : RzComponent<BreadcrumbItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center gap-1.5"
    );
    /// <summary>
    /// Gets or sets the content of the breadcrumb item, such as a <see cref="BreadcrumbLink"/>
    /// or <see cref="BreadcrumbPage"/>.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "li";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbItem;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `li` element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbLink.razor">
@namespace RizzyUI
@inherits RzComponent<BreadcrumbLink.Slots>

<HtmlElement Element="@EffectiveElement"
             href="@Href"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-link">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbLink.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An anchor link (`&lt;a&gt;`) for a breadcrumb item that is not the current page.
/// It can contain simple text or more complex components like <see cref="RzLink"/>.
/// </summary>
public partial class BreadcrumbLink : RzComponent<BreadcrumbLink.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbLink component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "transition-colors hover:text-foreground"
    );
    /// <summary>
    /// Gets or sets the URL the link navigates to.
    /// </summary>
    [Parameter]
    public string? Href { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the link.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "a";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbLink;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbLink component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `a` element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbList.razor">
@namespace RizzyUI
@inherits RzComponent<BreadcrumbList.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-list">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbList.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An ordered list (`&lt;ol&gt;`) that contains the breadcrumb items. This component should be
/// a direct child of <see cref="RzBreadcrumb"/>.
/// </summary>
public partial class BreadcrumbList : RzComponent<BreadcrumbList.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbList component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5 text-muted-foreground"
    );
    /// <summary>
    /// Gets or sets the content of the list, which should be a sequence of
    /// <see cref="BreadcrumbItem"/> and <see cref="BreadcrumbSeparator"/> components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "ol";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbList;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbList component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `ol` element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbPage.razor">
@namespace RizzyUI
@inherits RzComponent<BreadcrumbPage.Slots>

<HtmlElement Element="@EffectiveElement"
             aria-current="page"
             aria-disabled="true"
             role="link"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-page">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbPage.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A `&lt;span&gt;` element representing the current page in a breadcrumb trail. It is not interactive.
/// </summary>
public partial class BreadcrumbPage : RzComponent<BreadcrumbPage.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbPage component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "font-normal text-foreground"
    );
    /// <summary>
    /// Gets or sets the text content for the current page.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "span";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbPage;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbPage component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `span` element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbSeparator.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<BreadcrumbSeparator.Slots>

<HtmlElement Element="@EffectiveElement"
             role="presentation"
             aria-hidden="true"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="breadcrumb-separator">
    @if (ChildContent != null)
    {
        @ChildContent
    }
    else
    {
        <Blazicon Svg="MdiIcon.ChevronRight" class="@SlotClasses.GetIcon()" />
    }
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/BreadcrumbSeparator.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A list item (`&lt;li&gt;`) that renders a separator between breadcrumb items.
/// It defaults to a chevron icon but can be customized with child content.
/// </summary>
public partial class BreadcrumbSeparator : RzComponent<BreadcrumbSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the BreadcrumbSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center",
        slots: new()
        {
            [s => s.Icon] = "size-3.5"
        }
    );
    /// <summary>
    /// Gets or sets the custom content to be used as a separator, overriding the default icon.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "li";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.BreadcrumbSeparator;
    /// <summary>
    /// Defines the slots available for styling in the BreadcrumbSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `li` element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The icon slot for the default separator icon.
        /// </summary>
        public string? Icon { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor">
@namespace RizzyUI
@inherits RzComponent<RzBreadcrumb.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             aria-label="@AriaLabel"
             data-slot="breadcrumb">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A root container for a breadcrumb navigation trail. It renders as a <c>&lt;nav&gt;</c> element
/// and should contain a <see cref="BreadcrumbList"/> component.
/// </summary>
public partial class RzBreadcrumb : RzComponent<RzBreadcrumb.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzBreadcrumb component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-sm"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the breadcrumb container,
    /// which should be a <see cref="BreadcrumbList"/> component.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the breadcrumb navigation container, providing context for screen readers.
    /// If not set, it defaults to a localized "Breadcrumb".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav";
        AriaLabel ??= Localizer["RzBreadcrumb.AriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzBreadcrumb.AriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzBreadcrumb;
    /// <summary>
    /// Defines the slots available for styling in the RzBreadcrumb component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot, representing the root `nav` element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandEmpty.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<CommandEmpty.Slots>

<div @attributes="AdditionalAttributes"
     id="@Id"
     class="@SlotClasses.GetBase()"
     data-slot="command-empty"
     x-show="shouldShowEmptyOrError"
     x-cloak>
    <template x-if="hasError">
        <div class="text-destructive flex flex-col items-center gap-2">
            <Blazicon Svg="MdiIcon.AlertCircleOutline" class="size-6" />
            <p>Failed to load items.</p>
            <p class="text-xs" x-text="error"></p>
        </div>
    </template>
    <template x-if="notHasError">
        <div>
            @ChildContent
        </div>
    </template>
</div>
</file>

<file path="Components/Navigation/RzCommand/CommandEmpty.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that displays content when the command menu has no matching results for the current search query.
/// </summary>
public partial class CommandEmpty : RzComponent<CommandEmpty.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandEmpty component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "py-6 text-center text-sm"
    );
    /// <summary>
    /// Gets or sets the content to be displayed when no results are found.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandEmpty;
    /// <summary>
    /// Defines the slots available for styling in the CommandEmpty component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("command-empty")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandGroup.razor">
@namespace RizzyUI
@inherits RzComponent<CommandGroup.Slots>

<CascadingValue Value="this" IsFixed="true">
    <div @attributes="AdditionalAttributes"
         id="@Id"
         x-data="rzCommandGroup"
         data-slot="command-group"
         data-alpine-root="@Id"
         data-heading="@Heading"
         data-template-id="@HeadingTemplateId">
        <template x-if="firstRender" id="@HeadingTemplateId" data-heading-id="@HeadingId">
            <div class="@SlotClasses.GetHeading()" id="@HeadingId" data-slot="command-group-heading">@Heading</div>
        </template>
        @ChildContent
    </div>
</CascadingValue>
</file>

<file path="Components/Navigation/RzCommand/CommandGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for grouping <see cref="CommandItem"/>s under a common heading within a command menu.
/// </summary>
public partial class CommandGroup : RzComponent<CommandGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "overflow-hidden p-1 text-foreground",
        slots: new()
        {
            [s => s.Heading] = "px-2 py-1.5 text-xs font-medium text-muted-foreground"
        }
    );
    /// <summary>
    /// Gets or sets the heading text for the group.
    /// </summary>
    [Parameter]
    public string? Heading { get; set; }
    /// <summary>
    /// Gets or sets the child content, which should be a list of <see cref="CommandItem"/>s.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the unique ID for the heading element.
    /// </summary>
    protected string HeadingId { get; } = IdGenerator.UniqueId("rz-cmd-group-heading-");
    /// <summary>
    /// Gets the unique ID for the heading's template element.
    /// </summary>
    protected string HeadingTemplateId => $"{Id}-heading-template";
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandGroup;
    /// <summary>
    /// Defines the slots available for styling in the CommandGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("command-group")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the heading element.
        /// </summary>
        [Slot("command-group-heading")]
        public string? Heading { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandInput.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<CommandInput.Slots>

<div data-slot="command-input-wrapper" class="@SlotClasses.GetBase()">
    <Blazicon Svg="MdiIcon.Magnify" class="@SlotClasses.GetIcon()" />
    <input @attributes="AdditionalAttributes"
           id="@Id"
           class="@SlotClasses.GetInput()"
           data-slot="command-input"
           x-model.debounce.300ms="search"
           x-on:keydown="handleKeydown"
           x-on:focus="handleInteraction"
           role="combobox"
           x-bind:aria-expanded="isOpen"
           aria-controls="rz-command-list-@ParentCommand?.Id"
           x-bind:aria-activedescendant="activeDescendantId"
           autocomplete="off" />
</div>
</file>

<file path="Components/Navigation/RzCommand/CommandInput.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The input field for the command menu, responsible for capturing user search queries.
/// </summary>
public partial class CommandInput : RzComponent<CommandInput.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandInput component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex h-9 items-center gap-2 border-b px-3",
        slots: new()
        {
            [s => s.Icon] = "size-4 shrink-0 opacity-50",
            [s => s.Input] = "border-none focus-visible:ring-0 placeholder:text-muted-foreground flex h-8 w-full rounded-md bg-transparent py-3 text-sm outline-none disabled:cursor-not-allowed disabled:opacity-50"
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzCommand"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCommand? ParentCommand { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCommand == null)
            throw new InvalidOperationException($"{nameof(CommandInput)} must be used within an {nameof(RzCommand)}.");
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandInput;
    /// <summary>
    /// Defines the slots available for styling in the CommandInput component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the input wrapper.
        /// </summary>
        [Slot("command-input-wrapper")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the search icon.
        /// </summary>
        [Slot("icon")]
        public string? Icon { get; set; }
        /// <summary>
        /// The slot for the native input element.
        /// </summary>
        [Slot("input")]
        public string? Input { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandItem.razor">
@namespace RizzyUI
@inherits RzComponent<CommandItem.Slots>

<div @attributes="AdditionalAttributes"
     id="@Id"
     x-data="rzCommandItem"
     data-alpine-root="@Id"
     data-value="@Value"
     data-name="@Name"
     data-keywords="@_serializedKeywords"
     data-group="@ParentGroup?.Heading"
     data-disabled="@(Disabled.ToString().ToLowerInvariant())"
     data-force-mount="@(ForceMount.ToString().ToLowerInvariant())">
    <template x-if="firstRender" x-ref="template" id="@($"{Id}-template")">
        <div class="@SlotClasses.GetBase()" data-slot="command-item" aria-disabled="@(Disabled.ToString().ToLowerInvariant())" data-command-item-id="@Id">
            @ChildContent
        </div>
    </template>
</div>
</file>

<file path="Components/Navigation/RzCommand/CommandItem.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Text.Json;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a single selectable item within a command menu. Its content is defined as a template
/// and it registers itself with the parent <see cref="RzCommand"/> component.
/// </summary>
public partial class CommandItem : RzComponent<CommandItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
    );
    private string _serializedKeywords = "[]";
    /// <summary>
    /// Gets the parent <see cref="RzCommand"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCommand? ParentCommand { get; set; }
    /// <summary>
    /// Gets the parent <see cref="CommandGroup"/> component, if this item is nested within one.
    /// </summary>
    [CascadingParameter]
    protected CommandGroup? ParentGroup { get; set; }
    /// <summary>
    /// Gets or sets the unique value for this item. If not provided, it will be inferred from the text content.
    /// </summary>
    [Parameter]
    public string? Value { get; set; }
    /// <summary>
    /// Gets or sets the searchable name for this item, used for selection and filtering. If not provided, it will be inferred from the text content.
    /// </summary>
    [Parameter]
    public string? Name { get; set; }
    /// <summary>
    /// Gets or sets a collection of keywords to assist with filtering.
    /// </summary>
    [Parameter]
    public IEnumerable<string> Keywords { get; set; } = Enumerable.Empty<string>();
    /// <summary>
    /// Gets or sets the content to be rendered inside the item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether this item is disabled and cannot be selected.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether this item should always be rendered, regardless of the search query.
    /// </summary>
    [Parameter]
    public bool ForceMount { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCommand == null)
            throw new InvalidOperationException($"{nameof(CommandItem)} must be used within an {nameof(RzCommand)}.");
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _serializedKeywords = JsonSerializer.Serialize(Keywords);
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandItem;
    /// <summary>
    /// Defines the slots available for styling in the CommandItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the item's root element.
        /// </summary>
        [Slot("command-item")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandItemData.cs">
namespace RizzyUI;
/// <summary>
/// A default implementation of the <see cref="ICommandItemData"/> interface.
/// </summary>
public class CommandItemData : ICommandItemData
{
    /// <inheritdoc />
    public string Value { get; set; } = string.Empty;
    /// <inheritdoc />
    public string Name { get; set; } = string.Empty;
    /// <inheritdoc />
    public string? Shortcut { get; set; }
    /// <inheritdoc />
    public IEnumerable<string>? Keywords { get; set; }
    /// <inheritdoc />
    public string? Group { get; set; }
    /// <inheritdoc />
    public bool Disabled { get; set; }
    /// <inheritdoc />
    public bool ForceMount { get; set; }
}
</file>

<file path="Components/Navigation/RzCommand/CommandItemTemplate.razor">
@namespace RizzyUI
@inherits RzComponent<CommandItemTemplate.Slots>

<template id="@Id" data-slot="command-item-template">
    <div @attributes="AdditionalAttributes" class="@SlotClasses.GetBase()" data-slot="command-item">
        @ChildContent
    </div>
</template>
</file>

<file path="Components/Navigation/RzCommand/CommandItemTemplate.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines a client-side template for rendering data-bound items in an <see cref="RzCommand"/> component.
/// The content is rendered by Alpine.js for each item from a data source.
/// </summary>
public partial class CommandItemTemplate : RzComponent<CommandItemTemplate.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandItemTemplate. This styling is applied to the cloned item.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground aria-disabled:pointer-events-none aria-disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
    );
    [CascadingParameter]
    protected RzCommand? ParentCommand { get; set; }
    /// <summary>
    /// Gets or sets the render fragment that defines the template for each item.
    /// The template can use Alpine directives to bind to an `item` object in the scope (e.g., x-text="item.name").
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCommand == null)
            throw new InvalidOperationException($"{nameof(CommandItemTemplate)} must be used within an {nameof(RzCommand)}.");
        // The Id of this component becomes the Id of the template element
        Id = $"{ParentCommand.Id}-data-item-template";
        ParentCommand.DataItemTemplateId = Id;
    }
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandItemTemplate;
    /// <summary>
    /// Defines the slots for styling the CommandItemTemplate.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the item's root element.
        /// </summary>
        [Slot("command-item")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandList.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<CommandList.Slots>

<div @attributes="AdditionalAttributes"
     id="rz-command-list-@ParentCommand?.Id"
     class="@SlotClasses.GetBase()"
     data-slot="command-list"
     role="listbox"
     x-data="rzCommandList"
     x-on:rz:command:list-changed.window="renderList"
     x-on:click.capture="handleItemClick"
     x-on:mouseover.throttle.10ms="handleItemHover">
    
    <div x-show="showLoading()" class="flex items-center justify-center p-4" data-dynamic-item x-cloak>
        <RzSpinner Size="Size.Small" />
    </div>

    @ChildContent

</div>
</file>

<file path="Components/Navigation/RzCommand/CommandList.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The container that dynamically renders the list of filtered and sorted command items.
/// </summary>
public partial class CommandList : RzComponent<CommandList.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandList component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto"
    );
    /// <summary>
    /// Gets the parent <see cref="RzCommand"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzCommand? ParentCommand { get; set; }
    /// <summary>
    /// Gets or sets the child content, which should include <see cref="CommandItem"/>, <see cref="CommandGroup"/>, and <see cref="CommandEmpty"/> components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentCommand == null)
            throw new InvalidOperationException($"{nameof(CommandList)} must be used within an {nameof(RzCommand)}.");
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandList;
    /// <summary>
    /// Defines the slots available for styling in the CommandList component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the list container.
        /// </summary>
        [Slot("command-list")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<CommandSeparator.Slots>

<div @attributes="AdditionalAttributes"
     id="@Id"
     class="@SlotClasses.GetBase()"
     data-slot="command-separator"
     role="separator"
     x-show="firstRender">
</div>
</file>

<file path="Components/Navigation/RzCommand/CommandSeparator.razor.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A visual separator for use within a <see cref="CommandList"/> or <see cref="CommandGroup"/>.
/// </summary>
public partial class CommandSeparator : RzComponent<CommandSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "-mx-1 my-1 h-px bg-border"
    );
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandSeparator;
    /// <summary>
    /// Defines the slots available for styling in the CommandSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("command-separator")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/CommandShortcut.razor">
@namespace RizzyUI
@inherits RzComponent<CommandShortcut.Slots>

<span @attributes="AdditionalAttributes"
      id="@Id"
      class="@SlotClasses.GetBase()"
      data-slot="command-shortcut">
    @ChildContent
</span>
</file>

<file path="Components/Navigation/RzCommand/CommandShortcut.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component for displaying keyboard shortcuts within a <see cref="CommandItem"/>.
/// </summary>
public partial class CommandShortcut : RzComponent<CommandShortcut.Slots>
{
    /// <summary>
    /// Defines the default styling for the CommandShortcut component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "ml-auto text-xs tracking-widest text-muted-foreground"
    );
    /// <summary>
    /// Gets or sets the content of the shortcut, typically text representing key combinations.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.CommandShortcut;
    /// <summary>
    /// Defines the slots available for styling in the CommandShortcut component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("command-shortcut")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/ICommandItemData.cs">
namespace RizzyUI;
/// <summary>
/// Defines the contract for a command item that can be supplied as data to an RzCommand component.
/// </summary>
public interface ICommandItemData
{
    /// <summary>
    /// The unique value of the item, used for filtering and selection.
    /// </summary>
    string Value { get; set; }
    /// <summary>
    /// The name of the item, used for presentation.
    /// </summary>
    string Name { get; set; }
    /// <summary>
    /// The shortcut of the item, used for presentation.
    /// </summary>
    string? Shortcut { get; set; }
    /// <summary>
    /// A list of additional keywords to match against during search.
    /// </summary>
    IEnumerable<string>? Keywords { get; set; }
    /// <summary>
    /// The heading of the group this item belongs to.
    /// </summary>
    string? Group { get; set; }
    /// <summary>
    /// If true, the item cannot be selected.
    /// </summary>
    bool Disabled { get; set; }
    /// <summary>
    /// If true, the item will always be rendered, regardless of the search query.
    /// </summary>
    bool ForceMount { get; set; }
}
</file>

<file path="Components/Navigation/RzCommand/RzCommand.razor">
@namespace RizzyUI
@using RizzyUI.Extensions
@inherits RzComponent<RzCommand.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement" 
                 @attributes="@AdditionalAttributes" 
                 id="@Id" 
                 class="@SlotClasses.GetBase()"
                 data-slot="command"
                 x-data="rzCommand"
                 data-alpine-root="@Id"
                 data-loop="@(Loop.ToString().ToLowerInvariant())"
                 data-should-filter="@(ShouldFilter.ToString().ToLowerInvariant())"
                 data-selected-value="@SelectedValue"
                 data-items-id="@DataScriptId"
                 data-items-url="@ItemsUrl"
                 data-fetch-trigger="@FetchTrigger.ToString().ToKebabCase()"
                 data-server-filtering="@(ServerFiltering.ToString().ToLowerInvariant())"
                 data-template-id="@DataItemTemplateId"
                 aria-label="@AriaLabel">
        
        @if (string.IsNullOrEmpty(ItemsUrl) && Items.Any())
        {
            <script type="application/json" id="@DataScriptId">
                @((MarkupString)_serializedItems)
            </script>
        }

        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzCommand/RzCommand.razor.cs">
using Microsoft.AspNetCore.Components;
using System.Text.Json;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Defines when the data for the command menu should be fetched.
/// </summary>
public enum FetchTrigger
{
    /// <summary>
    /// Fetch the data as soon as the component is initialized.
    /// </summary>
    Immediate,
    /// <summary>
    /// Fetch the data only when the user first interacts with (opens) the command menu.
    /// </summary>
    OnOpen
}
/// <summary>
/// A highly interactive and accessible command menu component, inspired by cmdk and shadcn/ui.
/// It serves as the root container and state manager for the entire command menu family.
/// </summary>
public partial class RzCommand : RzComponent<RzCommand.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCommand component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground"
    );
    private string _serializedItems = "[]";
    /// <summary>
    /// Gets the unique ID for the JSON data script tag.
    /// </summary>
    protected string DataScriptId => $"{Id}-data";
    /// <summary>
    /// Internal property to hold the ID of the CommandItemTemplate.
    /// </summary>
    internal string? DataItemTemplateId { get; set; }
    /// <summary>
    /// Gets or sets the child content, which should include the various Command components like CommandInput and CommandList.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets a collection of command items to be rendered dynamically from a data source.
    /// These items are rendered on the client side by Alpine.js. The objects in the collection will be serialized to JSON.
    /// </summary>
    [Parameter]
    public IEnumerable<ICommandItemData> Items { get; set; } = [];
    /// <summary>
    /// Gets or sets a URL from which to fetch the command items as a JSON array.
    /// If this is set, the `Items` parameter is ignored.
    /// </summary>
    [Parameter]
    public string? ItemsUrl { get; set; }
    /// <summary>
    /// Gets or sets when to trigger the data fetch if `ItemsUrl` is provided.
    /// Defaults to `FetchTrigger.Immediate`.
    /// </summary>
    [Parameter]
    public FetchTrigger FetchTrigger { get; set; } = FetchTrigger.Immediate;
    /// <summary>
    /// Gets or sets a value indicating whether filtering should be performed on the server.
    /// If true, the search query will be appended to the `ItemsUrl` as `?q={query}`.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool ServerFiltering { get; set; }
    /// <summary>
    /// Gets or sets the accessible name for the command menu.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether the component should automatically filter and sort items based on the search query.
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool ShouldFilter { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether keyboard navigation should wrap around from the last item to the first, and vice-versa.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; }
    /// <summary>
    /// Gets or sets the currently selected value. This can be used to programmatically control the selection.
    /// </summary>
    [Parameter]
    public string? SelectedValue { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzCommand.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzCommand.DefaultAriaLabel"];
        if (string.IsNullOrEmpty(ItemsUrl) && Items.Any())
        {
            _serializedItems = JsonSerializer.Serialize(Items, new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });
        }
        else
        {
            _serializedItems = "[]";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCommand;
    /// <summary>
    /// Defines the slots available for styling in the RzCommand component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main command container.
        /// </summary>
        [Slot("command")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzCommand/RzCommandDialog.razor">
@namespace RizzyUI
@inherits RzComponent<RzCommandDialog.Slots>

<RzDialog @bind-Open="Open" EventTriggerName="@EventTriggerName">
    <DialogContent class="@SlotClasses.GetBase()" ShowCloseButton="@ShowCloseButton">
        <DialogHeader class="sr-only">
            <DialogTitle>@Title</DialogTitle>
            <DialogDescription>@Description</DialogDescription>
        </DialogHeader>
        <RzCommand class="@SlotClasses.GetCommand()"
                   ShouldFilter="@ShouldFilter"
                   Loop="@Loop"
                   SelectedValue="@SelectedValue">
            @ChildContent
        </RzCommand>
    </DialogContent>
</RzDialog>
</file>

<file path="Components/Navigation/RzCommand/RzCommandDialog.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A composite component that renders an <see cref="RzCommand"/> menu inside a modal <see cref="RzDialog"/>.
/// </summary>
public partial class RzCommandDialog : RzComponent<RzCommandDialog.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzCommandDialog component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "overflow-hidden p-0",
        slots: new()
        {
            [s => s.Command] = "[&_[data-slot=command-group-heading]]:text-muted-foreground [&_[data-slot=command-group-heading]]:px-2 [&_[data-slot=command-group-heading]]:font-medium [&_[data-slot=command-group]]:px-2 [&_[data-slot=command-group]:not([hidden])_~[data-slot=command-group]]:pt-0 [&_[data-slot=command-input-wrapper]_svg]:h-5 [&_[data-slot=command-input-wrapper]_svg]:w-5 [&_[data-slot=command-input]]:h-12 [&_[data-slot=command-input]]:h-12 [&_[data-slot=command-input-wrapper]]:h-12 [&_[data-slot=command-item]]:px-2 [&_[data-slot=command-item]]:py-3 [&_[data-slot=command-item]_svg]:h-5 [&_[data-slot=command-item]_svg]:w-5"
        }
    );
    /// <summary>
    /// Gets or sets a value indicating whether the dialog is open.
    /// </summary>
    [Parameter]
    public bool Open { get; set; }
    /// <summary>
    /// Gets or sets the title for the dialog, used for accessibility.
    /// </summary>
    [Parameter]
    public string? Title { get; set; }
    /// <summary>
    /// Gets or sets the description for the dialog, used for accessibility.
    /// </summary>
    [Parameter]
    public string? Description { get; set; }
    /// <summary>
    /// Gets or sets the child content of the command menu.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether to show the default close button on the dialog.
    /// </summary>
    [Parameter]
    public bool ShowCloseButton { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether the command menu should filter items.
    /// </summary>
    [Parameter]
    public bool ShouldFilter { get; set; } = true;
    /// <summary>
    /// Gets or sets a value indicating whether keyboard navigation should loop.
    /// </summary>
    [Parameter]
    public bool Loop { get; set; }
    /// <summary>
    /// Gets or sets the currently selected value in the command menu.
    /// </summary>
    [Parameter]
    public string? SelectedValue { get; set; }
    /// <summary>
    /// Gets or sets the name of the window event that will trigger this dialog to open.
    /// If empty, a unique name will be generated.
    /// </summary>
    [Parameter]
    public string EventTriggerName { get; set; } = string.Empty;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Title ??= Localizer["RzCommandDialog.DefaultTitle"];
        Description ??= Localizer["RzCommandDialog.DefaultDescription"];
        if (string.IsNullOrEmpty(EventTriggerName))
        {
            EventTriggerName = $"show-command-dialog-{Id}";
        }
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Title ??= Localizer["RzCommandDialog.DefaultTitle"];
        Description ??= Localizer["RzCommandDialog.DefaultDescription"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzCommandDialog;
    /// <summary>
    /// Defines the slots available for styling in the RzCommandDialog component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the dialog content panel.
        /// </summary>
        [Slot("dialog-content")]
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the nested RzCommand component.
        /// </summary>
        [Slot("command")]
        public string? Command { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuContent.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuContent.Slots>

<template x-teleport="body">
    <div @attributes="AdditionalAttributes"
         x-ref="content"
         id="@ContentId"
         data-floating
         data-popover
         role="menu"
         aria-labelledby="@TriggerId"
         x-show="open"
         x-cloak
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0 scale-95"
         x-transition:enter-end="opacity-100 scale-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100 scale-100"
         x-transition:leave-end="opacity-0 scale-95"
         x-trap="trapActive"
         x-on:click.outside="handleOutsideClick"
         x-on:keydown.down.prevent="focusNextItem"
         x-on:keydown.up.prevent="focusPreviousItem"
         x-on:keydown.home.prevent="focusFirstItem"
         x-on:keydown.end.prevent="focusLastItem"
         x-on:keydown.tab.prevent="handleContentTabKey"
         class="@SlotClasses.GetBase()"
         data-slot="dropdown-menu-content">
        <div class="@SlotClasses.GetInnerContainer()">
            @ChildContent
        </div>
    </div>
</template>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the content area of an <see cref="RzDropdownMenu"/> that appears when the trigger is activated.
/// It typically contains <see cref="DropdownMenuItem"/>, <see cref="DropdownMenuGroup"/>, and other related components.
/// </summary>
public partial class DropdownMenuContent : RzComponent<DropdownMenuContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute z-50 mt-1 min-w-[8rem] rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        slots: new()
        {
            [s => s.InnerContainer] = ""
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzDropdownMenu"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDropdownMenu? ParentDropdownMenu { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the dropdown panel. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets the ID for the content element.
    /// </summary>
    protected string ContentId => $"{ParentDropdownMenu?.Id}-content";
    /// <summary>
    /// Gets the ID of the trigger element that controls this content.
    /// </summary>
    protected string TriggerId => $"{ParentDropdownMenu?.Id}-trigger";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDropdownMenu == null)
        {
            throw new InvalidOperationException($"{nameof(DropdownMenuContent)} must be used within an {nameof(RzDropdownMenu)}.");
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuContent;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main content panel.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner container of the content.
        /// </summary>
        public string? InnerContainer { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuGroup.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuGroup.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="group"
             data-slot="dropdown-menu-group">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a group of related <see cref="DropdownMenuItem"/>s within <see cref="DropdownMenuContent"/>.
/// </summary>
public partial class DropdownMenuGroup : RzComponent<DropdownMenuGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "py-1"
    );
    /// <summary>
    /// Gets or sets the content of the group, typically <see cref="DropdownMenuItem"/>s. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuGroup;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuItem.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<DropdownMenuItem.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="menuitem"
             tabindex="-1"
             x-on:click="handleItemClick"
             x-on:mouseenter="handleItemMouseEnter"
             aria-disabled="@(Disabled.ToString().ToLowerInvariant())"
             disabled="@(Disabled ? "disabled" : null)"
             data-slot="dropdown-menu-item">
    @if (Icon != null)
    {
        <span class="@SlotClasses.GetIcon()"><Blazicon Svg="@Icon"/></span>
    }
    @ChildContent
    @if (ShortcutContent != null)
    {
        @ShortcutContent
    }
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuItem.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents an individual interactive item within a <see cref="DropdownMenuGroup"/> or <see cref="DropdownMenuContent"/>.
/// </summary>
public partial class DropdownMenuItem : RzComponent<DropdownMenuItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative flex cursor-default select-none w-full items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 hover:bg-accent hover:text-accent-foreground",
        slots: new()
        {
            [s => s.Icon] = "mr-2 size-4 text-xl"
        }
    );
    /// <summary>
    /// Gets or sets the content of the menu item, typically text. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets an optional icon to display before the item content.
    /// </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary>
    /// Gets or sets optional content to display as a shortcut hint (e.g., "S").
    /// This can be a <see cref="DropdownMenuShortcut"/> component or simple text.
    /// </summary>
    [Parameter]
    public RenderFragment? ShortcutContent { get; set; }
    /// <summary>
    /// Gets or sets a value indicating whether the menu item is disabled.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
        {
            Element = "button";
        }
        if (Element.Equals("button", StringComparison.OrdinalIgnoreCase) &&
            (AdditionalAttributes == null || !AdditionalAttributes.ContainsKey("type")))
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            AdditionalAttributes["type"] = "button";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuItem;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the icon element.
        /// </summary>
        public string? Icon { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuLabel.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuLabel.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             role="heading"
             aria-level="3"
             data-slot="dropdown-menu-label">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuLabel.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a non-interactive label or heading within a <see cref="DropdownMenuContent"/>.
/// </summary>
public partial class DropdownMenuLabel : RzComponent<DropdownMenuLabel.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuLabel component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "px-2 py-1.5 text-sm font-semibold text-foreground"
    );
    /// <summary>
    /// Gets or sets the content of the label. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuLabel;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuLabel component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuSeparator.Slots>

<HtmlElement Element="@EffectiveElement"
             role="separator"
             aria-orientation="horizontal"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="dropdown-menu-separator"/>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSeparator.razor.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a visual separator line within a <see cref="DropdownMenuContent"/> or <see cref="DropdownMenuGroup"/>.
/// </summary>
public partial class DropdownMenuSeparator : RzComponent<DropdownMenuSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "-mx-1 my-1 h-px bg-border"
    );
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
        {
            Element = "hr";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuSeparator;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuShortcut.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuShortcut.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="dropdown-menu-shortcut">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuShortcut.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a styled text element typically used to display keyboard shortcuts
/// alongside a <see cref="DropdownMenuItem"/>.
/// </summary>
public partial class DropdownMenuShortcut : RzComponent<DropdownMenuShortcut.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuShortcut component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "ml-auto text-xs tracking-widest text-muted-foreground"
    );
    /// <summary>
    /// Gets or sets the content of the shortcut, e.g., "S". Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
        {
            Element = "span";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuShortcut;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuShortcut component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSub.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuSub.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement"
                 @attributes="@AdditionalAttributes"
                 id="@Id"
                 class="@SlotClasses.GetBase()"
                 x-data="rzDropdownSubmenu"
                 data-alpine-root="@Id"
                 data-parent-id="@ParentDropdownMenu?.Id"
                 data-sub-anchor="@Anchor.ToString().ToKebabCase()"
                 data-sub-offset="@Offset"
                 data-slot="dropdown-menu-sub">
        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSub.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a sub-menu container within an <see cref="RzDropdownMenu"/>.
/// It requires a <see cref="DropdownMenuSubTrigger"/> and <see cref="DropdownMenuSubContent"/> as children.
/// Interactivity is managed by the 'rzDropdownSubmenu' Alpine.js component.
/// </summary>
public partial class DropdownMenuSub : RzComponent<DropdownMenuSub.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuSub component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative"
    );
    /// <summary>
    /// Gets the parent <see cref="RzDropdownMenu"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDropdownMenu? ParentDropdownMenu { get; set; }
    /// <summary>
    /// Gets or sets the content of the sub-menu, typically a <see cref="DropdownMenuSubTrigger"/>
    /// and a <see cref="DropdownMenuSubContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the preferred position of the sub-menu content relative to its trigger.
    /// Defaults to <see cref="AnchorPoint.RightStart"/>.
    /// </summary>
    [Parameter]
    public AnchorPoint Anchor { get; set; } = AnchorPoint.RightStart;
    /// <summary>
    /// Gets or sets the offset in pixels from the anchor point where the sub-menu content should appear.
    /// Defaults to -4 (slight overlap).
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = -4;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDropdownMenu == null)
        {
            throw new InvalidOperationException($"{nameof(DropdownMenuSub)} must be used within an {nameof(RzDropdownMenu)}.");
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuSub;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuSub component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSubContent.razor">
@namespace RizzyUI
@inherits RzComponent<DropdownMenuSubContent.Slots>

<template x-teleport="body">
	<div @attributes="AdditionalAttributes"
	     x-ref="subContent"
	     id="@SubContentId"
	     data-floating
	     data-popover
	     role="menu"
	     aria-labelledby="@SubTriggerId"
	     x-show="open"
	     x-cloak
         x-on:mouseenter="handleContentMouseEnter"
         x-on:mouseleave="handleContentMouseLeave"
	     x-transition:enter="transition ease-out duration-100"
	     x-transition:enter-start="opacity-0 scale-95"
	     x-transition:enter-end="opacity-100 scale-100"
	     x-transition:leave="transition ease-in duration-75"
	     x-transition:leave-start="opacity-100 scale-100"
	     x-transition:leave-end="opacity-0 scale-95"
	     x-trap="open"
	     x-on:keydown.escape.prevent="handleSubmenuEscape"
	     x-on:keydown.left.prevent="handleSubmenuArrowLeft"
	     x-on:keydown.down.prevent="focusNextItem"
	     x-on:keydown.up.prevent="focusPreviousItem"
	     x-on:keydown.home.prevent="focusFirstItem"
	     x-on:keydown.end.prevent="focusLastItem"
	     class="@SlotClasses.GetBase()"
         data-slot="dropdown-menu-sub-content">
		<div class="@SlotClasses.GetInnerContainer()">
			@ChildContent
		</div>
	</div>
</template>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSubContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the content area of a <see cref="DropdownMenuSub"/> that appears when its trigger is activated.
/// </summary>
public partial class DropdownMenuSubContent : RzComponent<DropdownMenuSubContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuSubContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg animate-in data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        slots: new()
        {
            [s => s.InnerContainer] = ""
        }
    );
    /// <summary>
    /// Gets the parent <see cref="DropdownMenuSub"/> component.
    /// </summary>
    [CascadingParameter]
    protected DropdownMenuSub? ParentSubmenu { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the sub-menu panel. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets the ID for the sub-menu content element.
    /// </summary>
    protected string SubContentId => $"{ParentSubmenu?.Id}-subcontent";
    /// <summary>
    /// Gets the ID of the sub-menu trigger element that controls this content.
    /// </summary>
    protected string SubTriggerId => $"{ParentSubmenu?.Id}-subtrigger";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSubmenu == null)
        {
            throw new InvalidOperationException($"{nameof(DropdownMenuSubContent)} must be used within a {nameof(DropdownMenuSub)}.");
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuSubContent;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuSubContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main content panel.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the inner container of the content.
        /// </summary>
        public string? InnerContainer { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSubTrigger.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<DropdownMenuSubTrigger.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@TriggerId"
             class="@SlotClasses.GetBase()"
             role="menuitem"
             tabindex="-1"
             aria-haspopup="menu"
             aria-controls="@SubContentId"
             x-ref="subTrigger"
             x-bind:aria-expanded="ariaExpanded"
             x-on:click.prevent="toggleSubmenu"
             x-on:mouseenter="handleTriggerMouseEnter"
             x-on:mouseleave="handleTriggerMouseLeave"
             x-on:keydown.enter.prevent="handleTriggerKeydown"
             x-on:keydown.space.prevent="handleTriggerKeydown"
             x-on:keydown.right.prevent="handleTriggerKeydown"
             data-slot="dropdown-menu-sub-trigger">
    @if (Icon != null)
    {
        <span class="@SlotClasses.GetIcon()"><Blazicon Svg="@Icon"/></span>
    }
    @ChildContent
    <Blazicon Svg="MdiIcon.ChevronRight" class="@SlotClasses.GetChevron()" aria-hidden="true"/>
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuSubTrigger.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the trigger element for a <see cref="DropdownMenuSub"/>, which opens a nested sub-menu.
/// It is typically styled like a <see cref="DropdownMenuItem"/> but includes a chevron icon.
/// </summary>
public partial class DropdownMenuSubTrigger : RzComponent<DropdownMenuSubTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuSubTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex cursor-default select-none w-full items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent hover:bg-accent hover:text-accent-foreground",
        slots: new()
        {
            [s => s.Icon] = "mr-2 size-4 text-xl",
            [s => s.Chevron] = "ml-auto size-4"
        }
    );
    /// <summary>
    /// Gets the parent <see cref="DropdownMenuSub"/> component.
    /// </summary>
    [CascadingParameter]
    protected DropdownMenuSub? ParentSubmenu { get; set; }
    /// <summary>
    /// Gets or sets the content of the sub-menu trigger, typically text. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets an optional icon to display before the trigger content.
    /// </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary>
    /// Gets the ID for the sub-menu trigger element.
    /// </summary>
    protected string TriggerId => $"{ParentSubmenu?.Id}-subtrigger";
    /// <summary>
    /// Gets the ID of the sub-menu content element this trigger controls.
    /// </summary>
    protected string SubContentId => $"{ParentSubmenu?.Id}-subcontent";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSubmenu == null)
        {
            throw new InvalidOperationException($"{nameof(DropdownMenuSubTrigger)} must be used within a {nameof(DropdownMenuSub)}.");
        }
        if (string.IsNullOrEmpty(Element))
        {
            Element = "button";
        }
        if (Element.Equals("button", StringComparison.OrdinalIgnoreCase) &&
            (AdditionalAttributes == null || !AdditionalAttributes.ContainsKey("type")))
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            AdditionalAttributes["type"] = "button";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuSubTrigger;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuSubTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the icon element.
        /// </summary>
        public string? Icon { get; set; }
        /// <summary>
        /// The slot for the chevron icon.
        /// </summary>
        public string? Chevron { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<DropdownMenuTrigger.Slots>

@if (AsChild)
{
	@RenderAsChild()
}
else
{
	<HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
		@ChildContent
	</HtmlElement>
}
</file>

<file path="Components/Navigation/RzDropdown/DropdownMenuTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents the trigger element for an <see cref="RzDropdownMenu"/>.
/// This component wraps the content that users will click or interact with to open the dropdown.
/// </summary>
public partial class DropdownMenuTrigger : RzAsChildComponent<DropdownMenuTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the DropdownMenuTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex"
    );
    /// <summary>
    /// Gets the parent <see cref="RzDropdownMenu"/> component.
    /// </summary>
    [CascadingParameter]
    protected RzDropdownMenu? ParentDropdownMenu { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered as the trigger. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets the ID for the trigger element.
    /// </summary>
    protected string TriggerId => $"{ParentDropdownMenu?.Id}-trigger";
    /// <summary>
    /// Gets the ID of the content element this trigger controls.
    /// </summary>
    protected string ContentId => $"{ParentDropdownMenu?.Id}-content";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentDropdownMenu == null)
        {
            throw new InvalidOperationException($"{nameof(DropdownMenuTrigger)} must be used within an {nameof(RzDropdownMenu)}.");
        }
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = TriggerId,
            ["class"] = SlotClasses.GetBase(),
            ["x-ref"] = "trigger",
            ["aria-haspopup"] = "menu",
            ["aria-controls"] = ContentId,
            ["x-bind:aria-expanded"] = "ariaExpanded",
            ["x-on:click"] = "toggle",
            ["x-on:mouseover"] = "handleTriggerMouseover",
            ["x-on:keydown.enter.prevent"] = "handleTriggerKeydown",
            ["x-on:keydown.space.prevent"] = "handleTriggerKeydown",
            ["x-on:keydown.down.prevent"] = "handleTriggerKeydown",
            ["x-on:keydown.up.prevent"] = "handleTriggerKeydown",
            ["data-slot"] = "dropdown-menu-trigger"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.DropdownMenuTrigger;
    /// <summary>
    /// Defines the slots available for styling in the DropdownMenuTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownMenu.razor">
@namespace RizzyUI
@inherits RzComponent<RzDropdownMenu.Slots>

<CascadingValue Value="this" IsFixed="true">
    <!-- Invisible Alpine controller: no visual wrapper, retains a stable $el -->
    <div id="@Id"
         class="@SlotClasses.GetBase()"
         x-data="rzDropdownMenu"
         data-alpine-root="@Id"
         data-offset="@Offset"
         data-anchor="@Anchor.ToString().ToKebabCase()"
         data-modal="@IsModal.ToString().ToLowerInvariant()"
         x-on:keydown.escape.window="handleWindowEscape"
         @attributes="@AdditionalAttributes"
         data-slot="dropdown-menu">
        @ChildContent
    </div>
</CascadingValue>
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownMenu.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The root component for a dropdown menu system. It provides context for its children,
/// including trigger, content, items, groups, and sub-menus.
/// Interactivity is managed by the 'rzDropdownMenu' Alpine.js component.
/// </summary>
public partial class RzDropdownMenu : RzComponent<RzDropdownMenu.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzDropdownMenu component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "contents" // Use 'contents' to make the wrapper layout-agnostic
    );
    /// <summary>
    /// Gets or sets the content of the dropdown menu, typically including a <see cref="DropdownMenuTrigger"/>
    /// and a <see cref="DropdownMenuContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the preferred position of the dropdown menu relative to the trigger.
    /// Defaults to <see cref="AnchorPoint.Bottom"/>.
    /// </summary>
    [Parameter]
    public AnchorPoint Anchor { get; set; } = AnchorPoint.Bottom;
    /// <summary>
    /// Gets or sets the offset in pixels from the anchor point where the dropdown menu should appear.
    /// Defaults to 4.
    /// </summary>
    [Parameter]
    public int Offset { get; set; } = 4;
    /// <summary>
    /// Gets or sets whether the dropdown menu behaves as a modal, affecting focus trapping.
    /// Defaults to false.
    /// </summary>
    [Parameter]
    public bool IsModal { get; set; } = false;
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzDropdownMenu;
    /// <summary>
    /// Defines the slots available for styling in the RzDropdownMenu component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzLink/RzLink.razor">
@namespace RizzyUI
@inherits RzComponent<RzLink.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" href="@Href" id="@Id" class="@SlotClasses.GetBase()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzLink/RzLink.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Represents a styled link component that renders an anchor (<c>a</c>) element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzLink : RzComponent<RzLink.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzLink component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "font-medium underline-offset-2 focus:outline-hidden",
        variants: new()
        {
            [l => ((RzLink)l).Color] = new Variant<SemanticColor, Slots>
            {
                [SemanticColor.Primary] = "text-primary",
                [SemanticColor.Secondary] = "text-secondary",
                [SemanticColor.Success] = "text-success",
                [SemanticColor.Warning] = "text-warning",
                [SemanticColor.Destructive] = "text-destructive",
                [SemanticColor.Info] = "text-info",
                [SemanticColor.Foreground] = "text-foreground",
                [SemanticColor.None] = ""
            },
            [l => ((RzLink)l).Underline] = new Variant<bool, Slots>
            {
                [true] = "hover:underline focus:underline"
            }
        }
    );
    /// <summary> Gets or sets the URL to which the link navigates. If null or empty, defaults to "#". </summary>
    [Parameter]
    public string? Href { get; set; }
    /// <summary>
    /// Gets or sets the color of the link. Defaults to <see cref="SemanticColor.Primary" />.
    /// </summary>
    [Parameter]
    public SemanticColor Color { get; set; } = SemanticColor.Primary;
    /// <summary> Gets or sets whether the link should be underlined on hover and focus. Defaults to true. </summary>
    [Parameter]
    public bool Underline { get; set; } = true;
    /// <summary> Gets or sets the content to be displayed inside the link (e.g., text or icons). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Sets default element to <c>a</c> for the link component.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "a";
    }
    /// <summary>
    /// Invoked when a component's parameters have been set or updated.
    /// Updates the <c>Href</c> parameter to a default value if it has not been specified.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Href ??= "#";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzLink;
    /// <summary>
    /// Defines the slots available for styling in the RzLink component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuContent.razor">
@namespace RizzyUI
@inherits RzComponent<NavigationMenuContent.Slots>

<div @attributes="AdditionalAttributes"
     x-ref="content_@ParentItem?.Id"
     id="@ContentId"
     data-item-id="@ParentItem?.Id"
     data-floating
     data-popover
     class="@SlotClasses.GetBase()"
     x-on:mouseenter="handleContentEnter"
     x-cloak
     data-slot="navigation-menu-content">
    @ChildContent
</div>
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Container for the content displayed when a <see cref="NavigationMenuTrigger"/> is activated. This is a nested component.
/// </summary>
public partial class NavigationMenuContent : RzComponent<NavigationMenuContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the NavigationMenuContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute left-0 top-full z-50 mt-1.5 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg will-change-[opacity,transform] data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 data-[motion=fade-in]:animate-in data-[motion=fade-in]:fade-in-0 data-[motion=fade-out]:animate-out data-[motion=fade-out]:fade-out-0 duration-200"
    );
    /// <summary>
    /// Cascading parent NavigationMenuItem.
    /// </summary>
    [CascadingParameter]
    protected NavigationMenuItem? ParentItem { get; set; }
    /// <summary>
    /// The content to be rendered inside the panel.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// The unique ID of the content panel.
    /// </summary>
    protected string ContentId => $"{ParentItem?.Id}-content";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentItem is null)
        {
            throw new InvalidOperationException($"{nameof(NavigationMenuContent)} must be used within a {nameof(NavigationMenuItem)}.");
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.NavigationMenuContent;
    /// <summary>
    /// Defines the slots available for styling in the NavigationMenuContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuItem.razor">
@namespace RizzyUI
@inherits RzComponent<NavigationMenuItem.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             @attributes="@AdditionalAttributes"
	             id="@Id"
	             class="@SlotClasses.GetBase()"
	             role="menuitem"
	             x-on:mouseenter="handleItemEnter"
                 data-slot="navigation-menu-item">
		@ChildContent
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuItem.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A wrapper for a navigation menu item, which can contain a trigger and content, or a direct link. This is a nested component.
/// </summary>
public partial class NavigationMenuItem : RzComponent<NavigationMenuItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the NavigationMenuItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative"
    );
    /// <summary>
    /// The parent RzNavigationMenu component.
    /// </summary>
    [CascadingParameter]
    protected RzNavigationMenu? ParentMenu { get; set; }
    /// <summary>
    /// Content of the item, typically a <see cref="NavigationMenuTrigger"/> and <see cref="NavigationMenuContent"/> or a <see cref="NavigationMenuLink"/>.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "li";
        ParentMenu?.AddItem(this);
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.NavigationMenuItem;
    /// <summary>
    /// Defines the slots available for styling in the NavigationMenuItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuLink.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<NavigationMenuLink.Slots>

@if (AsChild)
{
	@RenderAsChild()
}
else
{
	<HtmlElement Element="@EffectiveElement"
	             id="@Id"
	             class="@SlotClasses.GetBase()"
	             @attributes="@AdditionalAttributes">
		@ChildContent
	</HtmlElement>	
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuLink.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A link within a navigation menu that navigates to a URL. This is a nested component.
/// It acts as a wrapper and should contain a navigable element like an anchor tag or RzLink.
/// </summary>
public partial class NavigationMenuLink : RzAsChildComponent<NavigationMenuLink.Slots>
{
    /// <summary>
    /// Defines the default styling for the NavigationMenuLink component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new();
    /// <summary>
    /// The content to display within the link, typically an `&lt;a&gt;` or `&lt;RzLink&gt;` component.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Link URL to navigate to when the link is clicked.
    /// </summary>
    [Parameter]
    public string? Href { get; set; }
    /// <inheritdoc />
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc />
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["href"] = Href,
            ["data-slot"] = "navigation-menu-link"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.NavigationMenuLink;
    /// <summary>
    /// Defines the slots available for styling in the NavigationMenuLink component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuList.razor">
@namespace RizzyUI
@inherits RzComponent<NavigationMenuList.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-orientation="@ParentMenu?.Orientation.ToString().ToLowerInvariant()"
             dir="ltr"
             x-ref="list"
             data-slot="navigation-menu-list">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuList.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A list of navigation menu items. This is a nested component.
/// </summary>
public partial class NavigationMenuList : RzComponent<NavigationMenuList.Slots>
{
    /// <summary>
    /// Defines the default styling for the NavigationMenuList component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group flex flex-1 list-none items-center justify-center gap-1"
    );
    /// <summary>
    /// The parent RzNavigationMenu component.
    /// </summary>
    [CascadingParameter]
    protected RzNavigationMenu? ParentMenu { get; set; }
    /// <summary>
    /// The items to display in the list, typically <see cref="NavigationMenuItem"/> components.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "ul";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.NavigationMenuList;
    /// <summary>
    /// Defines the slots available for styling in the NavigationMenuList component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuTrigger.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<NavigationMenuTrigger.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@TriggerId"
             class="@SlotClasses.GetBase()"
             x-ref="@TriggerXRef"
             aria-haspopup="true"
             aria-expanded="false"
             aria-controls="@ContentId"
             data-state="closed"
             x-on:click.prevent="toggleActive"
             x-on:focus="handleTriggerEnter"
             data-slot="navigation-menu-trigger">
	@ChildContent
	<span class="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180">
		<Blazicon Svg="MdiIcon.ChevronDown" aria-hidden="true"/>
	</span>
</HtmlElement>
</file>

<file path="Components/Navigation/RzNavigationMenu/NavigationMenuTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The trigger that opens the content of a <see cref="NavigationMenuItem"/>. This is a nested component.
/// </summary>
public partial class NavigationMenuTrigger : RzComponent<NavigationMenuTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the NavigationMenuTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:bg-accent/50"
    );
    /// <summary>
    /// The parent NavigationMenuItem component.
    /// </summary>
    [CascadingParameter]
    protected NavigationMenuItem? ParentItem { get; set; }
    /// <summary>
    /// The text or other content to display in the trigger.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// The unique ID of the trigger element.
    /// </summary>
    protected string TriggerId => $"{ParentItem?.Id}-trigger";
    /// <summary>
    /// The ID of the content panel this trigger controls.
    /// </summary>
    protected string ContentId => $"{ParentItem?.Id}-content";
    /// <summary>
    /// Trigger XRef is used to reference the trigger element in Alpine.js.
    /// </summary>
    protected string TriggerXRef => $"trigger_{ParentItem?.Id}";
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "button";
        if (Element.Equals("button", StringComparison.OrdinalIgnoreCase) && (AdditionalAttributes is null || !AdditionalAttributes.ContainsKey("type")))
        {
            AdditionalAttributes ??= new Dictionary<string, object>();
            AdditionalAttributes["type"] = "button";
        }
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.NavigationMenuTrigger;
    /// <summary>
    /// Defines the slots available for styling in the NavigationMenuTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzNavigationMenu/RzNavigationMenu.razor">
@namespace RizzyUI
@inherits RzComponent<RzNavigationMenu.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement"
                 @attributes="@AdditionalAttributes"
                 id="@Id" 
                 class="@SlotClasses.GetBase()"
                 aria-label="@AriaLabel"
                 data-orientation="@Orientation.ToString().ToLowerInvariant()"
                 dir="ltr"
                 x-data="rzNavigationMenu"
                 data-alpine-root="@Id"
                 x-on:keydown.escape.window="closeMenu"
                 data-slot="navigation-menu">
        <div class="relative" x-on:mouseleave="scheduleClose">
            @ChildContent
        </div>
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzNavigationMenu/RzNavigationMenu.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A collection of links for navigating a website. This is a root-level component.
/// </summary>
/// <remarks>
/// As a root-level component, its name is prefixed with 'Rz'.
/// </remarks>
public partial class RzNavigationMenu : RzComponent<RzNavigationMenu.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzNavigationMenu component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center"
    );
    internal readonly List<NavigationMenuItem> Items = new();
    /// <summary>
    /// Gets or sets the content of the navigation menu, typically a <see cref="NavigationMenuList"/>.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// The orientation of the menu.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <summary>
    /// The accessible name for the navigation menu.
    /// If not set, a default localized label will be applied.
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav";
        AriaLabel ??= Localizer["RzNavigationMenu.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzNavigationMenu.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzNavigationMenu;
    internal void AddItem(NavigationMenuItem item)
    {
        if (!Items.Contains(item))
        {
            Items.Add(item);
        }
    }
    /// <summary>
    /// Defines the slots available for styling in the RzNavigationMenu component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarProvider.razor">
@namespace RizzyUI
@inherits RzComponent<RzSidebarProvider.Slots>

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="@EffectiveElement"
	             @attributes="@AdditionalAttributes"
	             id="@Id"
	             class="@SlotClasses.GetBase()"
	             data-slot="sidebar-wrapper"
	             x-data="rzSidebar"
	             x-mobile="isMobile"
	             data-alpine-root="@Id"
	             data-default-open="@DefaultOpen.ToString().ToLowerInvariant()"
	             data-collapsible="@Collapsible.ToString().ToLowerInvariant()"
	             data-shortcut="@KeyboardShortcut"
	             data-cookie-name="@PersistenceCookieName"
	             data-mobile-breakpoint="768">
		
		<style nonce="@Nonce">
            :root {
                --sidebar-width: @Width;
                --sidebar-mobile-width: @MobileWidth;
                --sidebar-width-icon: @IconWidth;
            }
        </style>
		
		@ChildContent
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarProvider.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Root provider for a sidebar system. It manages the shared state (open/closed, collapsible mode)
/// and cascades this information to all child sidebar components. It also hosts the Alpine.js component
/// responsible for client-side interactivity.
/// </summary>
public partial class RzSidebarProvider : RzComponent<RzSidebarProvider.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzSidebarProvider component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"
    );
    /// <summary>
    /// Gets or sets the content of the sidebar provider, which should include a <see cref="Sidebar"/>
    /// and a <see cref="SidebarTrigger"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the initial open state of the sidebar on desktop. This is an uncontrolled property.
    /// If a cookie is used for persistence, the cookie's value will override this. Defaults to true.
    /// </summary>
    [Parameter]
    public bool DefaultOpen { get; set; } = true;
    /// <summary>
    /// Gets or sets the collapsible behavior of the sidebar.
    /// Defaults to <see cref="SidebarCollapsible.OffCanvas"/>.
    /// </summary>
    [Parameter]
    public SidebarCollapsible Collapsible { get; set; } = SidebarCollapsible.OffCanvas;
    /// <summary>
    /// Gets or sets the keyboard key used for the open/close shortcut (e.g., "b").
    /// The shortcut is triggered with Cmd/Ctrl + key. Defaults to "b".
    /// </summary>
    [Parameter]
    public string KeyboardShortcut { get; set; } = "b";
    /// <summary>
    /// Gets or sets the name of the cookie used to persist the sidebar's open/closed state.
    /// If null or empty, the state will not be persisted. Defaults to "sidebar_state".
    /// </summary>
    [Parameter]
    public string? PersistenceCookieName { get; set; } = "sidebar_state";
    /// <summary>
    /// Gets or sets the width of the sidebar on desktop viewports.
    /// Must be a valid CSS value (e.g., "16rem", "250px"). Defaults to "16rem".
    /// </summary>
    [Parameter]
    public string Width { get; set; } = "16rem";
    /// <summary>
    /// Gets or sets the width of the sidebar on mobile viewports.
    /// Must be a valid CSS value (e.g., "18rem", "280px"). Defaults to "18rem".
    /// </summary>
    [Parameter]
    public string MobileWidth { get; set; } = "18rem";
    /// <summary>
    /// Gets or sets the width of the sidebar when collapsed to icon-only mode.
    /// Must be a valid CSS value. Defaults to "3rem".
    /// </summary>
    [Parameter]
    public string IconWidth { get; set; } = "3rem";
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzSidebarProvider;
    /// <summary>
    /// Defines the slots available for styling in the RzSidebarProvider component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/Sidebar.razor">
@namespace RizzyUI
@inherits RzComponent<Sidebar.Slots>

@if (ParentProvider?.Collapsible == SidebarCollapsible.None)
{
	<div data-slot="sidebar" class="@SlotClasses.GetBase()" @attributes="AdditionalAttributes">
		@ChildContent
	</div>
}
else
{
	<div class="@SlotClasses.GetBase()"
	     x-bind:data-state="desktopState"
	     x-bind:data-collapsible="getCollapsibleAttribute"
	     data-variant="@Variant.ToString().ToLowerInvariant()"
	     data-side="@Side.ToString().ToLowerInvariant()"
	     data-slot="sidebar">

		<div class="md:hidden">
			<RzSheet x-syncprop="openMobile -> open">
				<SheetContent Side="@(Side == SidebarSide.Left ? SheetSide.Left : SheetSide.Right)"
				              class="w-[var(--sidebar-mobile-width)] p-0 [&>button]:hidden"
				              x-bind:open="openMobile"
				              x-on:close="close">
					<div class="flex h-full w-full flex-col">
						@ChildContent
					</div>
				</SheetContent>
			</RzSheet>
		</div>

		<div class="hidden md:block">
			<div data-slot="sidebar-gap" class="@SlotClasses.GetGap()"></div>
			<div data-slot="sidebar-container" class="@SlotClasses.GetDesktopContainer()">
				<div data-sidebar="sidebar" data-slot="sidebar-inner" class="@SlotClasses.GetDesktopInner()">
					@ChildContent
				</div>
			</div>
		</div>
	</div>
}
</file>

<file path="Components/Navigation/RzSidebar/Sidebar.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The main container for the sidebar, which renders as an &lt;c&gt;&lt;aside&gt;&lt;/c&gt; element.
/// It consumes state from a parent <see cref="RzSidebarProvider"/> to manage its appearance and behavior.
/// </summary>
public partial class Sidebar : RzComponent<Sidebar.Slots>
{
    /// <summary>
    /// Defines the default styling for the Sidebar component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "group peer text-sidebar-foreground hidden md:block",
        slots: new()
        {
            [s => s.Gap] = "relative w-[var(--sidebar-width)] bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0",
            [s => s.DesktopContainer] = "fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-[left,right,width] duration-200 ease-linear md:flex",
            [s => s.DesktopInner] = "bg-sidebar flex h-full w-full flex-col"
        },
        variants: new()
        {
            [s => ((Sidebar)s).Variant] = new Variant<SidebarVariant, Slots>
            {
                [SidebarVariant.Floating] = new()
                {
                    [s => s.Gap] = "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem)]",
                    [s => s.DesktopContainer] = "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem+2px)]",
                    [s => s.DesktopInner] = "border-sidebar-border rounded-lg border shadow-sm"
                },
                [SidebarVariant.Inset] = new()
                {
                    [s => s.Gap] = "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem)]",
                    [s => s.DesktopContainer] = "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem+2px)]"
                },
                [SidebarVariant.Sidebar] = new()
                {
                    [s => s.Gap] = "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]",
                    [s => s.DesktopContainer] = "group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]"
                }
            },
            [s => ((Sidebar)s).Side] = new Variant<SidebarSide, Slots>
            {
                [SidebarSide.Left] = new()
                {
                    [s => s.DesktopContainer] = "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]",
                    [s => s.DesktopInner] = "group-data-[variant=sidebar]:border-r"
                },
                [SidebarSide.Right] = new()
                {
                    [s => s.Gap] = "order-last",
                    [s => s.DesktopContainer] = "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
                    [s => s.DesktopInner] = "group-data-[variant=sidebar]:border-l"
                }
            }
        }
    );
    /// <summary>
    /// Gets the parent <see cref="RzSidebarProvider"/> which manages the state for this sidebar.
    /// </summary>
    [CascadingParameter]
    protected RzSidebarProvider? ParentProvider { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the sidebar's navigation area. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets the side of the screen where the sidebar will appear.
    /// Defaults to <see cref="SidebarSide.Left"/>.
    /// </summary>
    [Parameter]
    public SidebarSide Side { get; set; } = SidebarSide.Left;
    /// <summary>
    /// Gets or sets the variant of the sidebar, which controls its overall layout behavior.
    /// Defaults to <see cref="SidebarVariant.Sidebar"/>.
    /// </summary>
    [Parameter]
    public SidebarVariant Variant { get; set; } = SidebarVariant.Sidebar;
    /// <summary>
    /// Gets or sets the ARIA label for the sidebar navigation, providing context for screen readers.
    /// If not set, it defaults to a localized "Sidebar navigation".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentProvider == null)
        {
            throw new InvalidOperationException($"{nameof(Sidebar)} must be used within an {nameof(RzSidebarProvider)}.");
        }
        Element = "div";
        AriaLabel ??= Localizer["RzSidebar.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSidebar.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.Sidebar;
    /// <summary>
    /// Defines the slots available for styling in the Sidebar component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the main sidebar container.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the gap element that pushes content when the sidebar is open.
        /// </summary>
        public string? Gap { get; set; }
        /// <summary>
        /// The slot for the desktop container of the sidebar.
        /// </summary>
        public string? DesktopContainer { get; set; }
        /// <summary>
        /// The slot for the inner content wrapper of the desktop sidebar.
        /// </summary>
        public string? DesktopInner { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarContent.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarContent.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The main scrollable content area of the sidebar, designed to hold <see cref="SidebarGroup"/> components.
/// </summary>
public partial class SidebarContent : RzComponent<SidebarContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex min-h-0 flex-1 flex-col gap-2 overflow-y-auto group-data-[collapsible=icon]:overflow-hidden"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the scrollable area.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarContent;
    /// <summary>
    /// Defines the slots available for styling in the SidebarContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarFooter.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarFooter.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-footer">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for content that should remain sticky at the bottom of the sidebar.
/// </summary>
public partial class SidebarFooter : RzComponent<SidebarFooter.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarFooter component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex shrink-0 flex-col gap-2 p-2"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the footer.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "footer";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarFooter;
    /// <summary>
    /// Defines the slots available for styling in the SidebarFooter component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroup.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarGroup.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement" role="group" aria-labelledby="@LabelId" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-group">
        @ChildContent
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A structural component for grouping related items within a <see cref="SidebarContent"/>.
/// It provides an accessible grouping by associating its content with a <see cref="SidebarGroupLabel"/>.
/// </summary>
public partial class SidebarGroup : RzComponent<SidebarGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative flex w-full min-w-0 flex-col p-2"
    );
    /// <summary>
    /// Gets the unique ID for the label associated with this group, used for `aria-labelledby`.
    /// </summary>
    public string LabelId { get; } = IdGenerator.UniqueId("rzsb-grouplabel-");
    /// <summary>
    /// Gets or sets the content of the group, which should include a <see cref="SidebarGroupLabel"/>
    /// and a <see cref="SidebarGroupContent"/>.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarGroup;
    /// <summary>
    /// Defines the slots available for styling in the SidebarGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroupContent.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarGroupContent.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-group-content">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroupContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the content within a <see cref="SidebarGroup"/>, typically a <see cref="SidebarMenu"/>.
/// </summary>
public partial class SidebarGroupContent : RzComponent<SidebarGroupContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarGroupContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "w-full text-sm"
    );
    /// <summary>
    /// Gets or sets the content to be rendered, usually a <see cref="SidebarMenu"/>.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarGroupContent;
    /// <summary>
    /// Defines the slots available for styling in the SidebarGroupContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroupLabel.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<SidebarGroupLabel.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarGroupLabel.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Renders a heading for a <see cref="SidebarGroup"/>. It can also function as a trigger for a
/// collapsible section when using the `AsChild` pattern.
/// </summary>
public partial class SidebarGroupLabel : RzAsChildComponent<SidebarGroupLabel.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarGroupLabel component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-none transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0 group-data-[state=collapsed]/sidebar:mx-auto group-data-[state=collapsed]/sidebar:opacity-0"
    );
    /// <summary>
    /// Gets the parent <see cref="SidebarGroup"/> to link via `aria-labelledby`.
    /// </summary>
    [CascadingParameter]
    protected SidebarGroup? ParentGroup { get; set; }
    /// <summary>
    /// Gets or sets the content of the label, typically text. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentGroup == null)
        {
            throw new InvalidOperationException($"{nameof(SidebarGroupLabel)} must be used within a {nameof(SidebarGroup)}.");
        }
        Element = "h3";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = ParentGroup?.LabelId,
            ["class"] = SlotClasses.GetBase(),
            ["data-slot"] = "sidebar-group-label"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarGroupLabel;
    /// <summary>
    /// Defines the slots available for styling in the SidebarGroupLabel component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarHeader.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarHeader.Slots>

<HtmlElement Element="@EffectiveElement" data-slot="sidebar-header" data-sidebar="header" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for content that should remain sticky at the top of the sidebar.
/// </summary>
public partial class SidebarHeader : RzComponent<SidebarHeader.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarHeader component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex shrink-0 flex-col gap-2 p-2"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the header.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "header";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarHeader;
    /// <summary>
    /// Defines the slots available for styling in the SidebarHeader component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarInset.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarInset.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-inset">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarInset.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A wrapper for the main content area that correctly adjusts its margin
/// based on the sidebar's state and variant.
/// </summary>
public partial class SidebarInset : RzComponent<SidebarInset.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarInset component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "bg-background w-full relative flex flex-1 flex-col transition-[margin-left] duration-200 ease-linear peer-data-[collapsible=icon][data-state=collapsed]:ml-[var(--sidebar-width-icon)] md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2"
    );
    /// <summary>
    /// Gets or sets the main content to be rendered within the inset container.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "main";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarInset;
    /// <summary>
    /// Defines the slots available for styling in the SidebarInset component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenu.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarMenu.Slots>

<HtmlElement Element="@EffectiveElement" data-slot="sidebar-menu" data-sidebar="menu" role="list" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenu.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A list container for <see cref="SidebarMenuItem"/> components.
/// </summary>
public partial class SidebarMenu : RzComponent<SidebarMenu.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenu component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-full min-w-0 flex-col gap-1"
    );
    /// <summary>
    /// Gets or sets the content of the menu, which should be a list of <see cref="SidebarMenuItem"/>.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "ul";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenu;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenu component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuAction.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<SidebarMenuAction.Slots>

<HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuAction.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An optional, secondary action button within a <see cref="SidebarMenuItem"/>,
/// typically used for icon-only actions like "add" or "more options".
/// </summary>
public partial class SidebarMenuAction : RzAsChildComponent<SidebarMenuAction.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenuAction component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "absolute right-2 top-1/2 -translate-y-1/2 opacity-0 transition-opacity group-hover/menu-item:opacity-100"
    );
    /// <summary>
    /// Gets or sets the content of the action button, usually an icon.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["data-slot"] = "sidebar-menu-action"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenuAction;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenuAction component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuBadge.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarMenuBadge.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-menu-badge">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuBadge.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A small badge component, typically used within a <see cref="SidebarMenuItem"/> to display a count or status.
/// </summary>
public partial class SidebarMenuBadge : RzComponent<SidebarMenuBadge.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenuBadge component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "ml-auto text-xs"
    );
    /// <summary>
    /// Gets or sets the content to be displayed inside the badge.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "span";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenuBadge;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenuBadge component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuButton.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<SidebarMenuButton.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuButton.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The primary interactive element within a <see cref="SidebarMenuItem"/>. It can be rendered as a button
/// or, using the `AsChild` pattern, as another element like an anchor tag.
/// </summary>
public partial class SidebarMenuButton : RzAsChildComponent<SidebarMenuButton.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenuButton component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-none ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&[aria-current=page]]:bg-sidebar-accent [&[aria-current=page]]:font-medium [&[aria-current=page]]:text-sidebar-accent-foreground [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 group-data-[state=collapsed]/sidebar:w-8 group-data-[state=collapsed]/sidebar:justify-center group-data-[state=collapsed]/sidebar:[&>span:last-child]:hidden",
        variants: new()
        {
            [b => ((SidebarMenuButton)b).Variant] = new Variant<SidebarMenuButtonVariant, Slots>
            {
                [SidebarMenuButtonVariant.Default] = "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
                [SidebarMenuButtonVariant.Outline] = "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]"
            },
            [b => ((SidebarMenuButton)b).Size] = new Variant<Size, Slots>
            {
                [Size.Small] = "h-7 text-xs",
                [Size.Medium] = "h-8 text-sm",
                [Size.Large] = "h-12 text-sm group-data-[collapsible=icon]:p-0"
            }
        }
    );
    /// <summary>
    /// Gets or sets the content of the button, typically an icon and a text label. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Gets or sets a value indicating whether this menu item is the currently active page.
    /// If true, it applies active styling and `aria-current="page"`. Defaults to false.
    /// </summary>
    [Parameter]
    public bool IsActive { get; set; }
    /// <summary>
    /// Gets or sets the visual variant of the button.
    /// Defaults to <see cref="SidebarMenuButtonVariant.Default"/>.
    /// </summary>
    [Parameter]
    public SidebarMenuButtonVariant Variant { get; set; } = SidebarMenuButtonVariant.Default;
    /// <summary>
    /// Gets or sets the size of the button.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "button";
    }
    /// <inheritdoc/>
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc/>
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = Id,
            ["class"] = SlotClasses.GetBase(),
            ["aria-current"] = IsActive ? "page" : null,
            ["data-slot"] = "sidebar-menu-button"
        };
        return attributes;
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenuButton;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenuButton component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuItem.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarMenuItem.Slots>

<HtmlElement Element="@EffectiveElement" data-slot="sidebar-menu-item"  data-sidebar="menu-item" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuItem.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// Represents a single item in a <see cref="SidebarMenu"/>, acting as a wrapper for a
/// <see cref="SidebarMenuButton"/> and other optional elements like <see cref="SidebarMenuAction"/>.
/// </summary>
public partial class SidebarMenuItem : RzComponent<SidebarMenuItem.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenuItem component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "relative group/menu-item"
    );
    /// <summary>
    /// Gets or sets the content of the menu item.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "li";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenuItem;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenuItem component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuSub.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarMenuSub.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-menu-sub">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarMenuSub.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for creating a nested, collapsible sub-menu within a <see cref="SidebarMenu"/>.
/// This component is intended to wrap a trigger and content for the sub-menu.
/// </summary>
public partial class SidebarMenuSub : RzComponent<SidebarMenuSub.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarMenuSub component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "border-sidebar-border flex min-w-0 flex-col gap-1 border-l ml-3.5 pl-2.5 py-0.5 w-auto"
    );
    /// <summary>
    /// Gets or sets the content of the sub-menu, which should include a trigger and content sections.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "ul";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarMenuSub;
    /// <summary>
    /// Defines the slots available for styling in the SidebarMenuSub component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarRail.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarRail.Slots>

<HtmlElement Element="@EffectiveElement"
             type="button"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             aria-label="@AriaLabel"
             tabindex="-1"
             x-on:click="toggle"
             data-slot="sidebar-rail" />
</file>

<file path="Components/Navigation/RzSidebar/SidebarRail.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive rail component used within a <see cref="RzSidebarProvider"/> to toggle the sidebar's visibility.
/// It renders as a button and is typically positioned at the edge of the sidebar.
/// </summary>
public partial class SidebarRail : RzComponent<SidebarRail.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarRail component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]/sidebar-wrapper:-right-4 group-data-[side=right]/sidebar-wrapper:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex group-data-[side=left]/sidebar-wrapper:cursor-w-resize group-data-[side=right]/sidebar-wrapper:cursor-e-resize [[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize hover:group-data-[collapsible=offcanvas]/sidebar-wrapper:bg-sidebar group-data-[collapsible=offcanvas]/sidebar-wrapper:translate-x-0 group-data-[collapsible=offcanvas]/sidebar-wrapper:after:left-full [[data-side=left][data-collapsible=offcanvas]_&]:-right-2 [[data-side=right][data-collapsible=offcanvas]_&]:-left-2"
    );
    /// <summary>
    /// Gets the parent <see cref="RzSidebarProvider"/> to access shared state and functions.
    /// </summary>
    [CascadingParameter]
    protected RzSidebarProvider? ParentProvider { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the rail, providing an accessible name for the toggle action.
    /// If not set, it defaults to a localized "Toggle Sidebar".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentProvider == null)
        {
            throw new InvalidOperationException($"{nameof(SidebarRail)} must be used within an {nameof(RzSidebarProvider)}.");
        }
        if (string.IsNullOrEmpty(Element))
            Element = "button";
        AriaLabel ??= Localizer["RzSidebarRail.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSidebarRail.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarRail;
    /// <summary>
    /// Defines the slots available for styling in the SidebarRail component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarSeparator.razor">
@namespace RizzyUI
@inherits RzComponent<SidebarSeparator.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()" data-slot="sidebar-separator" />
</file>

<file path="Components/Navigation/RzSidebar/SidebarSeparator.razor.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A visual separator line used to divide sections within the sidebar.
/// </summary>
public partial class SidebarSeparator : RzComponent<SidebarSeparator.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarSeparator component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "border-sidebar-border mx-2 w-auto border-t"
    );
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "hr";
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarSeparator;
    /// <summary>
    /// Defines the slots available for styling in the SidebarSeparator component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzSidebar/SidebarTrigger.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<SidebarTrigger.Slots>

<HtmlElement Element="@EffectiveElement"
             type="button"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             aria-label="@AriaLabel"
             x-on:click="toggle"
             aria-controls="@ParentProvider?.Id"
             x-bind:aria-expanded="isMobileOpen"
             data-slot="sidebar-trigger">
	@if (ChildContent == null)
	{
		<Blazicon Svg="@Lucide.PanelLeft"/>
	}
	else
	{
		@ChildContent
	}
</HtmlElement>
</file>

<file path="Components/Navigation/RzSidebar/SidebarTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// An interactive element, typically a button, that toggles the open/closed state of the sidebar.
/// It must be placed within an <see cref="RzSidebarProvider"/>.
/// </summary>
public partial class SidebarTrigger : RzComponent<SidebarTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the SidebarTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center justify-center rounded-md p-2 text-sidebar-foreground hover:bg-sidebar-accent focus:outline-none focus:ring-2 focus:ring-inset focus:ring-sidebar-ring"
    );
    /// <summary>
    /// Gets the parent <see cref="RzSidebarProvider"/> which manages the state.
    /// </summary>
    [CascadingParameter]
    protected RzSidebarProvider? ParentProvider { get; set; }
    /// <summary>
    /// Gets or sets the content to be rendered inside the trigger button.
    /// If not provided, a default icon may be rendered by the theme.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets the ARIA label for the trigger, providing an accessible name.
    /// If not set, it defaults to a localized "Toggle sidebar".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentProvider == null)
        {
            throw new InvalidOperationException($"{nameof(SidebarTrigger)} must be used within an {nameof(RzSidebarProvider)}.");
        }
        Element = "button";
        AriaLabel ??= Localizer["RzSidebarTrigger.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSidebarTrigger.DefaultAriaLabel"];
    }
    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.SidebarTrigger;
    /// <summary>
    /// Defines the slots available for styling in the SidebarTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzTabs/RzTabs.razor">
@namespace RizzyUI
@inherits RzComponent<RzTabs.Slots>

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement" 
                 @attributes="@AdditionalAttributes" 
                 id="@Id" 
                 class="@SlotClasses.GetBase()"
                 data-slot="@RzTabs.SlotNames.NameOf(SlotTypes.Base)">
        <div x-data="rzTabs"
             data-alpine-root="@Id"
             data-default-value="@DefaultValue"
             class="contents">
            @ChildContent
        </div>
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzTabs/RzTabs.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A set of layered sections of content, known as tab panels, that are displayed one at a time.
/// This is the root component that manages the state for all child tab components.
/// </summary>
public partial class RzTabs : RzComponent<RzTabs.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzTabs component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex flex-col gap-2"
    );
    /// <summary>
    /// The value of the tab that should be active when the component is first rendered.
    /// If not provided, the first tab will be selected.
    /// </summary>
    [Parameter]
    public string? DefaultValue { get; set; }
    /// <summary>
    /// The content of the tabs component, which should include a <see cref="TabsList"/> and one or more <see cref="TabsContent"/> components.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzTabs;
    /// <summary>
    /// Defines the slots available for styling in the RzTabs component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("tabs")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzTabs/TabsContent.razor">
@namespace RizzyUI
@inherits RzComponent<TabsContent.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@ContentId"
             class="@SlotClasses.GetBase()"
             data-slot="@TabsContent.SlotNames.NameOf(SlotTypes.Base)"
             role="tabpanel"
             aria-labelledby="@TriggerId"
             data-value="@Value"
             x-bind:aria-hidden="_attrAriaHidden"
             x-bind:hidden="_attrHidden"
             x-bind:tabIndex="_attrTabIndex"
             x-cloak>
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzTabs/TabsContent.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The content panel that is displayed when its associated <see cref="TabsTrigger"/> is active.
/// </summary>
public partial class TabsContent : RzComponent<TabsContent.Slots>
{
    /// <summary>
    /// Defines the default styling for the TabsContent component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "flex-1 outline-none"
    );
    [CascadingParameter]
    private RzTabs? ParentTabs { get; set; }
    /// <summary>
    /// A unique value that associates this content with a <see cref="TabsTrigger"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public string Value { get; set; } = string.Empty;
    /// <summary>
    /// The content to be displayed inside the panel.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the unique ID for the trigger element associated with this content.
    /// </summary>
    protected string TriggerId => $"{ParentTabs?.Id}-{Value}-trigger";
    /// <summary>
    /// Gets the unique ID for the content element.
    /// </summary>
    protected string ContentId => $"{ParentTabs?.Id}-{Value}-content";
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentTabs == null)
            throw new InvalidOperationException($"{nameof(TabsContent)} must be used within an {nameof(RzTabs)} component.");
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.TabsContent;
    /// <summary>
    /// Defines the slots available for styling in the TabsContent component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("tabs-content")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzTabs/TabsList.razor">
@namespace RizzyUI
@inherits RzComponent<TabsList.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="@TabsList.SlotNames.NameOf(SlotTypes.Base)"
             role="tablist"
             aria-label="@AriaLabel"
             aria-orientation="@Orientation.ToString().ToLowerInvariant()"
             x-on:keydown="onListKeydown">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzTabs/TabsList.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A container for the trigger buttons of an <see cref="RzTabs"/> component.
/// </summary>
public partial class TabsList : RzComponent<TabsList.Slots>
{
    /// <summary>
    /// Defines the default styling for the TabsList component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]"
    );
    /// <summary>
    /// The content of the list, which should be a series of <see cref="TabsTrigger"/> components.
    /// </summary>
    [Parameter, EditorRequired]
    public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// The accessible name for the tab list. Defaults to a localized "Tabs".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <summary>
    /// The orientation of the tab list, affecting keyboard navigation.
    /// Defaults to <see cref="Orientation.Horizontal"/>.
    /// </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
        AriaLabel ??= Localizer["RzTabs.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzTabs.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.TabsList;
    /// <summary>
    /// Defines the slots available for styling in the TabsList component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("tabs-list")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Navigation/RzTabs/TabsTrigger.razor">
@namespace RizzyUI
@inherits RzAsChildComponent<TabsTrigger.Slots>

@if (AsChild)
{
    @RenderAsChild()
}
else
{
    <HtmlElement Element="@EffectiveElement" type="button" @attributes="GetComponentAttributes()">
        @ChildContent
    </HtmlElement>
}
</file>

<file path="Components/Navigation/RzTabs/TabsTrigger.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// The interactive button that activates its associated <see cref="TabsContent"/>.
/// Can be rendered as a button or merged onto a child element.
/// </summary>
public partial class TabsTrigger : RzAsChildComponent<TabsTrigger.Slots>
{
    /// <summary>
    /// Defines the default styling for the TabsTrigger component.
    /// </summary>
    public static readonly TvDescriptor<RzAsChildComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
    );
    [CascadingParameter]
    private RzTabs? ParentTabs { get; set; }
    /// <summary>
    /// A unique value that associates this trigger with a <see cref="TabsContent"/>. Required.
    /// </summary>
    [Parameter, EditorRequired]
    public string Value { get; set; } = string.Empty;
    /// <summary>
    /// If true, the tab will be disabled and cannot be selected.
    /// </summary>
    [Parameter]
    public bool Disabled { get; set; }
    /// <summary>
    /// The content to be displayed inside the trigger button.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the unique ID for the trigger element.
    /// </summary>
    protected string TriggerId => $"{ParentTabs?.Id}-{Value}-trigger";
    /// <summary>
    /// Gets the unique ID for the associated content element.
    /// </summary>
    protected string ContentId => $"{ParentTabs?.Id}-{Value}-content";
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentTabs == null)
            throw new InvalidOperationException($"{nameof(TabsTrigger)} must be used within an {nameof(RzTabs)} component.");
        Element = "button";
    }
    /// <inheritdoc />
    protected override RenderFragment? GetAsChildContent() => ChildContent;
    /// <inheritdoc />
    protected override Dictionary<string, object?> GetComponentAttributes()
    {
        var attributes = new Dictionary<string, object?>(AdditionalAttributes ?? new(), StringComparer.OrdinalIgnoreCase)
        {
            ["id"] = TriggerId,
            ["class"] = SlotClasses.GetBase(),
            ["role"] = "tab",
            ["data-value"] = Value,
            ["aria-controls"] = ContentId,
            ["aria-disabled"] = Disabled ? "true" : null,
            // Alpine bindings
            ["x-on:click"] = "onTriggerClick",
            ["x-bind:aria-selected"] = "_attrAriaSelected",
            ["x-bind:tabindex"] = "_attrTabIndex",
            ["x-bind:data-state"] = "_attrDataState",
            ["x-bind:disabled"] = "_attrDisabled",
        };
        return attributes;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzAsChildComponent<Slots>, Slots> GetDescriptor() => Theme.TabsTrigger;
    /// <summary>
    /// Defines the slots available for styling in the TabsTrigger component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        [Slot("tabs-trigger")]
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Theme/RzDarkMode/RzDarkModeToggle.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent<RzDarkModeToggle.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             type="button"
             aria-label="@Localizer["RzDarkModeToggle.AriaLabel"]">
    <div x-data="rzDarkModeToggle"
         x-on:click="toggle"
         data-alpine-root="@Id"
         :aria-pressed="isDark">
        <div x-show="isLight" x-cloak>
            <Blazicon Svg="@DarkIcon" class="@SlotClasses.GetIcon()"/>
        </div>
        <div x-show="isDark" x-cloak>
            <Blazicon Svg="@LightIcon" class="@SlotClasses.GetIcon()"/>
        </div>
    </div>
</HtmlElement>
</file>

<file path="Components/Theme/RzDarkMode/RzDarkModeToggle.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Renders a button that toggles between light and dark color themes for the application.
///     Interactivity (state management and class toggling on `&lt;html>`) is handled via the `rzDarkModeToggle` Alpine.js
///     component.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDarkModeToggle : RzComponent<RzDarkModeToggle.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzDarkModeToggle component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center justify-center p-2 rounded-md transition-colors ease-in-out duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 text-foreground bg-background hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent dark:hover:text-accent-foreground dark:focus-visible:ring-offset-background",
        slots: new()
        {
            [s => s.Icon] = "transition-transform duration-300 ease-out size-5"
        }
    );
    /// <summary> Icon shown when light mode is active (clicking enables dark mode). Defaults to MoonOutline. </summary>
    [Parameter] public SvgIcon DarkIcon { get; set; } = Ionicon.MoonOutline;
    /// <summary> Icon shown when dark mode is active (clicking enables light mode). Defaults to SunnyOutline. </summary>
    [Parameter] public SvgIcon LightIcon { get; set; } = Ionicon.SunnyOutline;
    /// <summary> Defaults Element to "button" </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "button"; // Set the root element tag
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzDarkModeToggle;
    /// <summary>
    /// Defines the slots available for styling in the RzDarkModeToggle component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
        /// <summary>
        /// The slot for the icon element.
        /// </summary>
        public string? Icon { get; set; }
    }
}
</file>

<file path="Components/Theme/RzThemeProvider.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
using RizzyUI.Extensions;
using System.Text;
namespace RizzyUI;
/// <summary>
///     A Blazor component that provides the current theme's CSS variables and initial dark mode script
///     into the document head via <see cref="HeadOutlet" />. It also cascades the resolved theme
///     to its child content. If no theme parameter is provided, it uses the default theme specified
///     in <see cref="RizzyUIConfig" /> or falls back to <see cref="RzTheme.Default" />.
/// </summary>
public class RzThemeProvider : ComponentBase
{
    [Inject] private IOptions<RizzyUIConfig>? RizzyConfig { get; set; }
    /// <summary>
    ///     NonceProvider service that provides scoped per-request nonce values to RizzyUI components.
    /// </summary>
    [Inject]
    protected IRizzyNonceProvider RizzyNonceProvider { get; set; } = default!;
    /// <summary>
    ///     Gets or sets the theme to apply. If null, defaults to the theme configured in
    ///     <see cref="RizzyUIConfig.DefaultTheme" /> or <see cref="RzTheme.Default" />.
    /// </summary>
    [Parameter]
    public RzTheme? Theme { get; set; }
    /// <summary>
    ///     Gets or sets the child content to render within the theme provider context.
    ///     The resolved theme will be cascaded to this content.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Builds the render tree for the component, injecting a &lt;style&gt; tag with CSS variables
    ///     and an initial dark mode script into the head via <see cref="HeadContent" />. It also
    ///     renders the <see cref="ChildContent" /> wrapped in a <see cref="CascadingValue{TValue}" />
    ///     providing the resolved <see cref="RzTheme" />.
    /// </summary>
    /// <param name="builder">The <see cref="RenderTreeBuilder" /> used to build the component's output.</param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        // Determine the theme to use based on priority: Parameter > Config > Default
        var actualTheme = Theme ?? RizzyConfig?.Value.DefaultTheme ?? RzTheme.Default;
        // Generate the CSS variables string
        var css = GenerateRootVariables(actualTheme);
        var nonce = RizzyNonceProvider.GetNonce(); // Get nonce once for efficiency
        // Render HeadContent to inject style and script into <head>
        builder.OpenComponent<RzHeadContent>(0);
        builder.AddAttribute(1, "ChildContent", (RenderFragment)(headBuilder =>
        {
            // Inject the style tag with theme variables
            headBuilder.AddMarkupContent(2, $"<style nonce=\"{nonce}\">{css}</style>");
            // Inject the initial dark mode script
            // Notes:
            // - Normalizes localStorage to 'light'|'dark'|'auto'
            // - Guards against localStorage access failures (privacy mode / blocked storage)
            // - Sets both the root 'dark' class and color-scheme to avoid initial flashes
            headBuilder.AddMarkupContent(3, $@"<script nonce=""{nonce}"">(()=>{{
  try {{
    const raw = localStorage.getItem('darkMode');
    const mode = (raw === 'light' || raw === 'dark' || raw === 'auto') ? raw : 'auto';
    const prefersDark = !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
    const isDark = mode === 'dark' || (mode === 'auto' && prefersDark);
    const root = document.documentElement;
    root.classList.toggle('dark', isDark);
    root.style.colorScheme = isDark ? 'dark' : 'light';
  }} catch {{
    // If storage is blocked/unavailable, fall back to OS preference only
    const prefersDark = !!(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
    const root = document.documentElement;
    root.classList.toggle('dark', prefersDark);
    root.style.colorScheme = prefersDark ? 'dark' : 'light';
  }}
}})();</script>");
        }));
        builder.CloseComponent(); // Close HeadContent
        // Render ChildContent wrapped in a CascadingValue to provide the theme
        builder.OpenComponent<CascadingValue<RzTheme>>(4); // Use specific type RzTheme
        builder.AddAttribute(5, "Value", actualTheme);
        builder.AddAttribute(6, "IsFixed", true); // Theme instance is fixed for this provider's scope
        builder.AddAttribute(7, "ChildContent", (RenderFragment)(cascadeBuilder =>
        {
            cascadeBuilder.AddContent(8, ChildContent); // Render the actual child content
        }));
        builder.CloseComponent(); // Close CascadingValue<RzTheme>
    }
    /// <summary>
    ///     Generates the CSS variable definitions for the given theme.
    /// </summary>
    /// <param name="theme">The theme to generate variables from.</param>
    /// <returns>A string containing a :root CSS block with the theme variables.</returns>
    private string GenerateRootVariables(RzTheme theme)
    {
        var sb = new StringBuilder();
        // --- Light Theme (:root) ---
        sb.AppendLine(":root {");
        // Radius from the root theme
        sb.AppendLine($"  --radius: {theme.Radius};");
        // Global theme properties
        if (theme.AdditionalProperties != null)
        {
            foreach (var kvp in theme.AdditionalProperties)
            {
                sb.AppendLine($"  --{kvp.Key.ToKebabCase()}: {kvp.Value};");
            }
        }
        // All variables from the Light variant
        AppendVariantVariables(sb, theme.Light);
        sb.AppendLine("}");
        // --- Dark Theme (.dark) ---
        sb.AppendLine();
        // Scope dark variables to the document root to prevent accidental variable overrides
        // from nested elements that may use a "dark" class for other purposes.
        sb.AppendLine(":root.dark {");
        AppendVariantVariables(sb, theme.Dark);
        sb.AppendLine("}");
        // Base page styling to ensure the earliest paint uses the tokenized background/foreground.
        // This helps prevent a flash of white when the page is intended to start in dark mode.
        sb.AppendLine();
        sb.AppendLine("html, body {");
        sb.AppendLine("  background-color: var(--background);");
        sb.AppendLine("  color: var(--foreground);");
        sb.AppendLine("}");
        return sb.ToString();
    }
    private void AppendVariantVariables(StringBuilder sb, RzThemeVariant variant)
    {
        // Colors
        sb.AppendLine($"  --background: {variant.Background.ToCssColorString()};");
        sb.AppendLine($"  --foreground: {variant.Foreground.ToCssColorString()};");
        sb.AppendLine($"  --card: {variant.Card.ToCssColorString()};");
        sb.AppendLine($"  --card-foreground: {variant.CardForeground.ToCssColorString()};");
        sb.AppendLine($"  --popover: {variant.Popover.ToCssColorString()};");
        sb.AppendLine($"  --popover-foreground: {variant.PopoverForeground.ToCssColorString()};");
        sb.AppendLine($"  --primary: {variant.Primary.ToCssColorString()};");
        sb.AppendLine($"  --primary-foreground: {variant.PrimaryForeground.ToCssColorString()};");
        sb.AppendLine($"  --secondary: {variant.Secondary.ToCssColorString()};");
        sb.AppendLine($"  --secondary-foreground: {variant.SecondaryForeground.ToCssColorString()};");
        sb.AppendLine($"  --muted: {variant.Muted.ToCssColorString()};");
        sb.AppendLine($"  --muted-foreground: {variant.MutedForeground.ToCssColorString()};");
        sb.AppendLine($"  --accent: {variant.Accent.ToCssColorString()};");
        sb.AppendLine($"  --accent-foreground: {variant.AccentForeground.ToCssColorString()};");
        sb.AppendLine($"  --destructive: {variant.Destructive.ToCssColorString()};");
        sb.AppendLine($"  --destructive-foreground: {variant.DestructiveForeground.ToCssColorString()};");
        sb.AppendLine($"  --border: {variant.Border.ToCssColorString()};");
        sb.AppendLine($"  --input: {variant.Input.ToCssColorString()};");
        sb.AppendLine($"  --ring: {variant.Ring.ToCssColorString()};");
        // Chart Colors
        sb.AppendLine($"  --chart-1: {variant.Chart1.ToCssColorString()};");
        sb.AppendLine($"  --chart-2: {variant.Chart2.ToCssColorString()};");
        sb.AppendLine($"  --chart-3: {variant.Chart3.ToCssColorString()};");
        sb.AppendLine($"  --chart-4: {variant.Chart4.ToCssColorString()};");
        sb.AppendLine($"  --chart-5: {variant.Chart5.ToCssColorString()};");
        // Sidebar Colors
        sb.AppendLine($"  --sidebar: {variant.Sidebar.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-foreground: {variant.SidebarForeground.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-primary: {variant.SidebarPrimary.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-primary-foreground: {variant.SidebarPrimaryForeground.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-accent: {variant.SidebarAccent.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-accent-foreground: {variant.SidebarAccentForeground.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-border: {variant.SidebarBorder.ToCssColorString()};");
        sb.AppendLine($"  --sidebar-ring: {variant.SidebarRing.ToCssColorString()};");
        // Status Colors
        sb.AppendLine($"  --info: {variant.Info.ToCssColorString()};");
        sb.AppendLine($"  --info-foreground: {variant.InfoForeground.ToCssColorString()};");
        sb.AppendLine($"  --warning: {variant.Warning.ToCssColorString()};");
        sb.AppendLine($"  --warning-foreground: {variant.WarningForeground.ToCssColorString()};");
        sb.AppendLine($"  --success: {variant.Success.ToCssColorString()};");
        sb.AppendLine($"  --success-foreground: {variant.SuccessForeground.ToCssColorString()};");
        // Fonts
        sb.AppendLine($"  --font-sans: {variant.FontSans};");
        sb.AppendLine($"  --font-serif: {variant.FontSerif};");
        sb.AppendLine($"  --font-mono: {variant.FontMono};");
        // Radius (from variant)
        sb.AppendLine($"  --radius: {variant.Radius};");
        // Shadows
        sb.AppendLine($"  --shadow-2xs: {variant.Shadow2Xs};");
        sb.AppendLine($"  --shadow-xs: {variant.ShadowXs};");
        sb.AppendLine($"  --shadow-sm: {variant.ShadowSm};");
        sb.AppendLine($"  --shadow: {variant.Shadow};");
        sb.AppendLine($"  --shadow-md: {variant.ShadowMd};");
        sb.AppendLine($"  --shadow-lg: {variant.ShadowLg};");
        sb.AppendLine($"  --shadow-xl: {variant.ShadowXl};");
        sb.AppendLine($"  --shadow-2xl: {variant.Shadow2Xl};");
        // Additional Properties from the variant (e.g., letter-spacing, spacing)
        if (variant.AdditionalProperties != null)
        {
            foreach (var kvp in variant.AdditionalProperties)
            {
                sb.AppendLine($"  --{kvp.Key}: {kvp.Value};");
            }
        }
    }
}
</file>

<file path="Components/Theme/Themes/ArcticTheme.cs">
namespace RizzyUI;
/// <summary>
///     The default theme used for the application, inheriting from <see cref="RzTheme" />.
///     This theme is based on the default theme provided by shadcn/ui.
/// </summary>
public class ArcticTheme : RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="ArcticTheme" /> class with predefined values.
    /// </summary>
    public ArcticTheme() : base("Arctic", "arctic")
    {
        Radius = "0.375rem";
        Light = new RzThemeVariant
        {
            Background = new Color("oklch(1.0000 0 0)", "background"),
            Foreground = new Color("oklch(0.3211 0 0)", "foreground"),
            Card = new Color("oklch(1.0000 0 0)", "card"),
            CardForeground = new Color("oklch(0.3211 0 0)", "card-foreground"),
            Popover = new Color("oklch(1.0000 0 0)", "popover"),
            PopoverForeground = new Color("oklch(0.3211 0 0)", "popover-foreground"),
            Primary = new Color("oklch(0.6231 0.1880 259.8145)", "primary"),
            PrimaryForeground = new Color("oklch(1.0000 0 0)", "primary-foreground"),
            Secondary = new Color("oklch(0.9670 0.0029 264.5419)", "secondary"),
            SecondaryForeground = new Color("oklch(0.4461 0.0263 256.8018)", "secondary-foreground"),
            Muted = new Color("oklch(0.9846 0.0017 247.8389)", "muted"),
            MutedForeground = new Color("oklch(0.5510 0.0234 264.3637)", "muted-foreground"),
            Accent = new Color("oklch(0.9514 0.0250 236.8242)", "accent"),
            AccentForeground = new Color("oklch(0.3791 0.1378 265.5222)", "accent-foreground"),
            Destructive = new Color("oklch(0.6368 0.2078 25.3313)", "destructive"),
            DestructiveForeground = new Color("oklch(1.0000 0 0)", "destructive-foreground"),
            Border = new Color("oklch(0.9276 0.0058 264.5313)", "border"),
            Input = new Color("oklch(0.9276 0.0058 264.5313)", "input"),
            Ring = new Color("oklch(0.6231 0.1880 259.8145)", "ring"),
            Chart1 = new Color("oklch(0.6231 0.1880 259.8145)", "chart-1"),
            Chart2 = new Color("oklch(0.5461 0.2152 262.8809)", "chart-2"),
            Chart3 = new Color("oklch(0.4882 0.2172 264.3763)", "chart-3"),
            Chart4 = new Color("oklch(0.4244 0.1809 265.6377)", "chart-4"),
            Chart5 = new Color("oklch(0.3791 0.1378 265.5222)", "chart-5"),
            Sidebar = new Color("oklch(0.9846 0.0017 247.8389)", "sidebar"),
            SidebarForeground = new Color("oklch(0.3211 0 0)", "sidebar-foreground"),
            SidebarPrimary = new Color("oklch(0.6231 0.1880 259.8145)", "sidebar-primary"),
            SidebarPrimaryForeground = new Color("oklch(1.0000 0 0)", "sidebar-primary-foreground"),
            SidebarAccent = new Color("oklch(0.9514 0.0250 236.8242)", "sidebar-accent"),
            SidebarAccentForeground = new Color("oklch(0.3791 0.1378 265.5222)", "sidebar-accent-foreground"),
            SidebarBorder = new Color("oklch(0.9276 0.0058 264.5313)", "sidebar-border"),
            SidebarRing = new Color("oklch(0.6231 0.1880 259.8145)", "sidebar-ring"),
            FontSans = "Inter, sans-serif",
            FontSerif = "Source Serif 4, serif",
            FontMono = "JetBrains Mono, monospace",
            Radius = "0.375rem",
            Shadow2Xs = "0 1px 3px 0px hsl(0 0% 0% / 0.05)",
            ShadowXs = "0 1px 3px 0px hsl(0 0% 0% / 0.05)",
            ShadowSm = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 1px 2px -1px hsl(0 0% 0% / 0.10)",
            Shadow = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 1px 2px -1px hsl(0 0% 0% / 0.10)",
            ShadowMd = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 2px 4px -1px hsl(0 0% 0% / 0.10)",
            ShadowLg = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 4px 6px -1px hsl(0 0% 0% / 0.10)",
            ShadowXl = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 8px 10px -1px hsl(0 0% 0% / 0.10)",
            Shadow2Xl = "0 1px 3px 0px hsl(0 0% 0% / 0.25)",
            Info = Colors.Blue.L600,
            InfoForeground = Colors.White,
            Warning = Colors.Amber.L500,
            WarningForeground = Colors.White,
            Success = Colors.Green.L600,
            SuccessForeground = Colors.White,
            Code = CodeThemes.Github
        };
        Dark = new RzThemeVariant
        {
            Background = new Color("oklch(0.2046 0 0)", "background"),
            Foreground = new Color("oklch(0.9219 0 0)", "foreground"),
            Card = new Color("oklch(0.2686 0 0)", "card"),
            CardForeground = new Color("oklch(0.9219 0 0)", "card-foreground"),
            Popover = new Color("oklch(0.2686 0 0)", "popover"),
            PopoverForeground = new Color("oklch(0.9219 0 0)", "popover-foreground"),
            Primary = new Color("oklch(0.6231 0.1880 259.8145)", "primary"),
            PrimaryForeground = new Color("oklch(1.0000 0 0)", "primary-foreground"),
            Secondary = new Color("oklch(0.2686 0 0)", "secondary"),
            SecondaryForeground = new Color("oklch(0.9219 0 0)", "secondary-foreground"),
            Muted = new Color("oklch(0.2686 0 0)", "muted"),
            MutedForeground = new Color("oklch(0.7155 0 0)", "muted-foreground"),
            Accent = new Color("oklch(0.3791 0.1378 265.5222)", "accent"),
            AccentForeground = new Color("oklch(0.8823 0.0571 254.1284)", "accent-foreground"),
            Destructive = new Color("oklch(0.6368 0.2078 25.3313)", "destructive"),
            DestructiveForeground = new Color("oklch(1.0000 0 0)", "destructive-foreground"),
            Border = new Color("oklch(0.3715 0 0)", "border"),
            Input = new Color("oklch(0.3715 0 0)", "input"),
            Ring = new Color("oklch(0.6231 0.1880 259.8145)", "ring"),
            Chart1 = new Color("oklch(0.7137 0.1434 254.6240)", "chart-1"),
            Chart2 = new Color("oklch(0.6231 0.1880 259.8145)", "chart-2"),
            Chart3 = new Color("oklch(0.5461 0.2152 262.8809)", "chart-3"),
            Chart4 = new Color("oklch(0.4882 0.2172 264.3763)", "chart-4"),
            Chart5 = new Color("oklch(0.4244 0.1809 265.6377)", "chart-5"),
            Sidebar = new Color("oklch(0.2046 0 0)", "sidebar"),
            SidebarForeground = new Color("oklch(0.9219 0 0)", "sidebar-foreground"),
            SidebarPrimary = new Color("oklch(0.6231 0.1880 259.8145)", "sidebar-primary"),
            SidebarPrimaryForeground = new Color("oklch(1.0000 0 0)", "sidebar-primary-foreground"),
            SidebarAccent = new Color("oklch(0.3791 0.1378 265.5222)", "sidebar-accent"),
            SidebarAccentForeground = new Color("oklch(0.8823 0.0571 254.1284)", "sidebar-accent-foreground"),
            SidebarBorder = new Color("oklch(0.3715 0 0)", "sidebar-border"),
            SidebarRing = new Color("oklch(0.6231 0.1880 259.8145)", "sidebar-ring"),
            FontSans = "Inter, sans-serif",
            FontSerif = "Source Serif 4, serif",
            FontMono = "JetBrains Mono, monospace",
            Radius = "0.375rem",
            Shadow2Xs = "0 1px 3px 0px hsl(0 0% 0% / 0.05)",
            ShadowXs = "0 1px 3px 0px hsl(0 0% 0% / 0.05)",
            ShadowSm = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 1px 2px -1px hsl(0 0% 0% / 0.10)",
            Shadow = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 1px 2px -1px hsl(0 0% 0% / 0.10)",
            ShadowMd = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 2px 4px -1px hsl(0 0% 0% / 0.10)",
            ShadowLg = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 4px 6px -1px hsl(0 0% 0% / 0.10)",
            ShadowXl = "0 1px 3px 0px hsl(0 0% 0% / 0.10), 0 8px 10px -1px hsl(0 0% 0% / 0.10)",
            Shadow2Xl = "0 1px 3px 0px hsl(0 0% 0% / 0.25)",
            Info = Colors.Blue.L500,
            InfoForeground = Colors.White,
            Warning = Colors.Amber.L400,
            WarningForeground = Colors.Black,
            Success = Colors.Green.L500,
            SuccessForeground = Colors.White,
            Code = CodeThemes.DefaultDark
        };
    }
}
</file>

<file path="Components/Theme/Themes/Code/CodeThemes.cs">
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
namespace RizzyUI;
/// <summary>
///     Provides static RizzyCodeTheme instances for each theme in your JSON.
/// </summary>
public static class CodeThemes
{
    /// <summary> Apathy theme. </summary>
    public static RizzyCodeTheme Apathy { get; } = new("#031A16", "#81B5AC", "#2B685E", "#4C963E", "#3E7996", "#96883E",
        "#3E9688", "#883E96", "#963E4C", "#81B5AC", "#3E9688", "#883E96");
    /// <summary> Ashes theme. </summary>
    public static RizzyCodeTheme Ashes { get; } = new("#1C2023", "#C7CCD1", "#747C84", "#C795AE", "#C7C795", "#AE95C7",
        "#C7AE95", "#95C7AE", "#95AEC7", "#C7CCD1", "#C7AE95", "#95C7AE");
    /// <summary> Atelier Cave Light theme. </summary>
    public static RizzyCodeTheme AtelierCaveLight { get; } = new("#efecf4", "#585260", "#7e7887", "#955ae7", "#aa573c",
        "#576ddb", "#be4678", "#2a9292", "#398bc6", "#585260", "#be4678", "#2a9292");
    /// <summary> Atelier Cave theme. </summary>
    public static RizzyCodeTheme AtelierCave { get; } = new("#19171c", "#8b8792", "#655f6d", "#955ae7", "#aa573c",
        "#576ddb", "#be4678", "#2a9292", "#398bc6", "#8b8792", "#be4678", "#2a9292");
    /// <summary> Atelier Dune Light theme. </summary>
    public static RizzyCodeTheme AtelierDuneLight { get; } = new("#fefbec", "#6e6b5e", "#999580", "#b854d4", "#b65611",
        "#6684e1", "#d73737", "#60ac39", "#1fad83", "#6e6b5e", "#d73737", "#60ac39");
    /// <summary> Atelier Dune theme. </summary>
    public static RizzyCodeTheme AtelierDune { get; } = new("#20201d", "#a6a28c", "#7d7a68", "#b854d4", "#b65611",
        "#6684e1", "#d73737", "#60ac39", "#1fad83", "#a6a28c", "#d73737", "#60ac39");
    /// <summary> Atelier Estuary Light theme. </summary>
    public static RizzyCodeTheme AtelierEstuaryLight { get; } = new("#f4f3ec", "#5f5e4e", "#878573", "#5f9182",
        "#ae7313", "#36a166", "#ba6236", "#7d9726", "#5b9d48", "#5f5e4e", "#ba6236", "#7d9726");
    /// <summary> Atelier Estuary theme. </summary>
    public static RizzyCodeTheme AtelierEstuary { get; } = new("#22221b", "#929181", "#6c6b5a", "#5f9182", "#ae7313",
        "#36a166", "#ba6236", "#7d9726", "#5b9d48", "#929181", "#ba6236", "#7d9726");
    /// <summary> Atelier Forest Light theme. </summary>
    public static RizzyCodeTheme AtelierForestLight { get; } = new("#f1efee", "#68615e", "#9c9491", "#6666ea",
        "#df5320", "#407ee7", "#f22c40", "#7b9726", "#3d97b8", "#68615e", "#f22c40", "#7b9726");
    /// <summary> Atelier Forest theme. </summary>
    public static RizzyCodeTheme AtelierForest { get; } = new("#1b1918", "#a8a19f", "#766e6b", "#6666ea", "#df5320",
        "#407ee7", "#f22c40", "#7b9726", "#3d97b8", "#a8a19f", "#f22c40", "#7b9726");
    /// <summary> Atelier Heath Light theme. </summary>
    public static RizzyCodeTheme AtelierHeathLight { get; } = new("#f7f3f7", "#695d69", "#9e8f9e", "#7b59c0", "#a65926",
        "#516aec", "#ca402b", "#918b3b", "#159393", "#695d69", "#ca402b", "#918b3b");
    /// <summary> Atelier Heath theme. </summary>
    public static RizzyCodeTheme AtelierHeath { get; } = new("#1b181b", "#ab9bab", "#776977", "#7b59c0", "#a65926",
        "#516aec", "#ca402b", "#918b3b", "#159393", "#ab9bab", "#ca402b", "#918b3b");
    /// <summary> Atelier Lakeside Light theme. </summary>
    public static RizzyCodeTheme AtelierLakesideLight { get; } = new("#ebf8ff", "#516d7b", "#7195a8", "#6b6bb8",
        "#935c25", "#257fad", "#d22d72", "#568c3b", "#2d8f6f", "#516d7b", "#d22d72", "#568c3b");
    /// <summary> Atelier Lakeside theme. </summary>
    public static RizzyCodeTheme AtelierLakeside { get; } = new("#161b1d", "#7ea2b4", "#5a7b8c", "#6b6bb8", "#935c25",
        "#257fad", "#d22d72", "#568c3b", "#2d8f6f", "#7ea2b4", "#d22d72", "#568c3b");
    /// <summary> Atelier Plateau Light theme. </summary>
    public static RizzyCodeTheme AtelierPlateauLight { get; } = new("#f4ecec", "#585050", "#7e7777", "#8464c4",
        "#b45a3c", "#7272ca", "#ca4949", "#4b8b8b", "#5485b6", "#585050", "#ca4949", "#4b8b8b");
    /// <summary> Atelier Plateau theme. </summary>
    public static RizzyCodeTheme AtelierPlateau { get; } = new("#1b1818", "#8a8585", "#655d5d", "#8464c4", "#b45a3c",
        "#7272ca", "#ca4949", "#4b8b8b", "#5485b6", "#8a8585", "#ca4949", "#4b8b8b");
    /// <summary> Atelier Savanna Light theme. </summary>
    public static RizzyCodeTheme AtelierSavannaLight { get; } = new("#ecf4ee", "#526057", "#78877d", "#55859b",
        "#9f713c", "#478c90", "#b16139", "#489963", "#1c9aa0", "#526057", "#b16139", "#489963");
    /// <summary> Atelier Savanna theme. </summary>
    public static RizzyCodeTheme AtelierSavanna { get; } = new("#171c19", "#87928a", "#5f6d64", "#55859b", "#9f713c",
        "#478c90", "#b16139", "#489963", "#1c9aa0", "#87928a", "#b16139", "#489963");
    /// <summary> Atelier Seaside Light theme. </summary>
    public static RizzyCodeTheme AtelierSeasideLight { get; } = new("#f4fbf4", "#5e6e5e", "#809980", "#ad2bee",
        "#87711d", "#3d62f5", "#e6193c", "#29a329", "#1999b3", "#5e6e5e", "#e6193c", "#29a329");
    /// <summary> Atelier Seaside theme. </summary>
    public static RizzyCodeTheme AtelierSeaside { get; } = new("#131513", "#8ca68c", "#687d68", "#ad2bee", "#87711d",
        "#3d62f5", "#e6193c", "#29a329", "#1999b3", "#8ca68c", "#e6193c", "#29a329");
    /// <summary> Atelier Sulphurpool Light theme. </summary>
    public static RizzyCodeTheme AtelierSulphurpoolLight { get; } = new("#f5f7ff", "#5e6687", "#898ea4", "#6679cc",
        "#c76b29", "#3d8fd1", "#c94922", "#ac9739", "#22a2c9", "#5e6687", "#c94922", "#ac9739");
    /// <summary> Atelier Sulphurpool theme. </summary>
    public static RizzyCodeTheme AtelierSulphurpool { get; } = new("#202746", "#979db4", "#6b7394", "#6679cc",
        "#c76b29", "#3d8fd1", "#c94922", "#ac9739", "#22a2c9", "#979db4", "#c94922", "#ac9739");
    /// <summary> Bespin theme. </summary>
    public static RizzyCodeTheme Bespin { get; } = new("#28211c", "#8a8986", "#666666", "#9b859d", "#cf7d34", "#5ea6ea",
        "#cf6a4c", "#54be0d", "#afc4db", "#8a8986", "#cf6a4c", "#54be0d");
    /// <summary> Brewer theme. </summary>
    public static RizzyCodeTheme Brewer { get; } = new("#0c0d0e", "#b7b8b9", "#737475", "#756bb1", "#e6550d", "#3182bd",
        "#e31a1c", "#31a354", "#80b1d3", "#b7b8b9", "#e31a1c", "#31a354");
    /// <summary> Bright theme. </summary>
    public static RizzyCodeTheme Bright { get; } = new("#000000", "#e0e0e0", "#b0b0b0", "#d381c3", "#fc6d24", "#6fb3d2",
        "#fb0120", "#a1c659", "#76c7b7", "#e0e0e0", "#fb0120", "#a1c659");
    /// <summary> Brushtrees Dark theme. </summary>
    public static RizzyCodeTheme BrushtreesDark { get; } = new("#485867", "#B0C5C8", "#8299A1", "#b386b2", "#d8bba2",
        "#868cb3", "#b38686", "#87b386", "#86b3b3", "#B0C5C8", "#b38686", "#87b386");
    /// <summary> Brushtrees theme. </summary>
    public static RizzyCodeTheme Brushtrees { get; } = new("#E3EFEF", "#6D828E", "#98AFB5", "#b386b2", "#d8bba2",
        "#868cb3", "#b38686", "#87b386", "#86b3b3", "#6D828E", "#b38686", "#87b386");
    /// <summary> Chalk theme. </summary>
    public static RizzyCodeTheme Chalk { get; } = new("#151515", "#d0d0d0", "#505050", "#e1a3ee", "#eda987", "#6fc2ef",
        "#fb9fb1", "#acc267", "#12cfc0", "#d0d0d0", "#fb9fb1", "#acc267");
    /// <summary> Circus theme. </summary>
    public static RizzyCodeTheme Circus { get; } = new("#191919", "#a7a7a7", "#5f5a60", "#b888e2", "#4bb1a7", "#639ee4",
        "#dc657d", "#84b97c", "#4bb1a7", "#a7a7a7", "#dc657d", "#84b97c");
    /// <summary> Classic Dark theme. </summary>
    public static RizzyCodeTheme ClassicDark { get; } = new("#151515", "#D0D0D0", "#505050", "#AA759F", "#D28445",
        "#6A9FB5", "#AC4142", "#90A959", "#75B5AA", "#D0D0D0", "#AC4142", "#90A959");
    /// <summary> Classic Light theme. </summary>
    public static RizzyCodeTheme ClassicLight { get; } = new("#F5F5F5", "#303030", "#B0B0B0", "#AA759F", "#D28445",
        "#6A9FB5", "#AC4142", "#90A959", "#75B5AA", "#303030", "#AC4142", "#90A959");
    /// <summary> Codeschool theme. </summary>
    public static RizzyCodeTheme Codeschool { get; } = new("#232c31", "#9ea7a6", "#3f4944", "#c59820", "#43820d",
        "#484d79", "#2a5491", "#237986", "#b02f30", "#9ea7a6", "#2a5491", "#237986");
    /// <summary> Cupcake theme. </summary>
    public static RizzyCodeTheme Cupcake { get; } = new("#fbf1f2", "#8b8198", "#bfb9c6", "#BB99B4", "#EBB790",
        "#7297B9", "#D57E85", "#A3B367", "#69A9A7", "#8b8198", "#D57E85", "#A3B367");
    /// <summary> Cupertino theme. </summary>
    public static RizzyCodeTheme Cupertino { get; } = new("#5e5e5e", "#c0c0c0", "#808080", "#a90d91", "#eb8500",
        "#0000ff", "#c41a15", "#007400", "#318495", "#c0c0c0", "#c41a15", "#007400");
    /// <summary> Darktooth theme. </summary>
    public static RizzyCodeTheme Darktooth { get; } = new("#1D2021", "#A89984", "#665C54", "#8F4673", "#FE8625",
        "#0D6678", "#FB543F", "#95C085", "#8BA59B", "#A89984", "#FB543F", "#95C085");
    /// <summary> Default Dark theme. </summary>
    public static RizzyCodeTheme DefaultDark { get; } = new("#181818", "#d8d8d8", "#585858", "#ba8baf", "#dc9656",
        "#7cafc2", "#ab4642", "#a1b56c", "#86c1b9", "#d8d8d8", "#ab4642", "#a1b56c");
    /// <summary> Default Light theme. </summary>
    public static RizzyCodeTheme DefaultLight { get; } = new("#f8f8f8", "#383838", "#b8b8b8", "#ba8baf", "#dc9656",
        "#7cafc2", "#ab4642", "#a1b56c", "#86c1b9", "#383838", "#ab4642", "#a1b56c");
    /// <summary> Dracula theme. </summary>
    public static RizzyCodeTheme Dracula { get; } = new("#282936", "#e9e9f4", "#4d4f68", "#b45bcf", "#b45bcf",
        "#62d6e8", "#ea51b2", "#00f769", "#a1efe4", "#e9e9f4", "#ea51b2", "#00f769");
    /// <summary> Eighties theme. </summary>
    public static RizzyCodeTheme Eighties { get; } = new("#2d2d2d", "#d3d0c8", "#747369", "#cc99cc", "#f99157",
        "#6699cc", "#f2777a", "#99cc99", "#66cccc", "#d3d0c8", "#f2777a", "#99cc99");
    /// <summary> Embers theme. </summary>
    public static RizzyCodeTheme Embers { get; } = new("#16130F", "#A39A90", "#5A5047", "#82576D", "#828257", "#6D5782",
        "#826D57", "#57826D", "#576D82", "#A39A90", "#826D57", "#57826D");
    /// <summary> Flat theme. </summary>
    public static RizzyCodeTheme Flat { get; } = new("#2C3E50", "#e0e0e0", "#95A5A6", "#9B59B6", "#E67E22", "#3498DB",
        "#E74C3C", "#2ECC71", "#1ABC9C", "#e0e0e0", "#E74C3C", "#2ECC71");
    /// <summary> Github theme. </summary>
    public static RizzyCodeTheme Github { get; } = new("#ffffff", "#333333", "#969896", "#a71d5d", "#0086b3", "#795da3",
        "#ed6a43", "#183691", "#183691", "#333333", "#ed6a43", "#183691");
    /// <summary> Google Dark theme. </summary>
    public static RizzyCodeTheme GoogleDark { get; } = new("#1d1f21", "#c5c8c6", "#969896", "#A36AC7", "#F96A38",
        "#3971ED", "#CC342B", "#198844", "#3971ED", "#c5c8c6", "#CC342B", "#198844");
    /// <summary> Google Light theme. </summary>
    public static RizzyCodeTheme GoogleLight { get; } = new("#ffffff", "#373b41", "#b4b7b4", "#A36AC7", "#F96A38",
        "#3971ED", "#CC342B", "#198844", "#3971ED", "#373b41", "#CC342B", "#198844");
    /// <summary> Grayscale Dark theme. </summary>
    public static RizzyCodeTheme GrayscaleDark { get; } = new("#101010", "#b9b9b9", "#525252", "#747474", "#999999",
        "#686868", "#7c7c7c", "#8e8e8e", "#868686", "#b9b9b9", "#7c7c7c", "#8e8e8e");
    /// <summary> Grayscale Light theme. </summary>
    public static RizzyCodeTheme GrayscaleLight { get; } = new("#f7f7f7", "#464646", "#ababab", "#747474", "#999999",
        "#686868", "#7c7c7c", "#8e8e8e", "#868686", "#464646", "#7c7c7c", "#8e8e8e");
    /// <summary> Greenscreen theme. </summary>
    public static RizzyCodeTheme Greenscreen { get; } = new("#001100", "#00bb00", "#007700", "#00bb00", "#009900",
        "#009900", "#007700", "#00bb00", "#005500", "#00bb00", "#007700", "#00bb00");
    /// <summary> Gruvbox Dark Hard theme. </summary>
    public static RizzyCodeTheme GruvboxDarkHard { get; } = new("#1d2021", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    /// <summary> Gruvbox Dark Medium theme. </summary>
    public static RizzyCodeTheme GruvboxDarkMedium { get; } = new("#282828", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    /// <summary> Gruvbox Dark Pale theme. </summary>
    public static RizzyCodeTheme GruvboxDarkPale { get; } = new("#262626", "#dab997", "#8a8a8a", "#d485ad", "#ff8700",
        "#83adad", "#d75f5f", "#afaf00", "#85ad85", "#dab997", "#d75f5f", "#afaf00");
    /// <summary> Gruvbox Dark Soft theme. </summary>
    public static RizzyCodeTheme GruvboxDarkSoft { get; } = new("#32302f", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    /// <summary> Gruvbox Light Hard theme. </summary>
    public static RizzyCodeTheme GruvboxLightHard { get; } = new("#f9f5d7", "#504945", "#bdae93", "#8f3f71", "#af3a03",
        "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    /// <summary> Gruvbox Light Medium theme. </summary>
    public static RizzyCodeTheme GruvboxLightMedium { get; } = new("#fbf1c7", "#504945", "#bdae93", "#8f3f71",
        "#af3a03", "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    /// <summary> Gruvbox Light Soft theme. </summary>
    public static RizzyCodeTheme GruvboxLightSoft { get; } = new("#f2e5bc", "#504945", "#bdae93", "#8f3f71", "#af3a03",
        "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    /// <summary> Harmonic Dark theme. </summary>
    public static RizzyCodeTheme HarmonicDark { get; } = new("#0b1c2c", "#cbd6e2", "#627e99", "#bf568b", "#bfbf56",
        "#8b56bf", "#bf8b56", "#56bf8b", "#568bbf", "#cbd6e2", "#bf8b56", "#56bf8b");
    /// <summary> Harmonic Light theme. </summary>
    public static RizzyCodeTheme HarmonicLight { get; } = new("#f7f9fb", "#405c79", "#aabcce", "#bf568b", "#bfbf56",
        "#8b56bf", "#bf8b56", "#56bf8b", "#568bbf", "#405c79", "#bf8b56", "#56bf8b");
    /// <summary> Hopscotch theme. </summary>
    public static RizzyCodeTheme Hopscotch { get; } = new("#322931", "#b9b5b8", "#797379", "#c85e7c", "#fd8b19",
        "#1290bf", "#dd464c", "#8fc13e", "#149b93", "#b9b5b8", "#dd464c", "#8fc13e");
    /// <summary> Ia Dark theme. </summary>
    public static RizzyCodeTheme IaDark { get; } = new("#1a1a1a", "#cccccc", "#767676", "#b98eb2", "#d86868", "#8eccdd",
        "#d88568", "#83a471", "#7c9cae", "#cccccc", "#d88568", "#83a471");
    /// <summary> Ia Light theme. </summary>
    public static RizzyCodeTheme IaLight { get; } = new("#f6f6f6", "#181818", "#898989", "#a94598", "#c43e18",
        "#48bac2", "#9c5a02", "#38781c", "#2d6bb1", "#181818", "#9c5a02", "#38781c");
    /// <summary> Icy theme. </summary>
    public static RizzyCodeTheme Icy { get; } = new("#021012", "#095b67", "#052e34", "#00acc1", "#b3ebf2", "#00bcd4",
        "#16c1d9", "#4dd0e1", "#26c6da", "#095b67", "#16c1d9", "#4dd0e1");
    /// <summary> Irblack theme. </summary>
    public static RizzyCodeTheme Irblack { get; } = new("#000000", "#b5b3aa", "#6c6c66", "#ff73fd", "#e9c062",
        "#96cbfe", "#ff6c60", "#a8ff60", "#c6c5fe", "#b5b3aa", "#ff6c60", "#a8ff60");
    /// <summary> Isotope theme. </summary>
    public static RizzyCodeTheme Isotope { get; } = new("#000000", "#d0d0d0", "#808080", "#cc00ff", "#ff9900",
        "#0066ff", "#ff0000", "#33ff00", "#00ffff", "#d0d0d0", "#ff0000", "#33ff00");
    /// <summary> Macintosh theme. </summary>
    public static RizzyCodeTheme Macintosh { get; } = new("#000000", "#c0c0c0", "#808080", "#4700a5", "#ff6403",
        "#0000d3", "#dd0907", "#1fb714", "#02abea", "#c0c0c0", "#dd0907", "#1fb714");
    /// <summary> Marrakesh theme. </summary>
    public static RizzyCodeTheme Marrakesh { get; } = new("#201602", "#948e48", "#6c6823", "#8868b3", "#b36144",
        "#477ca1", "#c35359", "#18974e", "#75a738", "#948e48", "#c35359", "#18974e");
    /// <summary> Materia theme. </summary>
    public static RizzyCodeTheme Materia { get; } = new("#263238", "#CDD3DE", "#707880", "#82AAFF", "#EA9560",
        "#89DDFF", "#EC5F67", "#8BD649", "#80CBC4", "#CDD3DE", "#EC5F67", "#8BD649");
    /// <summary> Material Darker theme. </summary>
    public static RizzyCodeTheme MaterialDarker { get; } = new("#212121", "#EEFFFF", "#4A4A4A", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#EEFFFF", "#F07178", "#C3E88D");
    /// <summary> Material Lighter theme. </summary>
    public static RizzyCodeTheme MaterialLighter { get; } = new("#FAFAFA", "#80CBC4", "#CCD7DA", "#7C4DFF", "#F76D47",
        "#6182B8", "#FF5370", "#91B859", "#39ADB5", "#80CBC4", "#FF5370", "#91B859");
    /// <summary> Material Palenight theme. </summary>
    public static RizzyCodeTheme MaterialPalenight { get; } = new("#292D3E", "#959DCB", "#676E95", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#959DCB", "#F07178", "#C3E88D");
    /// <summary> Material Vivid theme. </summary>
    public static RizzyCodeTheme MaterialVivid { get; } = new("#263238", "#B0BEC5", "#546E7A", "#651FFF", "#FF9100",
        "#2979FF", "#FF1744", "#00E676", "#00B0FF", "#B0BEC5", "#FF1744", "#00E676");
    /// <summary> Material theme. </summary>
    public static RizzyCodeTheme Material { get; } = new("#263238", "#EEFFFF", "#546E7A", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#EEFFFF", "#F07178", "#C3E88D");
    /// <summary> Mellow Purple theme. </summary>
    public static RizzyCodeTheme MellowPurple { get; } = new("#1e0528", "#ffeeff", "#320f55", "#8991bb", "#aa00a3",
        "#550068", "#00d9e9", "#05cb0d", "#b900b1", "#ffeeff", "#00d9e9", "#05cb0d");
    /// <summary> Mexico Light theme. </summary>
    public static RizzyCodeTheme MexicoLight { get; } = new("#f8f8f8", "#383838", "#b8b8b8", "#96609e", "#dc9656",
        "#7cafc2", "#ab4642", "#538947", "#4b8093", "#383838", "#ab4642", "#538947");
    /// <summary> Mocha theme. </summary>
    public static RizzyCodeTheme Mocha { get; } = new("#3B3228", "#d0c8c6", "#7e705a", "#a89bb9", "#d28b71", "#8ab3b5",
        "#cb6077", "#beb55b", "#7bbda4", "#d0c8c6", "#cb6077", "#beb55b");
    /// <summary> Monokai theme. </summary>
    public static RizzyCodeTheme Monokai { get; } = new("#272822", "#f8f8f2", "#75715e", "#ae81ff", "#fd971f",
        "#66d9ef", "#f92672", "#a6e22e", "#a1efe4", "#f8f8f2", "#f92672", "#a6e22e");
    /// <summary> Nord theme. </summary>
    public static RizzyCodeTheme Nord { get; } = new("#2E3440", "#E5E9F0", "#4C566A", "#A3BE8C", "#81A1C1", "#EBCB8B",
        "#88C0D0", "#BF616A", "#D08770", "#E5E9F0", "#88C0D0", "#BF616A");
    /// <summary> Ocean theme. </summary>
    public static RizzyCodeTheme Ocean { get; } = new("#2b303b", "#c0c5ce", "#65737e", "#b48ead", "#d08770", "#8fa1b3",
        "#bf616a", "#a3be8c", "#96b5b4", "#c0c5ce", "#bf616a", "#a3be8c");
    /// <summary> OceanicNext theme. </summary>
    public static RizzyCodeTheme OceanicNext { get; } = new("#1B2B34", "#C0C5CE", "#65737E", "#C594C5", "#F99157",
        "#6699CC", "#EC5f67", "#99C794", "#5FB3B3", "#C0C5CE", "#EC5f67", "#99C794");
    /// <summary> One Light theme. </summary>
    public static RizzyCodeTheme OneLight { get; } = new("#fafafa", "#383a42", "#a0a1a7", "#a626a4", "#d75f00",
        "#4078f2", "#ca1243", "#50a14f", "#0184bc", "#383a42", "#ca1243", "#50a14f");
    /// <summary> Onedark theme. </summary>
    public static RizzyCodeTheme Onedark { get; } = new("#282c34", "#abb2bf", "#545862", "#c678dd", "#d19a66",
        "#61afef", "#e06c75", "#98c379", "#56b6c2", "#abb2bf", "#e06c75", "#98c379");
    /// <summary> Outrun Dark theme. </summary>
    public static RizzyCodeTheme OutrunDark { get; } = new("#00002A", "#D0D0FA", "#50507A", "#F10596", "#FC8D28",
        "#66B0FF", "#FF4242", "#59F176", "#0EF0F0", "#D0D0FA", "#FF4242", "#59F176");
    /// <summary> Paraiso theme. </summary>
    public static RizzyCodeTheme Paraiso { get; } = new("#2f1e2e", "#a39e9b", "#776e71", "#815ba4", "#f99b15",
        "#06b6ef", "#ef6155", "#48b685", "#5bc4bf", "#a39e9b", "#ef6155", "#48b685");
    /// <summary> Phd theme. </summary>
    public static RizzyCodeTheme Phd { get; } = new("#061229", "#b8bbc2", "#717885", "#9989cc", "#f0a000", "#5299bf",
        "#d07346", "#99bf52", "#72b9bf", "#b8bbc2", "#d07346", "#99bf52");
    /// <summary> Pico theme. </summary>
    public static RizzyCodeTheme Pico { get; } = new("#000000", "#5f574f", "#008751", "#ff77a8", "#ffa300", "#83769c",
        "#ff004d", "#00e756", "#29adff", "#5f574f", "#ff004d", "#00e756");
    /// <summary> Pop theme. </summary>
    public static RizzyCodeTheme Pop { get; } = new("#000000", "#d0d0d0", "#505050", "#b31e8d", "#f29333", "#0e5a94",
        "#eb008a", "#37b349", "#00aabb", "#d0d0d0", "#eb008a", "#37b349");
    /// <summary> Porple theme. </summary>
    public static RizzyCodeTheme Porple { get; } = new("#292c36", "#d8d8d8", "#65568a", "#b74989", "#d28e5d", "#8485ce",
        "#f84547", "#95c76f", "#64878f", "#d8d8d8", "#f84547", "#95c76f");
    /// <summary> Railscasts theme. </summary>
    public static RizzyCodeTheme Railscasts { get; } = new("#2b2b2b", "#e6e1dc", "#5a647e", "#b6b3eb", "#cc7833",
        "#6d9cbe", "#da4939", "#a5c261", "#519f50", "#e6e1dc", "#da4939", "#a5c261");
    /// <summary> Rebecca theme. </summary>
    public static RizzyCodeTheme Rebecca { get; } = new("#292a44", "#f1eff8", "#666699", "#7aa5ff", "#efe4a1",
        "#2de0a7", "#a0a0c5", "#6dfedf", "#8eaee0", "#f1eff8", "#a0a0c5", "#6dfedf");
    /// <summary> Seti theme. </summary>
    public static RizzyCodeTheme Seti { get; } = new("#151718", "#d6d6d6", "#41535B", "#a074c4", "#db7b55", "#55b5db",
        "#Cd3f45", "#9fca56", "#55dbbe", "#d6d6d6", "#Cd3f45", "#9fca56");
    /// <summary> Shapeshifter theme. </summary>
    public static RizzyCodeTheme Shapeshifter { get; } = new("#f9f9f9", "#102015", "#555555", "#f996e2", "#e09448",
        "#3b48e3", "#e92f2f", "#0ed839", "#23edda", "#102015", "#e92f2f", "#0ed839");
    /// <summary> Snazzy theme. </summary>
    public static RizzyCodeTheme Snazzy { get; } = new("#1e1f29", "#eff0eb", "#78787e", "#ff6ac1", "#ff9f43", "#57c7ff",
        "#ff5c57", "#5af78e", "#9aedfe", "#eff0eb", "#ff5c57", "#5af78e");
    /// <summary> Solarflare theme. </summary>
    public static RizzyCodeTheme Solarflare { get; } = new("#18262F", "#A6AFB8", "#667581", "#A363D5", "#E66B2B",
        "#33B5E1", "#EF5253", "#7CC844", "#52CBB0", "#A6AFB8", "#EF5253", "#7CC844");
    /// <summary> Solarized Dark theme. </summary>
    public static RizzyCodeTheme SolarizedDark { get; } = new("#002b36", "#93a1a1", "#657b83", "#6c71c4", "#cb4b16",
        "#268bd2", "#dc322f", "#859900", "#2aa198", "#93a1a1", "#dc322f", "#859900");
    /// <summary> Solarized Light theme. </summary>
    public static RizzyCodeTheme SolarizedLight { get; } = new("#fdf6e3", "#586e75", "#839496", "#6c71c4", "#cb4b16",
        "#268bd2", "#dc322f", "#859900", "#2aa198", "#586e75", "#dc322f", "#859900");
    /// <summary> Spacemacs theme. </summary>
    public static RizzyCodeTheme Spacemacs { get; } = new("#1f2022", "#a3a3a3", "#585858", "#a31db1", "#ffa500",
        "#4f97d7", "#f2241f", "#67b11d", "#2d9574", "#a3a3a3", "#f2241f", "#67b11d");
    /// <summary> Summerfruit Dark theme. </summary>
    public static RizzyCodeTheme SummerfruitDark { get; } = new("#151515", "#D0D0D0", "#505050", "#AD00A1", "#FD8900",
        "#3777E6", "#FF0086", "#00C918", "#1FAAAA", "#D0D0D0", "#FF0086", "#00C918");
    /// <summary> Summerfruit Light theme. </summary>
    public static RizzyCodeTheme SummerfruitLight { get; } = new("#FFFFFF", "#101010", "#B0B0B0", "#AD00A1", "#FD8900",
        "#3777E6", "#FF0086", "#00C918", "#1FAAAA", "#101010", "#FF0086", "#00C918");
    /// <summary> Tomorrow Night theme. </summary>
    public static RizzyCodeTheme TomorrowNight { get; } = new("#1d1f21", "#c5c8c6", "#969896", "#b294bb", "#de935f",
        "#81a2be", "#cc6666", "#b5bd68", "#8abeb7", "#c5c8c6", "#cc6666", "#b5bd68");
    /// <summary> Tomorrow theme. </summary>
    public static RizzyCodeTheme Tomorrow { get; } = new("#ffffff", "#4d4d4c", "#8e908c", "#8959a8", "#f5871f",
        "#4271ae", "#c82829", "#718c00", "#3e999f", "#4d4d4c", "#c82829", "#718c00");
    /// <summary> Tube theme. </summary>
    public static RizzyCodeTheme Tube { get; } = new("#231f20", "#d9d8d8", "#737171", "#98005d", "#f386a1", "#009ddc",
        "#ee2e24", "#00853e", "#85cebc", "#d9d8d8", "#ee2e24", "#00853e");
    /// <summary> Twilight theme. </summary>
    public static RizzyCodeTheme Twilight { get; } = new("#1e1e1e", "#a7a7a7", "#5f5a60", "#9b859d", "#cda869",
        "#7587a6", "#cf6a4c", "#8f9d6a", "#afc4db", "#a7a7a7", "#cf6a4c", "#8f9d6a");
    /// <summary> Unikitty Dark theme. </summary>
    public static RizzyCodeTheme UnikittyDark { get; } = new("#2e2a31", "#bcbabe", "#838085", "#bb60ea", "#d65407",
        "#796af5", "#d8137f", "#17ad98", "#149bda", "#bcbabe", "#d8137f", "#17ad98");
    /// <summary> Unikitty Light theme. </summary>
    public static RizzyCodeTheme UnikittyLight { get; } = new("#ffffff", "#6c696e", "#a7a5a8", "#aa17e6", "#d65407",
        "#775dff", "#d8137f", "#17ad98", "#149bda", "#6c696e", "#d8137f", "#17ad98");
    /// <summary> Unikitty Reversible theme. </summary>
    public static RizzyCodeTheme UnikittyReversible { get; } = new("#2e2a31", "#c3c2c4", "#878589", "#b33ce8",
        "#d65407", "#7864fa", "#d8137f", "#17ad98", "#149bda", "#c3c2c4", "#d8137f", "#17ad98");
    /// <summary> Woodland theme. </summary>
    public static RizzyCodeTheme Woodland { get; } = new("#231e18", "#cabcb1", "#9d8b70", "#bb90e2", "#ca7f32",
        "#88a4d3", "#d35c5c", "#b7ba53", "#6eb958", "#cabcb1", "#d35c5c", "#b7ba53");
    /// <summary> Xcode Dusk theme. </summary>
    public static RizzyCodeTheme XcodeDusk { get; } = new("#282B35", "#939599", "#686A71", "#B21889", "#786DC5",
        "#790EAD", "#B21889", "#DF0002", "#00A0BE", "#939599", "#B21889", "#DF0002");
    /// <summary> Zenburn theme. </summary>
    public static RizzyCodeTheme Zenburn { get; } = new("#3f3f3f", "#dcdccc", "#4f4f4f", "#dc8cc3", "#dfaf8f",
        "#7cb8bb", "#dca3a3", "#5f7f5f", "#93e0e3", "#dcdccc", "#dca3a3", "#5f7f5f");
}
</file>

<file path="Components/Theme/Themes/Code/RizzyCodeTheme.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Defines a syntax highlighting color theme for code.
/// </summary>
public class RizzyCodeTheme
{
    /// <summary>
    ///     Initialize theme
    /// </summary>
    /// <param name="background">The background color.</param>
    /// <param name="color">The default text color.</param>
    /// <param name="comment">The color for comments.</param>
    /// <param name="keyword">The color for keywords.</param>
    /// <param name="attribute">The color for attributes.</param>
    /// <param name="symbol">The color for symbols.</param>
    /// <param name="nameSpace">The color for namespaces.</param>
    /// <param name="variable">The color for variables.</param>
    /// <param name="literal">The color for literals.</param>
    /// <param name="punctuation">The color for punctuation.</param>
    /// <param name="deletion">The color for deletions in diffs.</param>
    /// <param name="addition">The color for additions in diffs.</param>
    public RizzyCodeTheme(
        string background,
        string color,
        string comment,
        string keyword,
        string attribute,
        string symbol,
        string nameSpace,
        string variable,
        string literal,
        string punctuation,
        string deletion,
        string addition)
    {
        Background = new Color(background);
        Color = new Color(color);
        Comment = new Color(comment);
        Keyword = new Color(keyword);
        Attribute = new Color(attribute);
        Symbol = new Color(symbol);
        Namespace = new Color(nameSpace);
        Variable = new Color(variable);
        Literal = new Color(literal);
        Punctuation = new Color(punctuation);
        Deletion = new Color(deletion);
        Addition = new Color(addition);
    }
    /// <summary>
    ///     Gets the background color used for code highlighting.
    /// </summary>
    public Color Background { get; init; }
    /// <summary>
    ///     Gets the default color used for code highlighting.
    /// </summary>
    public Color Color { get; init; }
    /// <summary>
    ///     Gets the color used for comments.
    /// </summary>
    public Color Comment { get; init; }
    /// <summary>
    ///     Gets the color used for keywords.
    /// </summary>
    public Color Keyword { get; init; }
    /// <summary>
    ///     Gets the color used for attributes.
    /// </summary>
    public Color Attribute { get; init; }
    /// <summary>
    ///     Gets the color used for symbols.
    /// </summary>
    public Color Symbol { get; init; }
    /// <summary>
    ///     Gets the color used for namespaces.
    /// </summary>
    public Color Namespace { get; init; }
    /// <summary>
    ///     Gets the color used for variables.
    /// </summary>
    public Color Variable { get; init; }
    /// <summary>
    ///     Gets the color used for literals.
    /// </summary>
    public Color Literal { get; init; }
    /// <summary>
    ///     Gets the color used for punctuation.
    /// </summary>
    public Color Punctuation { get; init; }
    /// <summary>
    ///     Gets the color used to indicate deletions.
    /// </summary>
    public Color Deletion { get; init; }
    /// <summary>
    ///     Gets the color used to indicate additions.
    /// </summary>
    public Color Addition { get; init; }
}
</file>

<file path="Components/Typography/RzHeading.razor">
@namespace RizzyUI
@inherits RzTypographyBase<RzHeading.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
    <div x-data="rzHeading" data-alpine-root="@Id">
        @if (ChildContent == null && !string.IsNullOrEmpty(QuickReferenceTitle))
        {
            @QuickReferenceTitle
        }
        else
        {
            @ChildContent
        }
    </div>
</HtmlElement>
</file>

<file path="Components/Typography/RzHeading.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Renders an HTML heading element (h1-h4) with appropriate typography styling based on the level and active
///     &lt;see cref="RzTheme" /&gt;.
///     Inherits common text styling options from &lt;see cref="RzTypographyBase" /&gt;. Can register itself with an
///     &lt;see cref="RzQuickReferenceContainer" /&gt;.
/// </xmldoc>
public partial class RzHeading : RzTypographyBase<RzHeading.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzHeading component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "scroll-m-20 tracking-tight",
        variants: new()
        {
            [c => ((RzHeading)c).Level] = new Variant<HeadingLevel, Slots>
            {
                [HeadingLevel.H1] = "text-4xl font-extrabold lg:text-5xl",
                [HeadingLevel.H2] = "border-b pb-2 text-3xl font-semibold first:mt-0",
                [HeadingLevel.H3] = "text-2xl font-semibold",
                [HeadingLevel.H4] = "text-xl font-semibold"
            },
            [c => ((RzHeading)c).TextColor] = new Variant<SemanticColor, Slots>
            {
                [SemanticColor.Primary] = "text-primary",
                [SemanticColor.Secondary] = "text-secondary",
                [SemanticColor.Muted] = "text-muted-foreground",
                [SemanticColor.Foreground] = "text-foreground",
            },
            [c => ((RzHeading)c).Weight] = new Variant<TextWeight, Slots>
            {
                [TextWeight.Thin] = "font-thin",
                [TextWeight.Normal] = "font-normal",
                [TextWeight.Bold] = "font-bold",
                [TextWeight.ExtraBold] = "font-extrabold"
            },
            [c => ((RzHeading)c).Size] = new Variant<TextSize, Slots>
            {
                [TextSize.Small] = "text-sm",
                [TextSize.Medium] = "text-base",
                [TextSize.Large] = "text-lg",
                [TextSize.ExtraLarge] = "text-xl",
                [TextSize.TwoXL] = "text-2xl",
                [TextSize.ThreeXL] = "text-3xl",
                [TextSize.FourXL] = "text-4xl",
                [TextSize.FiveXL] = "text-5xl"
            },
            [c => ((RzHeading)c).LineHeight] = new Variant<Leading, Slots>
            {
                [Leading.None] = "leading-none",
                [Leading.Tight] = "leading-tight",
                [Leading.Snug] = "leading-snug",
                [Leading.Normal] = "leading-normal",
                [Leading.Relaxed] = "leading-relaxed",
                [Leading.Loose] = "leading-loose"
            },
            [c => ((RzHeading)c).Decoration] = new Variant<TextDecoration, Slots>
            {
                [TextDecoration.None] = "no-underline",
                [TextDecoration.Underline] = "underline",
                [TextDecoration.Overline] = "overline",
                [TextDecoration.LineThrough] = "line-through"
            },
            [c => ((RzHeading)c).Transform] = new Variant<TextTransform, Slots>
            {
                [TextTransform.None] = "normal-case",
                [TextTransform.Uppercase] = "uppercase",
                [TextTransform.Lowercase] = "lowercase",
                [TextTransform.Capitalize] = "capitalize"
            }
        }
    );
    private bool _registered;
    /// <summary> Represents the heading level (H1-H4), determining the HTML tag and base styles. Required. </summary>
    [Parameter]
    [EditorRequired]
    public required HeadingLevel Level { get; set; }
    /// <summary> The content to be rendered inside the heading tag. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     The title text to use when registering this heading with an &lt;see cref="RzQuickReferenceContainer" /&gt;. If null
    ///     or empty, the heading will not be registered.
    /// </summary>
    [Parameter]
    public string? QuickReferenceTitle { get; set; }
    /// <summary> Gets the parent &lt;see cref="RzQuickReferenceContainer" /&gt; if this heading is nested within one. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Element = Level switch
        {
            HeadingLevel.H1 => "h1",
            HeadingLevel.H2 => "h2",
            HeadingLevel.H3 => "h3",
            HeadingLevel.H4 => "h4",
            _ => "h1"
        };
        if (TextColor is null)
            TextColor = SemanticColor.Foreground;
        if (!_registered && QuickReferenceContainer != null)
        {
            if (string.IsNullOrEmpty(QuickReferenceTitle))
                QuickReferenceTitle = ChildContent?.AsMarkupString() ?? "[Missing QuickReferenceTitle]";
            QuickReferenceContainer.RegisterHeading(Level, QuickReferenceTitle, Id);
            _registered = true;
        }
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzHeading;
    /// <summary>
    /// Defines the slots available for styling in the RzHeading component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Typography/RzKbd/RzKbd.razor">
@namespace RizzyUI
@inherits RzComponent<RzKbd.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="kbd">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Typography/RzKbd/RzKbd.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that renders a keyboard key, typically used to display keyboard shortcuts.
/// </summary>
public partial class RzKbd : RzComponent<RzKbd.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzKbd component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "bg-muted text-muted-foreground pointer-events-none inline-flex h-5 w-fit min-w-5 items-center justify-center gap-1 rounded-sm px-1 font-sans text-xs font-medium select-none [&_svg:not([class*='size-'])]:size-3 [[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the kbd element.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "kbd";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzKbd;
    /// <summary>
    /// Defines the slots available for styling in the RzKbd component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Typography/RzKbd/RzKbdGroup.razor">
@namespace RizzyUI
@inherits RzComponent<RzKbdGroup.Slots>

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="kbd-group">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Typography/RzKbd/RzKbdGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A component that groups multiple <see cref="RzKbd"/> components together.
/// </summary>
public partial class RzKbdGroup : RzComponent<RzKbdGroup.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzKbdGroup component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center gap-1"
    );
    /// <summary>
    /// Gets or sets the content to be rendered inside the group, typically multiple <see cref="RzKbd"/> components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "kbd";
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzKbdGroup;
    /// <summary>
    /// Defines the slots available for styling in the RzKbdGroup component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Typography/RzParagraph.razor">
@namespace RizzyUI
@inherits RzTypographyBase<RzParagraph.Slots>

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@SlotClasses.GetBase()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Typography/RzParagraph.razor.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Renders a paragraph (&lt;c&gt;p&lt;/c&gt;) element with standard typography styling.
///     Inherits text styling options from &lt;see cref="RzTypographyBase" /&gt;.
///     Styling, including prose width, is determined by the active &lt;see cref="RzTheme" /&gt;.
/// </xmldoc>
public partial class RzParagraph : RzTypographyBase<RzParagraph.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzParagraph component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "leading-7 [&:not(:first-child)]:mt-6",
        variants: new()
        {
            [c => ((RzParagraph)c).ProseWidth] = new Variant<ProseWidth, Slots>
            {
                [ProseWidth.Compact] = "max-w-prose prose-sm",
                [ProseWidth.Comfortable] = "max-w-prose",
                [ProseWidth.Relaxed] = "max-w-prose prose-lg",
                [ProseWidth.Wide] = "max-w-screen-md",
                [ProseWidth.UltraWide] = "max-w-screen-lg",
                [ProseWidth.Full] = "max-w-none"
            },
            [c => ((RzParagraph)c).TextColor] = new Variant<SemanticColor, Slots>
            {
                [SemanticColor.Primary] = "text-primary",
                [SemanticColor.Secondary] = "text-secondary",
                [SemanticColor.Muted] = "text-muted-foreground",
                [SemanticColor.Foreground] = "text-foreground",
            },
            [c => ((RzParagraph)c).Weight] = new Variant<TextWeight, Slots>
            {
                [TextWeight.Thin] = "font-thin",
                [TextWeight.Normal] = "font-normal",
                [TextWeight.Bold] = "font-bold",
                [TextWeight.ExtraBold] = "font-extrabold"
            },
            [c => ((RzParagraph)c).Size] = new Variant<TextSize, Slots>
            {
                [TextSize.Small] = "text-sm",
                [TextSize.Medium] = "text-base",
                [TextSize.Large] = "text-lg",
                [TextSize.ExtraLarge] = "text-xl",
                [TextSize.TwoXL] = "text-2xl",
                [TextSize.ThreeXL] = "text-3xl",
                [TextSize.FourXL] = "text-4xl",
                [TextSize.FiveXL] = "text-5xl"
            },
            [c => ((RzParagraph)c).LineHeight] = new Variant<Leading, Slots>
            {
                [Leading.None] = "leading-none",
                [Leading.Tight] = "leading-tight",
                [Leading.Snug] = "leading-snug",
                [Leading.Normal] = "leading-normal",
                [Leading.Relaxed] = "leading-relaxed",
                [Leading.Loose] = "leading-loose"
            },
            [c => ((RzParagraph)c).Decoration] = new Variant<TextDecoration, Slots>
            {
                [TextDecoration.None] = "no-underline",
                [TextDecoration.Underline] = "underline",
                [TextDecoration.Overline] = "overline",
                [TextDecoration.LineThrough] = "line-through"
            },
            [c => ((RzParagraph)c).Transform] = new Variant<TextTransform, Slots>
            {
                [TextTransform.None] = "normal-case",
                [TextTransform.Uppercase] = "uppercase",
                [TextTransform.Lowercase] = "lowercase",
                [TextTransform.Capitalize] = "capitalize"
            }
        }
    );
    /// <summary> The content to be rendered inside the paragraph. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets the maximum character width of the paragraph. Defaults to Full. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Full;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p";
        TextColor ??= SemanticColor.Foreground;
    }
    /// <inheritdoc />
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzParagraph;
    /// <summary>
    /// Defines the slots available for styling in the RzParagraph component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        /// <summary>
        /// The base slot for the component's root element.
        /// </summary>
        public string? Base { get; set; }
    }
}
</file>

<file path="Components/Typography/RzTypographyBase.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <xmldoc>
///     Base class for typography components like <see cref="RzHeading" /> and <see cref="RzParagraph" />.
///     Provides common parameters for text styling (color, weight, size, etc.) and access to the theme's typography
///     styles. This version is generic to support TailwindVariants.NET.
/// </xmldoc>
public abstract partial class RzTypographyBase<TSlots> : RzComponent<TSlots>
    where TSlots : ISlots, new()
{
    /// <summary> Gets or sets the text color. If null, defaults are often applied by inheriting components. </summary>
    [Parameter]
    public SemanticColor? TextColor { get; set; }
    /// <summary> Gets or sets the font weight. </summary>
    [Parameter]
    public TextWeight? Weight { get; set; }
    /// <summary> Gets or sets the text size. </summary>
    [Parameter]
    public TextSize? Size { get; set; }
    /// <summary> Gets or sets the line height (leading). </summary>
    [Parameter]
    public Leading? LineHeight { get; set; }
    /// <summary> Gets or sets the text decoration (underline, etc.). </summary>
    [Parameter]
    public TextDecoration? Decoration { get; set; }
    /// <summary> Gets or sets the text transformation (uppercase, etc.). </summary>
    [Parameter]
    public TextTransform? Transform { get; set; }
}
</file>

<file path="Components/Typography/Styles.cs">
namespace RizzyUI;
/// <summary>
///     Represents the heading level, corresponding to HTML heading tags.
/// </summary>
public enum HeadingLevel
{
    /// <summary>
    ///     Heading level 1 (&lt;h1&gt;), typically the largest heading.
    /// </summary>
    H1,
    /// <summary>
    ///     Heading level 2 (&lt;h2&gt;), typically used for main sections.
    /// </summary>
    H2,
    /// <summary>
    ///     Heading level 3 (&lt;h3&gt;), typically used for subsections.
    /// </summary>
    H3,
    /// <summary>
    ///     Heading level 4 (&lt;h4&gt;), typically used for smaller subsections.
    /// </summary>
    H4
}
/// <summary>
///     Represents the font weight.
/// </summary>
public enum TextWeight
{
    /// <summary>
    ///     Thin font weight (font-weight: 100).
    /// </summary>
    Thin,
    /// <summary>
    ///     Normal font weight (font-weight: 400).
    /// </summary>
    Normal,
    /// <summary>
    ///     Bold font weight (font-weight: 700).
    /// </summary>
    Bold,
    /// <summary>
    ///     Extra bold font weight (font-weight: 800).
    /// </summary>
    ExtraBold
}
/// <summary>
///     Represents the font size.
/// </summary>
public enum TextSize
{
    /// <summary>
    ///     Small text size (font-size: 0.875rem; 14px).
    /// </summary>
    Small,
    /// <summary>
    ///     Medium text size (font-size: 1rem; 16px).
    /// </summary>
    Medium,
    /// <summary>
    ///     Large text size (font-size: 1.125rem; 18px).
    /// </summary>
    Large,
    /// <summary>
    ///     Extra large text size (font-size: 1.25rem; 20px).
    /// </summary>
    ExtraLarge,
    /// <summary>
    ///     2XL text size (font-size: 1.5rem; 24px).
    /// </summary>
    TwoXL,
    /// <summary>
    ///     3XL text size (font-size: 1.875rem; 30px).
    /// </summary>
    ThreeXL,
    /// <summary>
    ///     4XL text size (font-size: 2.25rem; 36px).
    /// </summary>
    FourXL,
    /// <summary>
    ///     5XL text size (font-size: 3rem; 48px).
    /// </summary>
    FiveXL
}
/// <summary>
///     Represents text decoration styles.
/// </summary>
public enum TextDecoration
{
    /// <summary>
    ///     No text decoration (text-decoration: none).
    /// </summary>
    None,
    /// <summary>
    ///     Underlined text (text-decoration: underline).
    /// </summary>
    Underline,
    /// <summary>
    ///     Overlined text (text-decoration: overline).
    /// </summary>
    Overline,
    /// <summary>
    ///     Line-through text (text-decoration: line-through).
    /// </summary>
    LineThrough
}
/// <summary>
///     Represents text transformation styles.
/// </summary>
public enum TextTransform
{
    /// <summary>
    ///     Normal text (text-transform: none).
    /// </summary>
    None,
    /// <summary>
    ///     Uppercase text (text-transform: uppercase).
    /// </summary>
    Uppercase,
    /// <summary>
    ///     Lowercase text (text-transform: lowercase).
    /// </summary>
    Lowercase,
    /// <summary>
    ///     Capitalized text (text-transform: capitalize).
    /// </summary>
    Capitalize
}
/// <summary>
///     Represents the line height.
/// </summary>
public enum Leading
{
    /// <summary>
    ///     None line height (line-height: 1).
    /// </summary>
    None,
    /// <summary>
    ///     Tight line height (line-height: 1.25).
    /// </summary>
    Tight,
    /// <summary>
    ///     Snug line height (line-height: 1.375).
    /// </summary>
    Snug,
    /// <summary>
    ///     Normal line height (line-height: 1.5).
    /// </summary>
    Normal,
    /// <summary>
    ///     Relaxed line height (line-height: 1.625).
    /// </summary>
    Relaxed,
    /// <summary>
    ///     Loose line height (line-height: 2).
    /// </summary>
    Loose
}
</file>

<file path="Components/Utility/ColorUtil.cs">
namespace RizzyUI;
/// <summary>
///     Provides utility methods for converting accent and semantic color values to complete Tailwind CSS class strings for
///     background and text styling.
/// </summary>
public static class ColorUtil
{
    // ReSharper disable once UnusedMember.Local
    [SuppressMessage("CodeQuality", "IDE0051:Remove unused private members",
        Justification = "This is to allow Tailwind utilities to discover used classes")]
#pragma warning disable CS0414 // Field is assigned but its value is never used
    private static readonly string TwBackgroundClassAfterDiscovery =
#pragma warning restore CS0414 // Field is assigned but its value is never used
        "after:bg-background after:bg-foreground after:bg-card after:bg-card-foreground after:bg-popover after:bg-popover-foreground " +
        "after:bg-primary after:bg-primary-foreground after:bg-secondary after:bg-secondary-foreground " +
        "after:bg-muted after:bg-muted-foreground after:bg-accent after:bg-accent-foreground " +
        "after:bg-destructive after:bg-destructive-foreground after:bg-border after:bg-input after:bg-ring " +
        "after:bg-info after:bg-info-foreground after:bg-warning after:bg-warning-foreground after:bg-success after:bg-success-foreground"; // Updated to OnInfo, OnWarning, OnSuccess to match SemanticColor
    /// <summary>
    ///     Converts an AccentColor to a background class string
    /// </summary>
    /// <param name="accentColor">The accent color.</param>
    /// <returns>The Tailwind CSS background class.</returns>
    public static string ToLightBackgroundClass(this AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "bg-gray-100",
            AccentColor.Emerald => "bg-emerald-200",
            AccentColor.Teal => "bg-teal-200",
            AccentColor.Blue => "bg-blue-200",
            AccentColor.Indigo => "bg-indigo-200",
            AccentColor.Purple => "bg-purple-200",
            AccentColor.Pink => "bg-pink-200",
            AccentColor.Red => "bg-red-200",
            AccentColor.Orange => "bg-orange-200",
            AccentColor.Yellow => "bg-yellow-300",
            _ => "bg-gray-100"
        };
    }
    /// <summary>
    ///     Converts an AccentColor to a background class string
    /// </summary>
    /// <param name="accentColor">The accent color.</param>
    /// <returns>The Tailwind CSS background class.</returns>
    public static string ToDarkBackgroundClass(this AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "bg-gray-400",
            AccentColor.Emerald => "bg-emerald-800",
            AccentColor.Teal => "bg-teal-600",
            AccentColor.Blue => "bg-blue-600",
            AccentColor.Indigo => "bg-indigo-700",
            AccentColor.Purple => "bg-purple-600",
            AccentColor.Pink => "bg-pink-500",
            AccentColor.Red => "bg-red-500",
            AccentColor.Orange => "bg-orange-500",
            AccentColor.Yellow => "bg-yellow-300",
            _ => "bg-gray-400"
        };
    }
    /// <summary>
    ///     Converts an AccentColor to a text class string
    /// </summary>
    /// <param name="accentColor">The accent color.</param>
    /// <returns>The Tailwind CSS text class.</returns>
    public static string ToTextClass(AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "text-gray-600",
            AccentColor.Emerald => "text-emerald-700",
            AccentColor.Teal => "text-teal-700",
            AccentColor.Blue => "text-blue-700",
            AccentColor.Indigo => "text-indigo-700",
            AccentColor.Purple => "text-purple-700",
            AccentColor.Pink => "text-pink-700",
            AccentColor.Red => "text-red-700",
            AccentColor.Orange => "text-orange-700",
            AccentColor.Yellow => "text-yellow-800",
            _ => "text-gray-600"
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a text class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS class.</returns>
    public static string ToTextClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "",
            SemanticColor.Background => "text-background",
            SemanticColor.Foreground => "text-foreground",
            SemanticColor.Card => "text-card",
            SemanticColor.CardForeground => "text-card-foreground",
            SemanticColor.Popover => "text-popover",
            SemanticColor.PopoverForeground => "text-popover-foreground",
            SemanticColor.Primary => "text-primary",
            SemanticColor.PrimaryForeground => "text-primary-foreground",
            SemanticColor.Secondary => "text-secondary",
            SemanticColor.SecondaryForeground => "text-secondary-foreground",
            SemanticColor.Muted => "text-muted",
            SemanticColor.MutedForeground => "text-muted-foreground",
            SemanticColor.Accent => "text-accent",
            SemanticColor.AccentForeground => "text-accent-foreground",
            SemanticColor.Destructive => "text-destructive",
            SemanticColor.DestructiveForeground => "text-destructive-foreground",
            SemanticColor.Border => "text-border",
            SemanticColor.Input => "text-input",
            SemanticColor.Ring => "text-ring",
            SemanticColor.Info => "text-info",
            SemanticColor.InfoForeground => "text--info-foreground",
            SemanticColor.Warning => "text-warning",
            SemanticColor.WarningForeground => "text-warning-foreground",
            SemanticColor.Success => "text-success",
            SemanticColor.SuccessForeground => "text-success-foreground",
            _ => "text-foreground"
        };
    }
    /// <summary>
    /// Converts a SemanticColor to a fill class string.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS fill class.</returns>
    public static string ToFillClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "",
            SemanticColor.Background => "fill-background",
            SemanticColor.Foreground => "fill-foreground",
            SemanticColor.Card => "fill-card",
            SemanticColor.CardForeground => "fill-card-foreground",
            SemanticColor.Popover => "fill-popover",
            SemanticColor.PopoverForeground => "fill-popover-foreground",
            SemanticColor.Primary => "fill-primary",
            SemanticColor.PrimaryForeground => "fill-primary-foreground",
            SemanticColor.Secondary => "fill-secondary",
            SemanticColor.SecondaryForeground => "fill-secondary-foreground",
            SemanticColor.Muted => "fill-muted",
            SemanticColor.MutedForeground => "fill-muted-foreground",
            SemanticColor.Accent => "fill-accent",
            SemanticColor.AccentForeground => "fill-accent-foreground",
            SemanticColor.Destructive => "fill-destructive",
            SemanticColor.DestructiveForeground => "fill-destructive-foreground",
            SemanticColor.Border => "fill-border",
            SemanticColor.Input => "fill-input",
            SemanticColor.Ring => "fill-ring",
            SemanticColor.Info => "fill-info",
            SemanticColor.InfoForeground => "fill--info-foreground",
            SemanticColor.Warning => "fill-warning",
            SemanticColor.WarningForeground => "fill-warning-foreground",
            SemanticColor.Success => "fill-success",
            SemanticColor.SuccessForeground => "fill-success-foreground",
            _ => "fill-foreground"
        };
    }
    /// <summary>
    ///     Converts a StatusColor to a text class string, including dark mode variants for Status colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS class.</returns>
    public static string ToTextClass(this StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "text-primary",
            StatusColor.Secondary => "text-secondary",
            StatusColor.Success => "text-success", // Assumes --success CSS var exists
            StatusColor.Info => "text-info",       // Assumes --info CSS var exists
            StatusColor.Warning => "text-warning",   // Assumes --warning CSS var exists
            StatusColor.Destructive => "text-destructive", // Maps to semantic destructive
            _ => "text-primary"
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a background class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS background class.</returns>
    public static string ToBackgroundClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "",
            SemanticColor.Background => "bg-background",
            SemanticColor.Foreground => "bg-foreground",
            SemanticColor.Card => "bg-card",
            SemanticColor.CardForeground => "bg-card-foreground",
            SemanticColor.Popover => "bg-popover",
            SemanticColor.PopoverForeground => "bg-popover-foreground",
            SemanticColor.Primary => "bg-primary",
            SemanticColor.PrimaryForeground => "bg-primary-foreground",
            SemanticColor.Secondary => "bg-secondary",
            SemanticColor.SecondaryForeground => "bg-secondary-foreground",
            SemanticColor.Muted => "bg-muted",
            SemanticColor.MutedForeground => "bg-muted-foreground",
            SemanticColor.Accent => "bg-accent",
            SemanticColor.AccentForeground => "bg-accent-foreground",
            SemanticColor.Destructive => "bg-destructive",
            SemanticColor.DestructiveForeground => "bg-destructive-foreground",
            SemanticColor.Border => "bg-border",
            SemanticColor.Input => "bg-input",
            SemanticColor.Ring => "bg-ring",
            SemanticColor.Info => "bg-info",
            SemanticColor.InfoForeground => "bg--info-foreground",
            SemanticColor.Warning => "bg-warning",
            SemanticColor.WarningForeground => "bg-warning-foreground",
            SemanticColor.Success => "bg-success",
            SemanticColor.SuccessForeground => "bg-success-foreground",
            _ => "bg-background"
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a background class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <param name="pseudoSelector">Tailwind pseudo element modifier ("before" or "after")</param>
    /// <returns>A string representing the corresponding CSS background class.</returns>
    public static string ToBackgroundClass(this SemanticColor color, string pseudoSelector)
    {
        var ps = pseudoSelector + ":";
        return color switch
        {
            SemanticColor.None => "",
            SemanticColor.Background => $"{ps}bg-background",
            SemanticColor.Foreground => $"{ps}bg-foreground",
            SemanticColor.Card => $"{ps}bg-card",
            SemanticColor.CardForeground => $"{ps}bg-card-foreground",
            SemanticColor.Popover => $"{ps}bg-popover",
            SemanticColor.PopoverForeground => $"{ps}bg-popover-foreground",
            SemanticColor.Primary => $"{ps}bg-primary",
            SemanticColor.PrimaryForeground => $"{ps}bg-primary-foreground",
            SemanticColor.Secondary => $"{ps}bg-secondary",
            SemanticColor.SecondaryForeground => $"{ps}bg-secondary-foreground",
            SemanticColor.Muted => $"{ps}bg-muted",
            SemanticColor.MutedForeground => $"{ps}bg-muted-foreground",
            SemanticColor.Accent => $"{ps}bg-accent",
            SemanticColor.AccentForeground => $"{ps}bg-accent-foreground",
            SemanticColor.Destructive => $"{ps}bg-destructive",
            SemanticColor.DestructiveForeground => $"{ps}bg-destructive-foreground",
            SemanticColor.Border => $"{ps}bg-border",
            SemanticColor.Input => $"{ps}bg-input",
            SemanticColor.Ring => $"{ps}bg-ring",
            SemanticColor.Info => $"{ps}bg-info",
            SemanticColor.InfoForeground => $"{ps}bg--info-foreground",
            SemanticColor.Warning => $"{ps}bg-warning",
            SemanticColor.WarningForeground => $"{ps}bg-warning-foreground",
            SemanticColor.Success => $"{ps}bg-success",
            SemanticColor.SuccessForeground => $"{ps}bg-success-foreground",
            _ => $"{ps}bg-background"
        };
    }
}
</file>

<file path="Components/Variants.cs">
namespace RizzyUI;
/// <summary>
///     Variants for button, alert, and badge components, defining their appearance and purpose.
/// </summary>
public enum ThemeVariant
{
    /// <summary>Default button styling.</summary>
    Default,
    /// <summary>Primary button for main actions, often bold and attention-grabbing.</summary>
    Primary,
    /// <summary>Secondary button for supporting actions.</summary>
    Secondary,
    /// <summary>Alternate styling for varied contexts.</summary>
    Accent,
    /// <summary>Inverse styling for dark backgrounds.</summary>
    Inverse,
    /// <summary>Information styling, typically blue for neutral actions.</summary>
    Information,
    /// <summary>Destructive styling, often red for critical actions.</summary>
    Destructive,
    /// <summary>Warning styling, often yellow for cautionary actions.</summary>
    Warning,
    /// <summary>Success styling, often green for positive actions.</summary>
    Success,
    /// <summary>Ghost button for minimal and subtle interactions.</summary>
    Ghost
}
/// <summary>
///     Appearance option for divider
/// </summary>
public enum SeparatorStyle
{
    /// <summary>
    ///     Solid line
    /// </summary>
    Solid,
    /// <summary>
    ///     Dashed line
    /// </summary>
    Dashed,
    /// <summary>
    ///     Dotted line
    /// </summary>
    Dotted
}
/// <summary>
///     Size options for various components to define their dimensions.
/// </summary>
public enum Size
{
    /// <summary>Extra small size, for compact components.</summary>
    ExtraSmall,
    /// <summary>Small size, smaller than the default.</summary>
    Small,
    /// <summary>Medium size, the default size.</summary>
    Medium,
    /// <summary>Large size, for bigger components.</summary>
    Large,
    /// <summary>Extra large size, for oversized components.</summary>
    ExtraLarge
}
/// <summary>
///     Defines available width options for prose content, measured in approximate characters per line (CPL).
/// </summary>
public enum ProseWidth
{
    /// <summary>
    ///     A compact width, approximately 56 characters per line.
    ///     Best for sidebars, footnotes, or narrow content blocks.
    /// </summary>
    Compact,
    /// <summary>
    ///     A comfortable width, approximately 64 characters per line.
    ///     Ideal for general prose readability in documentation and articles.
    /// </summary>
    Comfortable,
    /// <summary>
    ///     A relaxed width, approximately 72 characters per line.
    ///     Provides more space while maintaining good readability.
    /// </summary>
    Relaxed,
    /// <summary>
    ///     A wide width, approximately 80 characters per line.
    ///     Suitable for blog posts, long-form content, and expanded reading areas.
    /// </summary>
    Wide,
    /// <summary>
    ///     An ultrawide width, approximately 100 characters per line.
    ///     Best for technical documentation, research papers, or code-heavy content.
    /// </summary>
    UltraWide,
    /// <summary>
    ///     No maximum width constraint.
    ///     Useful for tables, charts, or content requiring full-width display.
    /// </summary>
    Full
}
/// <summary>
///     Justification options for layout alignment.
/// </summary>
public enum Justify
{
    /// <summary>Align items to the start.</summary>
    Start,
    /// <summary>Center align items.</summary>
    Center,
    /// <summary>Align items to the end.</summary>
    End
}
/// <summary>
///     Alignment options.
/// </summary>
public enum Align
{
    /// <summary>Align items to the start.</summary>
    Start,
    /// <summary>Center align items.</summary>
    Center,
    /// <summary>Align items to the end.</summary>
    End
}
/// <summary>
///     Anchor point options
/// </summary>
public enum AnchorPoint
{
    /// <summary>
    ///     Anchor to top start
    /// </summary>
    TopStart,
    /// <summary>
    ///     Anchor to top with center-alignment
    /// </summary>
    Top,
    /// <summary>
    ///     Anchor to top end
    /// </summary>
    TopEnd,
    /// <summary>
    ///     Anchor to left start
    /// </summary>
    LeftStart,
    /// <summary>
    /// Anchor to left middle
    /// </summary>
    Left,
    /// <summary>
    /// Anchor to left end
    /// </summary>
    LeftEnd,
    /// <summary>
    ///     Anchor to right start
    /// </summary>
    RightStart,
    /// <summary>
    /// Anchor to right middle
    /// </summary>
    Right,
    /// <summary>
    /// Anchor to right end
    /// </summary>
    RightEnd,
    /// <summary>
    ///     Anchor to bottom start
    /// </summary>
    BottomStart,
    /// <summary>
    ///     Anchor to bottom
    /// </summary>
    Bottom,
    /// <summary>
    ///     Anchor to bottom end
    /// </summary>
    BottomEnd
}
/// <summary>
///     Specifies the origin point for transformations.
/// </summary>
public enum OriginPoint
{
    /// <summary>
    ///     Origin at the center.
    /// </summary>
    OriginCenter,
    /// <summary>
    ///     Origin at the top.
    /// </summary>
    OriginTop,
    /// <summary>
    ///     Origin at the top-right.
    /// </summary>
    OriginTopRight,
    /// <summary>
    ///     Origin at the right.
    /// </summary>
    OriginRight,
    /// <summary>
    ///     Origin at the bottom-right.
    /// </summary>
    OriginBottomRight,
    /// <summary>
    ///     Origin at the bottom.
    /// </summary>
    OriginBottom,
    /// <summary>
    ///     Origin at the bottom-left.
    /// </summary>
    OriginBottomLeft,
    /// <summary>
    ///     Origin at the left.
    /// </summary>
    OriginLeft,
    /// <summary>
    ///     Origin at the top-left.
    /// </summary>
    OriginTopLeft
}
/// <summary>
///     Shape options for avatar components.
/// </summary>
public enum AvatarShape
{
    /// <summary>Circle-shaped avatar.</summary>
    Circle,
    /// <summary>Square-shaped avatar.</summary>
    Square
}
/// <summary>
///     Size options for modal components based on Tailwind's max-width utilities.
/// </summary>
[SuppressMessage("ReSharper", "InconsistentNaming")]
public enum ModalSize
{
    /// <summary>Extra small modal, max-width: 320px.</summary>
    ExtraSmall,
    /// <summary>Small modal, max-width: 384px.</summary>
    Small,
    /// <summary>Medium modal, max-width: 448px.</summary>
    Medium,
    /// <summary>Large modal, max-width: 512px.</summary>
    Large,
    /// <summary>Extra large modal, max-width: 576px.</summary>
    ExtraLarge,
    /// <summary>2XL modal, max-width: 672px.</summary>
    TwoXL,
    /// <summary>3XL modal, max-width: 768px.</summary>
    ThreeXL,
    /// <summary>4XL modal, max-width: 896px.</summary>
    FourXL,
    /// <summary>5XL modal, max-width: 1024px.</summary>
    FiveXL,
    /// <summary>6XL modal, max-width: 1152px.</summary>
    SixXL,
    /// <summary>7XL modal, max-width: 1280px.</summary>
    SevenXL
}
/// <summary>
///     SemanticColor options for components, including surface and status colors.
/// </summary>
public enum SemanticColor
{
    /// <summary>No specific semantic color is applied; typically inherits or uses a component default.</summary>
    None,
    /// <summary>General page background color (maps to --background in kitchen sink).</summary>
    Background,
    /// <summary>General page foreground/text color (maps to --foreground).</summary>
    Foreground,
    /// <summary>Background color for card components (maps to --card).</summary>
    Card,
    /// <summary>Foreground/text color for content on card components (maps to --card-foreground).</summary>
    CardForeground,
    /// <summary>Background color for popover components (maps to --popover).</summary>
    Popover,
    /// <summary>Foreground/text color for content on popover components (maps to --popover-foreground).</summary>
    PopoverForeground,
    /// <summary>Primary accent color, typically for interactive elements (maps to --primary).</summary>
    Primary,
    /// <summary>Foreground/text color for content on primary-colored elements (maps to --primary-foreground).</summary>
    PrimaryForeground,
    /// <summary>Secondary accent color (maps to --secondary).</summary>
    Secondary,
    /// <summary>Foreground/text color for content on secondary-colored elements (maps to --secondary-foreground).</summary>
    SecondaryForeground,
    /// <summary>Color for muted surfaces or backgrounds (maps to --muted).</summary>
    Muted,
    /// <summary>Foreground/text color for content on muted surfaces (maps to --muted-foreground).</summary>
    MutedForeground,
    /// <summary>Color for accented surfaces or backgrounds (maps to --accent).</summary>
    Accent,
    /// <summary>Foreground/text color for content on accented surfaces (maps to --accent-foreground).</summary>
    AccentForeground,
    /// <summary>Color for destructive actions or elements, indicating errors or critical operations (maps to --destructive).</summary>
    Destructive,
    /// <summary>Foreground/text color for content on destructive-colored elements (maps to an implied --destructive-foreground).</summary>
    DestructiveForeground,
    /// <summary>Color for borders (maps to --border).</summary>
    Border,
    /// <summary>Color for input backgrounds or borders (maps to --input).</summary>
    Input,
    /// <summary>Color for focus rings (maps to --ring).</summary>
    Ring,
    /// <summary>Informational color, often blue or neutral.</summary>
    Info,
    /// <summary>Foreground color on info background.</summary>
    InfoForeground,
    /// <summary>Warning color, often yellow for caution.</summary>
    Warning,
    /// <summary>Foreground color on warning background.</summary>
    WarningForeground,
    /// <summary>Success color, often green for positive feedback.</summary>
    Success,
    /// <summary>Foreground color on success background.</summary>
    SuccessForeground
}
/// <summary>
///     Accent color options for highlighting elements.
/// </summary>
public enum AccentColor
{
    /// <summary>Inherit accent color from parent context.</summary>
    Inherit,
    /// <summary>Gray accent color.</summary>
    Gray,
    /// <summary>Emerald green accent color.</summary>
    Emerald,
    /// <summary>Teal accent color.</summary>
    Teal,
    /// <summary>Blue accent color.</summary>
    Blue,
    /// <summary>Indigo accent color.</summary>
    Indigo,
    /// <summary>Purple accent color.</summary>
    Purple,
    /// <summary>Pink accent color.</summary>
    Pink,
    /// <summary>Red accent color.</summary>
    Red,
    /// <summary>Orange accent color.</summary>
    Orange,
    /// <summary>Yellow accent color.</summary>
    Yellow
}
/// <summary>
///     Defines the status color variants
/// </summary>
public enum StatusColor
{
    /// <summary>Primary status color.</summary>
    Primary,
    /// <summary>Secondary status color.</summary>
    Secondary,
    /// <summary>Success status color.</summary>
    Success,
    /// <summary>Info status color.</summary>
    Info,
    /// <summary>Warning status color.</summary>
    Warning,
    /// <summary>Destructive status color.</summary>
    Destructive
}
/// <summary>
///     Defines the label position options for the Progress component.
/// </summary>
public enum ProgressLabelPosition
{
    /// <summary>Label is positioned inside the progress bar.</summary>
    Inside,
    /// <summary>Label is positioned outside the progress bar.</summary>
    Outside
}
/// <summary>
/// Specifies the type of behavior for accordion components, determining whether single or multiple sections can be expanded simultaneously.
/// </summary>
public enum AccordionType
{
    /// <summary>
    /// An accordion type where only a single section can be expanded at a time.
    /// </summary>
    Single,
    /// <summary>
    /// Allows multiple sections of the accordion to be expanded at the same time.
    /// </summary>
    Multiple
}
/// <summary>
/// Specifies the visual variant of the sidebar.
/// </summary>
public enum SidebarVariant
{
    /// <summary>
    /// Default docked sidebar.
    /// </summary>
    Sidebar,
    /// <summary>
    /// Floating sidebar with a margin from the viewport edges.
    /// </summary>
    Floating,
    /// <summary>
    /// Inset sidebar where the main content flows around it.
    /// </summary>
    Inset
}
/// <summary>
/// Specifies the collapsible behavior of the sidebar.
/// </summary>
public enum SidebarCollapsible
{
    /// <summary>
    /// The sidebar slides off-canvas on mobile and can be collapsed on desktop.
    /// </summary>
    OffCanvas,
    /// <summary>
    /// The sidebar collapses to show only icons.
    /// </summary>
    Icon,
    /// <summary>
    /// The sidebar is not collapsible.
    /// </summary>
    None
}
/// <summary>
/// Specifies the side of the screen where the sidebar appears.
/// </summary>
public enum SidebarSide
{
    /// <summary>
    /// The sidebar appears on the left.
    /// </summary>
    Left,
    /// <summary>
    /// The sidebar appears on the right.
    /// </summary>
    Right
}
/// <summary>
/// Specifies the visual variant for a sidebar menu button.
/// </summary>
public enum SidebarMenuButtonVariant
{
    /// <summary>
    /// Default styling.
    /// </summary>
    Default,
    /// <summary>
    /// Outline styling.
    /// </summary>
    Outline
}
</file>

<file path="Constants.cs">
namespace RizzyUI;
/// <summary>
/// Contains constant values used throughout the RizzyUI library.
/// </summary>
public static class Constants
{
    /// <summary>
    /// Package name used for content resolution.
    /// </summary>
    public const string PackageName = "RizzyUI";
    /// <summary>
    /// Conventional name for RizzyLocalization override resource files provided by the consuming application.
    /// </summary>
    public const string RizzyLocalizationResourceName = "RizzyLocalization";
    /// <summary>
    /// Resolves path to internal package assets.
    /// </summary>
    /// <param name="path">The relative path within the package's wwwroot.</param>
    /// <returns>A URL path suitable for referencing package content (e.g., /_content/RizzyUI/js/rizzyui.js).</returns>
    public static string ContentUrl(string path)
    {
        // Ensure leading slash is removed if present, as ContentUrl assumes relative path from wwwroot
        path = path.TrimStart('/');
        return $"/_content/{PackageName}/{path}";
    }
    /// <summary>
    /// Contains constant definitions for custom JavaScript event names dispatched or listened to by RizzyUI components.
    /// Using these constants ensures consistency and avoids magic strings.
    /// </summary>
    public static class Events
    {
        /// <summary>
        /// Fired by RizzyUI immediately before Alpine initializes.
        /// </summary>
        public const string Initialize = "rz:init";
        /// <summary>
        /// The default event name that the RzDialog component listens for to trigger closing via external sources (e.g., HTMX HX-Trigger header).
        /// Can be overridden via the `CloseEventName` parameter on RzDialog.
        /// </summary>
        /// <remarks>Value: "rz:modal-close"</remarks>
        public const string DialogClose = "rz:dialog-close";
        /// <summary>
        /// Fired by the RzDialog Alpine component once during initialization, after its properties are set but before listeners are attached.
        /// Detail: `{ modalId: string, bodyId: string, footerId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-initialized"</remarks>
        public const string DialogInitialized = "rz:dialog-initialized";
        /// <summary>
        /// Fired by the RzDialog Alpine component just before the modal's `modalOpen` state is set to `true`. This event is cancelable.
        /// Detail: `{ modalId: string, originalEvent: Event | null }`
        /// </summary>
        /// <remarks>Value: "rz:modal-before-open"</remarks>
        public const string DialogBeforeOpen = "rz:dialog-before-open";
        /// <summary>
        /// Fired by the RzDialog Alpine component after the modal's `modalOpen` state is set to `true` and opening transitions are likely complete.
        /// Detail: `{ modalId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-after-open"</remarks>
        public const string DialogAfterOpen = "rz:dialog-after-open";
        /// <summary>
        /// Fired by the RzDialog Alpine component just before the modal's `modalOpen` state is set to `false`. This event is cancelable.
        /// Detail: `{ modalId: string, reason: 'escape' | 'backdrop' | 'button' | 'event' }`
        /// </summary>
        /// <remarks>Value: "rz:modal-before-close"</remarks>
        public const string DialogBeforeClose = "rz:dialog-before-close";
        /// <summary>
        /// Fired by the RzDialog Alpine component after the modal's `modalOpen` state is set to `false` and closing transitions are likely complete.
        /// Detail: `{ modalId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-after-close"</remarks>
        public const string DialogAfterClose = "rz:dialog-after-close";
    }
    /// <summary>
    /// Events specific to the RzCalendar component, mirroring Vanilla Calendar Pro actions.
    /// </summary>
    public static class CalendarEvents
    {
        /// <summary>Fired when the calendar initializes.</summary>
        public const string Init = "rz:calendar:init";
        /// <summary>Fired when the calendar is destroyed.</summary>
        public const string Destroy = "rz:calendar:destroy";
        /// <summary>Fired when a day is clicked.</summary>
        public const string ClickDay = "rz:calendar:clickDay";
        /// <summary>Fired when a week number is clicked.</summary>
        public const string ClickWeekNumber = "rz:calendar:clickWeekNumber";
        /// <summary>Fired when a month is clicked in the header.</summary>
        public const string ClickMonth = "rz:calendar:clickMonth";
        /// <summary>Fired when a year is clicked in the header.</summary>
        public const string ClickYear = "rz:calendar:clickYear";
        /// <summary>Fired when navigation arrows are clicked.</summary>
        public const string ClickArrow = "rz:calendar:clickArrow";
        /// <summary>Fired when time is changed.</summary>
        public const string ChangeTime = "rz:calendar:changeTime";
        /// <summary>Fired when the view changes (e.g. month switch).</summary>
        public const string ChangeView = "rz:calendar:changeView";
        /// <summary>Fired when dates are selected/deselected.</summary>
        public const string SelectDate = "rz:calendar:selectDate";
    }
}
</file>

<file path="Extensions/BlaziconsDataUriExtensions.cs">
using System;
using System.Text;
using Blazicons;
namespace RizzyUI;
/// <summary>
/// Extension methods for converting <see cref="SvgIcon"/> instances into string formats
/// that can be embedded directly in HTML, such as <c>data:</c> URIs.
/// </summary>
public static class BlaziconsDataUriExtensions
{
    /// <summary>
    /// Converts a <see cref="SvgIcon"/> into a Base64-encoded SVG <c>data:</c> URI string.
    /// </summary>
    /// <param name="icon">
    /// The icon to convert. The resulting data URI is based on the icon's rendered SVG markup
    /// (for example, after applying modifications such as size or color).
    /// </param>
    /// <returns>
    /// A string in the form <c>data:image/svg+xml;base64,&lt;base64&gt;</c> where the Base64 payload
    /// is the UTF-8 encoding of the icon's complete <c>&lt;svg&gt;...&lt;/svg&gt;</c> markup.
    /// </returns>
    /// <exception cref="ArgumentNullException">
    /// Thrown when <paramref name="icon"/> is <c>null</c>.
    /// </exception>
    /// <remarks>
    /// <para>
    /// The produced string is suitable for assignment to an <c>&lt;img src="..."&gt;</c> attribute
    /// or CSS properties that accept a URL value.
    /// </para>
    /// <para>
    /// This method Base64-encodes the SVG text to avoid issues with quoting and reserved characters
    /// that can arise when embedding raw SVG XML directly in a <c>data:</c> URI.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code language="csharp">
    /// var uri = MdiIcon.Information
    ///                 .WithColor("#0f172a")
    ///                 .ToSvgBase64DataUri();
    ///
    /// // e.g. &lt;img src="@uri" /&gt;
    /// </code>
    /// </example>
    public static string ToSvgBase64DataUri(this SvgIcon icon)
    {
        ArgumentNullException.ThrowIfNull(icon);
        var svgMarkup = icon.Markup.Trim();
        var bytes = Encoding.UTF8.GetBytes(svgMarkup);
        var base64 = Convert.ToBase64String(bytes);
        return $"data:image/svg+xml;base64,{base64}";
    }
}
</file>

<file path="Extensions/MarkdigExtensions.cs">
using Markdig;
using Markdig.Renderers;
using Markdig.Renderers.Html;
using Markdig.Renderers.Html.Inlines;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
namespace RizzyUI.Extensions;
/// <summary>
///     A Markdown extension that customizes the rendering of both block and inline code.
///     It ensures that all code tags include the "hljs" class, wraps fenced code blocks in a &lt;pre&gt; tag,
///     and renders inline code without a &lt;pre&gt; wrapper.
/// </summary>
public class RizzyCodeBlockExtension : IMarkdownExtension
{
    /// <summary>
    ///     Performs initial setup for the Markdown pipeline.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline builder.</param>
    public void Setup(MarkdownPipelineBuilder pipeline)
    {
        // No additional setup required.
    }
    /// <summary>
    ///     Configures the Markdown renderer to use custom renderers for code blocks and inline code.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline.</param>
    /// <param name="renderer">The Markdown renderer.</param>
    public void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer)
    {
        if (renderer is HtmlRenderer htmlRenderer)
        {
            // Remove and replace the existing CodeBlockRenderer.
            var originalCodeBlockRenderer = htmlRenderer.ObjectRenderers.FindExact<CodeBlockRenderer>();
            if (originalCodeBlockRenderer != null) htmlRenderer.ObjectRenderers.Remove(originalCodeBlockRenderer);
            htmlRenderer.ObjectRenderers.AddIfNotAlready(new RizzyCodeBlockRenderer(originalCodeBlockRenderer));
            // Remove and replace the existing CodeInlineRenderer.
            var originalCodeInlineRenderer = htmlRenderer.ObjectRenderers.FindExact<CodeInlineRenderer>();
            if (originalCodeInlineRenderer != null) htmlRenderer.ObjectRenderers.Remove(originalCodeInlineRenderer);
            htmlRenderer.ObjectRenderers.AddIfNotAlready(new RizzyCodeInlineRenderer(originalCodeInlineRenderer));
        }
    }
}
/// <summary>
///     A custom HTML renderer for Markdown code blocks that outputs them with the "hljs" class and an optional language
///     class.
///     Fenced code blocks are wrapped in &lt;pre&gt; tags, while non-fenced blocks are rendered with just a &lt;code&gt;
///     tag.
/// </summary>
public class RizzyCodeBlockRenderer : HtmlObjectRenderer<CodeBlock>
{
    private readonly CodeBlockRenderer? _originalRenderer;
    /// <summary>
    ///     Initializes a new instance of the <see cref="RizzyCodeBlockRenderer" /> class.
    /// </summary>
    /// <param name="originalRenderer">The original code block renderer, if any.</param>
    public RizzyCodeBlockRenderer(CodeBlockRenderer? originalRenderer = null)
    {
        _originalRenderer = originalRenderer;
    }
    /// <summary>
    ///     Writes the specified <see cref="CodeBlock" /> as HTML.
    /// </summary>
    /// <param name="renderer">The HTML renderer.</param>
    /// <param name="obj">The code block to render.</param>
    protected override void Write(HtmlRenderer renderer, CodeBlock obj)
    {
        // Build the base class attribute value with "hljs".
        var classes = "hljs";
        if (obj is FencedCodeBlock fencedCodeBlock)
        {
            var language = fencedCodeBlock.Info?.Trim() ?? string.Empty;
            if (!string.IsNullOrEmpty(language)) classes += $" language-{language}";
            // Write the opening tags for a fenced code block.
            renderer.Write("<pre><code");
            renderer.Write($" class=\"{classes}\"");
            renderer.Write(">");
        }
        else
        {
            // For non-fenced code blocks, only write the <code> tag.
            renderer.Write("<code");
            renderer.Write($" class=\"{classes}\"");
            renderer.Write(">");
        }
        // Write the content of the code block with HTML escaping.
        var content = obj.Lines.ToString();
        renderer.WriteEscape(content);
        // Write the closing tags.
        if (obj is FencedCodeBlock)
            renderer.Write("</code></pre>");
        else
            renderer.Write("</code>");
    }
}
/// <summary>
///     A custom HTML renderer for inline code that outputs code spans with the "hljs" class.
///     Inline code is rendered without a wrapping &lt;pre&gt; tag.
/// </summary>
public class RizzyCodeInlineRenderer : HtmlObjectRenderer<CodeInline>
{
    private readonly CodeInlineRenderer? _originalRenderer;
    /// <summary>
    ///     Initializes a new instance of the <see cref="RizzyCodeInlineRenderer" /> class.
    /// </summary>
    /// <param name="originalRenderer">The original inline code renderer, if any.</param>
    public RizzyCodeInlineRenderer(CodeInlineRenderer? originalRenderer = null)
    {
        _originalRenderer = originalRenderer;
    }
    /// <summary>
    ///     Writes the specified <see cref="CodeInline" /> as HTML.
    /// </summary>
    /// <param name="renderer">The HTML renderer.</param>
    /// <param name="obj">The inline code element to render.</param>
    protected override void Write(HtmlRenderer renderer, CodeInline obj)
    {
        renderer.Write("<code class=\"hljs\">");
        renderer.WriteEscape(obj.Content);
        renderer.Write("</code>");
    }
}
/// <summary>
///     Provides extension methods for <see cref="MarkdownPipelineBuilder" /> to add Rizzy syntax highlighting.
/// </summary>
public static class MarkdownPipelineBuilderExtensions
{
    /// <summary>
    ///     Adds the Rizzy syntax highlighting extension to the Markdown pipeline.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline builder.</param>
    /// <returns>The updated Markdown pipeline builder.</returns>
    public static MarkdownPipelineBuilder UseRizzySyntaxHighlighting(this MarkdownPipelineBuilder pipeline)
    {
        pipeline.Extensions.Add(new RizzyCodeBlockExtension());
        return pipeline;
    }
}
</file>

<file path="Extensions/ServiceCollectionExtensions.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
using RizzyUI.Localization;
using TailwindMerge.Extensions;
namespace RizzyUI;
/// <summary>
/// Provides extension methods for registering RizzyUI services with the dependency injection container.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds RizzyUI services to the specified <see cref="IServiceCollection"/> and configures RizzyUI options.
    /// </summary>
    /// <param name="services">The <see cref="IServiceCollection"/> to add services to.</param>
    /// <param name="configure">An action delegate to configure the <see cref="RizzyUIConfig"/>.</param>
    /// <returns>The <see cref="IServiceCollection"/> so that additional calls can be chained.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="configure"/> is null.</exception>
    public static IServiceCollection AddRizzyUI(this IServiceCollection services, Action<RizzyUIConfig> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);
        // Register IOptions<RizzyUIConfig> and apply the user's configuration.
        services.Configure(configure);
        // Call the internal method that performs the actual service registration.
        return services.AddRizzyUIInternal();
    }
    /// <summary>
    /// Adds RizzyUI services to the specified <see cref="IServiceCollection"/> with default options.
    /// </summary>
    /// <param name="services">The <see cref="IServiceCollection"/> to add services to.</param>
    /// <returns>The <see cref="IServiceCollection"/> so that additional calls can be chained.</returns>
    public static IServiceCollection AddRizzyUI(this IServiceCollection services)
    {
        // Ensure IOptions infrastructure is registered even if no specific configuration is provided.
        services.Configure<RizzyUIConfig>(config => { });
        return services.AddRizzyUIInternal();
    }
    /// <summary>
    /// Internal helper method containing the core service registrations for RizzyUI.
    /// Sets up TailwindMerge, HTTP context access, nonce provider, and localization.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection.</returns>
    // ReSharper disable once InconsistentNaming
    private static IServiceCollection AddRizzyUIInternal(this IServiceCollection services)
    {
        // Register core dependencies used by RizzyUI.
        services.AddTailwindVariants(); // Add TailwindVariants.NET service
        services.AddTailwindMerge();
        services.AddHttpContextAccessor();
        services.TryAddScoped<IRizzyNonceProvider, RizzyNonceProvider>();
        // Post-configure the options to ensure the default theme is always available.
        // This runs after any user-provided `configure` action.
        services.PostConfigure<RizzyUIConfig>(config =>
        {
            // Check if a theme with the same code as the default already exists.
            if (config.AvailableThemes.All(t => t.ThemeCode != config.DefaultTheme.ThemeCode))
            {
                // Add the default theme to the beginning of the list if it's not already there.
                config.AvailableThemes.Insert(0, config.DefaultTheme);
            }
            config.AvailableThemes.Add(RzTheme.VercelTheme);
            // Add default asset URLs, allowing users to override them.
            config.AssetUrls.TryAdd("EmblaCore", "https://cdn.jsdelivr.net/npm/embla-carousel@8.1.7/embla-carousel.umd.js");
            config.AssetUrls.TryAdd("EmblaAutoplay", "https://cdn.jsdelivr.net/npm/embla-carousel-autoplay@8.1.7/embla-carousel-autoplay.umd.js");
            config.AssetUrls.TryAdd("EmblaAutoScroll", "https://cdn.jsdelivr.net/npm/embla-carousel-auto-scroll@8.1.7/embla-carousel-auto-scroll.umd.js");
            config.AssetUrls.TryAdd("EmblaAutoHeight", "https://cdn.jsdelivr.net/npm/embla-carousel-auto-height@8.1.7/embla-carousel-auto-height.umd.js");
            config.AssetUrls.TryAdd("EmblaClassNames", "https://cdn.jsdelivr.net/npm/embla-carousel-class-names@8.1.7/embla-carousel-class-names.umd.js");
            config.AssetUrls.TryAdd("EmblaFade", "https://cdn.jsdelivr.net/npm/embla-carousel-fade@8.1.7/embla-carousel-fade.umd.js");
            config.AssetUrls.TryAdd("EmblaWheelGestures", "https://cdn.jsdelivr.net/npm/embla-carousel-wheel-gestures@8.1.7/embla-carousel-wheel-gestures.umd.js");
            config.AssetUrls.TryAdd("HighlightJsCore", Constants.ContentUrl("vendor/highlightjs/highlight.js"));
            config.AssetUrls.TryAdd("HighlightJsRazor", Constants.ContentUrl("js/lib/highlightjs-plugin/cshtml-razor.min.js"));
            config.AssetUrls.TryAdd("FlatpickrCore", "https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.js");
            config.AssetUrls.TryAdd("TomSelect", "https://cdn.jsdelivr.net/npm/tom-select@2.4.1/dist/js/tom-select.complete.min.js");
            config.AssetUrls.TryAdd("VanillaCalendarPro", "https://cdn.jsdelivr.net/npm/vanilla-calendar-pro/index.js");
            config.AssetUrls.TryAdd("VanillaCalendarCss", "https://cdn.jsdelivr.net/npm/vanilla-calendar-pro/styles/index.css");            
        });
        // --- Localization Setup ---
        bool localizationFactoryRegistered = services.Any(d => d.ServiceType == typeof(IStringLocalizerFactory));
        if (localizationFactoryRegistered)
        {
            // Decorate the existing factory IF localization is configured.
            services.Decorate<IStringLocalizerFactory>((innerFactory, sp) =>
            {
                var config = sp.GetRequiredService<IOptions<RizzyUIConfig>>().Value;
                // Pass the original factory, the service provider, and override config.
                return new RizzyStringLocalizerFactory(
                    innerFactory,
                    sp, // Provide IServiceProvider
                    config.LocalizationResourceType,
                    config.LocalizationResourceLocation
                );
            });
        }
        else
        {
            // If no factory registered, register the dummy for RizzyUI's needs.
            services.TryAddSingleton<IStringLocalizer<RizzyLocalization>, DummyRizzyStringLocalizer>();
        }
        return services;
    }
}
</file>

<file path="Extensions/StringExtensions.cs">
using System.Globalization;
using System.Text;
namespace RizzyUI.Extensions;
/// <summary>
/// Provides extension methods for string manipulation.
/// </summary>
internal static class StringExtensions
{
    private static readonly Random _random = new(Environment.TickCount);
    /// <summary>
    ///     Removes the minimum shared run of leading whitespace characters
    ///     (spaces, tabs, etc.) from each non-empty line in the given text.
    /// </summary>
    /// <param name="text">Multi-line string input.</param>
    /// <returns>
    ///     A new string with each non-empty line outdented by the
    ///     minimal number of leading whitespace characters found.
    /// </returns>
    public static string Outdent(this string text)
    {
        // Early exit for null or empty input
        if (string.IsNullOrEmpty(text))
            return text;
        // Split the input text into lines, preserving empty lines
        var lines = text.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        var minLeadingWhitespace = int.MaxValue;
        // 1st pass: Determine the minimum number of consecutive leading whitespace chars on non-whitespace lines
        foreach (var line in lines)
        {
            // Skip lines that are blank or entirely whitespace
            if (string.IsNullOrWhiteSpace(line))
                continue;
            var count = 0;
            while (count < line.Length && char.IsWhiteSpace(line[count])) count++;
            if (count < minLeadingWhitespace)
            {
                minLeadingWhitespace = count;
                if (minLeadingWhitespace == 0)
                    // Can't do better than zero; break early
                    break;
            }
        }
        // If no non-whitespace lines were found, or minLeadingWhitespace is zero, no outdent needed
        if (minLeadingWhitespace == int.MaxValue || minLeadingWhitespace == 0)
            return text;
        // 2nd pass: Build a new string with the computed leading whitespace removed
        var sb = new StringBuilder(text.Length);
        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            if (string.IsNullOrEmpty(line))
            {
                // Preserve blank lines as-is (including whitespace-only lines)
                sb.AppendLine(line);
            }
            else
            {
                // Remove exactly minLeadingWhitespace characters from the start,
                // or use an empty string if the line is shorter.
                var outdentedLine = line.Length >= minLeadingWhitespace
                    ? line.Substring(minLeadingWhitespace)
                    : string.Empty;
                sb.AppendLine(outdentedLine);
            }
        }
        // Optionally remove the final newline if you prefer not to have one
        if (sb.Length > 0 && sb[sb.Length - 1] == '\n')
        {
            sb.Length--;
            // If the preceding char is '\r', remove that too
            if (sb.Length > 0 && sb[sb.Length - 1] == '\r')
                sb.Length--;
        }
        return sb.ToString();
    }
    /// <summary>
    ///     Shuffle the characters in a string
    /// </summary>
    /// <param name="input">The input string.</param>
    /// <returns>A new string with the characters shuffled.</returns>
    public static string Shuffle(this string input)
    {
        return new string(input.ToCharArray()
            .OrderBy(x => _random.Next())
            .ToArray());
    }
    /// <summary>
    /// Trims empty lines from the beginning and end of a multi-line string.
    /// </summary>
    /// <param name="input">The input string.</param>
    /// <returns>A new string with leading and trailing empty lines removed.</returns>
    public static string TrimEmptyLines(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;
        // Split the string into lines
        var lines = input.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
        // Find the first non-empty line
        var start = 0;
        while (start < lines.Length && string.IsNullOrWhiteSpace(lines[start])) start++;
        // Find the last non-empty line
        var end = lines.Length - 1;
        while (end >= start && string.IsNullOrWhiteSpace(lines[end])) end--;
        // Join the lines back together, trimming the empty ones
        return string.Join(Environment.NewLine, lines[start..(end + 1)]);
    }
    /// <summary>
    /// Converts any delimited string (hyphens, underscores, spaces, etc.)
    /// into a space-separated Title Case string.
    /// <para>Examples:</para>
    /// <list type="bullet">
    ///   <item><description><c>"amber-vanilla".ToTitleCase()</c>  <c>"Amber Vanilla"</c></description></item>
    ///   <item><description><c>"amber_vanilla".ToTitleCase()</c>  <c>"Amber Vanilla"</c></description></item>
    ///   <item><description><c>"amber vanilla".ToTitleCase()</c>  <c>"Amber Vanilla"</c></description></item>
    /// </list>
    /// </summary>
    /// <param name="source">The original string.</param>
    /// <returns>Title-cased version, or the original string if its null/white-space.</returns>
    public static string ToTitleCase(this string? source)
    {
        if (string.IsNullOrWhiteSpace(source))
            return source ?? string.Empty;
        // Treat hyphens, underscores, and whitespace as word boundaries.
        char[] delimiters = ['-', '_', ' '];
        var textInfo = CultureInfo.CurrentCulture.TextInfo;
        return string.Join(' ',
            source
                .Split(delimiters, StringSplitOptions.RemoveEmptyEntries)
                .Select(w => textInfo.ToTitleCase(w.Trim())));
    }
    /// <summary>
    /// Converts a string to kebab-case, with words separated by hyphens.
    /// </summary>
    /// <param name="text">The input string to be converted to kebab-case.</param>
    /// <returns>A kebab-case representation of the input string.</returns>
    public static string ToKebabCase(this string text)
    {
        // Return the input text if it's null or empty
        if (string.IsNullOrEmpty(text)) return text;
        // Initialize a StringBuilder to store the result
        StringBuilder result = new();
        // Define a flag to track whether the previous character is a separator
        bool previousCharacterIsSeparator = true;
        // Iterate through each character in the input text
        for (int i = 0; i < text.Length; i++)
        {
            char currentChar = text[i];
            // If the current character is an uppercase letter or a digit
            if (char.IsUpper(currentChar) || char.IsDigit(currentChar))
            {
                // Add a hyphen if the previous character is not a separator and
                // the current character is preceded by a lowercase letter or followed by a lowercase letter
                if (!previousCharacterIsSeparator && (i > 0 && (char.IsLower(text[i - 1]) || (i < text.Length - 1 && char.IsLower(text[i + 1])))))
                {
                    result.Append("-");
                }
                // Append the lowercase version of the current character to the result
                result.Append(char.ToLowerInvariant(currentChar));
                // Update the flag to indicate that the current character is not a separator
                previousCharacterIsSeparator = false;
            }
            // If the current character is a lowercase letter
            else if (char.IsLower(currentChar))
            {
                // Append the current character to the result
                result.Append(currentChar);
                // Update the flag to indicate that the current character is not a separator
                previousCharacterIsSeparator = false;
            }
            // If the current character is a space, underscore, or hyphen
            else if (currentChar == ' ' || currentChar == '_' || currentChar == '-')
            {
                // Add a hyphen if the previous character is not a separator
                if (!previousCharacterIsSeparator)
                {
                    result.Append("-");
                }
                // Update the flag to indicate that the current character is a separator
                previousCharacterIsSeparator = true;
            }
        }
        // Return the kebab-case representation of the input string
        return result.ToString();
    }
}
</file>

<file path="Extensions/TwMergeExtensions.cs">
using System.Globalization;
using TailwindMerge;
namespace RizzyUI.Extensions;
/// <summary>
/// Provides extension methods for the <see cref="TwMerge"/> service.
/// </summary>
internal static class TwMergeExtensions
{
    /// <summary>
    /// Merges CSS class strings, including a class from additional attributes.
    /// </summary>
    /// <param name="twMerge">The TwMerge instance.</param>
    /// <param name="additionalAttributes">A dictionary of additional attributes, which may contain a 'class' key.</param>
    /// <param name="classNames">An array of class strings to merge.</param>
    /// <returns>A merged string of Tailwind CSS classes.</returns>
    public static string? Merge(this TwMerge twMerge, IReadOnlyDictionary<string, object>? additionalAttributes,
        params string[] classNames)
    {
        if (additionalAttributes is null || !additionalAttributes.TryGetValue("class", out var @class))
            return classNames.Length == 1 ? classNames[0] : twMerge.Merge(classNames);
        var classAttributeValue = Convert.ToString(@class, CultureInfo.InvariantCulture);
        if (string.IsNullOrEmpty(classAttributeValue))
            return classNames.Length == 1 ? classNames[0] : twMerge.Merge(classNames);
        if (classNames.Length == 0) return classAttributeValue;
        return twMerge.Merge([.. classNames, classAttributeValue]) ?? string.Empty;
    }
}
</file>

<file path="GlobalSuppressions.cs">
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.
[assembly:
    SuppressMessage("Style", "IDE0130:Namespace does not match folder structure", Justification = "<Pending>",
        Scope = "namespace", Target = "~N:RizzyUI")]
</file>

<file path="GlobalUsings.cs">
// Global using directives
global using Rizzy;
</file>

<file path="Localization/DummyRizzyStringLocalizer.cs">
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging; // Required for ILogger
namespace RizzyUI.Localization;
/// <summary>
/// A dummy implementation of <see cref="IStringLocalizer{T}"/> for <see cref="RizzyLocalization"/>.
/// This is registered as a fallback when the consuming application has not configured
/// standard ASP.NET Core localization services. It returns the requested resource key
/// as the localized value and logs a warning upon creation.
/// </summary>
internal sealed class DummyRizzyStringLocalizer : IStringLocalizer<RizzyLocalization>
{
    private readonly ILogger<DummyRizzyStringLocalizer> _logger;
    /// <summary>
    /// Initializes a new instance of the <see cref="DummyRizzyStringLocalizer"/> class
    /// and logs a warning indicating that localization services are missing.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    public DummyRizzyStringLocalizer(ILogger<DummyRizzyStringLocalizer> logger)
    {
        _logger = logger;
        // Log the warning only once when this dummy localizer is instantiated.
        _logger.LogWarning("RizzyUI: ASP.NET Core Localization services (AddLocalization) were not detected or IStringLocalizerFactory is missing. RizzyUI components will display resource keys instead of localized text. Configure localization in Program.cs to enable translations.");
    }
    /// <summary>
    /// Returns a <see cref="LocalizedString"/> where the value is the resource key itself,
    /// indicating that the resource was not found because localization is not configured.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <returns>A <see cref="LocalizedString"/> with the key as the value and ResourceNotFound set to true.</returns>
    public LocalizedString this[string name] =>
        // Return the key itself as the value, marking it as not found.
        new(name, name, resourceNotFound: true);
    /// <summary>
    /// Returns a formatted <see cref="LocalizedString"/> where the value is the resource key itself,
    /// indicating that the resource was not found because localization is not configured.
    /// Formatting arguments are ignored as there is no format string.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <param name="arguments">The formatting arguments (ignored).</param>
    /// <returns>A <see cref="LocalizedString"/> with the key as the value and ResourceNotFound set to true.</returns>
    public LocalizedString this[string name, params object[] arguments] =>
        // Return the key itself, arguments are ignored as there's no format string.
        new(name, name, resourceNotFound: true);
    /// <summary>
    /// Returns an empty enumeration, as no localized strings are available
    /// when using this dummy implementation.
    /// </summary>
    /// <param name="includeParentCultures">This parameter is ignored.</param>
    /// <returns>An empty <see cref="IEnumerable{LocalizedString}"/>.</returns>
    public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures)
    {
        // No strings are technically "found" in this dummy implementation.
        return [];
    }
}
</file>

<file path="Localization/RizzyStringLocalizer.cs">
using Microsoft.Extensions.Localization;
using System.Globalization;
namespace RizzyUI.Localization;
/// <summary>
/// Implements <see cref="IStringLocalizer{T}"/> for <see cref="RizzyLocalization"/> by first attempting
/// to find a localized string in the resources provided by the consuming application (override resources),
/// and if not found (or if the override only returned the key), falling back to the default resources
/// embedded within the RizzyUI library.
/// </summary>
/// <remarks>
/// This enables users of the RizzyUI library to override default translations or provide
/// translations for cultures not directly supported by the library. The correct culture is
/// determined by the ambient <see cref="CultureInfo.CurrentUICulture"/>.
/// </remarks>
internal sealed class RizzyStringLocalizer : IStringLocalizer<RizzyLocalization>, IStringLocalizer
{
    private readonly IStringLocalizer _applicationOverrideLocalizer;
    private readonly IStringLocalizer _rizzyLocalizer;
    /// <summary>
    /// Initializes a new instance of the <see cref="RizzyStringLocalizer"/> class.
    /// </summary>
    /// <param name="applicationOverrideLocalizer">The string localizer for the application's override resources (or a dummy if none configured).</param>
    /// <param name="rizzyLocalizer">The string localizer for RizzyUI's default embedded resources.</param>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="applicationOverrideLocalizer"/> or <paramref name="rizzyLocalizer"/> is null.</exception>
    public RizzyStringLocalizer(
        IStringLocalizer applicationOverrideLocalizer,
        IStringLocalizer rizzyLocalizer)
    {
        _applicationOverrideLocalizer = applicationOverrideLocalizer ?? throw new ArgumentNullException(nameof(applicationOverrideLocalizer));
        _rizzyLocalizer = rizzyLocalizer ?? throw new ArgumentNullException(nameof(rizzyLocalizer));
    }
    /// <summary>
    /// Gets the localized string for the specified name.
    /// It checks the application's override localizer first. If the resource is found there
    /// (and the value is not just the key itself), it returns the application's value.
    /// Otherwise, it falls back to RizzyUI's default embedded localizer.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <returns>The localized string.</returns>
    public LocalizedString this[string name]
    {
        get
        {
            var appString = _applicationOverrideLocalizer[name];
            // Check if the resource was truly found in the application override
            // Some localizers might return the key if not found, so check both flags.
            if (!appString.ResourceNotFound || !appString.Value.Equals(name, StringComparison.Ordinal))
            {
                return appString;
            }
            // Fallback to the library's default localizer
            return _rizzyLocalizer[name];
        }
    }
    /// <summary>
    /// Gets the formatted localized string for the specified name.
    /// It checks the application's override localizer first. If the resource is found there
    /// (and the value is not just the key itself), it returns the application's formatted value.
    /// Otherwise, it falls back to RizzyUI's default embedded localizer for formatting.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <param name="arguments">The values to format the string with.</param>
    /// <returns>The formatted localized string.</returns>
    public LocalizedString this[string name, params object[] arguments]
    {
        get
        {
            var appString = _applicationOverrideLocalizer[name, arguments];
            if (!appString.ResourceNotFound || !appString.Value.Equals(name, StringComparison.Ordinal))
            {
                return appString;
            }
            // Fallback to the library's default localizer for formatting
            return _rizzyLocalizer[name, arguments];
        }
    }
    /// <summary>
    /// Gets all localized strings for the current UI culture, merging application overrides with
    /// RizzyUI's default embedded resources. Application strings take precedence if keys conflict
    /// and the application resource was actually found (not just the key returned).
    /// </summary>
    /// <param name="includeParentCultures">Flag indicating whether strings from parent cultures should be included.</param>
    /// <returns>A collection of localized strings, with application overrides taking precedence.</returns>
    public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures)
    {
        // Start with RizzyUI's default strings as the base.
        var mergedStrings = _rizzyLocalizer.GetAllStrings(includeParentCultures)
                               .ToDictionary(ls => ls.Name, ls => ls);
        // Get application strings and merge/overwrite entries in the dictionary.
        var appStrings = _applicationOverrideLocalizer.GetAllStrings(includeParentCultures);
        foreach (var appString in appStrings)
        {
            // Only overwrite if the application resource was truly found
            if (!appString.ResourceNotFound || !appString.Value.Equals(appString.Name, StringComparison.Ordinal))
            {
                mergedStrings[appString.Name] = appString; // Overwrites library string if key exists
            }
        }
        return mergedStrings.Values;
    }
}
</file>

<file path="Localization/RizzyStringLocalizerFactory.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RizzyUI.Localization;
namespace RizzyUI;
/// <summary>
/// A custom <see cref="IStringLocalizerFactory"/> implementation that decorates the
/// default ASP.NET Core factory. When creating a localizer for <see cref="RizzyLocalization"/>,
/// it ensures the library's embedded resources are found correctly, independent of the
/// application's `LocalizationOptions.ResourcesPath`, while still allowing application overrides
/// that *do* respect the application's configuration. It caches the library-specific localizer
/// for performance.
/// </summary>
internal sealed class RizzyStringLocalizerFactory : IStringLocalizerFactory
{
    private readonly IStringLocalizerFactory _originalFactory;
    private readonly IServiceProvider _serviceProvider; // Needed to create a separate factory instance
    private readonly Type? _localizationResourceType;
    private readonly string? _localizationResourceLocation;
    // Replace the field and lock with a Lazy<T> instance
    private readonly Lazy<IStringLocalizer> _cachedLibraryLocalizer;
    /// <summary>
    /// Initializes a new instance of the <see cref="RizzyStringLocalizerFactory"/> class.
    /// </summary>
    /// <param name="originalFactory">The original <see cref="IStringLocalizerFactory"/> being decorated.</param>
    /// <param name="serviceProvider">The service provider to resolve dependencies for creating a default factory.</param>
    /// <param name="localizationResourceType">The application-provided marker type for override resources (optional).</param>
    /// <param name="localizationResourceLocation">The application-provided location for override resources (optional).</param>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="originalFactory"/> or <paramref name="serviceProvider"/> is null.</exception>
    public RizzyStringLocalizerFactory(
        IStringLocalizerFactory originalFactory,
        IServiceProvider serviceProvider,
        Type? localizationResourceType,
        string? localizationResourceLocation)
    {
        _originalFactory = originalFactory ?? throw new ArgumentNullException(nameof(originalFactory));
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _localizationResourceType = localizationResourceType;
        _localizationResourceLocation = localizationResourceLocation;
        // Initialize the lazy field with a factory delegate
        _cachedLibraryLocalizer = new Lazy<IStringLocalizer>(CreateLibraryLocalizer, LazyThreadSafetyMode.ExecutionAndPublication);
    }
    /// <summary>
    /// Creates an <see cref="IStringLocalizer"/> using the specified resource source type.
    /// If the type is <see cref="RizzyLocalization"/>, it returns a composite
    /// <see cref="RizzyStringLocalizer"/>. Otherwise, it delegates to the original factory.
    /// </summary>
    /// <param name="resourceSource">The <see cref="Type"/> to create a localizer for.</param>
    /// <returns>An appropriate <see cref="IStringLocalizer"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="resourceSource"/> is null.</exception>
    public IStringLocalizer Create(Type resourceSource)
    {
        ArgumentNullException.ThrowIfNull(resourceSource);
        if (resourceSource == typeof(RizzyLocalization))
        {
            // --- Get/Create the library localizer (cached) ---
            // This uses a separate factory instance with default options to ensure
            // RizzyUI's embedded resources are found regardless of app settings.
            var libraryLocalizer = GetOrCreateLibraryLocalizer();
            // --- Create the application override localizer (respects app config) ---
            // This uses the original factory passed in, so it honors the app's LocalizationOptions.
            IStringLocalizer appOverrideLocalizer = CreateAppOverrideLocalizer();
            // Return the composite localizer that handles the fallback logic.
            return new RizzyStringLocalizer(appOverrideLocalizer, libraryLocalizer);
        }
        // For any other type request, delegate directly to the original factory.
        return _originalFactory.Create(resourceSource);
    }
    /// <summary>
    /// Creates an <see cref="IStringLocalizer"/> using the specified base name and location.
    /// Delegates directly to the original factory.
    /// </summary>
    /// <param name="baseName">The base name of the resource.</param>
    /// <param name="location">The location (assembly name) to search for the resource.</param>
    /// <returns>An <see cref="IStringLocalizer"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="baseName"/> or <paramref name="location"/> is null.</exception>
    public IStringLocalizer Create(string baseName, string location)
    {
        ArgumentNullException.ThrowIfNull(baseName);
        ArgumentNullException.ThrowIfNull(location);
        return _originalFactory.Create(baseName, location);
    }
    /// <summary>
    /// Gets the cached library-specific localizer, lazily initialized in a thread-safe manner.
    /// </summary>
    /// <returns>The <see cref="IStringLocalizer"/> for RizzyUI's internal resources.</returns>
    private IStringLocalizer GetOrCreateLibraryLocalizer()
    {
        return _cachedLibraryLocalizer.Value;
    }
    /// <summary>
    /// Creates the library-specific localizer.
    /// </summary>
    /// <returns>A new <see cref="IStringLocalizer"/> for RizzyUI's internal resources.</returns>
    private IStringLocalizer CreateLibraryLocalizer()
    {
        // Resolve dependencies needed to create a default factory instance
        var loggerFactory = _serviceProvider.GetRequiredService<ILoggerFactory>();
        // Use default (empty) LocalizationOptions to ignore app's ResourcesPath
        var defaultLocalizationOptions = Options.Create(new LocalizationOptions() { ResourcesPath = "Resources" });
        // Instantiate the default Microsoft factory directly
        var librarySpecificFactory = new ResourceManagerStringLocalizerFactory(defaultLocalizationOptions, loggerFactory);
        // Create the localizer using the type marker, ensuring it finds embedded resources
        return librarySpecificFactory.Create(typeof(RizzyLocalization));
    }
    /// <summary>
    /// Creates the localizer for the application's override resources using the original factory.
    /// </summary>
    /// <returns>An <see cref="IStringLocalizer"/> for overrides, or a dummy if not configured.</returns>
    private IStringLocalizer CreateAppOverrideLocalizer()
    {
        if (_localizationResourceType != null)
        {
            // Use the type provided by the application config
            return _originalFactory.Create(_localizationResourceType);
        }
        if (!string.IsNullOrEmpty(_localizationResourceLocation))
        {
            // Use the location and convention name provided by the application config
            return _originalFactory.Create(Constants.RizzyLocalizationResourceName, _localizationResourceLocation);
        }
        // No override config provided, return the dummy instance
        return DummyLocalizer.Instance;
    }
    /// <summary>
    /// A private dummy localizer used when no application overrides are configured.
    /// </summary>
    private sealed class DummyLocalizer : IStringLocalizer
    {
        /// <summary>
        /// Gets the singleton instance of the dummy localizer.
        /// </summary>
        public static readonly DummyLocalizer Instance = new();
        // Private constructor to prevent external instantiation.
        private DummyLocalizer() { }
        /// <inheritdoc />
        public LocalizedString this[string name] => new(name, name, resourceNotFound: true);
        /// <inheritdoc />
        public LocalizedString this[string name, params object[] arguments] => new(name, name, resourceNotFound: true);
        /// <inheritdoc />
        public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures) => [];
    }
}
</file>

<file path="RizzyLocalization.cs">
using Microsoft.Extensions.Localization; // Added for xmldoc reference
namespace RizzyUI;
/// <summary>
/// An empty marker class used by <see cref="IStringLocalizer{T}"/>
/// to identify and locate RizzyUI's embedded resource files (.resx) named following the
/// convention `RizzyLocalization.{culture}.resx`.
/// This allows the library to manage its own default translations independently.
/// </summary>
/// <remarks>
/// This class is intentionally left empty. Its sole purpose is to serve as a type marker
/// for the localization system. Resource files should be named matching this class name
/// (e.g., RizzyLocalization.resx, RizzyLocalization.es.resx).
/// </remarks>
public sealed class RizzyLocalization
{
    // Intentionally empty.
}
</file>

<file path="RizzyUIConfig.cs">
namespace RizzyUI;
/// <summary>
/// Provides configuration options for the RizzyUI library.
/// </summary>
public sealed class RizzyUIConfig
{
    /// <summary>
    /// Gets or sets a dictionary of logical asset names to their CDN or local URLs.
    /// This allows for central management and user overrides of component dependencies.
    /// </summary>
    public Dictionary<string, string> AssetUrls { get; set; } = new();
    /// <summary>
    /// Gets or sets the default theme to be used by RizzyUI components if no theme is
    /// explicitly provided via <see cref="RzThemeProvider"/>.
    /// Defaults to <see cref="RzTheme.ArcticTheme"/>.
    /// </summary>
    public RzTheme DefaultTheme { get; set; } = RzTheme.Default;
    /// <summary>
    /// Gets or sets the list of available themes that can be used within the application.
    /// This list can be populated during startup using the <see cref="ThemeLoader"/> or by adding themes manually.
    /// </summary>
    public List<RzTheme> AvailableThemes { get; set; } = new();
    /// <summary>
    /// Gets or sets the marker <see cref="Type"/> used by the consuming application to identify
    /// its resource files (.resx) intended for overriding or augmenting RizzyUI's default translations.
    /// The resource files associated with this type should follow the naming convention `RizzyLocalization.{culture}.resx`.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If this property is set, RizzyUI's localization system will first look for translations
    /// within the application's resources associated with this type. If a key (e.g., "RzButton.AssistiveLabelDefault")
    /// is found, that translation will be used. If not found, it will fall back to RizzyUI's
    /// embedded default translation (found in `RizzyLocalization.resx` within the library).
    /// </para>
    /// <para>
    /// This allows users to customize RizzyUI component text or provide translations for languages
    /// not included in the library.
    /// </para>
    /// <para>
    /// This requires standard ASP.NET Core localization services (<c>AddLocalization</c>, <c>UseRequestLocalization</c>)
    /// to be configured in the consuming application's <c>Program.cs</c>.
    /// </para>
    /// <para>
    /// If both <see cref="LocalizationResourceType"/> and <see cref="LocalizationResourceLocation"/> are set,
    /// <see cref="LocalizationResourceType"/> takes precedence.
    /// </para>
    /// <example>
    /// In Program.cs:
    /// <code>
    /// builder.Services.AddRizzyUI(config =>
    /// {
    ///     // Assumes a marker type exists in the consuming app:
    ///     // namespace MyWebApp.Localization { public class RizzyOverrides { } }
    ///     config.LocalizationResourceType = typeof(MyWebApp.Localization.RizzyOverrides);
    /// });
    /// </code>
    /// The application would then provide `Resources/MyWebApp.Localization.RizzyOverrides.es.resx`
    /// containing keys like `RzButton.AssistiveLabelDefault`.
    /// </example>
    /// </remarks>
    public Type? LocalizationResourceType { get; set; }
    /// <summary>
    /// Gets or sets the resource location (typically the assembly name or root namespace) where the
    /// consuming application stores its RizzyUI override resource files.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Use this property if you don't have a specific marker <see cref="Type"/> for your override resources,
    /// but you follow the convention of naming the resource files <c>RizzyLocalization.resx</c>,
    /// <c>RizzyLocalization.es.resx</c>, etc., and place them within a designated location
    /// (e.g., a "Resources" folder within your application's project structure).
    /// </para>
    /// <para>
    /// The value should typically be the root namespace or assembly name where the resources reside,
    /// matching the configuration used in <c>AddLocalization</c>. The localization system will look
    /// for resources named `RizzyLocalization` within this location.
    /// </para>
    /// <para>
    /// <see cref="LocalizationResourceType"/> takes precedence if both are configured.
    /// </para>
    /// <para>
    /// Requires standard ASP.NET Core localization services to be configured.
    /// </para>
    /// <example>
    /// In Program.cs:
    /// <code>
    /// // Assuming override files are in WebApp/Resources/RizzyLocalization.resx
    /// builder.Services.AddLocalization(options => options.ResourcesPath = "Resources");
    /// builder.Services.AddRizzyUI(config =>
    /// {
    ///     config.LocalizationResourceLocation = "WebApp"; // Root namespace of the application
    /// });
    /// </code>
    /// </example>
    /// </remarks>
    public string? LocalizationResourceLocation { get; set; }
}
</file>

<file path="RzAsChildComponent.CloneFragment.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.RenderTree;
using RizzyUI.Utility.Parser;
namespace RizzyUI;
/// <content>
///  This partial file adds the `CloneFragment` helper to <see cref="RzComponent"/>.
/// </content>
[SuppressMessage("Usage", "BL0006:Do not use RenderTree types")]
[SuppressMessage("Usage", "ASP0006:Do not use non-literal sequence numbers")]
public abstract partial class RzAsChildComponent : RzComponent
{
    /// <summary>
    /// Clones a <paramref name="fragment"/> that is expected to have &lt;b&gt;exactly one&lt;/b&gt;
    /// root (either a DOM element or a component) and returns a new <see cref="RenderFragment"/>
    /// in which the root node is patched with the supplied <paramref name="attributes"/>.
    /// <list type="bullet">
    /// <item>
    ///     <description>
    ///     Attributes already defined in the incoming fragment &lt;b&gt;win&lt;/b&gt; over the supplied
    ///     <paramref name="attributes"/>mirroring &lt;c&gt;React.cloneElement&lt;/c&gt; semantics in shadcn/ui.
    ///     </description>
    /// </item>
    /// <item>
    ///     <description>
    ///     When the root is a DOM element, only attributes whose names begin with a lowercase
    ///     letter are considered. (Uppercase names are assumed to be Blazor component
    ///     parameters and are ignored.)  The exception is the &lt;c&gt;Id&lt;/c&gt; attribute, which is passed through
    ///     to the child Element as &lt;c&gt;id&lt;/c&gt; (lowercase).
    ///     </description>
    /// </item>
    /// <item>
    ///     <description>
    ///     If both the fragment and <paramref name="attributes"/> specify the &lt;c&gt;class&lt;/c&gt;
    ///     attribute, they are merged using <see cref="TailwindMerge.TwMerge.Merge(string?, string?)"/>,
    ///     so that utilities in the fragment take precedence while conflicts are resolved.
    ///     </description>
    /// </item>
    /// <item>
    ///     <description>
    ///     If the fragment contains &lt;i&gt;no&lt;/i&gt; frames, an empty fragment is returned.
    ///     If it contains multiple toplevel roots, an <see cref="InvalidOperationException"/>
    ///     is thrown, instructing the developer to wrap siblings in a container.
    ///     </description>
    /// </item>
    /// </list>
    /// </summary>
    /// <param name="fragment">The original <see cref="RenderFragment"/> to clone.</param>
    /// <param name="attributes">Base attributes that will be applied &lt;i&gt;unless&lt;/i&gt; the fragment already defines them.</param>
    /// <returns>A cloned <see cref="RenderFragment"/> with merged attributes.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the supplied fragment has more than one root or its root is neither an element nor a component.</exception>
    protected RenderFragment CloneFragment(RenderFragment fragment, IDictionary<string, object?>? attributes = null)
    {
        if (fragment is null)
            throw new ArgumentNullException(nameof(fragment));
        // Capture the fragment into a temporary builder
        var probe = new RenderTreeBuilder();
        fragment(probe);
        var range = probe.GetFrames();
        if (range.Count == 0)
        {
            // Empty fragment  return an empty fragment
            return _ => { };
        }
        var frames = range.Array;
        var root = frames[0];
        bool rootIsElement = root.FrameType == RenderTreeFrameType.Element;
        bool rootIsComponent = root.FrameType == RenderTreeFrameType.Component;
        bool rootIsMarkup = root.FrameType == RenderTreeFrameType.Markup;
        if (!rootIsElement && !rootIsComponent && !rootIsMarkup)
        {
            throw new InvalidOperationException("CloneFragment expects the RenderFragment to have exactly one root element, component, or markup. Wrap multiple nodes in a container element/component.");
        }
        int rootLen = GetSubtreeLength(root);
        if (rootLen != range.Count)
        {
            throw new InvalidOperationException("CloneFragment detected multiple top-level nodes. Please wrap sibling nodes in a container element or component.");
        }
        if (rootIsMarkup)
        {
            if (attributes is null || attributes.Count == 0)
            {
                return fragment; // No attributes to merge, return original
            }
            // Use the new utility to merge attributes into the markup string.
            var mergedMarkup = HtmlUtils.MergeRootElementAttributes(
                TwMerge,
                root.MarkupContent,
                attributes,
                new HtmlUtils.MergeOptions
                {
                    // Prepending is often safer for things like 'style' or event handlers
                    ConflictPolicyResolver = name => HtmlUtils.AttrConflictPolicy.PrependSpaceSeparated
                });
            // Return a new fragment that renders the modified markup.
            return builder => builder.AddMarkupContent(0, mergedMarkup);
        }
        // Prepare the base attributes (callersupplied props)
        var baseAttrs = attributes is null
            ? new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase)
            : new Dictionary<string, object?>(attributes, StringComparer.OrdinalIgnoreCase);
        // For DOM root, drop attributes that begin with an uppercase letter
        if (rootIsElement)
        {
            // Remove attributes that are not lower-case (assumed to be component parameters)
            foreach (var key in baseAttrs.Keys.ToArray())
            {
                if (key.Length == 0) { baseAttrs.Remove(key); continue; }
                if (!char.IsUpper(key[0])) continue;
                if (key is "Id" or "Href")
                {
                    baseAttrs.Add(key.ToLowerInvariant(), baseAttrs[key]);
                }
                baseAttrs.Remove(key);
            }
        }
        // Return a fragment that replays frames and applies precedence rules
        return builder => EmitRoot(builder, frames, baseAttrs, rootIsElement);
    }
    /*  internal helpers  */
    private void EmitRoot(RenderTreeBuilder b, RenderTreeFrame[] frames, IDictionary<string, object?> baseAttrs, bool rootIsElement)
    {
        // root frame is always frames[0]
        ref var root = ref frames[0];
        int originalRootIndex = 0;
        if (rootIsElement)
        {
            b.OpenElement(root.Sequence, root.ElementName);
            if (root.ElementKey != null) b.SetKey(root.ElementKey);
        }
        else
        {
            b.OpenComponent(root.Sequence, root.ComponentType);
            if (root.ComponentKey != null) b.SetKey(root.ComponentKey);
        }
        // Drain any original attributes (they win over baseAttrs)
        CopyAttributesWithPrecedence(b, frames, ref originalRootIndex, baseAttrs);
        // originalRootIndex is now the first child/frame after attributes
        // Compute exactly how many childframes remain under this root:
        //   root.SubtreeLength includes root + all attribute frames + all descendant frames
        //   so descendantFramesCount = root.SubtreeLength  1  attributeFrameCount
        // and attributeFrameCount == originalRootIndex  originalRootIndexOfRoot  1
        // but simpler: childCount = root.SubtreeLength  originalRootIndex
        int childCount = rootIsElement
            ? root.ElementSubtreeLength - originalRootIndex
            : root.ComponentSubtreeLength - originalRootIndex;
        // Replay just those child frames
        ReplayChildren(b, frames, originalRootIndex, childCount);
        if (rootIsElement)
            b.CloseElement();
        else
            b.CloseComponent();
    }
    /// <summary>
    /// Copies attribute frames from <paramref name="frames"/> into <paramref name="b"/>, letting
    /// those original attributes override any matching keys in <paramref name="baseAttrs"/>. After
    /// originals are copied, remaining <paramref name="baseAttrs"/> entries are appended. For the
    /// &lt;c&gt;class&lt;/c&gt; attribute, <see cref="TailwindMerge.TwMerge.Merge(string?, string?)"/> is used to merge
    /// Tailwind class lists, with the original (fragment) classes taking precedence.
    /// </summary>
    private void CopyAttributesWithPrecedence(RenderTreeBuilder b, RenderTreeFrame[] frames, ref int idx, IDictionary<string, object?> baseAttrs)
    {
        int i = idx + 1;
        int maxSeq = -1;
        // First copy original attributes (they win)
        while (i < frames.Length && frames[i].FrameType == RenderTreeFrameType.Attribute)
        {
            var attr = frames[i];
            var name = attr.AttributeName;
            var val = attr.AttributeValue;
            if (string.Equals(name, "class", StringComparison.OrdinalIgnoreCase))
            {
                baseAttrs.TryGetValue("class", out var baseClassObj);
                var baseClass = baseClassObj?.ToString();
                var originalClas = val?.ToString();
                // Assuming TwMerge is available in the project context
                // val = TwMerge.Merge(baseClass, originalClas);
                val = $"{baseClass} {originalClas}".Trim(); // Simple merge as fallback
                baseAttrs.Remove("class");
            }
            else
            {
                // Original overrides base
                baseAttrs.Remove(name);
            }
            b.AddAttribute(attr.Sequence, name, val);
            maxSeq = Math.Max(maxSeq, attr.Sequence);
            i++;
        }
        // Append remaining base attributes
        int seq = maxSeq + 1;
        foreach (var kv in baseAttrs)
        {
            b.AddAttribute(seq++, kv.Key, kv.Value);
        }
        idx = i; // advance caller index past attributes
    }
    private static void CopyAttributesVerbatim(RenderTreeBuilder b, RenderTreeFrame[] frames, ref int idx)
    {
        int i = idx + 1;
        while (i < frames.Length && frames[i].FrameType == RenderTreeFrameType.Attribute)
        {
            var a = frames[i];
            b.AddAttribute(a.Sequence, a.AttributeName, a.AttributeValue);
            i++;
        }
        idx = i;
    }
    private static void ReplayChildren(RenderTreeBuilder b, RenderTreeFrame[] frames, int start, int length)
    {
        int i = start;
        int end = start + length;
        while (i < end)
        {
            var f = frames[i];
            switch (f.FrameType)
            {
                case RenderTreeFrameType.Element:
                    {
                        // Remember where this elements frame sits
                        int elementIndex = i;
                        int subtreeLength = f.ElementSubtreeLength;
                        // Open it
                        b.OpenElement(f.Sequence, f.ElementName);
                        if (f.ElementKey != null) b.SetKey(f.ElementKey);
                        // Drain its attributes (they get written verbatim)
                        CopyAttributesVerbatim(b, frames, ref i);
                        // Now i == elementIndex + 1 + attributeCount
                        // So compute how many real children remain in this subtree:
                        int childCount = subtreeLength - (i - elementIndex);
                        // Recurse into exactly that many child frames
                        ReplayChildren(b, frames, i, childCount);
                        // Close the element
                        b.CloseElement();
                        // Skip the entire subtree in one jump:
                        // elementIndex + subtreeLength = first frame after this subtree
                        i = elementIndex + subtreeLength;
                    }
                    break;
                case RenderTreeFrameType.Component:
                    {
                        int componentIndex = i;
                        int subtreeLength = f.ComponentSubtreeLength;
                        b.OpenComponent(f.Sequence, f.ComponentType);
                        if (f.ComponentKey != null) b.SetKey(f.ComponentKey);
                        CopyAttributesVerbatim(b, frames, ref i);
                        int childCount = subtreeLength - (i - componentIndex);
                        ReplayChildren(b, frames, i, childCount);
                        b.CloseComponent();
                        i = componentIndex + subtreeLength;
                    }
                    break;
                case RenderTreeFrameType.Region:
                    {
                        // Regions never have attributes, so a simple pattern works
                        int regionIndex = i;
                        int subtreeLength = f.RegionSubtreeLength;
                        // Recurse into its children
                        ReplayChildren(b, frames, i + 1, subtreeLength - 1);
                        // Skip entire region
                        i = regionIndex + subtreeLength;
                    }
                    break;
                case RenderTreeFrameType.Text:
                    b.AddContent(f.Sequence, f.TextContent);
                    i++;
                    break;
                case RenderTreeFrameType.Markup:
                    b.AddMarkupContent(f.Sequence, f.MarkupContent);
                    i++;
                    break;
                case RenderTreeFrameType.ElementReferenceCapture:
                    b.AddElementReferenceCapture(f.Sequence, (Action<ElementReference>)f.ElementReferenceCaptureAction!);
                    i++;
                    break;
                case RenderTreeFrameType.ComponentReferenceCapture:
                    b.AddComponentReferenceCapture(f.Sequence, (Action<object>)f.ComponentReferenceCaptureAction!);
                    i++;
                    break;
                default:
                    // Skip any frame types were not explicitly handling
                    i++;
                    break;
            }
        }
    }
    private static int GetSubtreeLength(in RenderTreeFrame frame) => frame.FrameType switch
    {
        RenderTreeFrameType.Element => frame.ElementSubtreeLength,
        RenderTreeFrameType.Component => frame.ComponentSubtreeLength,
        RenderTreeFrameType.Region => frame.RegionSubtreeLength,
        _ => 1
    };
}
</file>

<file path="RzAsChildComponent.cs">
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
/// Base class for RizzyUI components that implement the "asChild" composition pattern from shadcn/ui.
/// This pattern allows components to either render their own wrapper element or merge their behavior
/// and styling onto a child element, providing maximum flexibility for component consumers.
/// </summary>
/// <remarks>
/// <para>
/// The asChild pattern is particularly useful for creating highly composable component libraries where
/// components need to work with various element types (e.g., a Button component that can render as a
/// button, anchor, or any other element).
/// </para>
/// <para>
/// When <see cref="AsChild"/> is &lt;c&gt;false&lt;/c&gt; (default), the component renders normally using its
/// .razor template. When <see cref="AsChild"/> is &lt;c&gt;true&lt;/c&gt;, the component extracts its child content,
/// merges its attributes/behavior onto that child, and renders the child directly.
/// </para>
/// <para>
/// Derived components must implement <see cref="GetAsChildContent"/> to specify which RenderFragment
/// should be used for the asChild pattern, and <see cref="GetComponentAttributes"/> to define which
/// attributes should be merged onto the child element.
/// </para>
/// </remarks>
/// <example>
/// &lt;code&gt;
/// // Normal usage - renders as button
/// &amp;lt;MyButton OnClick="@HandleClick"&amp;gt;Click me&amp;lt;/MyButton&amp;gt;
/// 
/// // AsChild usage - renders as anchor with button behavior
/// &amp;lt;MyButton AsChild="true" OnClick="@HandleClick"&amp;gt;
///     &amp;lt;a href="/home"&amp;gt;Go Home&amp;lt;/a&amp;gt;
/// &amp;lt;/MyButton&amp;gt;
/// &lt;/code&gt;
/// </example>
public abstract partial class RzAsChildComponent : RzComponent
{
    /// <summary>
    /// Gets or sets whether the component should render its child content directly with merged attributes
    /// instead of wrapping it in the component's default element.
    /// </summary>
    /// <value>
    /// &lt;c&gt;true&lt;/c&gt; to render the child element directly with merged component attributes;
    /// &lt;c&gt;false&lt;/c&gt; to render the component normally with its own wrapper element.
    /// Default is &lt;c&gt;false&lt;/c&gt;.
    /// </value>
    /// <remarks>
    /// When set to &lt;c&gt;true&lt;/c&gt;, the content returned by <see cref="GetAsChildContent"/> must contain
    /// exactly one root element or component. Multiple root elements will cause the component to throw
    /// an <see cref="InvalidOperationException"/> during rendering.
    /// </remarks>
    [Parameter] public bool AsChild { get; set; }
    /// <summary>
    /// Renders the component in asChild mode by cloning the specified child content and merging component attributes onto it.
    /// Throws an <see cref="InvalidOperationException"/> if <see cref="AsChild"/> is &lt;c&gt;false&lt;/c&gt; or if the required content is missing.
    /// </summary>
    /// <returns>
    /// A <see cref="RenderFragment"/> that renders the child element with merged attributes when <see cref="AsChild"/> is &lt;c&gt;true&lt;/c&gt;.
    /// </returns>
    protected RenderFragment RenderAsChild() => builder =>
    {
        if (!AsChild)
            throw new InvalidOperationException($"{GetType().Name}: RenderAsChild should not be called when AsChild is false.");
        var asChildContent = GetAsChildContent();
        if (asChildContent != null)
        {
            var attributes = GetComponentAttributes();
            var cloned = CloneFragment(asChildContent, attributes);
            builder.AddContent(0, cloned);
        }
        else
        {
            var contentProp = GetType()
                .GetProperties()
                .Where(p => p.PropertyType == typeof(RenderFragment) && p.GetValue(this) == null)
                .Select(p => p.Name)
                .FirstOrDefault() ?? "ChildContent";
            throw new InvalidOperationException(
                $"{GetType().Name}: AsChild requires {contentProp} to be provided with exactly one root element.");
        }
    };
    /// <summary>
    /// When overridden in a derived class, returns the <see cref="RenderFragment"/> that should be used
    /// when the component is rendered in asChild mode.
    /// </summary>
    /// <returns>
    /// The <see cref="RenderFragment"/> to be cloned and enhanced with component attributes when
    /// <see cref="AsChild"/> is &lt;c&gt;true&lt;/c&gt;. Typically returns a component's main content parameter
    /// (e.g., ChildContent). May return &lt;c&gt;null&lt;/c&gt; if no appropriate content is available.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method determines which content the asChild pattern operates on. For components with multiple
    /// RenderFragment parameters (e.g., Header, Body, Footer), this typically returns the "main" content fragment.
    /// </para>
    /// <para>
    /// The returned RenderFragment must contain exactly one root element when <see cref="AsChild"/> is &lt;c&gt;true&lt;/c&gt;.
    /// Multiple root elements will cause an <see cref="InvalidOperationException"/> during rendering.
    /// </para>
    /// </remarks>
    /// <example>
    /// &lt;code&gt;
    /// // Simple implementation for a component with single content
    /// protected override RenderFragment? GetAsChildContent() =&gt; ChildContent;
    /// 
    /// // For a component with multiple fragments
    /// protected override RenderFragment? GetAsChildContent() =&gt; Body ?? ChildContent;
    /// &lt;/code&gt;
    /// </example>
    protected abstract RenderFragment? GetAsChildContent();
    /// <summary>
    /// When overridden in a derived class, returns the attributes that should be applied to either
    /// the component's root element (when <see cref="AsChild"/> is &lt;c&gt;false&lt;/c&gt;) or merged onto
    /// the child element (when <see cref="AsChild"/> is &lt;c&gt;true&lt;/c&gt;).
    /// </summary>
    /// <returns>
    /// A dictionary of attribute names and values to be applied. Values may be &lt;c&gt;null&lt;/c&gt;, in which
    /// case they will be omitted from the rendered output. The dictionary should use case-insensitive
    /// key comparison for consistency with HTML attributes.
    /// </returns>
    /// <remarks>
    /// <para>
    /// This method should return all behavioral and styling attributes that define the component's
    /// functionality, such as CSS classes, event handlers, ARIA attributes, and data attributes.
    /// </para>
    /// <para>
    /// For DOM elements, use lowercase attribute names (e.g., "class", "onclick", "aria-label").
    /// The <see cref="RzComponent.CloneFragment"/> method will handle filtering inappropriate attributes
    /// when applying them to DOM elements versus Blazor components.
    /// </para>
    /// <para>
    /// Consider using <see cref="RzComponent.TwMerge"/> to intelligently merge Tailwind CSS classes
    /// with any additional classes from <see cref="RzComponent.AdditionalAttributes"/>.
    /// </para>
    /// </remarks>
    /// <example>
    /// &lt;code&gt;
    /// protected override Dictionary&amp;lt;string, object?&amp;gt; GetComponentAttributes()
    /// {
    ///     return new Dictionary&amp;lt;string, object?&amp;gt;(StringComparer.OrdinalIgnoreCase)
    ///     {
    ///         ["class"] = TwMerge.Merge("btn btn-primary", AdditionalAttributes?.GetValueOrDefault("class")?.ToString()),
    ///         ["disabled"] = IsDisabled ? true : null,
    ///         ["onclick"] = OnClick.HasDelegate ? OnClick : null,
    ///         ["aria-pressed"] = IsPressed.ToString().ToLowerInvariant()
    ///     };
    /// }
    /// &lt;/code&gt;
    /// </example>
    protected abstract Dictionary<string, object?> GetComponentAttributes();
}
</file>

<file path="RzAsChildComponentOfT.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A generic base class for RizzyUI components that implement the "asChild" pattern and utilize the TailwindVariants.NET system.
/// It handles the boilerplate of injecting services, managing slot maps, and invoking the Tv function, while also providing the logic for merging attributes onto a child element.
/// </summary>
/// <typeparam name="TSlots">The component-specific class that implements ISlots.</typeparam>
public abstract class RzAsChildComponent<TSlots> : RzAsChildComponent, ISlottable<TSlots>
    where TSlots : ISlots, new()
{
    [Inject]
    private TwVariants Tv { get; set; } = default!;
    /// <summary>
    /// Holds the computed class strings for all slots of the component.
    /// This is populated by Tv.Invoke in OnParametersSet.
    /// </summary>
    private SlotsMap<TSlots> _slots = new();
    /// <summary>
    /// Publicly exposes the computed slot classes for use by child components.
    /// </summary>
    public SlotsMap<TSlots> SlotClasses => _slots;
    /// <summary>
    /// Allows for per-instance overrides of slot classes.
    /// </summary>
    [Parameter]
    public TSlots? Classes { get; set; }
    /// <summary>
    /// Implements the ISlotted interface property.
    /// This property extracts the 'class' attribute from AdditionalAttributes,
    /// allowing Tv.Invoke to merge it into the base slot.
    /// </summary>
    public string? Class => AdditionalAttributes?.TryGetValue("class", out var classes) == true ? classes?.ToString() : null;
    /// <summary>
    /// When implemented in a derived class, this method must return the TvDescriptor
    /// for the component, which is typically retrieved from the active theme.
    /// </summary>
    /// <returns>The component's TvDescriptor.</returns>
    protected abstract TvDescriptor<RzAsChildComponent<TSlots>, TSlots> GetDescriptor();
    /// <summary>
    /// Invokes the TailwindVariants function to compute the final slot classes
    /// based on the component's current parameters and the theme's descriptor.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _slots = Tv.Invoke(this, GetDescriptor());
    }
}
</file>

<file path="RzComponent.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Localization; // Required for IStringLocalizer
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
using Rizzy.Utility;
using TailwindMerge;
namespace RizzyUI;
/// <summary>
/// Base class for all RizzyUI components, providing common functionality
/// such as theme access, attribute merging, nonce handling, and localization support.
/// </summary>
public abstract partial class RzComponent : ComponentBase
{
    private string? _nonce;
    /// <summary>
    /// Gets the currently active theme instance via Cascading Parameter.
    /// This allows components to access theme settings defined by <see cref="RzThemeProvider"/>.
    /// </summary>
    [CascadingParameter]
    protected RzTheme? CascadedTheme { get; set; }
    /// <summary>
    /// Injected configuration options for RizzyUI. Used primarily to access the default theme
    /// if no theme is provided via the cascading parameter.
    /// </summary>
    [Inject]
    private IOptions<RizzyUIConfig>? Config { get; set; }
    /// <summary>
    /// Gets the Tailwind Merge service instance, used for intelligently merging
    /// Tailwind CSS classes, resolving conflicts, and removing redundancies.
    /// </summary>
    [Inject]
    protected TwMerge TwMerge { get; set; } = default!;
    /// <summary>
    /// Gets the nonce provider service, which supplies per-request nonce values
    /// required for Content Security Policy (CSP) compliance when components
    /// generate or load dynamic scripts or styles.
    /// </summary>
    [Inject]
    protected IRizzyNonceProvider RizzyNonceProvider { get; set; } = default!;
    /// <summary>
    /// Gets the string localizer instance configured for RizzyUI.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This localizer uses <see cref="RizzyLocalization"/> as its marker type. If the consuming
    /// application has configured localization overrides via <see cref="RizzyUIConfig"/> (by setting
    /// <see cref="RizzyUIConfig.LocalizationResourceType"/> or <see cref="RizzyUIConfig.LocalizationResourceLocation"/>),
    /// this instance will prioritize the application's resources before falling back to
    /// RizzyUI's embedded defaults.
    /// </para>
    /// <para>
    /// Use this property within derived components to access localized default strings, e.g.,
    /// <c>Localizer["RzButton.AssistiveLabelDefault"]</c>. The keys should follow the
    /// convention `ComponentName.ResourceKey`.
    /// </para>
    /// <para>
    /// For localizing text provided *by* the consuming application (e.g., via `Label` or
    /// `Title` parameters), the application should use its own <see cref="IStringLocalizer{T}"/> instance
    /// before passing the localized string to the component parameter.
    /// </para>
    /// </remarks>
    [Inject]
    protected IStringLocalizer<RizzyLocalization> Localizer { get; set; } = default!;
    /// <summary>
    /// Gets or sets the HTML element tag name to be rendered as the root of this component.
    /// Defaults to "div". Derived components can override this in their `OnInitialized` method if needed.
    /// </summary>
    [Parameter]
    public string Element { get; set; } = string.Empty;
    /// <summary>
    /// Unique identifier for the component instance. 
    /// </summary>
    [Parameter]
    public string Id { get; set; } = IdGenerator.UniqueId("rz");
    /// <summary>
    /// Captures unmatched HTML attributes passed to the component. These attributes are typically
    /// applied to the root element rendered by the component. Use the `class` attribute here
    /// for additional CSS classes; they will be merged with the component's base classes.
    /// </summary>
    [SuppressMessage("Usage", "CA2227:Collection properties should be read only", Justification = "Required by Blazor for parameter capture.")]
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    /// <summary>
    /// Gets the effective theme instance being used by this component. It prioritizes the
    /// theme cascaded from <see cref="RzThemeProvider"/>, falling back to the configured
    /// default theme (<see cref="RizzyUIConfig.DefaultTheme"/>), and finally to the library's
    /// hardcoded default (<see cref="RzTheme.Default"/>).
    /// </summary>
    protected RzTheme Theme { get; private set; } = RzTheme.Default;
    /// <summary>
    /// Gets the Content Security Policy (CSP) nonce value for the current HTTP request.
    /// This value is retrieved once per component instance from the <see cref="RizzyNonceProvider"/>
    /// and should be applied to inline `&lt;script>` or `&lt;style>` tags generated by the component, if any,
    /// to comply with strict CSP directives.
    /// </summary>
    protected string Nonce => _nonce ??= RizzyNonceProvider.GetNonce();
    /// <summary>
    /// Actual HTML element tag name to be rendered as the root of this component.
    /// </summary>
    protected string EffectiveElement => string.IsNullOrEmpty(Element) ? "div" : Element;
    /// <summary>
    /// Initializes the component and resolves the effective theme.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Resolve the theme instance based on cascade or config/default.
        Theme = CascadedTheme ?? Config?.Value.DefaultTheme ?? RzTheme.Default;
    }
}
</file>

<file path="RzComponentOfT.cs">
using Microsoft.AspNetCore.Components;
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// A generic base class for RizzyUI components that utilize the TailwindVariants.NET system.
/// It handles the boilerplate of injecting services, managing slot maps, and invoking the Tv function.
/// </summary>
/// <typeparam name="TSlots">The component-specific class that implements ISlots.</typeparam>
public abstract class RzComponent<TSlots> : RzComponent, ISlottable<TSlots>
    where TSlots : ISlots, new()
{
    [Inject]
    private TwVariants Tv { get; set; } = default!;
    /// <summary>
    /// Holds the computed class strings for all slots of the component.
    /// This is populated by Tv.Invoke in OnParametersSet.
    /// </summary>
    private SlotsMap<TSlots> _slots = new();
    /// <summary>
    /// Publicly exposes the computed slot classes for use by child components.
    /// </summary>
    public SlotsMap<TSlots> SlotClasses => _slots;
    /// <summary>
    /// Allows for per-instance overrides of slot classes.
    /// </summary>
    [Parameter]
    public TSlots? Classes { get; set; }
    /// <summary>
    /// Implements the ISlotted interface property.
    /// This property extracts the 'class' attribute from AdditionalAttributes,
    /// allowing Tv.Invoke to merge it into the base slot.
    /// </summary>
    public string? Class => AdditionalAttributes?.TryGetValue("class", out var classes) == true ? classes?.ToString() : null;
    /// <summary>
    /// When implemented in a derived class, this method must return the TvDescriptor
    /// for the component, which is typically retrieved from the active theme.
    /// </summary>
    /// <returns>The component's TvDescriptor.</returns>
    protected abstract TvDescriptor<RzComponent<TSlots>, TSlots> GetDescriptor();
    /// <summary>
    /// Invokes the TailwindVariants function to compute the final slot classes
    /// based on the component's current parameters and the theme's descriptor.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _slots = Tv.Invoke(this, GetDescriptor());
    }
}
</file>

<file path="RzTheme.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Represents the comprehensive theme data for the RizzyUI application.
///     It holds semantic colors (light/dark variants), status colors, border settings,
///     and references to style definitions for all individual RizzyUI components.
///     This class allows for theme customization and provides styling context to components.
/// </summary>
public partial class RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="RzTheme" /> class, setting the name, code,
    ///     and instantiating all default component style definitions.
    /// </summary>
    /// <param name="name">The full, human-readable name of the theme.</param>
    /// <param name="themeCode">The short, lowercase code name for the theme.</param>
    public RzTheme(string name, string themeCode)
    {
        Name = name;
        ThemeCode = themeCode;
        // Instantiate default styles for all components
        // RzAlert Family
        RzAlert = RizzyUI.RzAlert.DefaultDescriptor;
        AlertTitle = RizzyUI.AlertTitle.DefaultDescriptor;
        AlertDescription = RizzyUI.AlertDescription.DefaultDescriptor;
        // RzAvatar Family
        RzAvatar = RizzyUI.RzAvatar.DefaultDescriptor;
        // RzBadge
        RzBadge = RizzyUI.RzBadge.DefaultDescriptor;
        // RzBreadcrumb Family
        RzBreadcrumb = RizzyUI.RzBreadcrumb.DefaultDescriptor;
        BreadcrumbList = RizzyUI.BreadcrumbList.DefaultDescriptor;
        BreadcrumbItem = RizzyUI.BreadcrumbItem.DefaultDescriptor;
        BreadcrumbLink = RizzyUI.BreadcrumbLink.DefaultDescriptor;
        BreadcrumbPage = RizzyUI.BreadcrumbPage.DefaultDescriptor;
        BreadcrumbSeparator = RizzyUI.BreadcrumbSeparator.DefaultDescriptor;
        BreadcrumbEllipsis = RizzyUI.BreadcrumbEllipsis.DefaultDescriptor;
        // RzButton
        RzButton = RizzyUI.RzButton.DefaultDescriptor;
        ButtonGroupSeparator = RizzyUI.ButtonGroupSeparator.DefaultDescriptor;
        ButtonGroupText = RizzyUI.ButtonGroupText.DefaultDescriptor;
        // RzDialog Family
        RzDialog = RizzyUI.RzDialog.DefaultDescriptor;
        DialogContent = RizzyUI.DialogContent.DefaultDescriptor;
        DialogHeader = RizzyUI.DialogHeader.DefaultDescriptor;
        DialogFooter = RizzyUI.DialogFooter.DefaultDescriptor;
        DialogTitle = RizzyUI.DialogTitle.DefaultDescriptor;
        DialogTrigger = RizzyUI.DialogTrigger.DefaultDescriptor;
        DialogClose = RizzyUI.DialogClose.DefaultDescriptor;
        DialogDescription = RizzyUI.DialogDescription.DefaultDescriptor;
        // RzEmpty Family
        RzEmpty = RizzyUI.RzEmpty.DefaultDescriptor;
        EmptyHeader = RizzyUI.EmptyHeader.DefaultDescriptor;
        EmptyMedia = RizzyUI.EmptyMedia.DefaultDescriptor;
        EmptyTitle = RizzyUI.EmptyTitle.DefaultDescriptor;
        EmptyDescription = RizzyUI.EmptyDescription.DefaultDescriptor;
        EmptyContent = RizzyUI.EmptyContent.DefaultDescriptor;
        // RzIndicator
        RzIndicator = RizzyUI.RzIndicator.DefaultDescriptor;
        // RzPopover Family
        RzPopover = RizzyUI.RzPopover.DefaultDescriptor;
        PopoverTrigger = RizzyUI.PopoverTrigger.DefaultDescriptor;
        PopoverContent = RizzyUI.PopoverContent.DefaultDescriptor;
        // RzProgress
        RzProgress = RizzyUI.RzProgress.DefaultDescriptor;
        // RzSeparator
        RzSeparator = RizzyUI.RzSeparator.DefaultDescriptor;
        // RzSheet Family
        RzSheet = RizzyUI.RzSheet.DefaultDescriptor;
        SheetContent = RizzyUI.SheetContent.DefaultDescriptor;
        SheetHeader = RizzyUI.SheetHeader.DefaultDescriptor;
        SheetFooter = RizzyUI.SheetFooter.DefaultDescriptor;
        SheetTitle = RizzyUI.SheetTitle.DefaultDescriptor;
        SheetDescription = RizzyUI.SheetDescription.DefaultDescriptor;
        SheetTrigger = RizzyUI.SheetTrigger.DefaultDescriptor;
        SheetClose = RizzyUI.SheetClose.DefaultDescriptor;
        // RzSpinner
        RzSpinner = RizzyUI.RzSpinner.DefaultDescriptor;
        // Typography Family
        RzKbd = RizzyUI.RzKbd.DefaultDescriptor;
        RzKbdGroup = RizzyUI.RzKbdGroup.DefaultDescriptor;
        RzHeading = RizzyUI.RzHeading.DefaultDescriptor;
        RzParagraph = RizzyUI.RzParagraph.DefaultDescriptor;
        // Layout Components (Migrated)
        RzAccordion = RizzyUI.RzAccordion.DefaultDescriptor;
        AccordionItem = RizzyUI.AccordionItem.DefaultDescriptor;
        RzArticle = RizzyUI.RzArticle.DefaultDescriptor;
        RzAspectRatio = RizzyUI.RzAspectRatio.DefaultDescriptor;
        RzCard = RizzyUI.RzCard.DefaultDescriptor;
        CardContent = RizzyUI.CardContent.DefaultDescriptor;
        CardAction = RizzyUI.CardAction.DefaultDescriptor;
        CardFooter = RizzyUI.CardFooter.DefaultDescriptor;
        CardHeader = RizzyUI.CardHeader.DefaultDescriptor;
        CardDescription = RizzyUI.CardDescription.DefaultDescriptor;
        CardTitle = RizzyUI.CardTitle.DefaultDescriptor;
        RzCarousel = RizzyUI.RzCarousel.DefaultDescriptor;
        CarouselNext = RizzyUI.CarouselNext.DefaultDescriptor;
        CarouselPrevious = RizzyUI.CarouselPrevious.DefaultDescriptor;
        CarouselContent = RizzyUI.CarouselContent.DefaultDescriptor;
        CarouselItem = RizzyUI.CarouselItem.DefaultDescriptor;
        RzCollapsible = RizzyUI.RzCollapsible.DefaultDescriptor;
        CollapsibleTrigger = RizzyUI.CollapsibleTrigger.DefaultDescriptor;
        CollapsibleContent = RizzyUI.CollapsibleContent.DefaultDescriptor;
        RzItemGroup = RizzyUI.RzItemGroup.DefaultDescriptor;
        RzItemSeparator = RizzyUI.RzItemSeparator.DefaultDescriptor;
        RzItem = RizzyUI.RzItem.DefaultDescriptor;
        ItemMedia = RizzyUI.ItemMedia.DefaultDescriptor;
        ItemContent = RizzyUI.ItemContent.DefaultDescriptor;
        ItemTitle = RizzyUI.ItemTitle.DefaultDescriptor;
        ItemDescription = RizzyUI.ItemDescription.DefaultDescriptor;
        ItemActions = RizzyUI.ItemActions.DefaultDescriptor;
        ItemHeader = RizzyUI.ItemHeader.DefaultDescriptor;
        ItemFooter = RizzyUI.ItemFooter.DefaultDescriptor;
        RzSearchButton = RizzyUI.RzSearchButton.DefaultDescriptor;
        RzSteps = RizzyUI.RzSteps.DefaultDescriptor;
        RzBrowser = RizzyUI.RzBrowser.DefaultDescriptor;
        RzCodeViewer = RizzyUI.RzCodeViewer.DefaultDescriptor;
        RzEmbeddedPreview = RizzyUI.RzEmbeddedPreview.DefaultDescriptor;
        RzMarkdown = RizzyUI.RzMarkdown.DefaultDescriptor;
        RzQuickReference = RizzyUI.RzQuickReference.DefaultDescriptor;
        RzQuickReferenceContainer = RizzyUI.RzQuickReferenceContainer.DefaultDescriptor;
        RzDropdownMenu = RizzyUI.RzDropdownMenu.DefaultDescriptor;
        DropdownMenuContent = RizzyUI.DropdownMenuContent.DefaultDescriptor;
        DropdownMenuGroup = RizzyUI.DropdownMenuGroup.DefaultDescriptor;
        DropdownMenuItem = RizzyUI.DropdownMenuItem.DefaultDescriptor;
        DropdownMenuLabel = RizzyUI.DropdownMenuLabel.DefaultDescriptor;
        DropdownMenuSeparator = RizzyUI.DropdownMenuSeparator.DefaultDescriptor;
        DropdownMenuShortcut = RizzyUI.DropdownMenuShortcut.DefaultDescriptor;
        DropdownMenuSub = RizzyUI.DropdownMenuSub.DefaultDescriptor;
        DropdownMenuSubContent = RizzyUI.DropdownMenuSubContent.DefaultDescriptor;
        DropdownMenuSubTrigger = RizzyUI.DropdownMenuSubTrigger.DefaultDescriptor;
        DropdownMenuTrigger = RizzyUI.DropdownMenuTrigger.DefaultDescriptor;
        RzLink = RizzyUI.RzLink.DefaultDescriptor;
        RzNavigationMenu = RizzyUI.RzNavigationMenu.DefaultDescriptor;
        NavigationMenuContent = RizzyUI.NavigationMenuContent.DefaultDescriptor;
        NavigationMenuItem = RizzyUI.NavigationMenuItem.DefaultDescriptor;
        NavigationMenuLink = RizzyUI.NavigationMenuLink.DefaultDescriptor;
        NavigationMenuList = RizzyUI.NavigationMenuList.DefaultDescriptor;
        NavigationMenuTrigger = RizzyUI.NavigationMenuTrigger.DefaultDescriptor;
        RzSidebarProvider = RizzyUI.RzSidebarProvider.DefaultDescriptor;
        Sidebar = RizzyUI.Sidebar.DefaultDescriptor;
        SidebarContent = RizzyUI.SidebarContent.DefaultDescriptor;
        SidebarFooter = RizzyUI.SidebarFooter.DefaultDescriptor;
        SidebarGroup = RizzyUI.SidebarGroup.DefaultDescriptor;
        SidebarGroupContent = RizzyUI.SidebarGroupContent.DefaultDescriptor;
        SidebarGroupLabel = RizzyUI.SidebarGroupLabel.DefaultDescriptor;
        SidebarHeader = RizzyUI.SidebarHeader.DefaultDescriptor;
        SidebarInset = RizzyUI.SidebarInset.DefaultDescriptor;
        SidebarMenu = RizzyUI.SidebarMenu.DefaultDescriptor;
        SidebarMenuAction = RizzyUI.SidebarMenuAction.DefaultDescriptor;
        SidebarMenuBadge = RizzyUI.SidebarMenuBadge.DefaultDescriptor;
        SidebarMenuButton = RizzyUI.SidebarMenuButton.DefaultDescriptor;
        SidebarMenuItem = RizzyUI.SidebarMenuItem.DefaultDescriptor;
        SidebarMenuSub = RizzyUI.SidebarMenuSub.DefaultDescriptor;
        SidebarRail = RizzyUI.SidebarRail.DefaultDescriptor;
        SidebarSeparator = RizzyUI.SidebarSeparator.DefaultDescriptor;
        SidebarTrigger = RizzyUI.SidebarTrigger.DefaultDescriptor;
        // Newly Migrated Components
        RzButtonGroup = RizzyUI.RzButtonGroup.DefaultDescriptor;
        RzDateEdit = RizzyUI.RzDateEdit.DefaultDescriptor;
        RzFormSection = RizzyUI.RzFormSection.DefaultDescriptor;
        RzInput = RizzyUI.FormInputStyles.DefaultDescriptor;
        RzInputText = RizzyUI.RzInputText.DefaultDescriptor;
        RzInputTextArea = RizzyUI.RzInputTextArea.DefaultDescriptor;
        RzCheckbox = RizzyUI.RzInputCheckbox.DefaultDescriptor;
        RzCheckboxGroup = RizzyUI.RzCheckboxGroupStyles.DefaultDescriptor;
        RzCheckboxGroupItem = RizzyUI.RzCheckboxGroupItemStyles.DefaultDescriptor;
        CheckboxGroupItemIndicator = RizzyUI.CheckboxGroupItemIndicatorStyles.DefaultDescriptor;
        RzNativeSelect = RizzyUI.RzNativeSelectStyles.DefaultDescriptor;
        RzInputNumber = RizzyUI.RzInputNumberStyles.DefaultDescriptor;
        RzRadioGroup = RizzyUI.RzRadioGroupStyles.DefaultDescriptor;
        RadioGroupItem = RizzyUI.RadioGroupItemStyles.DefaultDescriptor;
        RadioGroupItemIndicator = RizzyUI.RadioGroupItemIndicator.DefaultDescriptor;
        RzCombobox = RizzyUI.RzComboboxStyles.DefaultDescriptor;
        RzTabs = RizzyUI.RzTabs.DefaultDescriptor;
        TabsList = RizzyUI.TabsList.DefaultDescriptor;
        TabsTrigger = RizzyUI.TabsTrigger.DefaultDescriptor;
        TabsContent = RizzyUI.TabsContent.DefaultDescriptor;
        RzSwitch = RizzyUI.RzSwitchStyles.DefaultDescriptor;
        RzDarkModeToggle = RizzyUI.RzDarkModeToggle.DefaultDescriptor;
        RzTable = RizzyUI.RzTableStyles.DefaultDescriptor;
        TableBody = RizzyUI.TableBodyStyles.DefaultDescriptor;
        TableCell = RizzyUI.TableCellStyles.DefaultDescriptor;
        TableHeaderCell = RizzyUI.TableHeaderCellStyles.DefaultDescriptor;
        TableRow = RizzyUI.TableRowStyles.DefaultDescriptor;
        TablePagination = RizzyUI.TablePaginationStyles.DefaultDescriptor;
        RzFieldSet = RizzyUI.RzFieldSet.DefaultDescriptor;
        FieldLegend = RizzyUI.FieldLegend.DefaultDescriptor;
        FieldGroup = RizzyUI.RzFieldGroup.DefaultDescriptor;
        Field = RizzyUI.FieldStyles.DefaultDescriptor;
        FieldContent = RizzyUI.FieldContent.DefaultDescriptor;
        FieldLabel = RizzyUI.FieldLabelStyles.DefaultDescriptor;
        FieldTitle = RizzyUI.FieldTitle.DefaultDescriptor;
        FieldDescription = RizzyUI.FieldDescription.DefaultDescriptor;
        FieldSeparator = RizzyUI.FieldSeparator.DefaultDescriptor;
        FieldError = RizzyUI.FieldError.DefaultDescriptor;
        Label = RizzyUI.Label.DefaultDescriptor;
        RzInputGroup = RizzyUI.RzInputGroup.DefaultDescriptor;
        InputGroupAddon = RizzyUI.InputGroupAddonStyles.DefaultDescriptor;
        InputGroupButton = RizzyUI.InputGroupButtonStyles.DefaultDescriptor;
        InputGroupText = RizzyUI.InputGroupText.DefaultDescriptor;
        InputGroupInput = RizzyUI.InputGroupInput.DefaultDescriptor;
        InputGroupTextarea = RizzyUI.InputGroupTextarea.DefaultDescriptor;
        RzCommand = RizzyUI.RzCommand.DefaultDescriptor;
        RzCommandDialog = RizzyUI.RzCommandDialog.DefaultDescriptor;
        CommandInput = RizzyUI.CommandInput.DefaultDescriptor;
        CommandList = RizzyUI.CommandList.DefaultDescriptor;
        CommandEmpty = RizzyUI.CommandEmpty.DefaultDescriptor;
        CommandGroup = RizzyUI.CommandGroup.DefaultDescriptor;
        CommandItem = RizzyUI.CommandItem.DefaultDescriptor;
        CommandSeparator = RizzyUI.CommandSeparator.DefaultDescriptor;
        CommandShortcut = RizzyUI.CommandShortcut.DefaultDescriptor;
        CommandItemTemplate = RizzyUI.CommandItemTemplate.DefaultDescriptor;
        RzCalendar = RizzyUI.RzCalendar.DefaultDescriptor;
    }
    /// <summary>
    ///     Gets the full, human-readable name of the theme (e.g., "Arctic", "High Contrast").
    /// </summary>
    public string Name { get; init; }
    /// <summary>
    ///     Gets the short code name of the theme (lowercase, no spaces, e.g., "arctic", "highcontrast").
    ///     Used internally, such as for generating theme-specific CSS token names.
    /// </summary>
    public string ThemeCode { get; init; }
    /// <summary>
    ///     Gets or sets the color scheme definitions for the light mode variant of the theme.
    /// </summary>
    public RzThemeVariant Light { get; set; } = new();
    /// <summary>
    ///     Gets or sets the color scheme definitions for the dark mode variant of the theme.
    /// </summary>
    public RzThemeVariant Dark { get; set; } = new();
    /// <summary>
    ///     Gets the default border radius value used across components (e.g., "6px", "0.5rem").
    /// </summary>
    public string Radius { get; init; }
    /// <summary>
    /// Any additional variables that should be applied to elements using this theme
    /// </summary>
    public Dictionary<string, string>? AdditionalProperties { get; init; }
    /// <summary>
    ///     Gets the default Arctic theme instance.
    /// </summary>
    public static RzTheme Default => ArcticTheme;
    /// <summary>
    ///     Gets a new instance of the Arctic theme.
    /// </summary>
    public static RzTheme ArcticTheme => new ArcticTheme();
    /// <summary>
    /// Vercel theme instance, loaded from embedded resource.
    /// </summary>
    public static RzTheme VercelTheme => ThemeLoader.LoadFromEmbeddedResourceAsync(typeof(RzTheme).Assembly, "RizzyUI.Themes.vercel.json").GetAwaiter().GetResult()!;
}
#pragma warning restore CS8618
</file>

<file path="RzTheme.StyleProviders.cs">
using TailwindVariants.NET;
namespace RizzyUI;
/// <summary>
/// This partial class for RzTheme contains all the style provider properties for the RizzyUI components.
/// Each property holds a TvDescriptor that defines the default styling, slots, and variants for a component.
/// </summary>
public partial class RzTheme
{
    #region Data Table Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TableBody{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TableBodySlots>, TableBodySlots> TableBody { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TableCell{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TableCellSlots>, TableCellSlots> TableCell { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TableHeaderCell{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TableHeaderCellSlots>, TableHeaderCellSlots> TableHeaderCell { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TablePagination{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TablePaginationSlots>, TablePaginationSlots> TablePagination { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TableRow{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TableRowSlots>, TableRowSlots> TableRow { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzTable{TItem}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzTableSlots>, RzTableSlots> RzTable { get; set; }
    #endregion
    #region Display Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzAvatar"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzAvatar.Slots>, RzAvatar.Slots> RzAvatar { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzBadge"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzBadge.Slots>, RzBadge.Slots> RzBadge { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzIndicator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzIndicator.Slots>, RzIndicator.Slots> RzIndicator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzProgress"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzProgress.Slots>, RzProgress.Slots> RzProgress { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSeparator.Slots>, RzSeparator.Slots> RzSeparator { get; set; }
    #endregion
    #region Document Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzArticle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzArticle.Slots>, RzArticle.Slots> RzArticle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzBrowser"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzBrowser.Slots>, RzBrowser.Slots> RzBrowser { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCodeViewer"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCodeViewer.Slots>, RzCodeViewer.Slots> RzCodeViewer { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzEmbeddedPreview"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzEmbeddedPreview.Slots>, RzEmbeddedPreview.Slots> RzEmbeddedPreview { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzMarkdown"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzMarkdown.Slots>, RzMarkdown.Slots> RzMarkdown { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzQuickReference"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzQuickReference.Slots>, RzQuickReference.Slots> RzQuickReference { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzQuickReferenceContainer"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzQuickReferenceContainer.Slots>, RzQuickReferenceContainer.Slots> RzQuickReferenceContainer { get; set; }
    #endregion
    #region Feedback Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.AlertDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<AlertDescription.Slots>, AlertDescription.Slots> AlertDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.AlertTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<AlertTitle.Slots>, AlertTitle.Slots> AlertTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogClose"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<DialogClose.Slots>, DialogClose.Slots> DialogClose { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DialogContent.Slots>, DialogContent.Slots> DialogContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DialogDescription.Slots>, DialogDescription.Slots> DialogDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogFooter"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DialogFooter.Slots>, DialogFooter.Slots> DialogFooter { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DialogHeader.Slots>, DialogHeader.Slots> DialogHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DialogTitle.Slots>, DialogTitle.Slots> DialogTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DialogTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<DialogTrigger.Slots>, DialogTrigger.Slots> DialogTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.EmptyContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<EmptyContent.Slots>, EmptyContent.Slots> EmptyContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.EmptyDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<EmptyDescription.Slots>, EmptyDescription.Slots> EmptyDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.EmptyHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<EmptyHeader.Slots>, EmptyHeader.Slots> EmptyHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.EmptyMedia"/> component. </summary>
    public virtual TvDescriptor<RzComponent<EmptyMedia.Slots>, EmptyMedia.Slots> EmptyMedia { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.EmptyTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<EmptyTitle.Slots>, EmptyTitle.Slots> EmptyTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.PopoverContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<PopoverContent.Slots>, PopoverContent.Slots> PopoverContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.PopoverTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<PopoverTrigger.Slots>, PopoverTrigger.Slots> PopoverTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzAlert"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzAlert.Slots>, RzAlert.Slots> RzAlert { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzDialog"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzDialog.Slots>, RzDialog.Slots> RzDialog { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzEmpty"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzEmpty.Slots>, RzEmpty.Slots> RzEmpty { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzPopover"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzPopover.Slots>, RzPopover.Slots> RzPopover { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSheet"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSheet.Slots>, RzSheet.Slots> RzSheet { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSpinner"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSpinner.Slots>, RzSpinner.Slots> RzSpinner { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetClose"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<SheetClose.Slots>, SheetClose.Slots> SheetClose { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SheetContent.Slots>, SheetContent.Slots> SheetContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SheetDescription.Slots>, SheetDescription.Slots> SheetDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetFooter"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SheetFooter.Slots>, SheetFooter.Slots> SheetFooter { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SheetHeader.Slots>, SheetHeader.Slots> SheetHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SheetTitle.Slots>, SheetTitle.Slots> SheetTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SheetTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<SheetTrigger.Slots>, SheetTrigger.Slots> SheetTrigger { get; set; }
    #endregion
    #region Form Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzButton"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzButton.Slots>, RzButton.Slots> RzButton { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzButtonGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzButtonGroup.Slots>, RzButtonGroup.Slots> RzButtonGroup { get; set; }
	/// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ButtonGroupSeparator"/> component. </summary>
	public virtual TvDescriptor<RzComponent<ButtonGroupSeparator.Slots>, ButtonGroupSeparator.Slots> ButtonGroupSeparator { get; set; }
	/// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ButtonGroupText"/> component. </summary>
	public virtual TvDescriptor<RzAsChildComponent<ButtonGroupText.Slots>, ButtonGroupText.Slots> ButtonGroupText { get; set; }
	/// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCalendar"/> component. </summary>
	public virtual TvDescriptor<RzComponent<RzCalendar.Slots>, RzCalendar.Slots> RzCalendar { get; set; }    	
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzDateEdit"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzDateEdit.Slots>, RzDateEdit.Slots> RzDateEdit { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzFormSection"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzFormSection.Slots>, RzFormSection.Slots> RzFormSection { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSwitch"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSwitchSlots>, RzSwitchSlots> RzSwitch { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzNativeSelect{TValue}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzNativeSelectSlots>, RzNativeSelectSlots> RzNativeSelect { get; set; }    
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzFieldSet"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzFieldSet.Slots>, RzFieldSet.Slots> RzFieldSet { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldLegend"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldLegend.Slots>, FieldLegend.Slots> FieldLegend { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzFieldGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzFieldGroup.Slots>, RzFieldGroup.Slots> FieldGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.Field"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldSlots>, FieldSlots> Field { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldContent.Slots>, FieldContent.Slots> FieldContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldLabel"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldLabelSlots>, FieldLabelSlots> FieldLabel { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldTitle.Slots>, FieldTitle.Slots> FieldTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzInput"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FormInputSlots>, FormInputSlots> RzInput { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzInputText"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzInputText.Slots>, RzInputText.Slots> RzInputText { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzInputTextArea"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzInputTextArea.Slots>, RzInputTextArea.Slots> RzInputTextArea { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzInputCheckbox"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzInputCheckbox.Slots>, RzInputCheckbox.Slots> RzCheckbox { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCheckboxGroup{TValue}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCheckboxGroupSlots>, RzCheckboxGroupSlots> RzCheckboxGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCheckboxGroupItem{TValue}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCheckboxGroupItemSlots>, RzCheckboxGroupItemSlots> RzCheckboxGroupItem { get; set; }
	/// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CheckboxGroupItemIndicator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CheckboxGroupItemIndicator.Slots>, CheckboxGroupItemIndicator.Slots> CheckboxGroupItemIndicator { get; set; }
	/// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzInputNumber"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzInputNumberSlots>, RzInputNumberSlots> RzInputNumber { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzRadioGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzRadioGroupSlots>, RzRadioGroupSlots> RzRadioGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RadioGroupItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RadioGroupItemSlots>, RadioGroupItemSlots> RadioGroupItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RadioGroupItemIndicator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RadioGroupItemIndicator.Slots>, RadioGroupItemIndicator.Slots> RadioGroupItemIndicator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldDescription.Slots>, FieldDescription.Slots> FieldDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldSeparator.Slots>, FieldSeparator.Slots> FieldSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.FieldError"/> component. </summary>
    public virtual TvDescriptor<RzComponent<FieldError.Slots>, FieldError.Slots> FieldError { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.Label"/> component. </summary>
    public virtual TvDescriptor<RzComponent<Label.Slots>, Label.Slots> Label { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzInputGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzInputGroup.Slots>, RzInputGroup.Slots> RzInputGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.InputGroupAddon"/> component. </summary>
    public virtual TvDescriptor<RzComponent<InputGroupAddonSlots>, InputGroupAddonSlots> InputGroupAddon { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.InputGroupButton"/> component. </summary>
    public virtual TvDescriptor<RzComponent<InputGroupButtonSlots>, InputGroupButtonSlots> InputGroupButton { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.InputGroupText"/> component. </summary>
    public virtual TvDescriptor<RzComponent<InputGroupText.Slots>, InputGroupText.Slots> InputGroupText { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.InputGroupInput"/> component. </summary>
    public virtual TvDescriptor<RzComponent<InputGroupInput.Slots>, InputGroupInput.Slots> InputGroupInput { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.InputGroupTextarea"/> component. </summary>
    public virtual TvDescriptor<RzComponent<InputGroupTextarea.Slots>, InputGroupTextarea.Slots> InputGroupTextarea { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCombobox{TItem, TValue}"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzComboboxSlots>, RzComboboxSlots> RzCombobox { get; set; }
    #endregion
    #region Layout Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.AccordionItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<AccordionItem.Slots>, AccordionItem.Slots> AccordionItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardAction"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardAction.Slots>, CardAction.Slots> CardAction { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardContent.Slots>, CardContent.Slots> CardContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardDescription.Slots>, CardDescription.Slots> CardDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardFooter"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardFooter.Slots>, CardFooter.Slots> CardFooter { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardHeader.Slots>, CardHeader.Slots> CardHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CardTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CardTitle.Slots>, CardTitle.Slots> CardTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CarouselContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CarouselContent.Slots>, CarouselContent.Slots> CarouselContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CarouselItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CarouselItem.Slots>, CarouselItem.Slots> CarouselItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CarouselNext"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<CarouselNext.Slots>, CarouselNext.Slots> CarouselNext { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CarouselPrevious"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<CarouselPrevious.Slots>, CarouselPrevious.Slots> CarouselPrevious { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CollapsibleContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CollapsibleContent.Slots>, CollapsibleContent.Slots> CollapsibleContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CollapsibleTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<CollapsibleTrigger.Slots>, CollapsibleTrigger.Slots> CollapsibleTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemActions"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemActions.Slots>, ItemActions.Slots> ItemActions { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemContent.Slots>, ItemContent.Slots> ItemContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemDescription"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemDescription.Slots>, ItemDescription.Slots> ItemDescription { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemFooter"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemFooter.Slots>, ItemFooter.Slots> ItemFooter { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemHeader.Slots>, ItemHeader.Slots> ItemHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemMedia"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemMedia.Slots>, ItemMedia.Slots> ItemMedia { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzAccordion"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzAccordion.Slots>, RzAccordion.Slots> RzAccordion { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzAspectRatio"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzAspectRatio.Slots>, RzAspectRatio.Slots> RzAspectRatio { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCard"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCard.Slots>, RzCard.Slots> RzCard { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCarousel"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCarousel.Slots>, RzCarousel.Slots> RzCarousel { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCollapsible"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCollapsible.Slots>, RzCollapsible.Slots> RzCollapsible { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzItem"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<RzItem.Slots>, RzItem.Slots> RzItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzItemGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzItemGroup.Slots>, RzItemGroup.Slots> RzItemGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzItemSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzItemSeparator.Slots>, RzItemSeparator.Slots> RzItemSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSearchButton"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSearchButton.Slots>, RzSearchButton.Slots> RzSearchButton { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSteps"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSteps.Slots>, RzSteps.Slots> RzSteps { get; set; }
    #endregion
    #region Navigation Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbEllipsis"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbEllipsis.Slots>, BreadcrumbEllipsis.Slots> BreadcrumbEllipsis { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbItem.Slots>, BreadcrumbItem.Slots> BreadcrumbItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbLink"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbLink.Slots>, BreadcrumbLink.Slots> BreadcrumbLink { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbList"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbList.Slots>, BreadcrumbList.Slots> BreadcrumbList { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbPage"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbPage.Slots>, BreadcrumbPage.Slots> BreadcrumbPage { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.BreadcrumbSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<BreadcrumbSeparator.Slots>, BreadcrumbSeparator.Slots> BreadcrumbSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuContent.Slots>, DropdownMenuContent.Slots> DropdownMenuContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuGroup.Slots>, DropdownMenuGroup.Slots> DropdownMenuGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuItem.Slots>, DropdownMenuItem.Slots> DropdownMenuItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuLabel"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuLabel.Slots>, DropdownMenuLabel.Slots> DropdownMenuLabel { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuSeparator.Slots>, DropdownMenuSeparator.Slots> DropdownMenuSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuShortcut"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuShortcut.Slots>, DropdownMenuShortcut.Slots> DropdownMenuShortcut { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuSub"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuSub.Slots>, DropdownMenuSub.Slots> DropdownMenuSub { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuSubContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuSubContent.Slots>, DropdownMenuSubContent.Slots> DropdownMenuSubContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuSubTrigger"/> component. </summary>
    public virtual TvDescriptor<RzComponent<DropdownMenuSubTrigger.Slots>, DropdownMenuSubTrigger.Slots> DropdownMenuSubTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.DropdownMenuTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<DropdownMenuTrigger.Slots>, DropdownMenuTrigger.Slots> DropdownMenuTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.NavigationMenuContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<NavigationMenuContent.Slots>, NavigationMenuContent.Slots> NavigationMenuContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.NavigationMenuItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<NavigationMenuItem.Slots>, NavigationMenuItem.Slots> NavigationMenuItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.NavigationMenuLink"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<NavigationMenuLink.Slots>, NavigationMenuLink.Slots> NavigationMenuLink { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.NavigationMenuList"/> component. </summary>
    public virtual TvDescriptor<RzComponent<NavigationMenuList.Slots>, NavigationMenuList.Slots> NavigationMenuList { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.NavigationMenuTrigger"/> component. </summary>
    public virtual TvDescriptor<RzComponent<NavigationMenuTrigger.Slots>, NavigationMenuTrigger.Slots> NavigationMenuTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzBreadcrumb"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzBreadcrumb.Slots>, RzBreadcrumb.Slots> RzBreadcrumb { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzDropdownMenu"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzDropdownMenu.Slots>, RzDropdownMenu.Slots> RzDropdownMenu { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzLink"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzLink.Slots>, RzLink.Slots> RzLink { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzNavigationMenu"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzNavigationMenu.Slots>, RzNavigationMenu.Slots> RzNavigationMenu { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzSidebarProvider"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzSidebarProvider.Slots>, RzSidebarProvider.Slots> RzSidebarProvider { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzTabs"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzTabs.Slots>, RzTabs.Slots> RzTabs { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TabsList"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TabsList.Slots>, TabsList.Slots> TabsList { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TabsTrigger"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<TabsTrigger.Slots>, TabsTrigger.Slots> TabsTrigger { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.TabsContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<TabsContent.Slots>, TabsContent.Slots> TabsContent { get; set; }    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.Sidebar"/> component. </summary>
    public virtual TvDescriptor<RzComponent<Sidebar.Slots>, Sidebar.Slots> Sidebar { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarContent.Slots>, SidebarContent.Slots> SidebarContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarFooter"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarFooter.Slots>, SidebarFooter.Slots> SidebarFooter { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarGroup.Slots>, SidebarGroup.Slots> SidebarGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarGroupContent"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarGroupContent.Slots>, SidebarGroupContent.Slots> SidebarGroupContent { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarGroupLabel"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<SidebarGroupLabel.Slots>, SidebarGroupLabel.Slots> SidebarGroupLabel { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarHeader"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarHeader.Slots>, SidebarHeader.Slots> SidebarHeader { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarInset"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarInset.Slots>, SidebarInset.Slots> SidebarInset { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenu"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarMenu.Slots>, SidebarMenu.Slots> SidebarMenu { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenuAction"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<SidebarMenuAction.Slots>, SidebarMenuAction.Slots> SidebarMenuAction { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenuBadge"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarMenuBadge.Slots>, SidebarMenuBadge.Slots> SidebarMenuBadge { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenuButton"/> component. </summary>
    public virtual TvDescriptor<RzAsChildComponent<SidebarMenuButton.Slots>, SidebarMenuButton.Slots> SidebarMenuButton { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenuItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarMenuItem.Slots>, SidebarMenuItem.Slots> SidebarMenuItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarMenuSub"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarMenuSub.Slots>, SidebarMenuSub.Slots> SidebarMenuSub { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarRail"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarRail.Slots>, SidebarRail.Slots> SidebarRail { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarSeparator.Slots>, SidebarSeparator.Slots> SidebarSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.SidebarTrigger"/> component. </summary>
    public virtual TvDescriptor<RzComponent<SidebarTrigger.Slots>, SidebarTrigger.Slots> SidebarTrigger { get; set; }
    #endregion
    #region Theme Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzDarkModeToggle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzDarkModeToggle.Slots>, RzDarkModeToggle.Slots> RzDarkModeToggle { get; set; }
    #endregion
    #region Typography Components
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.ItemTitle"/> component. </summary>
    public virtual TvDescriptor<RzComponent<ItemTitle.Slots>, ItemTitle.Slots> ItemTitle { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzHeading"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzHeading.Slots>, RzHeading.Slots> RzHeading { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzKbd"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzKbd.Slots>, RzKbd.Slots> RzKbd { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzKbdGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzKbdGroup.Slots>, RzKbdGroup.Slots> RzKbdGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzParagraph"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzParagraph.Slots>, RzParagraph.Slots> RzParagraph { get; set; }
    #endregion
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCommand"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCommand.Slots>, RzCommand.Slots> RzCommand { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.RzCommandDialog"/> component. </summary>
    public virtual TvDescriptor<RzComponent<RzCommandDialog.Slots>, RzCommandDialog.Slots> RzCommandDialog { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandInput"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandInput.Slots>, CommandInput.Slots> CommandInput { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandList"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandList.Slots>, CommandList.Slots> CommandList { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandEmpty"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandEmpty.Slots>, CommandEmpty.Slots> CommandEmpty { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandGroup"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandGroup.Slots>, CommandGroup.Slots> CommandGroup { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandItem"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandItem.Slots>, CommandItem.Slots> CommandItem { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandSeparator"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandSeparator.Slots>, CommandSeparator.Slots> CommandSeparator { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandShortcut"/> component. </summary>
    public virtual TvDescriptor<RzComponent<CommandShortcut.Slots>, CommandShortcut.Slots> CommandShortcut { get; set; }
    /// <summary> Gets or sets the style definitions for the <see cref="RizzyUI.CommandItemTemplate"/> component. </summary>
	public virtual TvDescriptor<RzComponent<CommandItemTemplate.Slots>, CommandItemTemplate.Slots> CommandItemTemplate { get; set; }
}
</file>

<file path="RzThemeVariant.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Defines a color theme variant (e.g., light or dark) with properties mapping to CSS custom properties.
/// </summary>
public class RzThemeVariant
{
    /// <summary>General page background color (maps to --background).</summary>
    public Color Background { get; init; }
    /// <summary>General page foreground/text color (maps to --foreground).</summary>
    public Color Foreground { get; init; }
    /// <summary>Background color for card components (maps to --card).</summary>
    public Color Card { get; init; }
    /// <summary>Foreground/text color for content on card components (maps to --card-foreground).</summary>
    public Color CardForeground { get; init; }
    /// <summary>Background color for popover components (maps to --popover).</summary>
    public Color Popover { get; init; }
    /// <summary>Foreground/text color for content on popover components (maps to --popover-foreground).</summary>
    public Color PopoverForeground { get; init; }
    /// <summary>Primary accent color (maps to --primary).</summary>
    public Color Primary { get; init; }
    /// <summary>Foreground/text color for content on primary-colored elements (maps to --primary-foreground).</summary>
    public Color PrimaryForeground { get; init; }
    /// <summary>Secondary accent color (maps to --secondary).</summary>
    public Color Secondary { get; init; }
    /// <summary>Foreground/text color for content on secondary-colored elements (maps to --secondary-foreground).</summary>
    public Color SecondaryForeground { get; init; }
    /// <summary>Color for muted surfaces or backgrounds (maps to --muted).</summary>
    public Color Muted { get; init; }
    /// <summary>Foreground/text color for content on muted surfaces (maps to --muted-foreground).</summary>
    public Color MutedForeground { get; init; }
    /// <summary>Color for accented surfaces or backgrounds (maps to --accent).</summary>
    public Color Accent { get; init; }
    /// <summary>Foreground/text color for content on accented surfaces (maps to --accent-foreground).</summary>
    public Color AccentForeground { get; init; }
    /// <summary>Color for destructive actions or elements (maps to --destructive).</summary>
    public Color Destructive { get; init; }
    /// <summary>Foreground/text color for content on destructive-colored elements (maps to --destructive-foreground).</summary>
    public Color DestructiveForeground { get; init; }
    /// <summary>Color for borders (maps to --border).</summary>
    public Color Border { get; init; }
    /// <summary>Color for input backgrounds or borders (maps to --input).</summary>
    public Color Input { get; init; }
    /// <summary>Color for focus rings (maps to --ring).</summary>
    public Color Ring { get; init; }
    /// <summary>Color for the first series in a chart (maps to --chart-1).</summary>
    public Color Chart1 { get; init; }
    /// <summary>Color for the second series in a chart (maps to --chart-2).</summary>
    public Color Chart2 { get; init; }
    /// <summary>Color for the third series in a chart (maps to --chart-3).</summary>
    public Color Chart3 { get; init; }
    /// <summary>Color for the fourth series in a chart (maps to --chart-4).</summary>
    public Color Chart4 { get; init; }
    /// <summary>Color for the fifth series in a chart (maps to --chart-5).</summary>
    public Color Chart5 { get; init; }
    /// <summary>Background color for the sidebar (maps to --sidebar).</summary>
    public Color Sidebar { get; init; }
    /// <summary>Foreground/text color for content in the sidebar (maps to --sidebar-foreground).</summary>
    public Color SidebarForeground { get; init; }
    /// <summary>Primary accent color used within the sidebar (maps to --sidebar-primary).</summary>
    public Color SidebarPrimary { get; init; }
    /// <summary>Foreground color for content on primary-accented sidebar elements (maps to --sidebar-primary-foreground).</summary>
    public Color SidebarPrimaryForeground { get; init; }
    /// <summary>Secondary accent color for sidebar elements, like hover states (maps to --sidebar-accent).</summary>
    public Color SidebarAccent { get; init; }
    /// <summary>Foreground color for content on secondary-accented sidebar elements (maps to --sidebar-accent-foreground).</summary>
    public Color SidebarAccentForeground { get; init; }
    /// <summary>Color for borders within the sidebar (maps to --sidebar-border).</summary>
    public Color SidebarBorder { get; init; }
    /// <summary>Color for focus rings within the sidebar (maps to --sidebar-ring).</summary>
    public Color SidebarRing { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for informational messages or states.
    /// </summary>
    public Color Info { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on an <see cref="Info" /> background.
    /// </summary>
    public Color InfoForeground { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used to indicate warning or cautionary states.
    /// </summary>
    public Color Warning { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on a <see cref="Warning" /> background.
    /// </summary>
    public Color WarningForeground { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used to indicate success or positive states.
    /// </summary>
    public Color Success { get; init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on a <see cref="Success" /> background.
    /// </summary>
    public Color SuccessForeground { get; init; }
    /// <summary>The code highlighting theme for this variant.</summary>
    public RizzyCodeTheme Code { get; init; }
    /// <summary>The sans-serif font family (maps to --font-sans).</summary>
    public string FontSans { get; init; }
    /// <summary>The serif font family (maps to --font-serif).</summary>
    public string FontSerif { get; init; }
    /// <summary>The monospace font family (maps to --font-mono).</summary>
    public string FontMono { get; init; }
    /// <summary>The base border radius value (maps to --radius).</summary>
    public string Radius { get; init; }
    /// <summary>The extra-extra-small box shadow value (maps to --shadow-2xs).</summary>
    public string Shadow2Xs { get; init; }
    /// <summary>The extra-small box shadow value (maps to --shadow-xs).</summary>
    public string ShadowXs { get; init; }
    /// <summary>The small box shadow value (maps to --shadow-sm).</summary>
    public string ShadowSm { get; init; }
    /// <summary>The default box shadow value (maps to --shadow).</summary>
    public string Shadow { get; init; }
    /// <summary>The medium box shadow value (maps to --shadow-md).</summary>
    public string ShadowMd { get; init; }
    /// <summary>The large box shadow value (maps to --shadow-lg).</summary>
    public string ShadowLg { get; init; }
    /// <summary>The extra-large box shadow value (maps to --shadow-xl).</summary>
    public string ShadowXl { get; init; }
    /// <summary>The extra-extra-large box shadow value (maps to --shadow-2xl).</summary>
    public string Shadow2Xl { get; init; }
    /// <summary>
    /// Any additional variables that should be applied to elements using this theme variant.
    /// </summary>
    public Dictionary<string, string>? AdditionalProperties { get; init; }
}
</file>

<file path="Utility/Parser/HtmlUtils.cs">
using System.Text;
using TailwindMerge;
namespace RizzyUI.Utility.Parser;
/// <summary>
/// Provides utility methods for parsing and manipulating HTML.
/// </summary>
internal static class HtmlUtils
{
    /// <summary>
    /// Defines the policy for resolving attribute conflicts during merging.
    /// </summary>
    public enum AttrConflictPolicy
    {
        /// <summary>
        /// Replace the existing attribute value with the new one.
        /// </summary>
        Replace,
        /// <summary>
        /// Append the new attribute value to the existing one, separated by a space.
        /// </summary>
        AppendSpaceSeparated,
        /// <summary>
        /// Prepend the new attribute value to the existing one, separated by a space.
        /// </summary>
        PrependSpaceSeparated
    }
    /// <summary>
    /// Defines options for the attribute merging process.
    /// </summary>
    public sealed class MergeOptions
    {
        /// <summary>
        /// Gets or sets the comparer for attribute names. Defaults to OrdinalIgnoreCase.
        /// </summary>
        public StringComparer Comparer { get; init; } = StringComparer.OrdinalIgnoreCase;
        /// <summary>
        /// Gets or sets a value indicating whether to preserve unquoted attributes when replacing values.
        /// </summary>
        public bool PreserveUnquotedOnReplace { get; init; } = true;
        /// <summary>
        /// Optional policy resolver for non-"class" attributes.
        /// </summary>
        public Func<string, AttrConflictPolicy>? ConflictPolicyResolver { get; init; }
    }
    private enum QuoteKind : byte { None, Single, Double }
    /// <summary>
    /// Merges a dictionary of attributes into the root element of an HTML fragment.
    /// </summary>
    /// <param name="merge">The TwMerge instance for merging CSS classes.</param>
    /// <param name="htmlFragment">The HTML fragment to modify.</param>
    /// <param name="parameters">The attributes to merge.</param>
    /// <param name="options">Options for the merge process.</param>
    /// <returns>The modified HTML fragment string.</returns>
    public static string MergeRootElementAttributes(
        TwMerge merge,
        string htmlFragment,
        IDictionary<string, object?> parameters,
        MergeOptions? options = null)
    {
        options ??= new MergeOptions();
        if (string.IsNullOrWhiteSpace(htmlFragment))
            throw new ArgumentException("HTML fragment cannot be null or empty.", nameof(htmlFragment));
        if (parameters.Count == 0)
            return htmlFragment; // fast path
        // Build index map + arrays for bitmap tracking
        var indexMap = new Dictionary<string, int>(parameters.Count, options.Comparer);
        var keys = new string[parameters.Count];
        var values = new string?[parameters.Count];
        var used = new bool[parameters.Count];
        {
            int idx = 0;
            foreach (var kvp in parameters)
            {
                indexMap[kvp.Key] = idx;
                keys[idx] = kvp.Key;
                values[idx] = kvp.Value?.ToString();
                idx++;
            }
        }
        ReadOnlySpan<char> s = htmlFragment.AsSpan();
        int len = s.Length;
        int i = 0;
        // Skip leading whitespace
        while (i < len && char.IsWhiteSpace(s[i])) i++;
        if (i >= len || s[i] != '<')
            throw new ArgumentException("Fragment must start with an HTML element.");
        i++; // '<'
        // Tag name
        int tagNameStart = i;
        while (i < len && (char.IsLetterOrDigit(s[i]) || s[i] is ':' or '-' or '_' or '.')) i++;
        if (i == tagNameStart)
            throw new ArgumentException("No tag name found.");
        string tagName = new string(s.Slice(tagNameStart, i - tagNameStart));
        var sb = new StringBuilder(htmlFragment.Length + parameters.Count * 16);
        sb.Append('<').Append(tagName);
        bool selfClosing = false;
        // Parse attributes
        while (i < len)
        {
            while (i < len && char.IsWhiteSpace(s[i])) i++;
            if (i >= len) throw new ArgumentException("Unexpected end of input while parsing attributes.");
            char c = s[i];
            if (c == '>')
            {
                i++;
                break;
            }
            if (c == '/' && i + 1 < len && s[i + 1] == '>')
            {
                selfClosing = true;
                i += 2;
                break;
            }
            // Attribute name
            int attrNameStart = i;
            while (i < len)
            {
                c = s[i];
                if (c == '=' || char.IsWhiteSpace(c) || c == '>' || c == '/') break;
                i++;
            }
            if (i == attrNameStart) throw new ArgumentException("Malformed attribute name.");
            string attrName = new string(s.Slice(attrNameStart, i - attrNameStart));
            while (i < len && char.IsWhiteSpace(s[i])) i++;
            bool hasValue = false;
            QuoteKind quoteKind = QuoteKind.None;
            ReadOnlySpan<char> valueSpan = default;
            if (i < len && s[i] == '=')
            {
                hasValue = true;
                i++;
                while (i < len && char.IsWhiteSpace(s[i])) i++;
                if (i >= len) throw new ArgumentException("Unexpected end after '='.");
                char q = s[i];
                if (q == '"' || q == '\'')
                {
                    quoteKind = q == '"' ? QuoteKind.Double : QuoteKind.Single;
                    i++;
                    int valStart = i;
                    while (i < len && s[i] != q) i++;
                    if (i >= len) throw new ArgumentException($"Unterminated attribute value for '{attrName}'.");
                    valueSpan = s.Slice(valStart, i - valStart);
                    i++;
                }
                else
                {
                    int valStart = i;
                    while (i < len)
                    {
                        c = s[i];
                        if (char.IsWhiteSpace(c) || c == '>' || (c == '/' && i + 1 < len && s[i + 1] == '>'))
                            break;
                        i++;
                    }
                    valueSpan = s.Slice(valStart, i - valStart);
                    quoteKind = QuoteKind.None;
                }
            }
            if (indexMap.TryGetValue(attrName, out var idx))
            {
                used[idx] = true;
                string? newValue = values[idx];
                // Rule: null => remove attribute
                if (newValue is null)
                {
                    continue;
                }
                // Special case: class => TwMerge.Merge(existing, new)
                if (IsClassAttr(attrName, options.Comparer))
                {
                    var existing = valueSpan.IsEmpty ? string.Empty : valueSpan.ToString();
                    string merged = merge.Merge([existing, newValue]) ?? string.Empty;
                    EmitAttr(sb, "class", merged, quoteKind, options.PreserveUnquotedOnReplace);
                }
                else
                {
                    var policy = options.ConflictPolicyResolver?.Invoke(attrName) ?? AttrConflictPolicy.Replace;
                    switch (policy)
                    {
                        case AttrConflictPolicy.Replace:
                            EmitAttr(sb, attrName, newValue, quoteKind, options.PreserveUnquotedOnReplace);
                            break;
                        case AttrConflictPolicy.AppendSpaceSeparated:
                            {
                                var existing = valueSpan.IsEmpty ? string.Empty : valueSpan.ToString();
                                var merged = existing.Length == 0 ? newValue : existing + " " + newValue;
                                EmitAttr(sb, attrName, merged, quoteKind, options.PreserveUnquotedOnReplace);
                                break;
                            }
                        case AttrConflictPolicy.PrependSpaceSeparated:
                            {
                                var existing = valueSpan.IsEmpty ? string.Empty : valueSpan.ToString();
                                var merged = existing.Length == 0 ? newValue : newValue + " " + existing;
                                EmitAttr(sb, attrName, merged, quoteKind, options.PreserveUnquotedOnReplace);
                                break;
                            }
                    }
                }
            }
            else
            {
                // Emit original
                if (!hasValue)
                {
                    sb.Append(' ').Append(attrName);
                }
                else
                {
                    sb.Append(' ').Append(attrName).Append('=');
                    switch (quoteKind)
                    {
                        case QuoteKind.Double: sb.Append('"').Append(valueSpan).Append('"'); break;
                        case QuoteKind.Single: sb.Append('\'').Append(valueSpan).Append('\''); break;
                        default: sb.Append(valueSpan); break;
                    }
                }
            }
        }
        // Add remaining dictionary parameters (skip nulls), with special handling for class
        for (int k = 0; k < keys.Length; k++)
        {
            if (used[k]) continue;
            var key = keys[k];
            var v = values[k];
            if (v is null) continue; // null => remove / don't add
            if (IsClassAttr(key, options.Comparer))
            {
                // No original class present => merge with empty string
                EmitAttrAlwaysQuoted(sb, "class", v);
            }
            else
            {
                EmitAttrAlwaysQuoted(sb, key, v);
            }
        }
        if (selfClosing)
        {
            sb.Append("/>");
            return sb.ToString();
        }
        sb.Append('>');
        if (i < len)
        {
            sb.Append(s.Slice(i));
        }
        return sb.ToString();
    }
    private static bool IsClassAttr(string name, StringComparer comparer)
        => comparer.Equals(name, "class");
    private static void EmitAttrAlwaysQuoted(StringBuilder sb, string name, string value)
    {
        sb.Append(' ').Append(name).Append('=').Append('"').Append(value).Append('"');
    }
    private static void EmitAttr(
        StringBuilder sb,
        string name,
        string value,
        QuoteKind originalQuote,
        bool preserveUnquotedOnReplace)
    {
        sb.Append(' ').Append(name).Append('=');
        if (originalQuote == QuoteKind.None && preserveUnquotedOnReplace && IsUnquotedSafe(value))
        {
            sb.Append(value);
            return;
        }
        char q = originalQuote switch
        {
            QuoteKind.Single => '\'',
            QuoteKind.Double => '"',
            _ => '"'
        };
        if (q == '\'' && value.IndexOf('\'') >= 0)
            q = '"';
        sb.Append(q).Append(value).Append(q);
    }
    // HTML5: unquoted value must not contain whitespace or: " ' ` = < >
    private static bool IsUnquotedSafe(string value)
    {
        for (int j = 0; j < value.Length; j++)
        {
            char ch = value[j];
            if (char.IsWhiteSpace(ch)) return false;
            switch (ch)
            {
                case '"':
                case '\'':
                case '`':
                case '=':
                case '<':
                case '>':
                    return false;
            }
        }
        return true;
    }
}
</file>

<file path="Utility/Serialization/Converters/CalendarPositionConverter.cs">
using RizzyUI;
using System.Text.Json;
using System.Text.Json.Serialization;
namespace Jalex.UI.Components.Form.Converters;
/// <summary>
///     Converts a Flatpickr CalendarPosition to/from json
/// </summary>
public class CalendarPositionConverter : JsonConverter<CalendarPosition>
{
    /// <summary>
    ///     Converts string enum representation of CalendarPosition into it's enum counterpart
    /// </summary>
    /// <param name="reader">The JSON reader.</param>
    /// <param name="typeToConvert">The type to convert.</param>
    /// <param name="options">The serializer options.</param>
    /// <returns>The deserialized <see cref="CalendarPosition"/> value.</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown if the JSON value is not a valid CalendarPosition.</exception>
    public override CalendarPosition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString() ?? string.Empty;
        // Convert string values back to enum values during deserialization
        return value switch
        {
            "auto" => CalendarPosition.Auto,
            "above" => CalendarPosition.Above,
            "below" => CalendarPosition.Below,
            "auto left" => CalendarPosition.AutoLeft,
            "auto center" => CalendarPosition.AutoCenter,
            "auto right" => CalendarPosition.AutoRight,
            "above left" => CalendarPosition.AboveLeft,
            "above center" => CalendarPosition.AboveCenter,
            "above right" => CalendarPosition.AboveRight,
            "below left" => CalendarPosition.BelowLeft,
            "below center" => CalendarPosition.BelowCenter,
            "below right" => CalendarPosition.BelowRight,
            _ => throw new ArgumentOutOfRangeException($"Unexpected value when parsing CalendarPosition: {value}")
        };
    }
    /// <summary>
    ///     Converts CalendarPosition enum to text
    /// </summary>
    /// <param name="writer">The JSON writer.</param>
    /// <param name="value">The value to write.</param>
    /// <param name="options">The serializer options.</param>
    /// <exception cref="ArgumentOutOfRangeException">Thrown if the enum value is not a valid CalendarPosition.</exception>
    public override void Write(Utf8JsonWriter writer, CalendarPosition value, JsonSerializerOptions options)
    {
        // Convert enum values to specific string representations for serialization
        var stringValue = value switch
        {
            CalendarPosition.Auto => "auto",
            CalendarPosition.Above => "above",
            CalendarPosition.Below => "below",
            CalendarPosition.AutoLeft => "auto left",
            CalendarPosition.AutoCenter => "auto center",
            CalendarPosition.AutoRight => "auto right",
            CalendarPosition.AboveLeft => "above left",
            CalendarPosition.AboveCenter => "above center",
            CalendarPosition.AboveRight => "above right",
            CalendarPosition.BelowLeft => "below left",
            CalendarPosition.BelowCenter => "below center",
            CalendarPosition.BelowRight => "below right",
            _ => throw new ArgumentOutOfRangeException($"Unexpected CalendarPosition value: {value}")
        };
        writer.WriteStringValue(stringValue);
    }
}
</file>

<file path="Utility/Serialization/Converters/RawStringConverter.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
namespace RizzyUI.Utility.Serialization.Converters;
/// <summary>
///     A custom JSON converter that serializes and deserializes strings as raw values. This allows a developer to embed
///     javascript code in an object and it will serialize that value without any quotation or JSON escaping.
/// </summary>
public class RawStringConverter : JsonConverter<string>
{
    /// <summary>
    ///     Deserialization of json objects with raw values not supported
    /// </summary>
    /// <param name="reader">The JSON reader.</param>
    /// <param name="typeToConvert">The type to convert.</param>
    /// <param name="options">The serializer options.</param>
    /// <returns>An empty string, as deserialization is not supported.</returns>
    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return string.Empty;
    }
    /// <summary>
    ///     Writes the raw value, bypassing JSON escaping and quotation marks
    /// </summary>
    /// <param name="writer">The JSON writer.</param>
    /// <param name="value">The value to write.</param>
    /// <param name="options">The serializer options.</param>
    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        writer.WriteRawValue(value, true);
    }
}
</file>

<file path="Utility/Serialization/Converters/RzThemeConverter.cs">
using RizzyUI.Extensions;
using System.Text.Json;
using System.Text.Json.Serialization;
namespace RizzyUI.Utility.Serialization.Converters;
/// <summary>
/// A custom JSON converter for deserializing a shadcn/ui theme JSON schema into an <see cref="RzTheme"/> object.
/// This converter uses an intermediate DTO for robust and explicit mapping of JSON properties to the RzTheme model.
/// </summary>
public class RzThemeConverter : JsonConverter<RzTheme>
{
    /// <summary>
    /// Reads and converts the JSON to type <see cref="RzTheme"/>.
    /// </summary>
    /// <param name="reader">The JSON reader.</param>
    /// <param name="typeToConvert">The type to convert.</param>
    /// <param name="options">The serializer options.</param>
    /// <returns>The deserialized <see cref="RzTheme"/> object, or null if deserialization fails.</returns>
    public override RzTheme? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var dto = JsonSerializer.Deserialize<ShadcnThemeDto>(ref reader, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        if (dto is null) return null;
        var themeName = dto.Name.ToTitleCase();
        var themeCode = themeName.ToKebabCase();
        var lightVariant = MapVariant(dto.CssVars.Light, dto.CssVars.Theme, isDark: false);
        var darkVariant = MapVariant(dto.CssVars.Dark, dto.CssVars.Theme, isDark: true);
        var radius = dto.CssVars.Theme.GetValueOrDefault("radius", "0.5rem");
        dto.CssVars.Theme.Remove("radius");
        var theme = new RzTheme(themeName, themeCode)
        {
            Light = lightVariant,
            Dark = darkVariant,
            Radius = radius,
            AdditionalProperties = dto.CssVars.Theme.Count > 0 ? new Dictionary<string, string>(dto.CssVars.Theme) : null
        };
        return theme;
    }
    /// <summary>
    /// Maps a dictionary of CSS variables from the DTO to an <see cref="RzThemeVariant"/> object.
    /// </summary>
    private static RzThemeVariant MapVariant(Dictionary<string, string> variantVars, Dictionary<string, string> globalVars, bool isDark)
    {
        string GetValue(string key, string defaultValue) => variantVars.GetValueOrDefault(key, globalVars.GetValueOrDefault(key, defaultValue));
        var variant = new RzThemeVariant
        {
            // Colors
            Background = CreateColor(variantVars, "background"),
            Foreground = CreateColor(variantVars, "foreground"),
            Card = CreateColor(variantVars, "card"),
            CardForeground = CreateColor(variantVars, "card-foreground"),
            Popover = CreateColor(variantVars, "popover"),
            PopoverForeground = CreateColor(variantVars, "popover-foreground"),
            Primary = CreateColor(variantVars, "primary"),
            PrimaryForeground = CreateColor(variantVars, "primary-foreground"),
            Secondary = CreateColor(variantVars, "secondary"),
            SecondaryForeground = CreateColor(variantVars, "secondary-foreground"),
            Muted = CreateColor(variantVars, "muted"),
            MutedForeground = CreateColor(variantVars, "muted-foreground"),
            Accent = CreateColor(variantVars, "accent"),
            AccentForeground = CreateColor(variantVars, "accent-foreground"),
            Destructive = CreateColor(variantVars, "destructive"),
            DestructiveForeground = CreateColor(variantVars, "destructive-foreground", new Color("oklch(1 0 0)", "white")),
            Border = CreateColor(variantVars, "border"),
            Input = CreateColor(variantVars, "input"),
            Ring = CreateColor(variantVars, "ring"),
            // Chart Colors
            Chart1 = CreateColor(variantVars, "chart-1"),
            Chart2 = CreateColor(variantVars, "chart-2"),
            Chart3 = CreateColor(variantVars, "chart-3"),
            Chart4 = CreateColor(variantVars, "chart-4"),
            Chart5 = CreateColor(variantVars, "chart-5"),
            // Sidebar Colors
            Sidebar = CreateColor(variantVars, "sidebar", CreateColor(variantVars, "background")),
            SidebarForeground = CreateColor(variantVars, "sidebar-foreground", CreateColor(variantVars, "foreground")),
            SidebarPrimary = CreateColor(variantVars, "sidebar-primary", CreateColor(variantVars, "primary")),
            SidebarPrimaryForeground = CreateColor(variantVars, "sidebar-primary-foreground", CreateColor(variantVars, "primary-foreground")),
            SidebarAccent = CreateColor(variantVars, "sidebar-accent", CreateColor(variantVars, "accent")),
            SidebarAccentForeground = CreateColor(variantVars, "sidebar-accent-foreground", CreateColor(variantVars, "accent-foreground")),
            SidebarBorder = CreateColor(variantVars, "sidebar-border", CreateColor(variantVars, "border")),
            SidebarRing = CreateColor(variantVars, "sidebar-ring", CreateColor(variantVars, "ring")),
            // Status Colors (with fallbacks to theme colors)
            Success = CreateColor(variantVars, "success", isDark ? Colors.Green.L500 : Colors.Green.L600),
            SuccessForeground = CreateColor(variantVars, "success-foreground", Colors.White),
            Warning = CreateColor(variantVars, "warning", isDark ? Colors.Amber.L400 : Colors.Amber.L500),
            WarningForeground = CreateColor(variantVars, "warning-foreground", Colors.Black),
            Info = CreateColor(variantVars, "info", isDark ? Colors.Sky.L500 : Colors.Sky.L600),
            InfoForeground = CreateColor(variantVars, "info-foreground", Colors.White),
            // Fonts
            FontSans = GetValue("font-sans", "sans-serif"),
            FontSerif = GetValue("font-serif", "serif"),
            FontMono = GetValue("font-mono", "monospace"),
            // Radius
            Radius = GetValue("radius", "0.5rem"),
            // Shadows
            Shadow2Xs = GetValue("shadow-2xs", "0 1px 2px 0px hsl(0 0% 0% / 0.09)"),
            ShadowXs = GetValue("shadow-xs", "0 1px 2px 0px hsl(0 0% 0% / 0.09)"),
            ShadowSm = GetValue("shadow-sm", "0 1px 2px 0px hsl(0 0% 0% / 0.18), 0 1px 2px -1px hsl(0 0% 0% / 0.18)"),
            Shadow = GetValue("shadow", "0 1px 2px 0px hsl(0 0% 0% / 0.18), 0 1px 2px -1px hsl(0 0% 0% / 0.18)"),
            ShadowMd = GetValue("shadow-md", "0 1px 2px 0px hsl(0 0% 0% / 0.18), 0 2px 4px -1px hsl(0 0% 0% / 0.18)"),
            ShadowLg = GetValue("shadow-lg", "0 1px 2px 0px hsl(0 0% 0% / 0.18), 0 4px 6px -1px hsl(0 0% 0% / 0.18)"),
            ShadowXl = GetValue("shadow-xl", "0 1px 2px 0px hsl(0 0% 0% / 0.18), 0 8px 10px -1px hsl(0 0% 0% / 0.18)"),
            Shadow2Xl = GetValue("shadow-2xl", "0 1px 2px 0px hsl(0 0% 0% / 0.45)"),
            // Code Theme
            Code = isDark ? CodeThemes.DefaultDark : CodeThemes.Github,
            AdditionalProperties = variantVars.Count > 0 ? new(variantVars) : null  // Copy the remaining CSS variables to CustomProperties
        };
        return variant;
    }
    /// <summary>
    /// Creates a <see cref="Color"/> object from the CSS variables dictionary.
    /// </summary>
    private static Color CreateColor(Dictionary<string, string> cssVars, string key, Color? fallback = null)
    {
        if (cssVars.TryGetValue(key, out var value) && !string.IsNullOrEmpty(value))
        {
            cssVars.Remove(key); // Remove the key to prevent duplication in the theme
            return new Color(value, key);
        }
        return fallback ?? new Color("transparent", "transparent");
    }
    /// <summary>
    /// Writes a specified value as JSON. This method is not implemented.
    /// </summary>
    /// <param name="writer">The JSON writer.</param>
    /// <param name="value">The value to write.</param>
    /// <param name="options">The serializer options.</param>
    /// <exception cref="NotImplementedException">Thrown because serialization of RzTheme is not supported.</exception>
    public override void Write(Utf8JsonWriter writer, RzTheme value, JsonSerializerOptions options)
    {
        throw new NotImplementedException("Serialization of RzTheme to shadcn/ui format is not supported.");
    }
}
/// <summary>
/// A Data Transfer Object (DTO) representing the top-level structure of a shadcn/ui theme JSON file.
/// </summary>
internal record ShadcnThemeDto
{
    /// <summary>
    /// Gets or sets the name of the theme.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; init; } = string.Empty;
    /// <summary>
    /// Gets or sets the CSS variables for the theme.
    /// </summary>
    [JsonPropertyName("cssVars")]
    public CssVarsDto CssVars { get; init; } = new();
}
/// <summary>
/// A DTO representing the `cssVars` object within a shadcn/ui theme, containing dictionaries
/// for global, light mode, and dark mode variables.
/// </summary>
internal record CssVarsDto
{
    /// <summary>
    /// Gets or sets the global theme variables.
    /// </summary>
    [JsonPropertyName("theme")]
    public Dictionary<string, string> Theme { get; init; } = new();
    /// <summary>
    /// Gets or sets the light mode theme variables.
    /// </summary>
    [JsonPropertyName("light")]
    public Dictionary<string, string> Light { get; init; } = new();
    /// <summary>
    /// Gets or sets the dark mode theme variables.
    /// </summary>
    [JsonPropertyName("dark")]
    public Dictionary<string, string> Dark { get; init; } = new();
}
</file>

<file path="Utility/Serialization/Converters/SingleQuoteStringConverter.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
namespace RizzyUI.Utility.Serialization.Converters;
/// <summary>
/// A custom JSON converter that serializes a string with single quotes.
/// </summary>
internal class SingleQuoteStringConverter : JsonConverter<string>
{
    /// <summary>
    /// Reads and converts the JSON to type <see cref="string"/>.
    /// </summary>
    /// <param name="reader">The JSON reader.</param>
    /// <param name="typeToConvert">The type to convert.</param>
    /// <param name="options">The serializer options.</param>
    /// <returns>The deserialized string.</returns>
    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // Reading logic (not relevant for serialization)
        return reader.GetString() ?? string.Empty;
    }
    /// <summary>
    /// Writes a specified value as JSON.
    /// </summary>
    /// <param name="writer">The JSON writer.</param>
    /// <param name="value">The value to write.</param>
    /// <param name="options">The serializer options.</param>
    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        // Attempt to write single-quoted string
        writer.WriteRawValue($"'{value.Replace("'", "\\'")}'", true);
    }
}
</file>

<file path="Utility/ThemeLoader.cs">
using RizzyUI.Utility.Serialization.Converters;
using System.Reflection;
using System.Security;
using System.Text.Json;
namespace RizzyUI;
/// <xmldoc>
/// A static service class responsible for loading and deserializing RizzyUI themes from various sources.
/// It uses a custom <see cref="RzThemeConverter"/> to handle the specific JSON structure of shadcn/ui themes.
/// This class provides robust error handling for I/O and parsing operations.
/// </xmldoc>
public static class ThemeLoader
{
    private static readonly JsonSerializerOptions _jsonOptions;
    /// <summary>
    /// Initializes the static instance of the <see cref="ThemeLoader"/> class,
    /// setting up the necessary JSON serialization options.
    /// </summary>
    static ThemeLoader()
    {
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            Converters = { new RzThemeConverter() }
        };
    }
    /// <xmldoc>
    /// Asynchronously loads and deserializes a theme from a stream.
    /// </xmldoc>
    /// <param name="stream">The stream containing the JSON theme data. The stream must be readable.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the deserialized <see cref="RzTheme"/>.</returns>
    /// <exception cref="ArgumentNullException">Thrown if the provided <paramref name="stream"/> is null.</exception>
    /// <exception cref="ArgumentException">Thrown if the stream cannot be read.</exception>
    /// <exception cref="JsonException">Thrown if the JSON in the stream is invalid or cannot be deserialized into an <see cref="RzTheme"/>.</exception>
    /// <exception cref="NotSupportedException">Thrown if the stream does not support asynchronous reading.</exception>
    public static async Task<RzTheme?> LoadFromStreamAsync(Stream stream)
    {
        ArgumentNullException.ThrowIfNull(stream);
        if (!stream.CanRead)
        {
            throw new ArgumentException("The provided stream cannot be read.", nameof(stream));
        }
        try
        {
            return await JsonSerializer.DeserializeAsync<RzTheme>(stream, _jsonOptions);
        }
        catch (JsonException ex)
        {
            // Re-throw with more context for easier debugging.
            throw new JsonException("Failed to deserialize the theme from the stream. Ensure the JSON is valid and matches the expected format.", ex);
        }
    }
    /// <xmldoc>
    /// Asynchronously loads a theme from an embedded resource within a specified assembly.
    /// </xmldoc>
    /// <param name="assembly">The assembly containing the embedded resource.</param>
    /// <param name="resourceName">The full name of the embedded resource (e.g., "MyWebApp.Themes.MyTheme.json").</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the deserialized <see cref="RzTheme"/>.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="assembly"/> or <paramref name="resourceName"/> is null or empty.</exception>
    /// <exception cref="FileNotFoundException">Thrown if the specified embedded resource cannot be found in the assembly.</exception>
    /// <exception cref="JsonException">Thrown if the embedded resource contains invalid JSON.</exception>
    public static async Task<RzTheme?> LoadFromEmbeddedResourceAsync(Assembly assembly, string resourceName)
    {
        ArgumentNullException.ThrowIfNull(assembly);
        if (string.IsNullOrEmpty(resourceName))
        {
            throw new ArgumentNullException(nameof(resourceName));
        }
        await using var stream = assembly.GetManifestResourceStream(resourceName);
        if (stream == null)
        {
            throw new FileNotFoundException($"The embedded resource '{resourceName}' was not found in assembly '{assembly.FullName}'. Ensure the resource name is correct and the file's 'Build Action' is set to 'Embedded resource'.");
        }
        return await LoadFromStreamAsync(stream);
    }
    /// <xmldoc>
    /// Asynchronously loads a theme from a specified URL.
    /// </xmldoc>
    /// <param name="httpClient">The <see cref="HttpClient"/> instance to use for the request.</param>
    /// <param name="url">The URL from which to fetch the theme JSON.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the deserialized <see cref="RzTheme"/>.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="httpClient"/> or <paramref name="url"/> is null or empty.</exception>
    /// <exception cref="HttpRequestException">Thrown if the HTTP request fails (e.g., network error, non-success status code like 404 Not Found).</exception>
    /// <exception cref="JsonException">Thrown if the response body contains invalid JSON.</exception>
    public static async Task<RzTheme?> LoadFromUrlAsync(HttpClient httpClient, string url)
    {
        ArgumentNullException.ThrowIfNull(httpClient);
        if (string.IsNullOrEmpty(url))
        {
            throw new ArgumentNullException(nameof(url));
        }
        try
        {
            var response = await httpClient.GetAsync(url);
            response.EnsureSuccessStatusCode(); // Throws HttpRequestException for non-2xx responses.
            await using var stream = await response.Content.ReadAsStreamAsync();
            return await LoadFromStreamAsync(stream);
        }
        catch (HttpRequestException ex)
        {
            throw new HttpRequestException($"Failed to load theme from URL '{url}'. See inner exception for details.", ex);
        }
    }
    /// <xmldoc>
    /// Asynchronously loads a theme from a physical file path.
    /// </xmldoc>
    /// <param name="filePath">The absolute or relative path to the theme JSON file.</param>
    /// <returns>A task that represents the asynchronous operation. The task result contains the deserialized <see cref="RzTheme"/>.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="filePath"/> is null or empty.</exception>
    /// <exception cref="FileNotFoundException">Thrown if the file at the specified path does not exist.</exception>
    /// <exception cref="DirectoryNotFoundException">Thrown if the directory specified in the path does not exist.</exception>
    /// <exception cref="IOException">Thrown if an I/O error occurs while opening the file.</exception>
    /// <exception cref="SecurityException">Thrown if the caller does not have the required permission to access the file.</exception>
    /// <exception cref="UnauthorizedAccessException">Thrown if the caller does not have the required permission or the path is a directory.</exception>
    /// <exception cref="JsonException">Thrown if the file contains invalid JSON.</exception>
    public static async Task<RzTheme?> LoadFromFileAsync(string filePath)
    {
        if (string.IsNullOrEmpty(filePath))
        {
            throw new ArgumentNullException(nameof(filePath));
        }
        try
        {
            await using var stream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read);
            return await LoadFromStreamAsync(stream);
        }
        catch (Exception ex) when (ex is FileNotFoundException or DirectoryNotFoundException or IOException or SecurityException or UnauthorizedAccessException)
        {
            // Re-throw common file access exceptions with more context.
            throw new IOException($"Failed to load theme from file path '{filePath}'. See inner exception for details.", ex);
        }
    }
}
</file>

<file path="wwwroot/js/antiforgerySnippet.js">
if (!document.body.attributes.__htmx_antiforgery) {
    document.addEventListener("htmx:configRequest", evt => {
        let httpVerb = evt.detail.verb.toUpperCase();
        if (httpVerb === 'GET') return;
        let antiforgery = htmx.config.antiforgery;
        if (antiforgery) {
            // already specified on the form, short circuit
            if (evt.detail.parameters[antiforgery.formFieldName])
                return;
            if (antiforgery.headerName) {
                evt.detail.headers[antiforgery.headerName]
                    = antiforgery.requestToken;
            } else {
                evt.detail.parameters[antiforgery.formFieldName]
                    = antiforgery.requestToken;
            }
        }
    });
    document.addEventListener("htmx:afterOnLoad", evt => {
        if (evt.detail.boosted) {
            const parser = new DOMParser();
            const html = parser.parseFromString(evt.detail.xhr.responseText, 'text/html');
            const selector = 'meta[name=htmx-config]';
            const config = html.querySelector(selector);
            if (config) {
                const current = document.querySelector(selector);
                // only change the anti-forgery token
                const key = 'antiforgery';
                htmx.config[key] = JSON.parse(config.attributes['content'].value)[key];
                // update DOM, probably not necessary, but for sanity's sake
                current.replaceWith(config);
            }
        }
    });
    document.body.attributes.__htmx_antiforgery = true;
}
</file>

<file path="wwwroot/js/antiforgerySnippet.min.js">
document.body.attributes.__htmx_antiforgery||(document.addEventListener("htmx:configRequest",t=>{if(t.detail.verb.toUpperCase()==="GET")return;let e=htmx.config.antiforgery;if(e){if(t.detail.parameters[e.formFieldName])return;e.headerName?t.detail.headers[e.headerName]=e.requestToken:t.detail.parameters[e.formFieldName]=e.requestToken}}),document.addEventListener("htmx:afterOnLoad",t=>{if(t.detail.boosted){const e=new DOMParser().parseFromString(t.detail.xhr.responseText,"text/html"),a="meta[name=htmx-config]",r=e.querySelector(a);if(r){const i=document.querySelector(a),n="antiforgery";htmx.config[n]=JSON.parse(r.attributes.content.value)[n],i.replaceWith(r)}}}),document.body.attributes.__htmx_antiforgery=!0);
</file>

<file path="wwwroot/js/rizzyui-csp.es.js">
var flushPending = false;
var flushing = false;
var queue = [];
var lastFlushedIndex = -1;
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  let index = queue.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex)
    queue.splice(index, 1);
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i2 = 0; i2 < queue.length; i2++) {
    queue[i2]();
    lastFlushedIndex = i2;
  }
  queue.length = 0;
  lastFlushedIndex = -1;
  flushing = false;
}
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  } });
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup2 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i2) => i2());
      };
    }
    el._x_effects.add(effectReference);
    cleanup2 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup2();
  }];
}
function watch(getter, callback) {
  let firstTime = true;
  let oldValue;
  let effectReference = effect(() => {
    let value = getter();
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  });
  return () => release(effectReference);
}
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds.push(callback);
  }
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i2) => i2());
      delete el._x_attributeCleanups[name];
    }
  });
}
function cleanupElement(el) {
  el._x_effects?.forEach(dequeueJob);
  while (el._x_cleanups?.length)
    el._x_cleanups.pop()();
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var queuedMutations = [];
function flushObserver() {
  let records = observer.takeRecords();
  queuedMutations.push(() => records.length > 0 && onMutate(records));
  let queueLengthWhenTriggered = queuedMutations.length;
  queueMicrotask(() => {
    if (queuedMutations.length === queueLengthWhenTriggered) {
      while (queuedMutations.length > 0)
        queuedMutations.shift()();
    }
  });
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = /* @__PURE__ */ new Set();
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < mutations.length; i2++) {
    if (mutations[i2].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i2].type === "childList") {
      mutations[i2].removedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (!node._x_marker)
          return;
        removedNodes.add(node);
      });
      mutations[i2].addedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (removedNodes.has(node)) {
          removedNodes.delete(node);
          return;
        }
        if (node._x_marker)
          return;
        addedNodes.push(node);
      });
    }
    if (mutations[i2].type === "attributes") {
      let el = mutations[i2].target;
      let name = mutations[i2].attributeName;
      let oldValue = mutations[i2].oldValue;
      let add2 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add2();
      } else if (el.hasAttribute(name)) {
        remove();
        add2();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i2) => i2(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.some((i2) => i2.contains(node)))
      continue;
    onElRemoveds.forEach((i2) => i2(node));
  }
  for (let node of addedNodes) {
    if (!node.isConnected)
      continue;
    onElAddeds.forEach((i2) => i2(node));
  }
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data2, referenceNode) {
  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
  };
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  return new Proxy({ objects }, mergeProxyTrap);
}
var mergeProxyTrap = {
  ownKeys({ objects }) {
    return Array.from(
      new Set(objects.flatMap((i2) => Object.keys(i2)))
    );
  },
  has({ objects }, name) {
    if (name == Symbol.unscopables)
      return false;
    return objects.some(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
    );
  },
  get({ objects }, name, thisProxy) {
    if (name == "toJSON")
      return collapseProxies;
    return Reflect.get(
      objects.find(
        (obj) => Reflect.has(obj, name)
      ) || {},
      name,
      thisProxy
    );
  },
  set({ objects }, name, value, thisProxy) {
    const target = objects.find(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name)
    ) || objects[objects.length - 1];
    const descriptor = Object.getOwnPropertyDescriptor(target, name);
    if (descriptor?.set && descriptor?.get)
      return descriptor.set.call(thisProxy, value) || true;
    return Reflect.set(target, name, value);
  }
};
function collapseProxies() {
  let keys = Reflect.ownKeys(this);
  return keys.reduce((acc, key) => {
    acc[key] = Reflect.get(this, key);
    return acc;
  }, {});
}
function initInterceptors(data2) {
  let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      if (typeof value === "object" && value !== null && value.__v_skip)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data2, path, key);
      } else {
        if (isObject2(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data2);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data2, path, key) {
      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data2, path, key) => {
        let innerValue = initialValue.initialize(data2, path, key);
        obj.initialValue = innerValue;
        return initialize(data2, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  let memoizedUtilities = getUtilities(el);
  Object.entries(magics).forEach(([name, callback]) => {
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, memoizedUtilities);
      },
      enumerable: false
    });
  });
  return obj;
}
function getUtilities(el) {
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  let utils = { interceptor, ...utilities };
  onElRemoved(el, cleanup2);
  return utils;
}
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e2) {
    handleError(e2, el, expression);
  }
}
function handleError(error2, el, expression = void 0) {
  error2 = Object.assign(
    error2 ?? { message: "No error message given." },
    { el, expression }
  );
  console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error2;
  }, 0);
}
var shouldAutoEvaluateFunctions = true;
function dontAutoEvaluateFunctions(callback) {
  let cache = shouldAutoEvaluateFunctions;
  shouldAutoEvaluateFunctions = false;
  let result = callback();
  shouldAutoEvaluateFunctions = cache;
  return result;
}
function evaluate$1(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [], context } = {}) => {
    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      let func2 = new AsyncFunction(
        ["__self", "scope"],
        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
      );
      Object.defineProperty(func2, "name", {
        value: `[Alpine] ${expression}`
      });
      return func2;
    } catch (error2) {
      handleError(error2, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [], context } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope2, ...dataStack]);
    if (typeof func === "function") {
      let promise = func.call(context, func, completeScope).catch((error2) => handleError(error2, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope2, params, el) {
  if (shouldAutoEvaluateFunctions && typeof value === "function") {
    let result = value.apply(scope2, params);
    if (result instanceof Promise) {
      result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i2) => receiver(i2));
  } else {
    receiver(value);
  }
}
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
  return {
    before(directive2) {
      if (!directiveHandlers[directive2]) {
        console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
        return;
      }
      const pos = directiveOrder.indexOf(directive2);
      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directiveExists(name) {
  return Object.keys(directiveHandlers).includes(name);
}
function directives(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives2.map((directive2) => {
    return getDirectiveHandler(el, directive2);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = /* @__PURE__ */ new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities(el) {
  let cleanups = [];
  let cleanup2 = (callback) => cleanups.push(callback);
  let [effect3, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect3,
    cleanup: cleanup2,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate$1.bind(evaluate$1, el)
  };
  let doCleanup = () => cleanups.forEach((i2) => i2());
  return [utilities, doCleanup];
}
function getDirectiveHandler(el, directive2) {
  let noop = () => {
  };
  let handler4 = directiveHandlers[directive2.type] || noop;
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  onAttributeRemoved(el, directive2.original, cleanup2);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler4.inline && handler4.inline(el, directive2, utilities);
    handler4 = handler4.bind(handler4, el, directive2, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
  };
  fullHandler.runCleanups = cleanup2;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into = (i2) => i2;
function toTransformedAttributes(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
      return transform(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({ name }) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i2) => i2.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport"
];
function byPriority(a2, b) {
  let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      // Allows events to pass the shadow DOM barrier.
      composed: true,
      cancelable: true
    })
  );
}
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback);
    node = node.nextElementSibling;
  }
}
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started = false;
function start() {
  if (started)
    warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started = true;
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
  setTimeout(() => {
    warnAboutMissingPlugins();
  });
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
var initInterceptors2 = [];
function interceptInit(callback) {
  initInterceptors2.push(callback);
}
var markerDispenser = 1;
function initTree(el, walker = walk, intercept = () => {
}) {
  if (findClosest(el, (i2) => i2._x_ignore))
    return;
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      if (el2._x_marker)
        return;
      intercept(el2, skip);
      initInterceptors2.forEach((i2) => i2(el2, skip));
      directives(el2, el2.attributes).forEach((handle) => handle());
      if (!el2._x_ignore)
        el2._x_marker = markerDispenser++;
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root, walker = walk) {
  walker(root, (el) => {
    cleanupElement(el);
    cleanupAttributes(el);
    delete el._x_marker;
  });
}
function warnAboutMissingPlugins() {
  let pluginDirectives = [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ];
  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
    if (directiveExists(directive2))
      return;
    selectors.some((selector) => {
      if (document.querySelector(selector)) {
        warn(`found "${selector}", but missing ${plugin2} plugin`);
        return true;
      }
    });
  });
}
var tickStack = [];
var isHolding = false;
function nextTick(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
  return new Promise((res) => {
    tickStack.push(() => {
      callback();
      res();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i2) => {
    if (el.classList.contains(i2)) {
      el.classList.remove(i2);
      removed.push(i2);
    }
  });
  forAdd.forEach((i2) => {
    if (!el.classList.contains(i2)) {
      el.classList.add(i2);
      added.push(i2);
    }
  });
  return () => {
    removed.forEach((i2) => el.classList.add(i2));
    added.forEach((i2) => el.classList.remove(i2));
  };
}
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "function")
    expression = evaluate2(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    "enter": (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    "leave": (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
  let delay3 = modifierValue$1(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue$1(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick2(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
    el._x_transition.out(() => {
    }, () => resolve(hide));
    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick2(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i2]) => i2?.());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e2) => {
          if (!e2.isFromCancelledTransition)
            throw e2;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start2);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay3 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay3);
      reachedEnd = true;
    });
  });
}
function modifierValue$1(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function onlyDuringClone(callback) {
  return (...args) => isCloning && callback(...args);
}
var interceptors = [];
function interceptClone(callback) {
  interceptors.push(callback);
}
function cloneNode(from, to) {
  interceptors.forEach((i2) => i2(from, to));
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    initTree(to, (el, callback) => {
      callback(el, () => {
      });
    });
  });
  isCloning = false;
}
var isCloningLegacy = false;
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  isCloningLegacy = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
  isCloningLegacy = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache);
}
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty(el, name, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (isRadio$1(el)) {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      if (typeof value === "boolean") {
        el.checked = safeParseBoolean(el.value) === value;
      } else {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    }
  } else if (isCheckbox(el)) {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value === void 0 ? "" : value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttributeAndProperty(el, name, value) {
  bindAttribute(el, name, value);
  setPropertyIfChanged(el, name, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function safeParseBoolean(rawValue) {
  if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
    return true;
  }
  if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
    return false;
  }
  return rawValue ? Boolean(rawValue) : null;
}
var booleanAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function isBooleanAttr(attrName) {
  return booleanAttributes.has(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding(el, name, fallback);
}
function extractProp(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions(() => {
      return evaluate$1(el, binding.expression);
    });
  }
  return getAttributeBinding(el, name, fallback);
}
function getAttributeBinding(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function isCheckbox(el) {
  return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
}
function isRadio$1(el) {
  return el.type === "radio" || el.localName === "ui-radio";
}
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this, args = arguments;
    const later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash;
  let reference = effect(() => {
    let outer = outerGet();
    let inner = innerGet();
    if (firstRun) {
      innerSet(cloneIfObject(outer));
      firstRun = false;
    } else {
      let outerHashLatest = JSON.stringify(outer);
      let innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        innerSet(cloneIfObject(outer));
      } else if (outerHashLatest !== innerHashLatest) {
        outerSet(cloneIfObject(inner));
      } else ;
    }
    outerHash = JSON.stringify(outerGet());
    JSON.stringify(innerGet());
  });
  return () => {
    release(reference);
  };
}
function cloneIfObject(value) {
  return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
}
function plugin(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i2) => i2(alpine_default));
}
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  initInterceptors(stores[name]);
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
}
function getStores() {
  return stores;
}
var binds = {};
function bind2(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    return applyBindingsObject(name, getBindings());
  } else {
    binds[name] = getBindings;
  }
  return () => {
  };
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives(el, attributes, original).map((handle) => {
    cleanupRunners.push(handle.runCleanups);
    handle();
  });
  return () => {
    while (cleanupRunners.length)
      cleanupRunners.pop()();
  };
}
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine$1 = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.15.0",
  flushAndStopDeferringMutations,
  dontAutoEvaluateFunctions,
  disableEffectScheduling,
  startObservingMutations,
  stopObservingMutations,
  setReactivityEngine,
  onAttributeRemoved,
  onAttributesAdded,
  closestDataStack,
  skipDuringClone,
  onlyDuringClone,
  addRootSelector,
  addInitSelector,
  interceptClone,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  interceptInit,
  setEvaluator,
  mergeProxies,
  extractProp,
  findClosest,
  onElRemoved,
  closestRoot,
  destroyTree,
  interceptor,
  // INTERNAL: not public API and is subject to change without major release.
  transition,
  // INTERNAL
  setStyles,
  // INTERNAL
  mutateDom,
  directive,
  entangle,
  throttle,
  debounce,
  evaluate: evaluate$1,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  // INTERNAL
  cloneNode,
  // INTERNAL
  bound: getBinding,
  $data: scope,
  watch,
  walk,
  data,
  bind: bind2
};
var alpine_default = Alpine$1;
var Token = class {
  constructor(type, value, start2, end) {
    this.type = type;
    this.value = value;
    this.start = start2;
    this.end = end;
  }
};
var Tokenizer = class {
  constructor(input) {
    this.input = input;
    this.position = 0;
    this.tokens = [];
  }
  tokenize() {
    while (this.position < this.input.length) {
      this.skipWhitespace();
      if (this.position >= this.input.length)
        break;
      const char = this.input[this.position];
      if (this.isDigit(char)) {
        this.readNumber();
      } else if (this.isAlpha(char) || char === "_" || char === "$") {
        this.readIdentifierOrKeyword();
      } else if (char === '"' || char === "'") {
        this.readString();
      } else if (char === "/" && this.peek() === "/") {
        this.skipLineComment();
      } else {
        this.readOperatorOrPunctuation();
      }
    }
    this.tokens.push(new Token("EOF", null, this.position, this.position));
    return this.tokens;
  }
  skipWhitespace() {
    while (this.position < this.input.length && /\s/.test(this.input[this.position])) {
      this.position++;
    }
  }
  skipLineComment() {
    while (this.position < this.input.length && this.input[this.position] !== "\n") {
      this.position++;
    }
  }
  isDigit(char) {
    return /[0-9]/.test(char);
  }
  isAlpha(char) {
    return /[a-zA-Z]/.test(char);
  }
  isAlphaNumeric(char) {
    return /[a-zA-Z0-9_$]/.test(char);
  }
  peek(offset2 = 1) {
    return this.input[this.position + offset2] || "";
  }
  readNumber() {
    const start2 = this.position;
    let hasDecimal = false;
    while (this.position < this.input.length) {
      const char = this.input[this.position];
      if (this.isDigit(char)) {
        this.position++;
      } else if (char === "." && !hasDecimal) {
        hasDecimal = true;
        this.position++;
      } else {
        break;
      }
    }
    const value = this.input.slice(start2, this.position);
    this.tokens.push(new Token("NUMBER", parseFloat(value), start2, this.position));
  }
  readIdentifierOrKeyword() {
    const start2 = this.position;
    while (this.position < this.input.length && this.isAlphaNumeric(this.input[this.position])) {
      this.position++;
    }
    const value = this.input.slice(start2, this.position);
    const keywords = ["true", "false", "null", "undefined", "new", "typeof", "void", "delete", "in", "instanceof"];
    if (keywords.includes(value)) {
      if (value === "true" || value === "false") {
        this.tokens.push(new Token("BOOLEAN", value === "true", start2, this.position));
      } else if (value === "null") {
        this.tokens.push(new Token("NULL", null, start2, this.position));
      } else if (value === "undefined") {
        this.tokens.push(new Token("UNDEFINED", void 0, start2, this.position));
      } else {
        this.tokens.push(new Token("KEYWORD", value, start2, this.position));
      }
    } else {
      this.tokens.push(new Token("IDENTIFIER", value, start2, this.position));
    }
  }
  readString() {
    const start2 = this.position;
    const quote = this.input[this.position];
    this.position++;
    let value = "";
    let escaped = false;
    while (this.position < this.input.length) {
      const char = this.input[this.position];
      if (escaped) {
        switch (char) {
          case "n":
            value += "\n";
            break;
          case "t":
            value += "	";
            break;
          case "r":
            value += "\r";
            break;
          case "\\":
            value += "\\";
            break;
          case quote:
            value += quote;
            break;
          default:
            value += char;
        }
        escaped = false;
      } else if (char === "\\") {
        escaped = true;
      } else if (char === quote) {
        this.position++;
        this.tokens.push(new Token("STRING", value, start2, this.position));
        return;
      } else {
        value += char;
      }
      this.position++;
    }
    throw new Error(`Unterminated string starting at position ${start2}`);
  }
  readOperatorOrPunctuation() {
    const start2 = this.position;
    const char = this.input[this.position];
    const next = this.peek();
    const nextNext = this.peek(2);
    if (char === "=" && next === "=" && nextNext === "=") {
      this.position += 3;
      this.tokens.push(new Token("OPERATOR", "===", start2, this.position));
    } else if (char === "!" && next === "=" && nextNext === "=") {
      this.position += 3;
      this.tokens.push(new Token("OPERATOR", "!==", start2, this.position));
    } else if (char === "=" && next === "=") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "==", start2, this.position));
    } else if (char === "!" && next === "=") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "!=", start2, this.position));
    } else if (char === "<" && next === "=") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "<=", start2, this.position));
    } else if (char === ">" && next === "=") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", ">=", start2, this.position));
    } else if (char === "&" && next === "&") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "&&", start2, this.position));
    } else if (char === "|" && next === "|") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "||", start2, this.position));
    } else if (char === "+" && next === "+") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "++", start2, this.position));
    } else if (char === "-" && next === "-") {
      this.position += 2;
      this.tokens.push(new Token("OPERATOR", "--", start2, this.position));
    } else {
      this.position++;
      const type = "()[]{},.;:?".includes(char) ? "PUNCTUATION" : "OPERATOR";
      this.tokens.push(new Token(type, char, start2, this.position));
    }
  }
};
var Parser = class {
  constructor(tokens) {
    this.tokens = tokens;
    this.position = 0;
  }
  parse() {
    if (this.isAtEnd()) {
      throw new Error("Empty expression");
    }
    const expr = this.parseExpression();
    this.match("PUNCTUATION", ";");
    if (!this.isAtEnd()) {
      throw new Error(`Unexpected token: ${this.current().value}`);
    }
    return expr;
  }
  parseExpression() {
    return this.parseAssignment();
  }
  parseAssignment() {
    const expr = this.parseTernary();
    if (this.match("OPERATOR", "=")) {
      const value = this.parseAssignment();
      if (expr.type === "Identifier" || expr.type === "MemberExpression") {
        return {
          type: "AssignmentExpression",
          left: expr,
          operator: "=",
          right: value
        };
      }
      throw new Error("Invalid assignment target");
    }
    return expr;
  }
  parseTernary() {
    const expr = this.parseLogicalOr();
    if (this.match("PUNCTUATION", "?")) {
      const consequent = this.parseExpression();
      this.consume("PUNCTUATION", ":");
      const alternate = this.parseExpression();
      return {
        type: "ConditionalExpression",
        test: expr,
        consequent,
        alternate
      };
    }
    return expr;
  }
  parseLogicalOr() {
    let expr = this.parseLogicalAnd();
    while (this.match("OPERATOR", "||")) {
      const operator = this.previous().value;
      const right = this.parseLogicalAnd();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseLogicalAnd() {
    let expr = this.parseEquality();
    while (this.match("OPERATOR", "&&")) {
      const operator = this.previous().value;
      const right = this.parseEquality();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseEquality() {
    let expr = this.parseRelational();
    while (this.match("OPERATOR", "==", "!=", "===", "!==")) {
      const operator = this.previous().value;
      const right = this.parseRelational();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseRelational() {
    let expr = this.parseAdditive();
    while (this.match("OPERATOR", "<", ">", "<=", ">=")) {
      const operator = this.previous().value;
      const right = this.parseAdditive();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseAdditive() {
    let expr = this.parseMultiplicative();
    while (this.match("OPERATOR", "+", "-")) {
      const operator = this.previous().value;
      const right = this.parseMultiplicative();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseMultiplicative() {
    let expr = this.parseUnary();
    while (this.match("OPERATOR", "*", "/", "%")) {
      const operator = this.previous().value;
      const right = this.parseUnary();
      expr = {
        type: "BinaryExpression",
        operator,
        left: expr,
        right
      };
    }
    return expr;
  }
  parseUnary() {
    if (this.match("OPERATOR", "++", "--")) {
      const operator = this.previous().value;
      const argument = this.parseUnary();
      return {
        type: "UpdateExpression",
        operator,
        argument,
        prefix: true
      };
    }
    if (this.match("OPERATOR", "!", "-", "+")) {
      const operator = this.previous().value;
      const argument = this.parseUnary();
      return {
        type: "UnaryExpression",
        operator,
        argument,
        prefix: true
      };
    }
    return this.parsePostfix();
  }
  parsePostfix() {
    let expr = this.parseMember();
    if (this.match("OPERATOR", "++", "--")) {
      const operator = this.previous().value;
      return {
        type: "UpdateExpression",
        operator,
        argument: expr,
        prefix: false
      };
    }
    return expr;
  }
  parseMember() {
    let expr = this.parsePrimary();
    while (true) {
      if (this.match("PUNCTUATION", ".")) {
        const property = this.consume("IDENTIFIER");
        expr = {
          type: "MemberExpression",
          object: expr,
          property: { type: "Identifier", name: property.value },
          computed: false
        };
      } else if (this.match("PUNCTUATION", "[")) {
        const property = this.parseExpression();
        this.consume("PUNCTUATION", "]");
        expr = {
          type: "MemberExpression",
          object: expr,
          property,
          computed: true
        };
      } else if (this.match("PUNCTUATION", "(")) {
        const args = this.parseArguments();
        expr = {
          type: "CallExpression",
          callee: expr,
          arguments: args
        };
      } else {
        break;
      }
    }
    return expr;
  }
  parseArguments() {
    const args = [];
    if (!this.check("PUNCTUATION", ")")) {
      do {
        args.push(this.parseExpression());
      } while (this.match("PUNCTUATION", ","));
    }
    this.consume("PUNCTUATION", ")");
    return args;
  }
  parsePrimary() {
    if (this.match("NUMBER")) {
      return { type: "Literal", value: this.previous().value };
    }
    if (this.match("STRING")) {
      return { type: "Literal", value: this.previous().value };
    }
    if (this.match("BOOLEAN")) {
      return { type: "Literal", value: this.previous().value };
    }
    if (this.match("NULL")) {
      return { type: "Literal", value: null };
    }
    if (this.match("UNDEFINED")) {
      return { type: "Literal", value: void 0 };
    }
    if (this.match("IDENTIFIER")) {
      return { type: "Identifier", name: this.previous().value };
    }
    if (this.match("PUNCTUATION", "(")) {
      const expr = this.parseExpression();
      this.consume("PUNCTUATION", ")");
      return expr;
    }
    if (this.match("PUNCTUATION", "[")) {
      return this.parseArrayLiteral();
    }
    if (this.match("PUNCTUATION", "{")) {
      return this.parseObjectLiteral();
    }
    throw new Error(`Unexpected token: ${this.current().type} "${this.current().value}"`);
  }
  parseArrayLiteral() {
    const elements = [];
    while (!this.check("PUNCTUATION", "]") && !this.isAtEnd()) {
      elements.push(this.parseExpression());
      if (this.match("PUNCTUATION", ",")) {
        if (this.check("PUNCTUATION", "]")) {
          break;
        }
      } else {
        break;
      }
    }
    this.consume("PUNCTUATION", "]");
    return {
      type: "ArrayExpression",
      elements
    };
  }
  parseObjectLiteral() {
    const properties = [];
    while (!this.check("PUNCTUATION", "}") && !this.isAtEnd()) {
      let key;
      let computed = false;
      if (this.match("STRING")) {
        key = { type: "Literal", value: this.previous().value };
      } else if (this.match("IDENTIFIER")) {
        const name = this.previous().value;
        key = { type: "Identifier", name };
      } else if (this.match("PUNCTUATION", "[")) {
        key = this.parseExpression();
        computed = true;
        this.consume("PUNCTUATION", "]");
      } else {
        throw new Error("Expected property key");
      }
      this.consume("PUNCTUATION", ":");
      const value = this.parseExpression();
      properties.push({
        type: "Property",
        key,
        value,
        computed,
        shorthand: false
      });
      if (this.match("PUNCTUATION", ",")) {
        if (this.check("PUNCTUATION", "}")) {
          break;
        }
      } else {
        break;
      }
    }
    this.consume("PUNCTUATION", "}");
    return {
      type: "ObjectExpression",
      properties
    };
  }
  match(...args) {
    for (let i2 = 0; i2 < args.length; i2++) {
      const arg = args[i2];
      if (i2 === 0 && args.length > 1) {
        const type = arg;
        for (let j = 1; j < args.length; j++) {
          if (this.check(type, args[j])) {
            this.advance();
            return true;
          }
        }
        return false;
      } else if (args.length === 1) {
        if (this.checkType(arg)) {
          this.advance();
          return true;
        }
        return false;
      }
    }
    return false;
  }
  check(type, value) {
    if (this.isAtEnd())
      return false;
    if (value !== void 0) {
      return this.current().type === type && this.current().value === value;
    }
    return this.current().type === type;
  }
  checkType(type) {
    if (this.isAtEnd())
      return false;
    return this.current().type === type;
  }
  advance() {
    if (!this.isAtEnd())
      this.position++;
    return this.previous();
  }
  isAtEnd() {
    return this.current().type === "EOF";
  }
  current() {
    return this.tokens[this.position];
  }
  previous() {
    return this.tokens[this.position - 1];
  }
  consume(type, value) {
    if (value !== void 0) {
      if (this.check(type, value))
        return this.advance();
      throw new Error(`Expected ${type} "${value}" but got ${this.current().type} "${this.current().value}"`);
    }
    if (this.check(type))
      return this.advance();
    throw new Error(`Expected ${type} but got ${this.current().type} "${this.current().value}"`);
  }
};
var Evaluator = class {
  evaluate({ node, scope: scope2 = {}, context = null, allowGlobal = false, forceBindingRootScopeToFunctions = true }) {
    switch (node.type) {
      case "Literal":
        return node.value;
      case "Identifier":
        if (node.name in scope2) {
          const value2 = scope2[node.name];
          if (typeof value2 === "function") {
            return value2.bind(scope2);
          }
          return value2;
        }
        if (allowGlobal && typeof globalThis[node.name] !== "undefined") {
          const value2 = globalThis[node.name];
          if (typeof value2 === "function") {
            return value2.bind(globalThis);
          }
          return value2;
        }
        throw new Error(`Undefined variable: ${node.name}`);
      case "MemberExpression":
        const object = this.evaluate({ node: node.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        if (object == null) {
          throw new Error("Cannot read property of null or undefined");
        }
        let memberValue;
        if (node.computed) {
          const property = this.evaluate({ node: node.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          memberValue = object[property];
        } else {
          memberValue = object[node.property.name];
        }
        if (typeof memberValue === "function") {
          if (forceBindingRootScopeToFunctions) {
            return memberValue.bind(scope2);
          } else {
            return memberValue.bind(object);
          }
        }
        return memberValue;
      case "CallExpression":
        const args = node.arguments.map((arg) => this.evaluate({ node: arg, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }));
        if (node.callee.type === "MemberExpression") {
          const obj = this.evaluate({ node: node.callee.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          let func;
          if (node.callee.computed) {
            const prop = this.evaluate({ node: node.callee.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            func = obj[prop];
          } else {
            func = obj[node.callee.property.name];
          }
          if (typeof func !== "function") {
            throw new Error("Value is not a function");
          }
          return func.apply(obj, args);
        } else {
          if (node.callee.type === "Identifier") {
            const name = node.callee.name;
            let func;
            if (name in scope2) {
              func = scope2[name];
            } else if (allowGlobal && typeof globalThis[name] !== "undefined") {
              func = globalThis[name];
            } else {
              throw new Error(`Undefined variable: ${name}`);
            }
            if (typeof func !== "function") {
              throw new Error("Value is not a function");
            }
            const thisContext = context !== null ? context : scope2;
            return func.apply(thisContext, args);
          } else {
            const callee = this.evaluate({ node: node.callee, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            if (typeof callee !== "function") {
              throw new Error("Value is not a function");
            }
            return callee.apply(context, args);
          }
        }
      case "UnaryExpression":
        const argument = this.evaluate({ node: node.argument, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        switch (node.operator) {
          case "!":
            return !argument;
          case "-":
            return -argument;
          case "+":
            return +argument;
          default:
            throw new Error(`Unknown unary operator: ${node.operator}`);
        }
      case "UpdateExpression":
        if (node.argument.type === "Identifier") {
          const name = node.argument.name;
          if (!(name in scope2)) {
            throw new Error(`Undefined variable: ${name}`);
          }
          const oldValue = scope2[name];
          if (node.operator === "++") {
            scope2[name] = oldValue + 1;
          } else if (node.operator === "--") {
            scope2[name] = oldValue - 1;
          }
          return node.prefix ? scope2[name] : oldValue;
        } else if (node.argument.type === "MemberExpression") {
          const obj = this.evaluate({ node: node.argument.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          const prop = node.argument.computed ? this.evaluate({ node: node.argument.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : node.argument.property.name;
          const oldValue = obj[prop];
          if (node.operator === "++") {
            obj[prop] = oldValue + 1;
          } else if (node.operator === "--") {
            obj[prop] = oldValue - 1;
          }
          return node.prefix ? obj[prop] : oldValue;
        }
        throw new Error("Invalid update expression target");
      case "BinaryExpression":
        const left = this.evaluate({ node: node.left, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        const right = this.evaluate({ node: node.right, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        switch (node.operator) {
          case "+":
            return left + right;
          case "-":
            return left - right;
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "&&":
            return left && right;
          case "||":
            return left || right;
          default:
            throw new Error(`Unknown binary operator: ${node.operator}`);
        }
      case "ConditionalExpression":
        const test = this.evaluate({ node: node.test, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        return test ? this.evaluate({ node: node.consequent, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : this.evaluate({ node: node.alternate, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
      case "AssignmentExpression":
        const value = this.evaluate({ node: node.right, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        if (node.left.type === "Identifier") {
          scope2[node.left.name] = value;
          return value;
        } else if (node.left.type === "MemberExpression") {
          const obj = this.evaluate({ node: node.left.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          if (node.left.computed) {
            const prop = this.evaluate({ node: node.left.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            obj[prop] = value;
          } else {
            obj[node.left.property.name] = value;
          }
          return value;
        }
        throw new Error("Invalid assignment target");
      case "ArrayExpression":
        return node.elements.map((el) => this.evaluate({ node: el, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }));
      case "ObjectExpression":
        const result = {};
        for (const prop of node.properties) {
          const key = prop.computed ? this.evaluate({ node: prop.key, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : prop.key.type === "Identifier" ? prop.key.name : this.evaluate({ node: prop.key, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          const value2 = this.evaluate({ node: prop.value, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          result[key] = value2;
        }
        return result;
      default:
        throw new Error(`Unknown node type: ${node.type}`);
    }
  }
};
function generateRuntimeFunction(expression) {
  try {
    const tokenizer = new Tokenizer(expression);
    const tokens = tokenizer.tokenize();
    const parser = new Parser(tokens);
    const ast = parser.parse();
    const evaluator = new Evaluator();
    return function(options = {}) {
      const { scope: scope2 = {}, context = null, allowGlobal = false, forceBindingRootScopeToFunctions = false } = options;
      return evaluator.evaluate({ node: ast, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
    };
  } catch (error2) {
    throw new Error(`CSP Parser Error: ${error2.message}`);
  }
}
function cspEvaluator(el, expression) {
  let dataStack = generateDataStack(el);
  if (typeof expression === "function") {
    return generateEvaluatorFromFunction(dataStack, expression);
  }
  let evaluator = generateEvaluator(el, expression, dataStack);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateDataStack(el) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  return [overriddenMagics, ...closestDataStack(el)];
}
function generateEvaluator(el, expression, dataStack) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    let completeScope = mergeProxies([scope2, ...dataStack]);
    let evaluate2 = generateRuntimeFunction(expression);
    let returnValue = evaluate2({
      scope: completeScope,
      allowGlobal: true,
      forceBindingRootScopeToFunctions: true
    });
    if (shouldAutoEvaluateFunctions && typeof returnValue === "function") {
      let nextReturnValue = returnValue.apply(returnValue, params);
      if (nextReturnValue instanceof Promise) {
        nextReturnValue.then((i2) => receiver(i2));
      } else {
        receiver(nextReturnValue);
      }
    } else if (typeof returnValue === "object" && returnValue instanceof Promise) {
      returnValue.then((i2) => receiver(i2));
    } else {
      receiver(returnValue);
    }
  };
}
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return (val) => !!map[val];
}
var EMPTY_OBJ = Object.freeze({});
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap = /* @__PURE__ */ new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol("iterate");
var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function isEffect(fn) {
  return fn && fn._isEffect === true;
}
function effect2(fn, options = EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }
  const effect3 = createReactiveEffect(fn, options);
  if (!options.lazy) {
    effect3();
  }
  return effect3;
}
function stop(effect3) {
  if (effect3.active) {
    cleanup(effect3);
    if (effect3.options.onStop) {
      effect3.options.onStop();
    }
    effect3.active = false;
  }
}
var uid = 0;
function createReactiveEffect(fn, options) {
  const effect3 = function reactiveEffect() {
    if (!effect3.active) {
      return fn();
    }
    if (!effectStack.includes(effect3)) {
      cleanup(effect3);
      try {
        enableTracking();
        effectStack.push(effect3);
        activeEffect = effect3;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };
  effect3.id = uid++;
  effect3.allowRecurse = !!options.allowRecurse;
  effect3._isEffect = true;
  effect3.active = true;
  effect3.raw = fn;
  effect3.deps = [];
  effect3.options = options;
  return effect3;
}
function cleanup(effect3) {
  const { deps } = effect3;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect3);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!shouldTrack || activeEffect === void 0) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add2 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect3) => {
        if (effect3 !== activeEffect || effect3.allowRecurse) {
          effects.add(effect3);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add2);
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add2(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add2(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          add2(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          add2(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const run = (effect3) => {
    if (effect3.options.onTrigger) {
      effect3.options.onTrigger({
        effect: effect3,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect3.options.scheduler) {
      effect3.options.scheduler(effect3);
    } else {
      effect3();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
var get2 = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject(res)) {
      return isReadonly ? readonly(res) : reactive2(res);
    }
    return res;
  };
}
var set2 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get2,
  set: set2,
  deleteProperty,
  has,
  ownKeys: ownKeys$1
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => isObject(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done: done2 } = innerIterator.next();
        return done2 ? { value, done: done2 } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done2
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (target && target[
    "__v_isReadonly"
    /* IS_READONLY */
  ]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* RAW */
  ] && !(isReadonly && target[
    "__v_isReactive"
    /* IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  return observed && toRaw(observed[
    "__v_raw"
    /* RAW */
  ]) || observed;
}
function isRef(r2) {
  return Boolean(r2 && r2.__v_isRef === true);
}
magic("nextTick", () => nextTick);
magic("dispatch", (el) => dispatch.bind(dispatch, el));
magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
  let evaluate2 = evaluateLater2(key);
  let getter = () => {
    let value;
    evaluate2((i2) => value = i2);
    return value;
  };
  let unwatch = watch(getter, callback);
  cleanup2(unwatch);
});
magic("store", getStores);
magic("data", (el) => scope(el));
magic("root", (el) => closestRoot(el));
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  findClosest(el, (i2) => {
    if (i2._x_refs)
      refObjects.push(i2._x_refs);
  });
  return refObjects;
}
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}
magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
  let cacheKey = `${name}${key ? `-${key}` : ""}`;
  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
});
interceptClone((from, to) => {
  if (from._x_id) {
    to._x_id = from._x_id;
  }
});
function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
  if (!el._x_id)
    el._x_id = {};
  if (el._x_id[cacheKey])
    return el._x_id[cacheKey];
  let output = callback();
  el._x_id[cacheKey] = output;
  cleanup2(() => {
    delete el._x_id[cacheKey];
  });
  return output;
}
magic("el", (el) => el);
warnMissingPluginMagic("Focus", "focus", "focus");
warnMissingPluginMagic("Persist", "persist", "persist");
function warnMissingPluginMagic(name, magicName, slug) {
  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
  let func = evaluateLater2(expression);
  let innerGet = () => {
    let result;
    func((i2) => result = i2);
    return result;
  };
  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { "__placeholder": val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle(
      {
        get() {
          return outerGet();
        },
        set(value) {
          outerSet(value);
        }
      },
      {
        get() {
          return innerGet();
        },
        set(value) {
          innerSet(value);
        }
      }
    );
    cleanup2(releaseEntanglement);
  });
});
directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = getTarget(expression);
  let clone2 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone2;
  clone2._x_teleportBack = el;
  el.setAttribute("data-teleport-template", true);
  clone2.setAttribute("data-teleport-target", true);
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone2.addEventListener(eventName, (e2) => {
        e2.stopPropagation();
        el.dispatchEvent(new e2.constructor(e2.type, e2));
      });
    });
  }
  addScopeToNode(clone2, {}, el);
  let placeInDom = (clone3, target2, modifiers2) => {
    if (modifiers2.includes("prepend")) {
      target2.parentNode.insertBefore(clone3, target2);
    } else if (modifiers2.includes("append")) {
      target2.parentNode.insertBefore(clone3, target2.nextSibling);
    } else {
      target2.appendChild(clone3);
    }
  };
  mutateDom(() => {
    placeInDom(clone2, target, modifiers);
    skipDuringClone(() => {
      initTree(clone2);
    })();
  });
  el._x_teleportPutBack = () => {
    let target2 = getTarget(expression);
    mutateDom(() => {
      placeInDom(el._x_teleport, target2, modifiers);
    });
  };
  cleanup2(
    () => mutateDom(() => {
      clone2.remove();
      destroyTree(clone2);
    })
  );
});
var teleportContainerDuringClone = document.createElement("div");
function getTarget(expression) {
  let target = skipDuringClone(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone;
  })();
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  return target;
}
var handler = () => {
};
handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup2(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);
directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
  effect3(evaluateLater(el, expression));
}));
function on(el, event2, modifiers, callback) {
  let listenerTarget = el;
  let handler4 = (e2) => callback(e2);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
  if (modifiers.includes("dot"))
    event2 = dotSyntax(event2);
  if (modifiers.includes("camel"))
    event2 = camelCase2(event2);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = debounce(handler4, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = throttle(handler4, wait);
  }
  if (modifiers.includes("prevent"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.preventDefault();
      next(e2);
    });
  if (modifiers.includes("stop"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.stopPropagation();
      next(e2);
    });
  if (modifiers.includes("once")) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      next(e2);
      listenerTarget.removeEventListener(event2, handler4, options);
    });
  }
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (el.contains(e2.target))
        return;
      if (e2.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e2);
    });
  }
  if (modifiers.includes("self"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.target === el && next(e2);
    });
  if (isKeyEvent(event2) || isClickEvent(event2)) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
        return;
      }
      next(e2);
    });
  }
  listenerTarget.addEventListener(event2, handler4, options);
  return () => {
    listenerTarget.removeEventListener(event2, handler4, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  if ([" ", "_"].includes(
    subject
  ))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event2) {
  return ["keydown", "keyup"].includes(event2);
}
function isClickEvent(event2) {
  return ["contextmenu", "click", "mouse"].some((i2) => event2.includes(i2));
}
function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
  let keyModifiers = modifiers.filter((i2) => {
    return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(i2);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e2[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (isClickEvent(e2.type))
        return false;
      if (keyToModifiers(e2.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    "ctrl": "control",
    "slash": "/",
    "space": " ",
    "spacebar": " ",
    "cmd": "meta",
    "esc": "escape",
    "up": "arrow-up",
    "down": "arrow-down",
    "left": "arrow-left",
    "right": "arrow-right",
    "period": ".",
    "comma": ",",
    "equal": "=",
    "minus": "-",
    "underscore": "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { "__placeholder": value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  let event2 = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning ? () => {
  } : on(el, event2, modifiers, (e2) => {
    setValue(getInputValue(el, modifiers, e2, getValue()));
  });
  if (modifiers.includes("fill")) {
    if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
      setValue(
        getInputValue(el, modifiers, { target: el }, getValue())
      );
    }
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup2(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on(el.form, "reset", [], (e2) => {
      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
    });
    cleanup2(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom(() => bind(el, "value", value));
    delete window.fromModel;
  };
  effect3(() => {
    let value = getValue();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue(el, modifiers, event2, currentValue) {
  return mutateDom(() => {
    if (event2 instanceof CustomEvent && event2.detail !== void 0)
      return event2.detail !== null && event2.detail !== void 0 ? event2.detail : event2.target.value;
    else if (isCheckbox(el)) {
      if (Array.isArray(currentValue)) {
        let newValue = null;
        if (modifiers.includes("number")) {
          newValue = safeParseNumber(event2.target.value);
        } else if (modifiers.includes("boolean")) {
          newValue = safeParseBoolean(event2.target.value);
        } else {
          newValue = event2.target.value;
        }
        return event2.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
      } else {
        return event2.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      if (modifiers.includes("number")) {
        return Array.from(event2.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        });
      } else if (modifiers.includes("boolean")) {
        return Array.from(event2.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseBoolean(rawValue);
        });
      }
      return Array.from(event2.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let newValue;
      if (isRadio$1(el)) {
        if (event2.target.checked) {
          newValue = event2.target.value;
        } else {
          newValue = currentValue;
        }
      } else {
        newValue = event2.target.value;
      }
      if (modifiers.includes("number")) {
        return safeParseNumber(newValue);
      } else if (modifiers.includes("boolean")) {
        return safeParseBoolean(newValue);
      } else if (modifiers.includes("trim")) {
        return newValue.trim();
      } else {
        return newValue;
      }
    }
  });
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate2(expression, {}, false);
  }
  return evaluate2(expression, {}, false);
}));
directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});
directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes(startingWith(":", into(prefix("bind:"))));
var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    getBindings((bindings) => {
      applyBindingsObject(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate2 = evaluateLater(el, expression);
  effect3(() => evaluate2((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom(() => bind(el, value, result, modifiers));
  }));
  cleanup2(() => {
    el._x_undoAddedClasses && el._x_undoAddedClasses();
    el._x_undoAddedStyles && el._x_undoAddedStyles();
  });
};
handler2.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive("bind", handler2);
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector(() => `[${prefix("data")}]`);
directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
  if (shouldSkipRegisteringDataDuringClone(el))
    return;
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data2 = evaluate$1(el, expression, { scope: dataProviderContext });
  if (data2 === void 0 || data2 === true)
    data2 = {};
  injectMagics(data2, el);
  let reactiveData = reactive(data2);
  initInterceptors(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate$1(el, reactiveData["init"]);
  cleanup2(() => {
    reactiveData["destroy"] && evaluate$1(el, reactiveData["destroy"]);
    undo();
  });
});
interceptClone((from, to) => {
  if (from._x_dataStack) {
    to._x_dataStack = from._x_dataStack;
    to.setAttribute("data-has-alpine-state", true);
  }
});
function shouldSkipRegisteringDataDuringClone(el) {
  if (!isCloning)
    return false;
  if (isCloningLegacy)
    return true;
  return el.hasAttribute("data-has-alpine-state");
}
directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
  let evaluate2 = evaluateLater(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once(
    (value) => value ? show() : hide(),
    (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    }
  );
  let oldValue;
  let firstTime = true;
  effect3(() => evaluate2((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(
    el,
    // the x-bind:key expression is stored for our use instead of evaluated.
    el._x_keyExpression || "index"
  );
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup2(() => {
    Object.values(el._x_lookup).forEach((el2) => mutateDom(
      () => {
        destroyTree(el2);
        el2.remove();
      }
    ));
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i2) => i2 + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject2(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => {
          if (keys.includes(value2))
            warn("Duplicate key on x-for", el);
          keys.push(value2);
        }, { scope: { index: key, ...scope2 } });
        scopes.push(scope2);
      });
    } else {
      for (let i2 = 0; i2 < items.length; i2++) {
        let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
        evaluateKey((value) => {
          if (keys.includes(value))
            warn("Duplicate key on x-for", el);
          keys.push(value);
        }, { scope: { index: i2, ...scope2 } });
        scopes.push(scope2);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i2 = 0; i2 < prevKeys.length; i2++) {
      let key = prevKeys[i2];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i2 = 0; i2 < keys.length; i2++) {
      let key = keys[i2];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i2, 0, key);
        adds.push([lastKey, i2]);
      } else if (prevIndex !== i2) {
        let keyInSpot = prevKeys.splice(i2, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i2, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i2 = 0; i2 < removes.length; i2++) {
      let key = removes[i2];
      if (!(key in lookup))
        continue;
      mutateDom(() => {
        destroyTree(lookup[key]);
        lookup[key].remove();
      });
      delete lookup[key];
    }
    for (let i2 = 0; i2 < moves.length; i2++) {
      let [keyInSpot, keyForSpot] = moves[i2];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        if (!elForSpot)
          warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i2 = 0; i2 < adds.length; i2++) {
      let [lastKey2, index] = adds[i2];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope2 = scopes[index];
      let key = keys[index];
      let clone2 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive(scope2);
      addScopeToNode(clone2, reactiveScope, templateEl);
      clone2._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom(() => {
        lastEl.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone2;
    }
    for (let i2 = 0; i2 < sames.length; i2++) {
      lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res = {};
  res.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res.item = item.replace(forIteratorRE, "").trim();
    res.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.collection = iteratorMatch[2].trim();
    }
  } else {
    res.item = item;
  }
  return res;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
    names.forEach((name, i2) => {
      scopeVariables[name] = item[i2];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler3() {
}
handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup2(() => delete root._x_refs[expression]);
};
directive("ref", handler3);
directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-if can only be used on a <template> tag", el);
  let evaluate2 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone2 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      el.after(clone2);
      skipDuringClone(() => initTree(clone2))();
    });
    el._x_currentIfEl = clone2;
    el._x_undoIf = () => {
      mutateDom(() => {
        destroyTree(clone2);
        clone2.remove();
      });
      delete el._x_currentIfEl;
    };
    return clone2;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect3(() => evaluate2((value) => {
    value ? show() : hide();
  }));
  cleanup2(() => el._x_undoIf && el._x_undoIf());
});
directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
  let names = evaluate2(expression);
  names.forEach((name) => setIdRoot(el, name));
});
interceptClone((from, to) => {
  if (from._x_ids) {
    to._x_ids = from._x_ids;
  }
});
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
  let evaluate2 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e2) => {
    evaluate2(() => {
    }, { scope: { "$event": e2 }, params: [e2] });
  });
  cleanup2(() => removeListener());
}));
warnMissingPluginDirective("Collapse", "collapse", "collapse");
warnMissingPluginDirective("Intersect", "intersect", "intersect");
warnMissingPluginDirective("Focus", "trap", "focus");
warnMissingPluginDirective("Mask", "mask", "mask");
function warnMissingPluginDirective(name, directiveName, slug) {
  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default.setEvaluator(cspEvaluator);
alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
var src_default$3 = alpine_default;
var module_default$3 = src_default$3;
function src_default$2(Alpine2) {
  Alpine2.directive("collapse", collapse);
  collapse.inline = (el, { modifiers }) => {
    if (!modifiers.includes("min"))
      return;
    el._x_doShow = () => {
    };
    el._x_doHide = () => {
    };
  };
  function collapse(el, { modifiers }) {
    let duration = modifierValue(modifiers, "duration", 250) / 1e3;
    let floor = modifierValue(modifiers, "min", 0);
    let fullyHide = !modifiers.includes("min");
    if (!el._x_isShown)
      el.style.height = `${floor}px`;
    if (!el._x_isShown && fullyHide)
      el.hidden = true;
    if (!el._x_isShown)
      el.style.overflow = "hidden";
    let setFunction = (el2, styles) => {
      let revertFunction = Alpine2.setStyles(el2, styles);
      return styles.height ? () => {
      } : revertFunction;
    };
    let transitionStyles = {
      transitionProperty: "height",
      transitionDuration: `${duration}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    el._x_transition = {
      in(before = () => {
      }, after = () => {
      }) {
        if (fullyHide)
          el.hidden = false;
        if (fullyHide)
          el.style.display = null;
        let current = el.getBoundingClientRect().height;
        el.style.height = "auto";
        let full = el.getBoundingClientRect().height;
        if (current === full) {
          current = floor;
        }
        Alpine2.transition(el, Alpine2.setStyles, {
          during: transitionStyles,
          start: { height: current + "px" },
          end: { height: full + "px" }
        }, () => el._x_isShown = true, () => {
          if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
            el.style.overflow = null;
          }
        });
      },
      out(before = () => {
      }, after = () => {
      }) {
        let full = el.getBoundingClientRect().height;
        Alpine2.transition(el, setFunction, {
          during: transitionStyles,
          start: { height: full + "px" },
          end: { height: floor + "px" }
        }, () => el.style.overflow = "hidden", () => {
          el._x_isShown = false;
          if (el.style.height == `${floor}px` && fullyHide) {
            el.style.display = "none";
            el.hidden = true;
          }
        });
      }
    };
  }
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "min") {
    let match = rawValue.match(/([0-9]+)px/);
    if (match)
      return match[1];
  }
  return rawValue;
}
var module_default$2 = src_default$2;
function src_default$1(Alpine2) {
  Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater2(expression);
    let options = {
      rootMargin: getRootMargin(modifiers),
      threshold: getThreshold(modifiers)
    };
    let observer2 = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting === (value === "leave"))
          return;
        evaluate2();
        modifiers.includes("once") && observer2.disconnect();
      });
    }, options);
    observer2.observe(el);
    cleanup2(() => {
      observer2.disconnect();
    });
  }));
}
function getThreshold(modifiers) {
  if (modifiers.includes("full"))
    return 0.99;
  if (modifiers.includes("half"))
    return 0.5;
  if (!modifiers.includes("threshold"))
    return 0;
  let threshold = modifiers[modifiers.indexOf("threshold") + 1];
  if (threshold === "100")
    return 1;
  if (threshold === "0")
    return 0;
  return Number(`.${threshold}`);
}
function getLengthValue(rawValue) {
  let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
  return match ? match[1] + (match[2] || "px") : void 0;
}
function getRootMargin(modifiers) {
  const key = "margin";
  const fallback = "0px 0px 0px 0px";
  const index = modifiers.indexOf(key);
  if (index === -1)
    return fallback;
  let values = [];
  for (let i2 = 1; i2 < 5; i2++) {
    values.push(getLengthValue(modifiers[index + i2] || ""));
  }
  values = values.filter((v2) => v2 !== void 0);
  return values.length ? values.join(" ").trim() : fallback;
}
var module_default$1 = src_default$1;
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
  return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = /* @__PURE__ */ function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return e2.key === "Tab" || e2.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i2) {
    if (fn(value)) {
      idx = i2;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event2) {
  return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n2) {
            return n2 === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
            return isTabbable(n2, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e2) {
    var target = getActualTarget(e2);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e2.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e2) {
    var target = getActualTarget(e2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e2.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e2.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e2.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e2) {
    if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
      e2.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e2)) {
      checkTab(e2);
      return;
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
function src_default(Alpine2) {
  let lastFocused;
  let currentFocused;
  window.addEventListener("focusin", () => {
    lastFocused = currentFocused;
    currentFocused = document.activeElement;
  });
  Alpine2.magic("focus", (el) => {
    let within = el;
    return {
      __noscroll: false,
      __wrapAround: false,
      within(el2) {
        within = el2;
        return this;
      },
      withoutScrolling() {
        this.__noscroll = true;
        return this;
      },
      noscroll() {
        this.__noscroll = true;
        return this;
      },
      withWrapAround() {
        this.__wrapAround = true;
        return this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(el2) {
        return isFocusable(el2);
      },
      previouslyFocused() {
        return lastFocused;
      },
      lastFocused() {
        return lastFocused;
      },
      focused() {
        return currentFocused;
      },
      focusables() {
        if (Array.isArray(within))
          return within;
        return focusable(within, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(el2) {
        let els = this.all();
        return els[0] && els[0].isSameNode(el2);
      },
      isLast(el2) {
        let els = this.all();
        return els.length && els.slice(-1)[0].isSameNode(el2);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
          return list[0];
        }
        return list[list.indexOf(current) + 1];
      },
      getPrevious() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === 0) {
          return list.slice(-1)[0];
        }
        return list[list.indexOf(current) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(el2) {
        if (!el2)
          return;
        setTimeout(() => {
          if (!el2.hasAttribute("tabindex"))
            el2.setAttribute("tabindex", "0");
          el2.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  });
  Alpine2.directive("trap", Alpine2.skipDuringClone(
    (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluator = evaluateLater2(expression);
      let oldValue = false;
      let options = {
        escapeDeactivates: false,
        allowOutsideClick: true,
        fallbackFocus: () => el
      };
      let undoInert = () => {
      };
      if (modifiers.includes("noautofocus")) {
        options.initialFocus = false;
      } else {
        let autofocusEl = el.querySelector("[autofocus]");
        if (autofocusEl)
          options.initialFocus = autofocusEl;
      }
      if (modifiers.includes("inert")) {
        options.onPostActivate = () => {
          Alpine2.nextTick(() => {
            undoInert = setInert(el);
          });
        };
      }
      let trap = createFocusTrap(el, options);
      let undoDisableScrolling = () => {
      };
      const releaseFocus = () => {
        undoInert();
        undoInert = () => {
        };
        undoDisableScrolling();
        undoDisableScrolling = () => {
        };
        trap.deactivate({
          returnFocus: !modifiers.includes("noreturn")
        });
      };
      effect3(() => evaluator((value) => {
        if (oldValue === value)
          return;
        if (value && !oldValue) {
          if (modifiers.includes("noscroll"))
            undoDisableScrolling = disableScrolling();
          setTimeout(() => {
            trap.activate();
          }, 15);
        }
        if (!value && oldValue) {
          releaseFocus();
        }
        oldValue = !!value;
      }));
      cleanup2(releaseFocus);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
      if (modifiers.includes("inert") && evaluate2(expression))
        setInert(el);
    }
  ));
}
function setInert(el) {
  let undos = [];
  crawlSiblingsUp(el, (sibling) => {
    let cache = sibling.hasAttribute("aria-hidden");
    sibling.setAttribute("aria-hidden", "true");
    undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
  });
  return () => {
    while (undos.length)
      undos.pop()();
  };
}
function crawlSiblingsUp(el, callback) {
  if (el.isSameNode(document.body) || !el.parentNode)
    return;
  Array.from(el.parentNode.children).forEach((sibling) => {
    if (sibling.isSameNode(el)) {
      crawlSiblingsUp(el.parentNode, callback);
    } else {
      callback(sibling);
    }
  });
}
function disableScrolling() {
  let overflow = document.documentElement.style.overflow;
  let paddingRight = document.documentElement.style.paddingRight;
  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.overflow = "hidden";
  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
  return () => {
    document.documentElement.style.overflow = overflow;
    document.documentElement.style.paddingRight = paddingRight;
  };
}
var module_default = src_default;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function eager() {
  return true;
}
function event({ component, argument }) {
  return new Promise((resolve) => {
    if (argument) {
      window.addEventListener(
        argument,
        () => resolve(),
        { once: true }
      );
    } else {
      const cb = (e2) => {
        if (e2.detail.id !== component.id) return;
        window.removeEventListener("async-alpine:load", cb);
        resolve();
      };
      window.addEventListener("async-alpine:load", cb);
    }
  });
}
function idle() {
  return new Promise((resolve) => {
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(resolve);
    } else {
      setTimeout(resolve, 200);
    }
  });
}
function media({ argument }) {
  return new Promise((resolve) => {
    if (!argument) {
      console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'");
      return resolve();
    }
    const mediaQuery = window.matchMedia(`(${argument})`);
    if (mediaQuery.matches) {
      resolve();
    } else {
      mediaQuery.addEventListener("change", resolve, { once: true });
    }
  });
}
function visible({ component, argument }) {
  return new Promise((resolve) => {
    const rootMargin = argument || "0px 0px 0px 0px";
    const observer2 = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        observer2.disconnect();
        resolve();
      }
    }, { rootMargin });
    observer2.observe(component.el);
  });
}
var strategies_default = {
  eager,
  event,
  idle,
  media,
  visible
};
async function awaitRequirements(component) {
  const requirements = parseRequirements(component.strategy);
  await generateRequirements(component, requirements);
}
async function generateRequirements(component, requirements) {
  if (requirements.type === "expression") {
    if (requirements.operator === "&&") {
      return Promise.all(
        requirements.parameters.map((param) => generateRequirements(component, param))
      );
    }
    if (requirements.operator === "||") {
      return Promise.any(
        requirements.parameters.map((param) => generateRequirements(component, param))
      );
    }
  }
  if (!strategies_default[requirements.method]) return false;
  return strategies_default[requirements.method]({
    component,
    argument: requirements.argument
  });
}
function parseRequirements(expression) {
  const tokens = tokenize(expression);
  let ast = parseExpression(tokens);
  if (ast.type === "method") {
    return {
      type: "expression",
      operator: "&&",
      parameters: [ast]
    };
  }
  return ast;
}
function tokenize(expression) {
  const regex = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g;
  const tokens = [];
  let match;
  while ((match = regex.exec(expression)) !== null) {
    const [_, parenthesis, operator, token] = match;
    if (parenthesis !== void 0) {
      tokens.push({ type: "parenthesis", value: parenthesis });
    } else if (operator !== void 0) {
      tokens.push({
        type: "operator",
        // we do the below to make operators backwards-compatible with previous
        // versions of Async Alpine, where '|' is equivalent to &&
        value: operator === "|" ? "&&" : operator
      });
    } else {
      const tokenObj = {
        type: "method",
        method: token.trim()
      };
      if (token.includes("(")) {
        tokenObj.method = token.substring(0, token.indexOf("(")).trim();
        tokenObj.argument = token.substring(
          token.indexOf("(") + 1,
          token.indexOf(")")
        );
      }
      if (token.method === "immediate") {
        token.method = "eager";
      }
      tokens.push(tokenObj);
    }
  }
  return tokens;
}
function parseExpression(tokens) {
  let ast = parseTerm(tokens);
  while (tokens.length > 0 && (tokens[0].value === "&&" || tokens[0].value === "|" || tokens[0].value === "||")) {
    const operator = tokens.shift().value;
    const right = parseTerm(tokens);
    if (ast.type === "expression" && ast.operator === operator) {
      ast.parameters.push(right);
    } else {
      ast = {
        type: "expression",
        operator,
        parameters: [ast, right]
      };
    }
  }
  return ast;
}
function parseTerm(tokens) {
  if (tokens[0].value === "(") {
    tokens.shift();
    const ast = parseExpression(tokens);
    if (tokens[0].value === ")") {
      tokens.shift();
    }
    return ast;
  } else {
    return tokens.shift();
  }
}
function async_alpine_default(Alpine2) {
  const directive2 = "load";
  const srcAttr = Alpine2.prefixed("load-src");
  const ignoreAttr = Alpine2.prefixed("ignore");
  let options = {
    defaultStrategy: "eager",
    keepRelativeURLs: false
  };
  let alias = false;
  let data2 = {};
  let realIndex = 0;
  function index() {
    return realIndex++;
  }
  Alpine2.asyncOptions = (opts) => {
    options = {
      ...options,
      ...opts
    };
  };
  Alpine2.asyncData = (name, download2 = false) => {
    data2[name] = {
      loaded: false,
      download: download2
    };
  };
  Alpine2.asyncUrl = (name, url) => {
    if (!name || !url || data2[name]) return;
    data2[name] = {
      loaded: false,
      download: () => import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        parseUrl(url)
      )
    };
  };
  Alpine2.asyncAlias = (path) => {
    alias = path;
  };
  const syncHandler = (el) => {
    Alpine2.skipDuringClone(() => {
      if (el._x_async) return;
      el._x_async = "init";
      el._x_ignore = true;
      el.setAttribute(ignoreAttr, "");
    })();
  };
  const handler4 = async (el) => {
    Alpine2.skipDuringClone(async () => {
      if (el._x_async !== "init") return;
      el._x_async = "await";
      const { name, strategy } = elementPrep(el);
      await awaitRequirements({
        name,
        strategy,
        el,
        id: el.id || index()
      });
      if (!el.isConnected) return;
      await download(name);
      if (!el.isConnected) return;
      activate(el);
      el._x_async = "loaded";
    })();
  };
  handler4.inline = syncHandler;
  Alpine2.directive(directive2, handler4).before("ignore");
  function elementPrep(el) {
    const name = parseName(el.getAttribute(Alpine2.prefixed("data")));
    const strategy = el.getAttribute(Alpine2.prefixed(directive2)) || options.defaultStrategy;
    const urlAttributeValue = el.getAttribute(srcAttr);
    if (urlAttributeValue) {
      Alpine2.asyncUrl(name, urlAttributeValue);
    }
    return {
      name,
      strategy
    };
  }
  async function download(name) {
    if (name.startsWith("_x_async_")) return;
    handleAlias(name);
    if (!data2[name] || data2[name].loaded) return;
    const module = await getModule(name);
    Alpine2.data(name, module);
    data2[name].loaded = true;
  }
  async function getModule(name) {
    if (!data2[name]) return;
    const module = await data2[name].download(name);
    if (typeof module === "function") return module;
    let whichExport = module[name] || module.default || Object.values(module)[0] || false;
    return whichExport;
  }
  function activate(el) {
    Alpine2.destroyTree(el);
    el._x_ignore = false;
    el.removeAttribute(ignoreAttr);
    if (el.closest(`[${ignoreAttr}]`)) return;
    Alpine2.initTree(el);
  }
  function handleAlias(name) {
    if (!alias || data2[name]) return;
    if (typeof alias === "function") {
      Alpine2.asyncData(name, alias);
      return;
    }
    Alpine2.asyncUrl(name, alias.replaceAll("[name]", name));
  }
  function parseName(attribute) {
    const parsedName = (attribute || "").trim().split(/[({]/g)[0];
    const ourName = parsedName || `_x_async_${index()}`;
    return ourName;
  }
  function parseUrl(url) {
    if (options.keepRelativeURLs) return url;
    const absoluteReg = new RegExp("^(?:[a-z+]+:)?//", "i");
    if (!absoluteReg.test(url)) {
      return new URL(url, document.baseURI).href;
    }
    return url;
  }
}
function t(t2, e2) {
  if (!(t2 instanceof e2)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function e(t2, e2) {
  for (var s2 = 0; s2 < e2.length; s2++) {
    var i2 = e2[s2];
    i2.enumerable = i2.enumerable || false;
    i2.configurable = true;
    if ("value" in i2) i2.writable = true;
    Object.defineProperty(t2, i2.key, i2);
  }
}
function s(t2, s2, i2) {
  if (s2) e(t2.prototype, s2);
  return t2;
}
var i = Object.defineProperty;
var n = function(t2, e2) {
  return i(t2, "name", { value: e2, configurable: true });
};
var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var h = n(function(t2) {
  return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
}, "stringToHTML"), d = n(function(t2) {
  var e2 = new DOMParser().parseFromString(t2, "application/xml");
  return document.importNode(e2.documentElement, true).outerHTML;
}, "getSvgNode");
var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
var N = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), O = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "fadeOut"), T = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), E = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "slideOut");
var m = function() {
  function e2(s2) {
    var i2 = this;
    t(this, e2);
    this.notifyOut = n(function(t2) {
      t2(i2);
    }, "notifyOut");
    var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
    if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  s(e2, [{ key: "checkRequirements", value: function t2() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function t2() {
    var t3 = document.querySelector(".".concat(u.CONTAINER));
    t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function t2() {
    this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function t2() {
    var t3 = this;
    var e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
      t3.close();
    });
  } }, { key: "setWrapper", value: function t2() {
    var t3 = this;
    switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
      case p.OUTLINE:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
        break;
      case p.FILLED:
        this.wrapper.classList.add(u.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case f.SUCCESS:
        this.wrapper.classList.add(u.NOTIFY_SUCCESS);
        break;
      case f.ERROR:
        this.wrapper.classList.add(u.NOTIFY_ERROR);
        break;
      case f.WARNING:
        this.wrapper.classList.add(u.NOTIFY_WARNING);
        break;
      case f.INFO:
        this.wrapper.classList.add(u.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
      t3.wrapper.classList.add(e3);
    });
  } }, { key: "setContent", value: function t2() {
    var t3 = document.createElement("div");
    t3.classList.add(u.NOTIFY_CONTENT);
    var e3, s2;
    this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
  } }, { key: "setIcon", value: function t2() {
    var t3 = n(function(t4) {
      switch (t4) {
        case f.SUCCESS:
          return v.SUCCESS;
        case f.ERROR:
          return v.ERROR;
        case f.WARNING:
          return v.WARNING;
        case f.INFO:
          return v.INFO;
      }
    }, "computedIcon"), e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
  } }, { key: "setObserver", value: function t2() {
    var t3 = this;
    var e3 = new IntersectionObserver(function(e4) {
      if (e4[0].intersectionRatio <= 0) t3.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      e3.observe(t3.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function t2(t2) {
    t2(this);
  } }, { key: "autoClose", value: function t2() {
    var t3 = this;
    setTimeout(function() {
      t3.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function t2() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function t2() {
    switch (this.effect) {
      case I.FADE:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
        break;
      case I.SLIDE:
        this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
        break;
      default:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
    }
  } }]);
  return e2;
}();
n(m, "Notify");
var w = m;
globalThis.Notify = w;
const allowedStatuses = ["success", "error", "warning", "info"];
const allowedPositions = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
];
const defaultConfig = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: true,
  autotimeout: 4e3,
  position: "right top"
};
function renderToast(options = {}) {
  const config = {
    ...defaultConfig,
    ...options
  };
  if (!allowedStatuses.includes(config.status)) {
    console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
    config.status = "info";
  }
  if (!allowedPositions.includes(config.position)) {
    console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
    config.position = "right top";
  }
  new w(config);
}
const Toast = {
  custom: renderToast,
  success(text, title = "Success", options = {}) {
    renderToast({
      status: "success",
      title,
      text,
      ...options
    });
  },
  error(text, title = "Error", options = {}) {
    renderToast({
      status: "error",
      title,
      text,
      ...options
    });
  },
  warning(text, title = "Warning", options = {}) {
    renderToast({
      status: "warning",
      title,
      text,
      ...options
    });
  },
  info(text, title = "Info", options = {}) {
    renderToast({
      status: "info",
      title,
      text,
      ...options
    });
  },
  setDefaults(newDefaults = {}) {
    Object.assign(defaultConfig, newDefaults);
  },
  get allowedStatuses() {
    return [...allowedStatuses];
  },
  get allowedPositions() {
    return [...allowedPositions];
  }
};
const devnull = function() {
}, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
function subscribe(bundleIds, callbackFn) {
  bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
  const depsNotFound = [];
  let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
  fn = function(bundleId2, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId2);
    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };
  while (i2--) {
    bundleId = bundleIds[i2];
    r2 = bundleResultCache[bundleId];
    if (r2) {
      fn(bundleId, r2);
      continue;
    }
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}
function publish(bundleId, pathsNotFound) {
  if (!bundleId) return;
  const q = bundleCallbackQueue[bundleId];
  bundleResultCache[bundleId] = pathsNotFound;
  if (!q) return;
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}
function executeCallbacks(args, depsNotFound) {
  if (typeof args === "function") args = { success: args };
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}
function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
  let result = ev.type[0];
  if (isLegacyIECss) {
    try {
      if (!e2.sheet.cssText.length) result = "e";
    } catch (x) {
      if (x.code !== 18) result = "e";
    }
  }
  if (result === "e") {
    numTries += 1;
    if (numTries < maxTries) {
      return loadFile(path, callbackFn, args, numTries);
    }
  } else if (e2.rel === "preload" && e2.as === "style") {
    e2.rel = "stylesheet";
    return;
  }
  callbackFn(path, result, ev.defaultPrevented);
}
function loadFile(path, callbackFn, args, numTries) {
  const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
  let isLegacyIECss, hasModuleSupport, e2;
  numTries = numTries || 0;
  if (/(^css!|\.css$)/.test(pathname)) {
    e2 = doc.createElement("link");
    e2.rel = "stylesheet";
    e2.href = pathStripped;
    isLegacyIECss = "hideFocus" in e2;
    if (isLegacyIECss && e2.relList) {
      isLegacyIECss = 0;
      e2.rel = "preload";
      e2.as = "style";
    }
    if (args.inlineStyleNonce) {
      e2.setAttribute("nonce", args.inlineStyleNonce);
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    e2 = doc.createElement("img");
    e2.src = pathStripped;
  } else {
    e2 = doc.createElement("script");
    e2.src = pathStripped;
    e2.async = async === void 0 ? true : async;
    if (args.inlineScriptNonce) {
      e2.setAttribute("nonce", args.inlineScriptNonce);
    }
    hasModuleSupport = "noModule" in e2;
    if (/^module!/.test(pathname)) {
      if (!hasModuleSupport) return callbackFn(path, "l");
      e2.type = "module";
    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
      return callbackFn(path, "l");
    }
  }
  const onEvent = function(ev) {
    handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
  };
  e2.addEventListener("load", onEvent, { once: true });
  e2.addEventListener("error", onEvent, { once: true });
  if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
}
function loadFiles(paths, callbackFn, args) {
  paths = Array.isArray(paths) ? paths : [paths];
  let numWaiting = paths.length, pathsNotFound = [];
  function fn(path, result, defaultPrevented) {
    if (result === "e") pathsNotFound.push(path);
    if (result === "b") {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }
    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  }
  for (let i2 = 0; i2 < paths.length; i2++) {
    loadFile(paths[i2], fn, args);
  }
}
function loadjs(paths, arg1, arg2) {
  let bundleId, args;
  if (arg1 && typeof arg1 === "string" && arg1.trim) {
    bundleId = arg1.trim();
  }
  args = (bundleId ? arg2 : arg1) || {};
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }
  function loadFn(resolve, reject) {
    loadFiles(paths, function(pathsNotFound) {
      executeCallbacks(args, pathsNotFound);
      if (resolve) {
        executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
      }
      publish(bundleId, pathsNotFound);
    }, args);
  }
  if (args.returnPromise) {
    return new Promise(loadFn);
  } else {
    loadFn();
  }
}
loadjs.ready = function ready(deps, args) {
  subscribe(deps, function(depsNotFound) {
    executeCallbacks(args, depsNotFound);
  });
  return loadjs;
};
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};
loadjs.reset = function reset() {
  Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
  Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
  Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
};
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};
function $data(idOrElement) {
  if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
    console.error(
      "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
    );
    return void 0;
  }
  if (idOrElement instanceof Element) {
    const target = resolveProxy(idOrElement) || idOrElement;
    let alpineData = Alpine.$data(target);
    if (alpineData === void 0) {
      const nearest = target.closest?.("[x-data]");
      if (nearest) {
        alpineData = Alpine.$data(nearest);
      }
    }
    if (alpineData === void 0) {
      warnDataUndefined("element", target);
    }
    return alpineData;
  }
  if (typeof idOrElement === "string") {
    const componentId = idOrElement.trim();
    if (!componentId) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return void 0;
    }
    const selector = `[data-alpine-root="${cssEscapeSafe(componentId)}"]`;
    let root = null;
    const wrapper = document.getElementById(componentId);
    if (wrapper) {
      root = wrapper.matches(selector) ? wrapper : wrapper.querySelector(selector);
    }
    if (!root) {
      root = findAlpineRootById(componentId);
    }
    if (!root) {
      console.warn(
        `Rizzy.$data: Could not locate an Alpine root using ${selector} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${componentId}"' is present.`
      );
      return void 0;
    }
    const alpineData = Alpine.$data(root);
    if (alpineData === void 0) {
      warnDataUndefined(`data-alpine-root="${componentId}"`, root);
    }
    return alpineData;
  }
  console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
  return void 0;
}
function resolveProxy(el) {
  if (!(el instanceof Element)) return null;
  const isProxyTag = el.tagName?.toLowerCase?.() === "rz-proxy";
  const proxyFor = el.getAttribute?.("data-for");
  if (isProxyTag || proxyFor) {
    const id = proxyFor || "";
    if (!id) return el;
    const root = findAlpineRootById(id);
    if (!root) {
      console.warn(
        `Rizzy.$data: Proxy element could not resolve Alpine root for id "${id}". Ensure the teleported root rendered with data-alpine-root="${id}".`
      );
      return null;
    }
    return root;
  }
  return el;
}
function findAlpineRootById(id) {
  const sel = `[data-alpine-root="${cssEscapeSafe(id)}"]`;
  const candidates = document.querySelectorAll(sel);
  for (const n2 of candidates) {
    if (n2.hasAttribute("x-data")) return n2;
  }
  if (candidates.length > 0) return candidates[0];
  return document.getElementById(id) || null;
}
function cssEscapeSafe(s2) {
  try {
    if (window.CSS && typeof window.CSS.escape === "function") {
      return window.CSS.escape(s2);
    }
  } catch (_) {
  }
  return String(s2).replace(/"/g, '\\"');
}
function warnDataUndefined(origin, target) {
  const desc = `${target.tagName?.toLowerCase?.() || "node"}${target.id ? "#" + target.id : ""}${target.classList?.length ? "." + Array.from(target.classList).join(".") : ""}`;
  console.warn(
    `Rizzy.$data: Located target via ${origin} (${desc}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
  );
}
function registerRzAccordion(Alpine2) {
  Alpine2.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: false,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function registerAccordionItem(Alpine2) {
  Alpine2.data("accordionItem", () => ({
    open: false,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true";
      this.sectionId = this.$el.dataset.sectionId;
      this.expandedClass = this.$el.dataset.expandedClass;
      const self = this;
      if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
        this.$watch("selected", (value, oldValue) => {
          if (value !== self.sectionId && !self.allowMultiple) {
            self.open = false;
          }
        });
      } else {
        console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
      }
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId;
      this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function registerRzAlert(Alpine2) {
  Alpine2.data("rzAlert", () => {
    return {
      parentElement: null,
      showAlert: true,
      init() {
        const alpineRoot = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
        this.parentElement = document.getElementById(alpineRoot);
      },
      dismiss() {
        this.showAlert = false;
        const self = this;
        setTimeout(() => {
          self.parentElement.style.display = "none";
        }, 205);
      }
    };
  });
}
function registerRzAspectRatio(Alpine2) {
  Alpine2.data("rzAspectRatio", () => ({
    init() {
      const ratio = parseFloat(this.$el.dataset.ratio);
      if (!isNaN(ratio) && ratio > 0) {
        const paddingBottom = 100 / ratio + "%";
        this.$el.style.paddingBottom = paddingBottom;
      } else {
        this.$el.style.paddingBottom = "100%";
      }
    }
  }));
}
function registerRzBrowser(Alpine2) {
  Alpine2.data("rzBrowser", () => {
    return {
      screenSize: "",
      setDesktopScreenSize() {
        this.screenSize = "";
      },
      setTabletScreenSize() {
        this.screenSize = "max-w-2xl";
      },
      setPhoneScreenSize() {
        this.screenSize = "max-w-sm";
      },
      // Get CSS classes for browser border based on screen size
      getBrowserBorderCss() {
        return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
      },
      // Get CSS classes for desktop screen button styling
      getDesktopScreenCss() {
        return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for tablet screen button styling
      getTabletScreenCss() {
        return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for phone screen button styling
      getPhoneScreenCss() {
        return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      }
    };
  });
}
function registerRzCalendar(Alpine2, require2) {
  Alpine2.data("rzCalendar", () => ({
    calendar: null,
    initialized: false,
    init() {
      const assets = JSON.parse(this.$el.dataset.assets || "[]");
      const configId = this.$el.dataset.configId;
      const nonce = this.$el.dataset.nonce;
      if (assets.length === 0) {
        console.warn("RzCalendar: No assets configured.");
        return;
      }
      require2(assets, {
        success: () => {
          this.initCalendar(configId);
        },
        error: (e2) => console.error("RzCalendar: Failed to load assets", e2)
      }, nonce);
    },
    initCalendar(configId) {
      const configElement = document.getElementById(configId);
      if (!configElement) {
        console.error(`RzCalendar: Config element #${configId} not found.`);
        return;
      }
      let rawConfig = {};
      try {
        rawConfig = JSON.parse(configElement.textContent);
      } catch (e2) {
        console.error("RzCalendar: Failed to parse config JSON", e2);
        return;
      }
      const actionHandlers = {
        clickDay: (e2, self) => this.dispatchCalendarEvent("clickDay", { event: e2, dates: self.selectedDates }),
        clickWeekNumber: (e2, number, days, year) => this.dispatchCalendarEvent("clickWeekNumber", { event: e2, number, days, year }),
        clickMonth: (e2, month) => this.dispatchCalendarEvent("clickMonth", { event: e2, month }),
        clickYear: (e2, year) => this.dispatchCalendarEvent("clickYear", { event: e2, year }),
        clickArrow: (e2, year, month) => this.dispatchCalendarEvent("clickArrow", { event: e2, year, month }),
        changeTime: (e2, time, hours, minutes, keeping) => this.dispatchCalendarEvent("changeTime", { event: e2, time, hours, minutes, keeping }),
        changeView: (view) => this.dispatchCalendarEvent("changeView", { view }),
        getDays: (day, date, HTMLElement2, HTMLButtonElement, self) => {
        }
      };
      const options = {
        ...rawConfig.options,
        styles: rawConfig.styles,
        // Correct property name for VCP
        actions: actionHandlers
      };
      if (window.VanillaCalendarPro) {
        this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, options);
        this.calendar.init();
        this.initialized = true;
        this.dispatchCalendarEvent("init", { instance: this.calendar });
      } else {
        console.error("RzCalendar: VanillaCalendar global not found.");
      }
    },
    dispatchCalendarEvent(eventName, detail) {
      this.$dispatch(`rz:calendar:${eventName}`, detail);
    },
    destroy() {
      if (this.calendar) {
        this.calendar.destroy();
        this.dispatchCalendarEvent("destroy", {});
      }
    }
  }));
}
function registerRzCarousel(Alpine2, require2) {
  function parseJsonFromScriptId(id) {
    if (!id) return {};
    const el = document.getElementById(id);
    if (!el) {
      console.warn(`[rzCarousel] JSON script element #${id} not found.`);
      return {};
    }
    try {
      return JSON.parse(el.textContent || "{}");
    } catch (e2) {
      console.error(`[rzCarousel] Failed to parse JSON from #${id}:`, e2);
      return {};
    }
  }
  Alpine2.data("rzCarousel", () => ({
    emblaApi: null,
    canScrollPrev: false,
    canScrollNext: false,
    selectedIndex: 0,
    scrollSnaps: [],
    init() {
      const assetsToLoad = (() => {
        try {
          return JSON.parse(this.$el.dataset.assets || "[]");
        } catch (e2) {
          console.error("[rzCarousel] Bad assets JSON:", e2);
          return [];
        }
      })();
      const nonce = this.$el.dataset.nonce || "";
      const config = parseJsonFromScriptId(this.$el.dataset.config);
      const options = config.Options || {};
      const pluginsConfig = config.Plugins || [];
      const self = this;
      if (assetsToLoad.length > 0 && typeof require2 === "function") {
        require2(
          assetsToLoad,
          {
            success() {
              if (window.EmblaCarousel) {
                self.initializeEmbla(options, pluginsConfig);
              } else {
                console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
              }
            },
            error(err) {
              console.error("[rzCarousel] Failed to load EmblaCarousel assets.", err);
            }
          },
          nonce
        );
      } else {
        if (window.EmblaCarousel) {
          this.initializeEmbla(options, pluginsConfig);
        } else {
          console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
        }
      }
    },
    initializeEmbla(options, pluginsConfig) {
      const viewport = this.$el.querySelector('[x-ref="viewport"]');
      if (!viewport) {
        console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
        return;
      }
      const instantiatedPlugins = this.instantiatePlugins(pluginsConfig);
      this.emblaApi = window.EmblaCarousel(viewport, options, instantiatedPlugins);
      this.emblaApi.on("select", this.onSelect.bind(this));
      this.emblaApi.on("reInit", this.onSelect.bind(this));
      this.onSelect();
    },
    instantiatePlugins(pluginsConfig) {
      if (!Array.isArray(pluginsConfig) || pluginsConfig.length === 0) {
        return [];
      }
      return pluginsConfig.map((pluginInfo) => {
        const constructor = window[pluginInfo.Name];
        if (typeof constructor !== "function") {
          console.error(`[rzCarousel] Plugin constructor '${pluginInfo.Name}' not found on window object.`);
          return null;
        }
        try {
          return constructor(pluginInfo.Options || {});
        } catch (e2) {
          console.error(`[rzCarousel] Error instantiating plugin '${pluginInfo.Name}':`, e2);
          return null;
        }
      }).filter(Boolean);
    },
    destroy() {
      if (this.emblaApi) this.emblaApi.destroy();
    },
    onSelect() {
      if (!this.emblaApi) return;
      this.selectedIndex = this.emblaApi.selectedScrollSnap();
      this.canScrollPrev = this.emblaApi.canScrollPrev();
      this.canScrollNext = this.emblaApi.canScrollNext();
      this.scrollSnaps = this.emblaApi.scrollSnapList();
    },
    cannotScrollPrev() {
      return !this.canScrollPrev;
    },
    cannotScrollNext() {
      return !this.canScrollNext;
    },
    scrollPrev() {
      this.emblaApi?.scrollPrev();
    },
    scrollNext() {
      this.emblaApi?.scrollNext();
    },
    scrollTo(index) {
      this.emblaApi?.scrollTo(index);
    }
  }));
}
function registerRzCodeViewer(Alpine2, require2) {
  Alpine2.data("rzCodeViewer", () => {
    return {
      expand: false,
      border: true,
      copied: false,
      copyTitle: "Copy",
      // Default title
      copiedTitle: "Copied!",
      // Default title
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const codeId = this.$el.dataset.codeid;
        const nonce = this.$el.dataset.nonce;
        this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
        this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
        require2(assets, {
          success: function() {
            const codeBlock = document.getElementById(codeId);
            if (window.hljs && codeBlock) {
              window.hljs.highlightElement(codeBlock);
            }
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      },
      // Function to check if code is NOT copied (for x-show)
      notCopied() {
        return !this.copied;
      },
      // Function to reset the copied state (e.g., on blur)
      disableCopied() {
        this.copied = false;
      },
      // Function to toggle the expand state
      toggleExpand() {
        this.expand = !this.expand;
      },
      // Function to copy code to clipboard
      copyHTML() {
        navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
        this.copied = !this.copied;
      },
      // Get the title for the copy button (copy/copied)
      getCopiedTitle() {
        return this.copied ? this.copiedTitle : this.copyTitle;
      },
      // Get CSS classes for the copy button based on copied state
      getCopiedCss() {
        return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
      },
      // Get CSS classes for the code container based on expand state
      getExpandCss() {
        return [this.expand ? "" : "max-h-60"];
      },
      // Get CSS classes for the expand button icon based on expand state
      getExpandButtonCss() {
        return this.expand ? "rotate-180" : "rotate-0";
      }
    };
  });
}
function registerRzCollapsible(Alpine2) {
  Alpine2.data("rzCollapsible", () => ({
    isOpen: false,
    init() {
      this.isOpen = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.isOpen = !this.isOpen;
    },
    state() {
      return this.isOpen ? "open" : "closed";
    }
  }));
}
function registerRzCombobox(Alpine2, require2) {
  Alpine2.data("rzCombobox", () => ({
    tomSelect: null,
    init() {
      const assets = JSON.parse(this.$el.dataset.assets || "[]");
      const nonce = this.$el.dataset.nonce;
      if (assets.length > 0 && typeof require2 === "function") {
        require2(assets, {
          success: () => this.initTomSelect(),
          error: (err) => console.error("RzCombobox: Failed to load assets.", err)
        }, nonce);
      } else if (window.TomSelect) {
        this.initTomSelect();
      }
    },
    initTomSelect() {
      const selectEl = this.$refs.selectInput;
      if (!selectEl) return;
      const configEl = document.getElementById(this.$el.dataset.configId);
      const config = configEl ? JSON.parse(configEl.textContent) : {};
      const render = {};
      const createAlpineRow = (templateRef, data2) => {
        if (!templateRef) return null;
        const div = document.createElement("div");
        let parsedItem = data2.item;
        if (typeof parsedItem === "string") {
          try {
            parsedItem = JSON.parse(parsedItem);
          } catch (e2) {
          }
        }
        const scope2 = {
          ...data2,
          item: parsedItem
        };
        if (Alpine2 && typeof Alpine2.addScopeToNode === "function") {
          Alpine2.addScopeToNode(div, scope2);
        } else {
          div._x_dataStack = [scope2];
        }
        div.innerHTML = templateRef.innerHTML;
        return div;
      };
      if (this.$refs.optionTemplate) {
        render.option = (data2, escape) => createAlpineRow(this.$refs.optionTemplate, data2);
      }
      if (this.$refs.itemTemplate) {
        render.item = (data2, escape) => createAlpineRow(this.$refs.itemTemplate, data2);
      }
      config.dataAttr = "data-item";
      this.tomSelect = new TomSelect(selectEl, {
        ...config,
        render,
        onInitialize: function() {
          this.sync();
        }
      });
    },
    destroy() {
      if (this.tomSelect) {
        this.tomSelect.destroy();
        this.tomSelect = null;
      }
    }
  }));
}
function registerRzDateEdit(Alpine2, require2) {
  Alpine2.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const cfgString = this.$el.dataset.config;
      const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
      if (cfgString) {
        const parsed = JSON.parse(cfgString);
        if (parsed) {
          this.options = parsed.options || {};
          this.placeholder = parsed.placeholder || "";
          this.prependText = parsed.prependText || "";
        }
      }
      const assets = JSON.parse(this.$el.dataset.assets);
      const nonce = this.$el.dataset.nonce;
      require2(assets, {
        success: function() {
          if (window.flatpickr && inputElem) {
            window.flatpickr(inputElem, this.options);
          }
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, nonce);
    }
  }));
}
function registerRzDialog(Alpine2) {
  Alpine2.data("rzDialog", () => ({
    modalOpen: false,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: true,
    closeOnClickOutside: true,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "";
      this.bodyId = this.$el.dataset.bodyId || "";
      this.footerId = this.$el.dataset.footerId || "";
      this.nonce = this.$el.dataset.nonce || "";
      this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
      this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
      this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
      this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
      this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: true
      }));
      if (this.eventTriggerName) {
        this._openListener = (e2) => {
          this.openModal(e2);
        };
        window.addEventListener(this.eventTriggerName, this._openListener);
      }
      this._closeEventListener = (event2) => {
        if (this.modalOpen) {
          this.closeModalInternally("event");
        }
      };
      window.addEventListener(this.closeEventName, this._closeEventListener);
      this._escapeListener = (e2) => {
        if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
          this.closeModalInternally("escape");
        }
      };
      window.addEventListener("keydown", this._escapeListener);
      this.$watch("modalOpen", (value) => {
        const currentWidth = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", value);
        const scrollBarWidth = document.body.offsetWidth - currentWidth;
        document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
        if (value) {
          this.$nextTick(() => {
            const dialogElement = this.$el.querySelector('[role="document"]');
            const focusable3 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
            focusable3?.focus();
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        } else {
          this.$nextTick(() => {
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        }
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      if (this._openListener && this.eventTriggerName) {
        window.removeEventListener(this.eventTriggerName, this._openListener);
      }
      if (this._closeEventListener) {
        window.removeEventListener(this.closeEventName, this._closeEventListener);
      }
      if (this._escapeListener) {
        window.removeEventListener("keydown", this._escapeListener);
      }
      document.body.classList.remove("overflow-hidden");
      document.body.style.setProperty("--page-scrollbar-width", `0px`);
    },
    openModal(event2 = null) {
      const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: event2 },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeOpenEvent);
      if (!beforeOpenEvent.defaultPrevented) {
        this.modalOpen = true;
      }
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(reason = "unknown") {
      const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeCloseEvent);
      if (!beforeCloseEvent.defaultPrevented) {
        document.activeElement?.blur && document.activeElement.blur();
        this.modalOpen = false;
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      }
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      if (this.closeOnClickOutside) {
        this.closeModalInternally("backdrop");
      }
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end) {
  return max(start2, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data2
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, []).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function registerRzDropdownMenu(Alpine2) {
  Alpine2.data("rzDropdownMenu", () => ({
    // --- STATE ---
    open: false,
    isModal: true,
    ariaExpanded: "false",
    trapActive: false,
    focusedIndex: null,
    menuItems: [],
    parentEl: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when menu opens
    anchor: "bottom",
    pixelOffset: 3,
    isSubmenuActive: false,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    // --- INIT ---
    init() {
      if (!this.$el.id) this.$el.id = crypto.randomUUID();
      this.selfId = this.$el.id;
      this.parentEl = this.$el;
      this.triggerEl = this.$refs.trigger;
      this.anchor = this.$el.dataset.anchor || "bottom";
      this.pixelOffset = parseInt(this.$el.dataset.offset) || 6;
      this.isModal = this.$el.dataset.modal !== "false";
      this.$watch("open", (value) => {
        if (value) {
          this._lastNavAt = 0;
          this.$nextTick(() => {
            this.contentEl = document.getElementById(`${this.selfId}-content`);
            if (!this.contentEl) return;
            this.updatePosition();
            this.menuItems = Array.from(
              this.contentEl.querySelectorAll(
                '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
              )
            );
          });
          this.ariaExpanded = "true";
          this.triggerEl.dataset.state = "open";
          this.trapActive = this.isModal;
        } else {
          this.focusedIndex = null;
          this.closeAllSubmenus();
          this.ariaExpanded = "false";
          delete this.triggerEl.dataset.state;
          this.trapActive = false;
          this.contentEl = null;
        }
      });
    },
    // --- METHODS ---
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`);
      computePosition(this.triggerEl, this.contentEl, {
        placement: this.anchor,
        middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(this.contentEl.style, { left: `${x}px`, top: `${y}px` });
      });
    },
    toggle() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      } else {
        this.open = true;
        this.focusedIndex = -1;
      }
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = false;
      let self = this;
      this.$nextTick(() => self.triggerEl?.focus());
    },
    handleTriggerKeydown(event2) {
      if (["Enter", " ", "ArrowDown", "ArrowUp"].includes(event2.key)) {
        event2.preventDefault();
        this.open = true;
        this.$nextTick(() => {
          if (event2.key === "ArrowUp") this.focusLastItem();
          else this.focusFirstItem();
        });
      }
    },
    focusNextItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
      this.focusCurrentItem();
    },
    focusPreviousItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
      this.focusCurrentItem();
    },
    focusFirstItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = 0;
      this.focusCurrentItem();
    },
    focusLastItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = this.menuItems.length - 1;
      this.focusCurrentItem();
    },
    focusCurrentItem() {
      if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
        this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
      }
    },
    focusSelectedItem(item) {
      if (!item || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      const index = this.menuItems.indexOf(item);
      if (index !== -1) {
        this.focusedIndex = index;
        item.focus();
      }
    },
    handleItemClick(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.open = false;
      let self = this;
      this.$nextTick(() => self.triggerEl?.focus());
    },
    handleItemMouseEnter(event2) {
      const item = event2.currentTarget;
      this.focusSelectedItem(item);
      if (item.getAttribute("aria-haspopup") !== "menu") {
        this.closeAllSubmenus();
      }
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      }
    },
    handleContentTabKey() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      }
    },
    handleTriggerMouseover() {
      let self = this;
      this.$nextTick(() => self.$el.firstElementChild?.focus());
    },
    closeAllSubmenus() {
      const submenus = this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      submenus.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
      this.isSubmenuActive = false;
    }
  }));
  Alpine2.data("rzDropdownSubmenu", () => ({
    // --- STATE ---
    open: false,
    ariaExpanded: "false",
    parentDropdown: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when submenu opens
    menuItems: [],
    focusedIndex: null,
    anchor: "right-start",
    pixelOffset: 0,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    siblingContainer: null,
    closeTimeout: null,
    closeDelay: 150,
    // --- INIT ---
    init() {
      if (!this.$el.id) this.$el.id = crypto.randomUUID();
      this.selfId = this.$el.id;
      const parentId = this.$el.dataset.parentId;
      if (parentId) {
        const parentEl = document.getElementById(parentId);
        if (parentEl) {
          this.parentDropdown = Alpine2.$data(parentEl);
        }
      }
      if (!this.parentDropdown) {
        console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
        return;
      }
      this.triggerEl = this.$refs.subTrigger;
      this.siblingContainer = this.$el.parentElement;
      this.anchor = this.$el.dataset.subAnchor || this.anchor;
      this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset;
      this.$watch("open", (value) => {
        if (value) {
          this._lastNavAt = 0;
          this.parentDropdown.isSubmenuActive = true;
          this.$nextTick(() => {
            this.contentEl = document.getElementById(`${this.selfId}-subcontent`);
            if (!this.contentEl) return;
            this.updatePosition(this.contentEl);
            this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])'));
          });
          this.ariaExpanded = "true";
          this.triggerEl.dataset.state = "open";
        } else {
          this.focusedIndex = null;
          this.ariaExpanded = "false";
          delete this.triggerEl.dataset.state;
          this.$nextTick(() => {
            const anySubmenuIsOpen = this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]');
            if (!anySubmenuIsOpen) this.parentDropdown.isSubmenuActive = false;
          });
          this.contentEl = null;
        }
      });
    },
    // --- METHODS ---
    updatePosition(contentEl) {
      if (!this.triggerEl || !contentEl) return;
      computePosition(this.triggerEl, contentEl, {
        placement: this.anchor,
        middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(contentEl.style, { left: `${x}px`, top: `${y}px` });
      });
    },
    handleTriggerMouseEnter() {
      clearTimeout(this.closeTimeout);
      this.triggerEl.focus();
      this.openSubmenu();
    },
    handleTriggerMouseLeave() {
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    handleContentMouseEnter() {
      clearTimeout(this.closeTimeout);
    },
    handleContentMouseLeave() {
      const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      if (childSubmenus) {
        const isAnyChildOpen = Array.from(childSubmenus).some((el) => Alpine2.$data(el)?.open);
        if (isAnyChildOpen) {
          return;
        }
      }
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    openSubmenu(focusFirst = false) {
      if (this.open) return;
      this.closeSiblingSubmenus();
      this.open = true;
      if (focusFirst) {
        this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem()));
      }
    },
    closeSubmenu() {
      const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      childSubmenus?.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
      this.open = false;
    },
    closeSiblingSubmenus() {
      if (!this.siblingContainer) return;
      const siblings = Array.from(this.siblingContainer.children).filter(
        (el) => el.hasAttribute("x-data") && el.getAttribute("x-data").startsWith("rzDropdownSubmenu") && el.id !== this.selfId
      );
      siblings.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
    },
    toggleSubmenu() {
      this.open ? this.closeSubmenu() : this.openSubmenu();
    },
    openSubmenuAndFocusFirst() {
      this.openSubmenu(true);
    },
    handleTriggerKeydown(e2) {
      if (["ArrowRight", "Enter", " "].includes(e2.key)) {
        e2.preventDefault();
        this.openSubmenuAndFocusFirst();
      }
    },
    focusNextItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
      this.focusCurrentItem();
    },
    focusPreviousItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
      this.focusCurrentItem();
    },
    focusFirstItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = 0;
      this.focusCurrentItem();
    },
    focusLastItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = this.menuItems.length - 1;
      this.focusCurrentItem();
    },
    focusCurrentItem() {
      if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
        this.menuItems[this.focusedIndex].focus();
      }
    },
    handleItemClick(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.parentDropdown.open = false;
      this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
    },
    handleItemMouseEnter(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      const index = this.menuItems.indexOf(item);
      if (index !== -1) {
        this.focusedIndex = index;
        item.focus();
      }
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu();
      } else {
        this.closeSiblingSubmenus();
      }
    },
    handleSubmenuEscape() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    },
    handleSubmenuArrowLeft() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    }
  }));
}
function registerRzDarkModeToggle(Alpine2) {
  Alpine2.data("rzDarkModeToggle", () => ({
    // Proxy all properties to the reactive store
    get mode() {
      return this.$store.theme.mode;
    },
    get prefersDark() {
      return this.$store.theme.prefersDark;
    },
    get effectiveDark() {
      return this.$store.theme.effectiveDark;
    },
    // Proxy properties from the store (isDark/isLight are getters on the store)
    get isDark() {
      return this.$store.theme.isDark;
    },
    get isLight() {
      return this.$store.theme.isLight;
    },
    // Proxy methods
    setLight() {
      this.$store.theme.setLight();
    },
    setDark() {
      this.$store.theme.setDark();
    },
    setAuto() {
      this.$store.theme.setAuto();
    },
    toggle() {
      this.$store.theme.toggle();
    }
  }));
}
function registerRzEmbeddedPreview(Alpine2) {
  Alpine2.data("rzEmbeddedPreview", () => {
    return {
      iframe: null,
      onDarkModeToggle: null,
      init() {
        try {
          this.iframe = this.$refs.iframe;
          const resize = this.debounce(() => {
            this.resizeIframe(this.iframe);
          }, 50);
          this.resizeIframe(this.iframe);
          const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
              resize();
            }
          });
          resizeObserver.observe(this.iframe);
          const iframe = this.iframe;
          this.onDarkModeToggle = (event2) => {
            iframe.contentWindow.postMessage(event2.detail, "*");
          };
          window.addEventListener("darkModeToggle", this.onDarkModeToggle);
        } catch (error2) {
          console.error("Cannot access iframe content");
        }
      },
      // Adjusts the iframe height based on its content
      resizeIframe(iframe) {
        if (iframe) {
          try {
            const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
            if (iframeDocument) {
              const iframeBody = iframeDocument.body;
              if (!iframeBody) {
                setInterval(() => {
                  this.resizeIframe(iframe);
                }, 150);
              } else {
                const newHeight = iframeBody.scrollHeight + 15;
                iframe.style.height = newHeight + "px";
              }
            }
          } catch (error2) {
            console.error("Error resizing iframe:", error2);
          }
        }
      },
      // Debounce helper to limit function calls
      debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      },
      destroy() {
        window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
      }
    };
  });
}
function registerRzEmpty(Alpine2) {
  Alpine2.data("rzEmpty", () => {
  });
}
function registerRzHeading(Alpine2) {
  Alpine2.data("rzHeading", () => {
    return {
      observer: null,
      headingId: "",
      init() {
        this.headingId = this.$el.dataset.alpineRoot;
        const self = this;
        if (typeof this.setCurrentHeading === "function") {
          const callback = (entries, observer2) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                self.setCurrentHeading(self.headingId);
              }
            });
          };
          const options = { threshold: 0.5 };
          this.observer = new IntersectionObserver(callback, options);
          this.observer.observe(this.$el);
        } else {
          console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
        }
      },
      destroy() {
        if (this.observer != null)
          this.observer.disconnect();
      }
    };
  });
}
function registerRzIndicator(Alpine2) {
  Alpine2.data("rzIndicator", () => ({
    visible: false,
    init() {
      const colorValue = this.$el.dataset.color;
      if (colorValue) {
        this.$el.style.backgroundColor = colorValue;
      } else {
        this.$el.style.backgroundColor = "var(--color-success)";
      }
      if (this.$el.dataset.visible === "true") {
        this.visible = true;
      }
    },
    notVisible() {
      return !this.visible;
    },
    setVisible(value) {
      this.visible = value;
    }
  }));
}
function registerRzInputGroupAddon(Alpine2) {
  Alpine2.data("rzInputGroupAddon", () => ({
    handleClick(event2) {
      if (event2.target.closest("button")) {
        return;
      }
      const parent = this.$el.parentElement;
      if (parent) {
        const input = parent.querySelector("input, textarea");
        input?.focus();
      }
    }
  }));
}
function registerRzMarkdown(Alpine2, require2) {
  Alpine2.data("rzMarkdown", () => {
    return {
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require2(assets, {
          success: function() {
            window.hljs.highlightAll();
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      }
    };
  });
}
function registerRzNavigationMenu(Alpine2, $data2) {
  Alpine2.data("rzNavigationMenu", () => ({
    activeItemId: null,
    open: false,
    closeTimeout: null,
    prevIndex: null,
    list: null,
    isClosing: false,
    /* ---------- helpers ---------- */
    _triggerIndex(id) {
      if (!this.list) return -1;
      const triggers = Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]'));
      return triggers.findIndex((t2) => t2.getAttribute("x-ref") === `trigger_${id}`);
    },
    _contentEl(id) {
      return document.getElementById(`${id}-content`);
    },
    /* ---------- lifecycle ---------- */
    init() {
      const contentEls = this.$el.querySelectorAll("[data-popover]");
      contentEls.forEach((el) => {
        el.style.display = "none";
      });
      this.$nextTick(() => {
        this.list = this.$refs.list;
      });
    },
    /* ---------- event handlers (from events with no params) ---------- */
    toggleActive(e2) {
      const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.activeItemId === id && this.open ? this.closeMenu() : this.openMenu(id);
    },
    handleTriggerEnter(e2) {
      const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.cancelClose();
      if (this.activeItemId !== id && !this.isClosing) {
        requestAnimationFrame(() => this.openMenu(id));
      }
    },
    handleItemEnter(e2) {
      const item = e2.currentTarget;
      if (!item) return;
      this.cancelClose();
      const trigger2 = item.querySelector('[x-ref^="trigger_"]');
      if (trigger2) {
        const id = trigger2.getAttribute("x-ref").replace("trigger_", "");
        if (this.activeItemId !== id && !this.isClosing) {
          requestAnimationFrame(() => this.openMenu(id));
        }
      } else {
        if (this.open && !this.isClosing) {
          this.closeMenu();
        }
      }
    },
    handleContentEnter() {
      this.cancelClose();
    },
    scheduleClose() {
      if (this.isClosing || this.closeTimeout) return;
      this.closeTimeout = setTimeout(() => this.closeMenu(), 150);
    },
    cancelClose() {
      if (this.closeTimeout) {
        clearTimeout(this.closeTimeout);
        this.closeTimeout = null;
      }
      this.isClosing = false;
    },
    /* ---------- open / close logic with direct DOM manipulation ---------- */
    openMenu(id) {
      this.cancelClose();
      this.isClosing = false;
      const newIdx = this._triggerIndex(id);
      const dir = newIdx > (this.prevIndex ?? newIdx) ? "end" : "start";
      const isFirstOpen = this.prevIndex === null;
      if (this.open && this.activeItemId && this.activeItemId !== id) {
        const oldTrig = this.$refs[`trigger_${this.activeItemId}`];
        if (oldTrig) delete oldTrig.dataset.state;
        const oldEl = this._contentEl(this.activeItemId);
        if (oldEl) {
          const outgoingDirection = dir === "end" ? "start" : "end";
          oldEl.setAttribute("data-motion", `to-${outgoingDirection}`);
          setTimeout(() => {
            oldEl.style.display = "none";
          }, 150);
        }
      }
      this.activeItemId = id;
      this.open = true;
      this.prevIndex = newIdx;
      const newTrig = this.$refs[`trigger_${id}`];
      const newContentEl = this._contentEl(id);
      if (!newTrig || !newContentEl) return;
      computePosition(newTrig, newContentEl, {
        placement: "bottom-start",
        middleware: [offset(6), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(newContentEl.style, { left: `${x}px`, top: `${y}px` });
      });
      newContentEl.style.display = "block";
      if (isFirstOpen) {
        newContentEl.setAttribute("data-motion", "fade-in");
      } else {
        newContentEl.setAttribute("data-motion", `from-${dir}`);
      }
      this.$nextTick(() => {
        newTrig.setAttribute("aria-expanded", "true");
        newTrig.dataset.state = "open";
      });
    },
    closeMenu() {
      if (!this.open || this.isClosing) return;
      this.isClosing = true;
      this.cancelClose();
      const activeId = this.activeItemId;
      if (!activeId) {
        this.isClosing = false;
        return;
      }
      const trig = this.$refs[`trigger_${activeId}`];
      if (trig) {
        trig.setAttribute("aria-expanded", "false");
        delete trig.dataset.state;
      }
      const contentEl = this._contentEl(activeId);
      if (contentEl) {
        contentEl.setAttribute("data-motion", "fade-out");
        setTimeout(() => {
          contentEl.style.display = "none";
        }, 150);
      }
      this.open = false;
      this.activeItemId = null;
      this.prevIndex = null;
      setTimeout(() => {
        this.isClosing = false;
      }, 150);
    }
  }));
}
function registerRzPopover(Alpine2) {
  Alpine2.data("rzPopover", () => ({
    open: false,
    ariaExpanded: "false",
    triggerEl: null,
    contentEl: null,
    init() {
      this.triggerEl = this.$refs.trigger;
      this.contentEl = this.$refs.content;
      this.$watch("open", (value) => {
        this.ariaExpanded = value.toString();
        if (value) {
          this.$nextTick(() => this.updatePosition());
        }
      });
    },
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      const anchor = this.$el.dataset.anchor || "bottom";
      const mainOffset = parseInt(this.$el.dataset.offset) || 0;
      const crossAxisOffset = parseInt(this.$el.dataset.crossAxisOffset) || 0;
      const alignmentAxisOffset = parseInt(this.$el.dataset.alignmentAxisOffset) || null;
      const strategy = this.$el.dataset.strategy || "absolute";
      const enableFlip = this.$el.dataset.enableFlip !== "false";
      const enableShift = this.$el.dataset.enableShift !== "false";
      const shiftPadding = parseInt(this.$el.dataset.shiftPadding) || 8;
      let middleware = [];
      middleware.push(offset({
        mainAxis: mainOffset,
        crossAxis: crossAxisOffset,
        alignmentAxis: alignmentAxisOffset
      }));
      if (enableFlip) {
        middleware.push(flip());
      }
      if (enableShift) {
        middleware.push(shift({ padding: shiftPadding }));
      }
      computePosition(this.triggerEl, this.contentEl, {
        placement: anchor,
        strategy,
        middleware
      }).then(({ x, y }) => {
        Object.assign(this.contentEl.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
    },
    toggle() {
      this.open = !this.open;
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = false;
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    }
  }));
}
function registerRzPrependInput(Alpine2) {
  Alpine2.data("rzPrependInput", () => {
    return {
      prependContainer: null,
      textInput: null,
      init() {
        this.prependContainer = this.$refs.prependContainer;
        this.textInput = this.$refs.textInput;
        let self = this;
        setTimeout(() => {
          self.updatePadding();
        }, 50);
        window.addEventListener("resize", this.updatePadding);
      },
      destroy() {
        window.removeEventListener("resize", this.updatePadding);
      },
      updatePadding() {
        const prependDiv = this.prependContainer;
        const inputElem = this.textInput;
        if (!prependDiv || !inputElem) {
          if (inputElem) {
            inputElem.classList.remove("text-transparent");
          }
          return;
        }
        const prependWidth = prependDiv.offsetWidth;
        const leftPadding = prependWidth + 10;
        inputElem.style.paddingLeft = leftPadding + "px";
        inputElem.classList.remove("text-transparent");
      }
    };
  });
}
function registerRzProgress(Alpine2) {
  Alpine2.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const element = this.$el;
      this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
      this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
      this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
      this.label = element.getAttribute("data-label");
      this.calculatePercentage();
      element.setAttribute("aria-valuenow", this.currentVal);
      element.setAttribute("aria-valuemin", this.minVal);
      element.setAttribute("aria-valuemax", this.maxVal);
      element.setAttribute("aria-valuetext", `${this.percentage}%`);
      this.updateProgressBar();
      const resizeObserver = new ResizeObserver((entries) => {
        this.updateProgressBar();
      });
      resizeObserver.observe(element);
      this.$watch("currentVal", () => {
        this.calculatePercentage();
        this.updateProgressBar();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      if (this.maxVal === this.minVal) {
        this.percentage = 0;
      } else {
        this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
      }
    },
    buildLabel() {
      var label = this.label || "{percent}%";
      this.calculatePercentage();
      return label.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const progressBar = this.$refs.progressBar;
      const barLabel = this.$refs.progressBarLabel;
      const innerLabel = this.$refs.innerLabel;
      if (barLabel && progressBar && innerLabel) {
        innerLabel.innerText = this.buildLabel();
        if (barLabel.clientWidth > progressBar.clientWidth) {
          barLabel.style.left = progressBar.clientWidth + 10 + "px";
        } else {
          barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
        }
      }
    },
    getLabelCss() {
      const barLabel = this.$refs.progressBarLabel;
      const progressBar = this.$refs.progressBar;
      if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
        return "text-foreground dark:text-foreground";
      }
      return "";
    },
    updateProgressBar() {
      const progressBar = this.$refs.progressBar;
      if (progressBar) {
        progressBar.style.width = `${this.percentage}%`;
        this.buildInsideLabelPosition();
      }
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(value) {
      this.currentVal = value;
    },
    increment(val = 1) {
      this.currentVal = Math.min(this.currentVal + val, this.maxVal);
    },
    decrement(val = 1) {
      this.currentVal = Math.max(this.currentVal - val, this.minVal);
    }
  }));
}
function registerRzQuickReferenceContainer(Alpine2) {
  Alpine2.data("rzQuickReferenceContainer", () => {
    return {
      headings: [],
      // Array of heading IDs
      currentHeadingId: "",
      // ID of the currently highlighted heading
      // Initializes the component with headings and the initial current heading from data attributes.
      init() {
        this.headings = JSON.parse(this.$el.dataset.headings || "[]");
        this.currentHeadingId = this.$el.dataset.currentheadingid || "";
      },
      // Handles click events on quick reference links.
      handleHeadingClick() {
        const id = this.$el.dataset.headingid;
        window.requestAnimationFrame(() => {
          this.currentHeadingId = id;
        });
      },
      // Sets the current heading ID based on intersection observer events from rzHeading.
      setCurrentHeading(id) {
        if (this.headings.includes(id)) {
          this.currentHeadingId = id;
        }
      },
      // Provides CSS classes for a link based on whether it's the current heading.
      // Returns an object suitable for :class binding.
      getSelectedCss() {
        const id = this.$el.dataset.headingid;
        return {
          "font-bold": this.currentHeadingId === id
          // Apply 'font-bold' if current
        };
      },
      // Determines the value for the aria-current attribute.
      getSelectedAriaCurrent() {
        const id = this.$el.dataset.headingid;
        return this.currentHeadingId === id ? "true" : null;
      }
    };
  });
}
function registerRzSheet(Alpine2) {
  Alpine2.data("rzSheet", () => ({
    open: false,
    init() {
      this.open = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.open = !this.open;
    },
    close() {
      this.open = false;
    },
    show() {
      this.open = true;
    },
    state() {
      return this.open ? "open" : "closed";
    }
  }));
}
function registerRzTabs(Alpine2) {
  Alpine2.data("rzTabs", () => ({
    selectedTab: "",
    _triggers: [],
    _observer: null,
    init() {
      const defaultValue = this.$el.dataset.defaultValue;
      this._observer = new MutationObserver(() => this.refreshTriggers());
      this._observer.observe(this.$el, { childList: true, subtree: true });
      this.refreshTriggers();
      if (defaultValue && this._triggers.some((t2) => t2.dataset.value === defaultValue)) {
        this.selectedTab = defaultValue;
      } else if (this._triggers.length > 0) {
        this.selectedTab = this._triggers[0].dataset.value;
      }
    },
    destroy() {
      if (this._observer) {
        this._observer.disconnect();
      }
    },
    refreshTriggers() {
      this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
    },
    onTriggerClick(e2) {
      const value = e2.currentTarget?.dataset?.value;
      if (!value || e2.currentTarget.getAttribute("aria-disabled") === "true") {
        return;
      }
      this.selectedTab = value;
      this.$dispatch("rz:tabs-change", { value: this.selectedTab });
    },
    isSelected(value) {
      return this.selectedTab === value;
    },
    bindTrigger() {
      this.selectedTab;
      const value = this.$el.dataset.value;
      const active = this.isSelected(value);
      const disabled = this.$el.getAttribute("aria-disabled") === "true";
      return {
        "aria-selected": String(active),
        "tabindex": active ? "0" : "-1",
        "data-state": active ? "active" : "inactive",
        ...disabled && { "disabled": true }
      };
    },
    _attrDisabled() {
      return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
    },
    _attrAriaSelected() {
      return String(this.$el.dataset.value === this.selectedTab);
    },
    _attrHidden() {
      return this.$el.dataset.value === this.selectedTab ? null : "true";
    },
    _attrAriaHidden() {
      return String(this.selectedTab !== this.$el.dataset.value);
    },
    _attrDataState() {
      return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
    },
    _attrTabIndex() {
      return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
    },
    onListKeydown(e2) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(e2.key)) {
        e2.preventDefault();
        const availableTriggers = this._triggers.filter((t2) => t2.getAttribute("aria-disabled") !== "true");
        if (availableTriggers.length === 0) return;
        const activeIndex = availableTriggers.findIndex((t2) => t2.dataset.value === this.selectedTab);
        if (activeIndex === -1) return;
        const isVertical = e2.currentTarget?.getAttribute("aria-orientation") === "vertical";
        const prevKey = isVertical ? "ArrowUp" : "ArrowLeft";
        const nextKey = isVertical ? "ArrowDown" : "ArrowRight";
        let newIndex = activeIndex;
        switch (e2.key) {
          case prevKey:
            newIndex = activeIndex - 1 < 0 ? availableTriggers.length - 1 : activeIndex - 1;
            break;
          case nextKey:
            newIndex = (activeIndex + 1) % availableTriggers.length;
            break;
          case "Home":
            newIndex = 0;
            break;
          case "End":
            newIndex = availableTriggers.length - 1;
            break;
        }
        if (newIndex >= 0 && newIndex < availableTriggers.length) {
          const newTrigger = availableTriggers[newIndex];
          this.selectedTab = newTrigger.dataset.value;
          this.$nextTick(() => newTrigger.focus());
        }
      }
    }
  }));
}
function registerRzSidebar(Alpine2) {
  Alpine2.data("rzSidebar", () => ({
    open: false,
    openMobile: false,
    isMobile: false,
    collapsible: "offcanvas",
    shortcut: "b",
    cookieName: "sidebar_state",
    mobileBreakpoint: 768,
    init() {
      this.collapsible = this.$el.dataset.collapsible || "offcanvas";
      this.shortcut = this.$el.dataset.shortcut || "b";
      this.cookieName = this.$el.dataset.cookieName || "sidebar_state";
      this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
      const savedState = this.cookieName ? document.cookie.split("; ").find((row) => row.startsWith(`${this.cookieName}=`))?.split("=")[1] : null;
      const defaultOpen = this.$el.dataset.defaultOpen === "true";
      this.open = savedState !== null ? savedState === "true" : defaultOpen;
      this.checkIfMobile();
      window.addEventListener("keydown", (e2) => {
        if ((e2.ctrlKey || e2.metaKey) && e2.key.toLowerCase() === this.shortcut.toLowerCase()) {
          e2.preventDefault();
          this.toggle();
        }
      });
      this.$watch("open", (value) => {
        if (this.cookieName) {
          document.cookie = `${this.cookieName}=${value}; path=/; max-age=31536000`;
        }
      });
    },
    checkIfMobile() {
      this.isMobile = window.innerWidth < this.mobileBreakpoint;
    },
    toggle() {
      if (this.isMobile) {
        this.openMobile = !this.openMobile;
      } else {
        this.open = !this.open;
      }
    },
    close() {
      if (this.isMobile) {
        this.openMobile = false;
      }
    },
    isMobileOpen() {
      return this.openMobile;
    },
    desktopState() {
      return this.open ? "expanded" : "collapsed";
    },
    mobileState() {
      return this.openMobile ? "open" : "closed";
    },
    getCollapsibleAttribute() {
      return this.desktopState() === "collapsed" ? this.collapsible : "";
    }
  }));
}
function registerRzCommand(Alpine2) {
  Alpine2.data("rzCommand", () => ({
    // --- STATE ---
    search: "",
    selectedValue: null,
    selectedIndex: -1,
    items: [],
    filteredItems: [],
    groupTemplates: /* @__PURE__ */ new Map(),
    activeDescendantId: null,
    isOpen: false,
    isEmpty: true,
    firstRender: true,
    isLoading: false,
    error: null,
    // --- CONFIG ---
    loop: false,
    shouldFilter: true,
    itemsUrl: null,
    fetchTrigger: "immediate",
    serverFiltering: false,
    dataItemTemplateId: null,
    _dataFetched: false,
    _debounceTimer: null,
    // --- COMPUTED (CSP-Compliant Methods) ---
    showLoading() {
      return this.isLoading;
    },
    hasError() {
      return this.error !== null;
    },
    notHasError() {
      return this.error == null;
    },
    shouldShowEmpty() {
      return this.isEmpty && this.search && !this.isLoading && !this.error;
    },
    shouldShowEmptyOrError() {
      return this.isEmpty && this.search && !this.isLoading || this.error !== null;
    },
    // --- LIFECYCLE ---
    init() {
      this.loop = this.$el.dataset.loop === "true";
      this.shouldFilter = this.$el.dataset.shouldFilter !== "false";
      this.selectedValue = this.$el.dataset.selectedValue || null;
      this.itemsUrl = this.$el.dataset.itemsUrl || null;
      this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate";
      this.serverFiltering = this.$el.dataset.serverFiltering === "true";
      this.dataItemTemplateId = this.$el.dataset.templateId || null;
      const itemsScriptId = this.$el.dataset.itemsId;
      let staticItems = [];
      if (itemsScriptId) {
        const itemsScript = document.getElementById(itemsScriptId);
        if (itemsScript) {
          try {
            staticItems = JSON.parse(itemsScript.textContent || "[]");
          } catch (e2) {
            console.error(`RzCommand: Failed to parse JSON from script tag #${itemsScriptId}`, e2);
          }
        }
      }
      if (staticItems.length > 0 && !this.dataItemTemplateId) {
        console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them.");
      }
      staticItems.forEach((item) => {
        item.id = item.id || `static-item-${crypto.randomUUID()}`;
        item.isDataItem = true;
        this.registerItem(item);
      });
      if (this.itemsUrl && this.fetchTrigger === "immediate") {
        this.fetchItems();
      }
      this.$watch("search", (newValue) => {
        this.firstRender = false;
        if (this.serverFiltering) {
          clearTimeout(this._debounceTimer);
          this._debounceTimer = setTimeout(() => {
            this.fetchItems(newValue);
          }, 300);
        } else {
          this.filterAndSortItems();
        }
      });
      this.$watch("selectedIndex", (newIndex, oldIndex) => {
        if (oldIndex > -1) {
          const oldItem = this.filteredItems[oldIndex];
          if (oldItem) {
            const oldEl = this.$el.querySelector(`[data-command-item-id="${oldItem.id}"]`);
            if (oldEl) {
              oldEl.removeAttribute("data-selected");
              oldEl.setAttribute("aria-selected", "false");
            }
          }
        }
        if (newIndex > -1 && this.filteredItems[newIndex]) {
          const selectedItem = this.filteredItems[newIndex];
          this.activeDescendantId = selectedItem.id;
          const el = this.$el.querySelector(`[data-command-item-id="${selectedItem.id}"]`);
          if (el) {
            el.setAttribute("data-selected", "true");
            el.setAttribute("aria-selected", "true");
            el.scrollIntoView({ block: "nearest" });
          }
          const newValue = selectedItem.value;
          if (this.selectedValue !== newValue) {
            this.selectedValue = newValue;
            this.$dispatch("rz:command:select", { value: newValue });
          }
        } else {
          this.activeDescendantId = null;
          this.selectedValue = null;
        }
      });
      this.$watch("selectedValue", (newValue) => {
        const index = this.filteredItems.findIndex((item) => item.value === newValue);
        if (this.selectedIndex !== index) {
          this.selectedIndex = index;
        }
      });
      this.$watch("filteredItems", (items) => {
        this.isOpen = items.length > 0 || this.isLoading;
        this.isEmpty = items.length === 0;
        if (!this.firstRender) {
          window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
            detail: {
              items: this.filteredItems,
              groups: this.groupTemplates,
              commandId: this.$el.id
            }
          }));
        }
      });
    },
    // --- METHODS ---
    async fetchItems(query = "") {
      if (!this.itemsUrl) return;
      if (!this.dataItemTemplateId) {
        console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data.");
        this.error = "Configuration error: No data template found.";
        return;
      }
      this.isLoading = true;
      this.error = null;
      try {
        const url = new URL(this.itemsUrl, window.location.origin);
        if (this.serverFiltering && query) {
          url.searchParams.append("q", query);
        }
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const data2 = await response.json();
        if (this.serverFiltering) {
          this.items = this.items.filter((i2) => !i2.isDataItem);
        }
        data2.forEach((item) => {
          item.id = item.id || `data-item-${crypto.randomUUID()}`;
          item.isDataItem = true;
          this.registerItem(item);
        });
        this._dataFetched = true;
      } catch (e2) {
        this.error = e2.message || "Failed to fetch command items.";
        console.error("RzCommand:", this.error);
      } finally {
        this.isLoading = false;
        this.filterAndSortItems();
      }
    },
    handleInteraction() {
      if (this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched) {
        this.fetchItems();
      }
    },
    registerItem(item) {
      if (this.items.some((i2) => i2.id === item.id)) return;
      item._order = this.items.length;
      this.items.push(item);
      if (this.selectedIndex === -1)
        this.selectedIndex = 0;
      if (!this.serverFiltering) {
        this.filterAndSortItems();
      }
    },
    unregisterItem(itemId) {
      this.items = this.items.filter((i2) => i2.id !== itemId);
      this.filterAndSortItems();
    },
    registerGroupTemplate(name, templateId) {
      if (!this.groupTemplates.has(name)) {
        this.groupTemplates.set(name, templateId);
      }
    },
    filterAndSortItems() {
      if (this.serverFiltering && this._dataFetched) {
        this.filteredItems = this.items;
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        return;
      }
      let items;
      if (!this.shouldFilter || !this.search) {
        items = this.items.map((item) => ({ ...item, score: 1 }));
      } else {
        items = this.items.map((item) => ({
          ...item,
          score: item.forceMount ? 0 : this.commandScore(item.name, this.search, item.keywords)
        })).filter((item) => item.score > 0 || item.forceMount).sort((a2, b) => {
          if (a2.forceMount && !b.forceMount) return 1;
          if (!a2.forceMount && b.forceMount) return -1;
          if (b.score !== a2.score) return b.score - a2.score;
          return (a2._order || 0) - (b._order || 0);
        });
      }
      this.filteredItems = items;
      if (this.selectedValue) {
        const newIndex = this.filteredItems.findIndex((item) => item.value === this.selectedValue);
        this.selectedIndex = newIndex > -1 ? newIndex : this.filteredItems.length > 0 ? 0 : -1;
      } else {
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
      }
    },
    // --- EVENT HANDLERS ---
    handleItemClick(event2) {
      const host = event2.target.closest("[data-command-item-id]");
      if (!host) return;
      const itemId = host.dataset.commandItemId;
      const index = this.filteredItems.findIndex((item) => item.id === itemId);
      if (index > -1) {
        const item = this.filteredItems[index];
        if (item && !item.disabled) {
          this.selectedIndex = index;
          this.$dispatch("rz:command:execute", { value: item.value });
        }
      }
    },
    handleItemHover(event2) {
      const host = event2.target.closest("[data-command-item-id]");
      if (!host) return;
      const itemId = host.dataset.commandItemId;
      const index = this.filteredItems.findIndex((item) => item.id === itemId);
      if (index > -1) {
        const item = this.filteredItems[index];
        if (item && !item.disabled) {
          if (this.selectedIndex !== index) {
            this.selectedIndex = index;
          }
        }
      }
    },
    // --- KEYBOARD NAVIGATION ---
    handleKeydown(e2) {
      switch (e2.key) {
        case "ArrowDown":
          e2.preventDefault();
          this.selectNext();
          break;
        case "ArrowUp":
          e2.preventDefault();
          this.selectPrev();
          break;
        case "Home":
          e2.preventDefault();
          this.selectFirst();
          break;
        case "End":
          e2.preventDefault();
          this.selectLast();
          break;
        case "Enter":
          e2.preventDefault();
          const item = this.filteredItems[this.selectedIndex];
          if (item && !item.disabled) {
            this.$dispatch("rz:command:execute", { value: item.value });
          }
          break;
      }
    },
    selectNext() {
      if (this.filteredItems.length === 0) return;
      let i2 = this.selectedIndex, count = 0;
      do {
        i2 = i2 + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : i2 + 1;
        count++;
        if (!this.filteredItems[i2]?.disabled) {
          this.selectedIndex = i2;
          return;
        }
        if (!this.loop && i2 === this.filteredItems.length - 1) return;
      } while (count <= this.filteredItems.length);
    },
    selectPrev() {
      if (this.filteredItems.length === 0) return;
      let i2 = this.selectedIndex, count = 0;
      do {
        i2 = i2 - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : i2 - 1;
        count++;
        if (!this.filteredItems[i2]?.disabled) {
          this.selectedIndex = i2;
          return;
        }
        if (!this.loop && i2 === 0) return;
      } while (count <= this.filteredItems.length);
    },
    selectFirst() {
      if (this.filteredItems.length > 0) {
        const firstEnabledIndex = this.filteredItems.findIndex((item) => !item.disabled);
        if (firstEnabledIndex > -1) this.selectedIndex = firstEnabledIndex;
      }
    },
    selectLast() {
      if (this.filteredItems.length > 0) {
        const lastEnabledIndex = this.filteredItems.map((item) => item.disabled).lastIndexOf(false);
        if (lastEnabledIndex > -1) this.selectedIndex = lastEnabledIndex;
      }
    },
    // --- SCORING ALGORITHM (Adapted from cmdk) ---
    commandScore(string, search, keywords = []) {
      const SCORE_CONTINUE_MATCH = 1;
      const SCORE_SPACE_WORD_JUMP = 0.9;
      const SCORE_NON_SPACE_WORD_JUMP = 0.8;
      const SCORE_CHARACTER_JUMP = 0.17;
      const PENALTY_SKIPPED = 0.999;
      const PENALTY_CASE_MISMATCH = 0.9999;
      const PENALTY_NOT_COMPLETE = 0.99;
      const IS_GAP_REGEXP = /[\\/_+.#"@[\(\{&]/;
      const IS_SPACE_REGEXP = /[\s-]/;
      const fullString = `${string} ${keywords ? keywords.join(" ") : ""}`;
      function formatInput(str) {
        return str.toLowerCase().replace(/[\s-]/g, " ");
      }
      function commandScoreInner(str, abbr, lowerStr, lowerAbbr, strIndex, abbrIndex, memo) {
        if (abbrIndex === abbr.length) {
          return strIndex === str.length ? SCORE_CONTINUE_MATCH : PENALTY_NOT_COMPLETE;
        }
        const memoKey = `${strIndex},${abbrIndex}`;
        if (memo[memoKey] !== void 0) return memo[memoKey];
        const abbrChar = lowerAbbr.charAt(abbrIndex);
        let index = lowerStr.indexOf(abbrChar, strIndex);
        let highScore = 0;
        while (index >= 0) {
          let score = commandScoreInner(str, abbr, lowerStr, lowerAbbr, index + 1, abbrIndex + 1, memo);
          if (score > highScore) {
            if (index === strIndex) {
              score *= SCORE_CONTINUE_MATCH;
            } else if (IS_GAP_REGEXP.test(str.charAt(index - 1))) {
              score *= SCORE_NON_SPACE_WORD_JUMP;
            } else if (IS_SPACE_REGEXP.test(str.charAt(index - 1))) {
              score *= SCORE_SPACE_WORD_JUMP;
            } else {
              score *= SCORE_CHARACTER_JUMP;
              if (strIndex > 0) {
                score *= Math.pow(PENALTY_SKIPPED, index - strIndex);
              }
            }
            if (str.charAt(index) !== abbr.charAt(abbrIndex)) {
              score *= PENALTY_CASE_MISMATCH;
            }
          }
          if (score > highScore) {
            highScore = score;
          }
          index = lowerStr.indexOf(abbrChar, index + 1);
        }
        memo[memoKey] = highScore;
        return highScore;
      }
      return commandScoreInner(fullString, search, formatInput(fullString), formatInput(search), 0, 0, {});
    }
  }));
}
function registerRzCommandItem(Alpine2) {
  Alpine2.data("rzCommandItem", () => ({
    parent: null,
    itemData: {},
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandItem must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      this.itemData = {
        id: this.$el.id,
        value: this.$el.dataset.value || this.$el.textContent.trim(),
        name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
        keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
        group: this.$el.dataset.group || null,
        templateId: this.$el.id + "-template",
        disabled: this.$el.dataset.disabled === "true",
        forceMount: this.$el.dataset.forceMount === "true"
      };
      this.parent.registerItem(this.itemData);
    },
    destroy() {
      if (this.parent) {
        this.parent.unregisterItem(this.itemData.id);
      }
    }
  }));
}
function registerRzCommandList(Alpine2) {
  Alpine2.data("rzCommandList", () => ({
    parent: null,
    dataItemTemplate: null,
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandList must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      if (this.parent.dataItemTemplateId) {
        this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId);
      }
    },
    renderList(event2) {
      if (event2.detail.commandId !== this.parent.$el.id) return;
      const items = event2.detail.items || [];
      const groups = event2.detail.groups || /* @__PURE__ */ new Map();
      const container = this.$el;
      container.querySelectorAll("[data-dynamic-item]").forEach((el) => el.remove());
      const groupedItems = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
      items.forEach((item) => {
        const groupName = item.group || "__ungrouped__";
        if (!groupedItems.has(groupName)) {
          groupedItems.set(groupName, []);
        }
        groupedItems.get(groupName).push(item);
      });
      groupedItems.forEach((groupItems, groupName) => {
        if (groupItems.length === 0) return;
        const groupContainer = document.createElement("div");
        groupContainer.setAttribute("role", "group");
        groupContainer.setAttribute("data-dynamic-item", "true");
        groupContainer.setAttribute("data-slot", "command-group");
        if (groupName !== "__ungrouped__") {
          const headingTemplateId = groups.get(groupName);
          if (headingTemplateId) {
            const headingTemplate = document.getElementById(headingTemplateId);
            if (headingTemplate && headingTemplate.content) {
              const headingClone = headingTemplate.content.cloneNode(true);
              const headingEl = headingClone.firstElementChild;
              if (headingEl) {
                groupContainer.setAttribute("aria-labelledby", headingEl.id);
                groupContainer.appendChild(headingClone);
              }
            }
          }
        }
        groupItems.forEach((item) => {
          const itemIndex = this.parent.filteredItems.indexOf(item);
          let itemEl;
          if (item.isDataItem) {
            if (!this.dataItemTemplate) {
              return;
            }
            const clone2 = this.dataItemTemplate.content.cloneNode(true);
            itemEl = clone2.firstElementChild;
            Alpine2.addScopeToNode(itemEl, { item });
          } else {
            const template = document.getElementById(item.templateId);
            if (template && template.content) {
              const clone2 = template.content.cloneNode(true);
              itemEl = clone2.querySelector(`[data-command-item-id="${item.id}"]`);
            }
          }
          if (itemEl) {
            itemEl.setAttribute("data-command-item-id", item.id);
            itemEl.setAttribute("data-value", item.value);
            if (item.keywords) itemEl.setAttribute("data-keywords", JSON.stringify(item.keywords));
            if (item.group) itemEl.setAttribute("data-group", item.group);
            if (item.disabled) itemEl.setAttribute("data-disabled", "true");
            if (item.forceMount) itemEl.setAttribute("data-force-mount", "true");
            itemEl.setAttribute("role", "option");
            itemEl.setAttribute("aria-selected", this.parent.selectedIndex === itemIndex);
            if (item.disabled) {
              itemEl.setAttribute("aria-disabled", "true");
            }
            if (this.parent.selectedIndex === itemIndex) {
              itemEl.setAttribute("data-selected", "true");
            }
            groupContainer.appendChild(itemEl);
            Alpine2.initTree(itemEl);
          }
        });
        container.appendChild(groupContainer);
      });
    }
  }));
}
function registerRzCommandGroup(Alpine2) {
  Alpine2.data("rzCommandGroup", () => ({
    parent: null,
    heading: "",
    templateId: "",
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandGroup must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      this.heading = this.$el.dataset.heading;
      this.templateId = this.$el.dataset.templateId;
      if (this.heading && this.templateId) {
        this.parent.registerGroupTemplate(this.heading, this.templateId);
      }
    }
  }));
}
async function generateBundleId(paths) {
  paths = [...paths].sort();
  const joinedPaths = paths.join("|");
  const encoder = new TextEncoder();
  const data2 = encoder.encode(joinedPaths);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function rizzyRequire(paths, callbackOrNonce, nonce) {
  let cbObj = void 0;
  let csp = void 0;
  if (typeof callbackOrNonce === "function") {
    cbObj = { success: callbackOrNonce };
  } else if (callbackOrNonce && typeof callbackOrNonce === "object") {
    cbObj = callbackOrNonce;
  } else if (typeof callbackOrNonce === "string") {
    csp = callbackOrNonce;
  }
  if (!csp && typeof nonce === "string") csp = nonce;
  const files = Array.isArray(paths) ? paths : [paths];
  return generateBundleId(files).then((bundleId) => {
    if (!loadjs.isDefined(bundleId)) {
      loadjs(files, bundleId, {
        // keep scripts ordered unless you explicitly change this later
        async: false,
        // pass CSP nonce to both script and style tags as your loader expects
        inlineScriptNonce: csp,
        inlineStyleNonce: csp
      });
    }
    return new Promise((resolve, reject) => {
      loadjs.ready(bundleId, {
        success: () => {
          try {
            if (cbObj && typeof cbObj.success === "function") cbObj.success();
          } catch (e2) {
            console.error("[rizzyRequire] success callback threw:", e2);
          }
          resolve({ bundleId });
        },
        error: (depsNotFound) => {
          try {
            if (cbObj && typeof cbObj.error === "function") {
              cbObj.error(depsNotFound);
            }
          } catch (e2) {
            console.error("[rizzyRequire] error callback threw:", e2);
          }
          reject(
            new Error(
              `[rizzyRequire] Failed to load bundle ${bundleId} (missing: ${Array.isArray(depsNotFound) ? depsNotFound.join(", ") : String(depsNotFound)})`
            )
          );
        }
      });
    });
  });
}
function registerComponents(Alpine2) {
  registerRzAccordion(Alpine2);
  registerAccordionItem(Alpine2);
  registerRzAlert(Alpine2);
  registerRzAspectRatio(Alpine2);
  registerRzBrowser(Alpine2);
  registerRzCalendar(Alpine2, rizzyRequire);
  registerRzCarousel(Alpine2, rizzyRequire);
  registerRzCodeViewer(Alpine2, rizzyRequire);
  registerRzCollapsible(Alpine2);
  registerRzCombobox(Alpine2, rizzyRequire);
  registerRzDateEdit(Alpine2, rizzyRequire);
  registerRzDialog(Alpine2);
  registerRzDropdownMenu(Alpine2);
  registerRzDarkModeToggle(Alpine2);
  registerRzEmbeddedPreview(Alpine2);
  registerRzEmpty(Alpine2);
  registerRzHeading(Alpine2);
  registerRzIndicator(Alpine2);
  registerRzInputGroupAddon(Alpine2);
  registerRzMarkdown(Alpine2, rizzyRequire);
  registerRzNavigationMenu(Alpine2);
  registerRzPopover(Alpine2);
  registerRzPrependInput(Alpine2);
  registerRzProgress(Alpine2);
  registerRzQuickReferenceContainer(Alpine2);
  registerRzSheet(Alpine2);
  registerRzTabs(Alpine2);
  registerRzSidebar(Alpine2);
  registerRzCommand(Alpine2);
  registerRzCommandItem(Alpine2);
  registerRzCommandList(Alpine2);
  registerRzCommandGroup(Alpine2);
}
function props(alpineRootElement) {
  if (!(alpineRootElement instanceof Element)) {
    console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el).");
    return {};
  }
  const propsScriptId = alpineRootElement.dataset.propsId;
  if (!propsScriptId) {
    return {};
  }
  const propsScriptEl = document.getElementById(propsScriptId);
  if (!propsScriptEl) {
    console.warn(`[Rizzy.props] Could not find the props script tag with ID '${propsScriptId}'.`);
    return {};
  }
  try {
    return JSON.parse(propsScriptEl.textContent || "{}");
  } catch (e2) {
    console.error(`[Rizzy.props] Failed to parse JSON from script tag #${propsScriptId}.`, e2);
    return {};
  }
}
const _registered = /* @__PURE__ */ new Map();
const _importCache = /* @__PURE__ */ new Map();
let _onAlpineInitAttached = false;
function onceImport(path) {
  if (!_importCache.has(path)) {
    _importCache.set(
      path,
      import(path).catch((err) => {
        _importCache.delete(path);
        throw err;
      })
    );
  }
  return _importCache.get(path);
}
function setAsyncLoader(name, path) {
  const Alpine2 = globalThis.Alpine;
  if (!(Alpine2 && typeof Alpine2.asyncData === "function")) {
    console.error(
      `[RizzyUI] Could not register async component '${name}'. AsyncAlpine not available.`
    );
    return false;
  }
  Alpine2.asyncData(
    name,
    () => onceImport(path).catch((error2) => {
      console.error(
        `[RizzyUI] Failed to load Alpine module '${name}' from '${path}'.`,
        error2
      );
      return () => ({
        _error: true,
        _errorMessage: `Module '${name}' failed to load.`
      });
    })
  );
  return true;
}
function registerAsyncComponent(name, path) {
  if (!name || !path) {
    console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
    return;
  }
  const prev = _registered.get(name);
  if (prev && prev.path !== path) {
    console.warn(
      `[RizzyUI] Re-registering '${name}' with a different path.
  Previous: ${prev.path}
  New:      ${path}`
    );
  }
  const Alpine2 = globalThis.Alpine;
  if (Alpine2 && Alpine2.version) {
    const changedPath = !prev || prev.path !== path;
    const alreadySet = prev && prev.loaderSet && !changedPath;
    if (!alreadySet) {
      const ok = setAsyncLoader(name, path);
      _registered.set(name, { path, loaderSet: ok });
    }
    return;
  }
  _registered.set(name, { path, loaderSet: false });
  if (!_onAlpineInitAttached) {
    _onAlpineInitAttached = true;
    document.addEventListener(
      "alpine:init",
      () => {
        for (const [n2, info] of _registered) {
          if (!info.loaderSet) {
            const ok = setAsyncLoader(n2, info.path);
            info.loaderSet = ok;
          }
        }
      },
      { once: true }
    );
  }
}
function registerMobileDirective(Alpine2) {
  Alpine2.directive("mobile", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    const bpMod = modifiers.find((m2) => m2.startsWith("bp-"));
    const BREAKPOINT = bpMod ? parseInt(bpMod.slice(3), 10) : 768;
    const ASSIGN_PROP = !!(expression && expression.length > 0);
    if (typeof window === "undefined" || !window.matchMedia) {
      el.dataset.mobile = "false";
      el.dataset.screen = "desktop";
      return;
    }
    const isMobileNow = () => window.innerWidth < BREAKPOINT;
    const reflect = (val) => {
      el.dataset.mobile = val ? "true" : "false";
      el.dataset.screen = val ? "mobile" : "desktop";
    };
    const getComponentData = () => {
      if (typeof Alpine2.$data === "function") return Alpine2.$data(el);
      return el.__x ? el.__x.$data : null;
    };
    const setProp = (val) => {
      if (!ASSIGN_PROP) return;
      const data2 = getComponentData();
      if (data2) data2[expression] = val;
    };
    const dispatch2 = (val) => {
      el.dispatchEvent(
        new CustomEvent("screen:change", {
          bubbles: true,
          detail: { isMobile: val, width: window.innerWidth, breakpoint: BREAKPOINT }
        })
      );
    };
    const mql = window.matchMedia(`(max-width: ${BREAKPOINT - 1}px)`);
    const update = () => {
      const val = isMobileNow();
      reflect(val);
      setProp(val);
      dispatch2(val);
    };
    update();
    const onChange = () => update();
    const onResize = () => update();
    mql.addEventListener("change", onChange);
    window.addEventListener("resize", onResize, { passive: true });
    cleanup2(() => {
      mql.removeEventListener("change", onChange);
      window.removeEventListener("resize", onResize);
    });
  });
}
function registerSyncDirective(Alpine2) {
  const handler4 = (el, { expression, modifiers }, { cleanup: cleanup2, effect: effect3 }) => {
    if (!expression || typeof expression !== "string") return;
    const setAtPath = (obj, path, value) => {
      const norm = path.replace(/\[(\d+)\]/g, ".$1");
      const keys = norm.split(".");
      const last = keys.pop();
      let cur = obj;
      for (const k of keys) {
        if (cur[k] == null || typeof cur[k] !== "object") cur[k] = isFinite(+k) ? [] : {};
        cur = cur[k];
      }
      cur[last] = value;
    };
    const stack = Alpine2.closestDataStack(el) || [];
    const childData = stack[0] || null;
    const parentData = stack[1] || null;
    if (!childData || !parentData) {
      if (import.meta?.env?.DEV) {
        console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
      }
      return;
    }
    const pairs = expression.split(",").map((s2) => s2.trim()).filter(Boolean).map((s2) => {
      const m2 = s2.split("->").map((x) => x.trim());
      if (m2.length !== 2) {
        console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', s2);
        return null;
      }
      return { parentPath: m2[0], childPath: m2[1] };
    }).filter(Boolean);
    const initChildWins = modifiers.includes("init-child") || modifiers.includes("child") || modifiers.includes("childWins");
    const guard = pairs.map(() => ({
      fromParent: false,
      fromChild: false,
      skipChildOnce: initChildWins
      // avoid redundant first child->parent write
    }));
    const stops = [];
    pairs.forEach((pair, idx) => {
      const g = guard[idx];
      if (initChildWins) {
        const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
        g.fromChild = true;
        setAtPath(parentData, pair.parentPath, childVal);
        queueMicrotask(() => {
          g.fromChild = false;
        });
      } else {
        const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
        g.fromParent = true;
        setAtPath(childData, pair.childPath, parentVal);
        queueMicrotask(() => {
          g.fromParent = false;
        });
      }
      const stop1 = effect3(() => {
        const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
        if (g.fromChild) return;
        g.fromParent = true;
        setAtPath(childData, pair.childPath, parentVal);
        queueMicrotask(() => {
          g.fromParent = false;
        });
      });
      const stop2 = effect3(() => {
        const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
        if (g.fromParent) return;
        if (g.skipChildOnce) {
          g.skipChildOnce = false;
          return;
        }
        g.fromChild = true;
        setAtPath(parentData, pair.parentPath, childVal);
        queueMicrotask(() => {
          g.fromChild = false;
        });
      });
      stops.push(stop1, stop2);
    });
    cleanup2(() => {
      for (const stop2 of stops) {
        try {
          stop2 && stop2();
        } catch {
        }
      }
    });
  };
  Alpine2.directive("syncprop", handler4);
}
class ThemeController {
  constructor() {
    this.storageKey = "darkMode";
    this.eventName = "rz:theme-change";
    this.darkClass = "dark";
    this._mode = "auto";
    this._mq = null;
    this._initialized = false;
    this._onMqChange = null;
    this._onStorage = null;
    this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  init() {
    if (this._initialized) return;
    if (typeof window === "undefined") return;
    this._initialized = true;
    this._mq = typeof window.matchMedia === "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
    const raw2 = this._safeReadStorage(this.storageKey);
    this._mode = this._normalizeMode(raw2 ?? "auto");
    this._sync();
    this._onMqChange = () => {
      this._sync();
    };
    if (this._mq) {
      if (typeof this._mq.addEventListener === "function") {
        this._mq.addEventListener("change", this._onMqChange);
      } else if (typeof this._mq.addListener === "function") {
        this._mq.addListener(this._onMqChange);
      }
    }
    this._onStorage = (e2) => {
      if (e2.key !== this.storageKey) return;
      const next = this._normalizeMode(e2.newValue ?? "auto");
      if (next !== this._mode) {
        this._mode = next;
        this._sync();
      }
    };
    window.addEventListener("storage", this._onStorage);
  }
  destroy() {
    if (!this._initialized) return;
    this._initialized = false;
    if (this._mq && this._onMqChange) {
      if (typeof this._mq.removeEventListener === "function") {
        this._mq.removeEventListener("change", this._onMqChange);
      } else if (typeof this._mq.removeListener === "function") {
        this._mq.removeListener(this._onMqChange);
      }
    }
    if (typeof window !== "undefined" && this._onStorage) {
      window.removeEventListener("storage", this._onStorage);
    }
    this._onMqChange = null;
    this._onStorage = null;
    this._mq = null;
    this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  // ----- Public State Accessors -----
  get mode() {
    return this._mode;
  }
  get prefersDark() {
    return !!this._mq?.matches;
  }
  get effectiveDark() {
    return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
  }
  // ----- Public API Surface -----
  isDark() {
    return this.effectiveDark;
  }
  isLight() {
    return !this.effectiveDark;
  }
  setLight() {
    this._setMode("light");
  }
  setDark() {
    this._setMode("dark");
  }
  setAuto() {
    this._setMode("auto");
  }
  toggle() {
    const currentlyDark = this.effectiveDark;
    this._setMode(currentlyDark ? "light" : "dark");
  }
  // ----- Internals -----
  _setMode(value) {
    this._mode = this._normalizeMode(value);
    this._persist();
    this._sync();
  }
  _normalizeMode(value) {
    return value === "light" || value === "dark" || value === "auto" ? value : "auto";
  }
  _safeReadStorage(key) {
    try {
      return window?.localStorage?.getItem(key);
    } catch (e2) {
      return null;
    }
  }
  _persist() {
    try {
      window?.localStorage?.setItem(this.storageKey, this._mode);
    } catch (e2) {
    }
  }
  _sync() {
    const effectiveDark = this.effectiveDark;
    const mode = this._mode;
    const prefersDark = this.prefersDark;
    const root = typeof document !== "undefined" ? document.documentElement : null;
    const domMatchesState = root ? root.classList.contains(this.darkClass) === effectiveDark && root.style.colorScheme === (effectiveDark ? "dark" : "light") : true;
    if (this._lastSnapshot.mode === mode && this._lastSnapshot.effectiveDark === effectiveDark && this._lastSnapshot.prefersDark === prefersDark && domMatchesState) {
      return;
    }
    this._lastSnapshot = { mode, effectiveDark, prefersDark };
    if (root) {
      root.classList.toggle(this.darkClass, effectiveDark);
      root.style.colorScheme = effectiveDark ? "dark" : "light";
    }
    if (typeof window !== "undefined") {
      window.dispatchEvent(
        new CustomEvent(this.eventName, {
          detail: {
            mode,
            darkMode: effectiveDark,
            // External API uses 'darkMode' convention
            prefersDark,
            source: "RizzyUI"
          }
        })
      );
    }
  }
}
const themeController = new ThemeController();
function registerStores(Alpine2) {
  themeController.init();
  Alpine2.store("theme", {
    // Reactive state mirrors
    // We mirror ALL derived properties to ensure Alpine reactivity works 
    // for bindings like x-show="prefersDark" or x-text="mode".
    _mode: themeController.mode,
    _prefersDark: themeController.prefersDark,
    _effectiveDark: themeController.effectiveDark,
    // Listener reference to prevent duplicate registration
    _onThemeChange: null,
    init() {
      if (!this._onThemeChange) {
        this._onThemeChange = () => this._refresh();
        window.addEventListener(themeController.eventName, this._onThemeChange);
      }
      this._refresh();
    },
    _refresh() {
      this._mode = themeController.mode;
      this._prefersDark = themeController.prefersDark;
      this._effectiveDark = themeController.effectiveDark;
    },
    // ----- Reactive Getters -----
    // These return the reactive properties from the store, ensuring Alpine
    // properly tracks dependencies.
    get mode() {
      return this._mode;
    },
    get effectiveDark() {
      return this._effectiveDark;
    },
    get prefersDark() {
      return this._prefersDark;
    },
    // Expose as getters (not methods) for consistency
    get isDark() {
      return this._effectiveDark;
    },
    get isLight() {
      return !this._effectiveDark;
    },
    // ----- Proxy Methods -----
    setLight() {
      themeController.setLight();
    },
    setDark() {
      themeController.setDark();
    },
    setAuto() {
      themeController.setAuto();
    },
    toggle() {
      themeController.toggle();
    }
  });
}
let cachedRizzyUI = null;
function bootstrapRizzyUI(Alpine2) {
  if (cachedRizzyUI) return cachedRizzyUI;
  Alpine2.plugin(module_default$2);
  Alpine2.plugin(module_default$1);
  Alpine2.plugin(module_default);
  Alpine2.plugin(async_alpine_default);
  if (typeof document !== "undefined") {
    document.addEventListener("alpine:init", () => {
      registerStores(Alpine2);
    });
  }
  registerComponents(Alpine2);
  registerMobileDirective(Alpine2);
  registerSyncDirective(Alpine2);
  cachedRizzyUI = {
    Alpine: Alpine2,
    require: rizzyRequire,
    toast: Toast,
    $data,
    props,
    registerAsyncComponent,
    theme: themeController
  };
  if (typeof window !== "undefined") {
    themeController.init();
    window.Alpine = Alpine2;
    window.Rizzy = { ...window.Rizzy || {}, ...cachedRizzyUI };
    document.dispatchEvent(new CustomEvent("rz:init", {
      detail: { Rizzy: window.Rizzy }
    }));
  }
  return cachedRizzyUI;
}
const RizzyUI = bootstrapRizzyUI(module_default$3);
module_default$3.start();
export {
  RizzyUI as default
};
//# sourceMappingURL=rizzyui-csp.es.js.map
</file>

<file path="wwwroot/js/rizzyui-csp.js">
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.RizzyUICsp = factory());
})(this, function() {
  "use strict";
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1 && index > lastFlushedIndex)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i2 = 0; i2 < queue.length; i2++) {
      queue[i2]();
      lastFlushedIndex = i2;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i2) => i2());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i2) => i2());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    el._x_effects?.forEach(dequeueJob);
    while (el._x_cleanups?.length)
      el._x_cleanups.pop()();
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mutations.length; i2++) {
      if (mutations[i2].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i2].type === "childList") {
        mutations[i2].removedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (!node._x_marker)
            return;
          removedNodes.add(node);
        });
        mutations[i2].addedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (removedNodes.has(node)) {
            removedNodes.delete(node);
            return;
          }
          if (node._x_marker)
            return;
          addedNodes.push(node);
        });
      }
      if (mutations[i2].type === "attributes") {
        let el = mutations[i2].target;
        let name = mutations[i2].attributeName;
        let oldValue = mutations[i2].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i2) => i2(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.some((i2) => i2.contains(node)))
        continue;
      onElRemoveds.forEach((i2) => i2(node));
    }
    for (let node of addedNodes) {
      if (!node.isConnected)
        continue;
      onElAddeds.forEach((i2) => i2(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i2) => Object.keys(i2)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Reflect.has(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return descriptor.set.call(thisProxy, value) || true;
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        if (typeof value === "object" && value !== null && value.__v_skip)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    let memoizedUtilities = getUtilities(el);
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, memoizedUtilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function getUtilities(el) {
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    let utils = { interceptor, ...utilities };
    onElRemoved(el, cleanup2);
    return utils;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e2) {
      handleError(e2, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate$1(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func.call(context, func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i2) => receiver(i2));
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directiveExists(name) {
    return Object.keys(directiveHandlers).includes(name);
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate$1.bind(evaluate$1, el)
    };
    let doCleanup = () => cleanups.forEach((i2) => i2());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i2) => i2;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i2) => i2.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a2, b) {
    let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
    setTimeout(() => {
      warnAboutMissingPlugins();
    });
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors2 = [];
  function interceptInit(callback) {
    initInterceptors2.push(callback);
  }
  var markerDispenser = 1;
  function initTree(el, walker = walk, intercept = () => {
  }) {
    if (findClosest(el, (i2) => i2._x_ignore))
      return;
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        if (el2._x_marker)
          return;
        intercept(el2, skip);
        initInterceptors2.forEach((i2) => i2(el2, skip));
        directives(el2, el2.attributes).forEach((handle) => handle());
        if (!el2._x_ignore)
          el2._x_marker = markerDispenser++;
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root, walker = walk) {
    walker(root, (el) => {
      cleanupElement(el);
      cleanupAttributes(el);
      delete el._x_marker;
    });
  }
  function warnAboutMissingPlugins() {
    let pluginDirectives = [
      ["ui", "dialog", ["[x-dialog], [x-popover]"]],
      ["anchor", "anchor", ["[x-anchor]"]],
      ["sort", "sort", ["[x-sort]"]]
    ];
    pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
      if (directiveExists(directive2))
        return;
      selectors.some((selector) => {
        if (document.querySelector(selector)) {
          warn(`found "${selector}", but missing ${plugin2} plugin`);
          return true;
        }
      });
    });
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i2) => {
      if (el.classList.contains(i2)) {
        el.classList.remove(i2);
        removed.push(i2);
      }
    });
    forAdd.forEach((i2) => {
      if (!el.classList.contains(i2)) {
        el.classList.add(i2);
        added.push(i2);
      }
    });
    return () => {
      removed.forEach((i2) => el.classList.add(i2));
      added.forEach((i2) => el.classList.remove(i2));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
    let delay2 = modifierValue$1(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue$1(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i2]) => i2?.());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e2) => {
            if (!e2.isFromCancelledTransition)
              throw e2;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay2 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay2);
        reachedEnd = true;
      });
    });
  }
  function modifierValue$1(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function onlyDuringClone(callback) {
    return (...args) => isCloning && callback(...args);
  }
  var interceptors = [];
  function interceptClone(callback) {
    interceptors.push(callback);
  }
  function cloneNode(from, to) {
    interceptors.forEach((i2) => i2(from, to));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to, (el, callback) => {
        callback(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (isRadio$1(el)) {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (isCheckbox(el)) {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  var booleanAttributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected",
    "shadowrootclonable",
    "shadowrootdelegatesfocus",
    "shadowrootserializable"
  ]);
  function isBooleanAttr(attrName) {
    return booleanAttributes.has(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate$1(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function isCheckbox(el) {
    return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
  }
  function isRadio$1(el) {
    return el.type === "radio" || el.localName === "ui-radio";
  }
  function debounce(func, wait) {
    let timeout;
    return function() {
      const context = this, args = arguments;
      const later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else ;
      }
      outerHash = JSON.stringify(outerGet());
      JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }
  function plugin(callback) {
    let callbacks = Array.isArray(callback) ? callback : [callback];
    callbacks.forEach((i2) => i2(alpine_default));
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    initInterceptors(stores[name]);
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine$1 = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.15.0",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate: evaluate$1,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine$1;
  var Token = class {
    constructor(type, value, start2, end) {
      this.type = type;
      this.value = value;
      this.start = start2;
      this.end = end;
    }
  };
  var Tokenizer = class {
    constructor(input) {
      this.input = input;
      this.position = 0;
      this.tokens = [];
    }
    tokenize() {
      while (this.position < this.input.length) {
        this.skipWhitespace();
        if (this.position >= this.input.length)
          break;
        const char = this.input[this.position];
        if (this.isDigit(char)) {
          this.readNumber();
        } else if (this.isAlpha(char) || char === "_" || char === "$") {
          this.readIdentifierOrKeyword();
        } else if (char === '"' || char === "'") {
          this.readString();
        } else if (char === "/" && this.peek() === "/") {
          this.skipLineComment();
        } else {
          this.readOperatorOrPunctuation();
        }
      }
      this.tokens.push(new Token("EOF", null, this.position, this.position));
      return this.tokens;
    }
    skipWhitespace() {
      while (this.position < this.input.length && /\s/.test(this.input[this.position])) {
        this.position++;
      }
    }
    skipLineComment() {
      while (this.position < this.input.length && this.input[this.position] !== "\n") {
        this.position++;
      }
    }
    isDigit(char) {
      return /[0-9]/.test(char);
    }
    isAlpha(char) {
      return /[a-zA-Z]/.test(char);
    }
    isAlphaNumeric(char) {
      return /[a-zA-Z0-9_$]/.test(char);
    }
    peek(offset2 = 1) {
      return this.input[this.position + offset2] || "";
    }
    readNumber() {
      const start2 = this.position;
      let hasDecimal = false;
      while (this.position < this.input.length) {
        const char = this.input[this.position];
        if (this.isDigit(char)) {
          this.position++;
        } else if (char === "." && !hasDecimal) {
          hasDecimal = true;
          this.position++;
        } else {
          break;
        }
      }
      const value = this.input.slice(start2, this.position);
      this.tokens.push(new Token("NUMBER", parseFloat(value), start2, this.position));
    }
    readIdentifierOrKeyword() {
      const start2 = this.position;
      while (this.position < this.input.length && this.isAlphaNumeric(this.input[this.position])) {
        this.position++;
      }
      const value = this.input.slice(start2, this.position);
      const keywords = ["true", "false", "null", "undefined", "new", "typeof", "void", "delete", "in", "instanceof"];
      if (keywords.includes(value)) {
        if (value === "true" || value === "false") {
          this.tokens.push(new Token("BOOLEAN", value === "true", start2, this.position));
        } else if (value === "null") {
          this.tokens.push(new Token("NULL", null, start2, this.position));
        } else if (value === "undefined") {
          this.tokens.push(new Token("UNDEFINED", void 0, start2, this.position));
        } else {
          this.tokens.push(new Token("KEYWORD", value, start2, this.position));
        }
      } else {
        this.tokens.push(new Token("IDENTIFIER", value, start2, this.position));
      }
    }
    readString() {
      const start2 = this.position;
      const quote = this.input[this.position];
      this.position++;
      let value = "";
      let escaped = false;
      while (this.position < this.input.length) {
        const char = this.input[this.position];
        if (escaped) {
          switch (char) {
            case "n":
              value += "\n";
              break;
            case "t":
              value += "	";
              break;
            case "r":
              value += "\r";
              break;
            case "\\":
              value += "\\";
              break;
            case quote:
              value += quote;
              break;
            default:
              value += char;
          }
          escaped = false;
        } else if (char === "\\") {
          escaped = true;
        } else if (char === quote) {
          this.position++;
          this.tokens.push(new Token("STRING", value, start2, this.position));
          return;
        } else {
          value += char;
        }
        this.position++;
      }
      throw new Error(`Unterminated string starting at position ${start2}`);
    }
    readOperatorOrPunctuation() {
      const start2 = this.position;
      const char = this.input[this.position];
      const next = this.peek();
      const nextNext = this.peek(2);
      if (char === "=" && next === "=" && nextNext === "=") {
        this.position += 3;
        this.tokens.push(new Token("OPERATOR", "===", start2, this.position));
      } else if (char === "!" && next === "=" && nextNext === "=") {
        this.position += 3;
        this.tokens.push(new Token("OPERATOR", "!==", start2, this.position));
      } else if (char === "=" && next === "=") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "==", start2, this.position));
      } else if (char === "!" && next === "=") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "!=", start2, this.position));
      } else if (char === "<" && next === "=") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "<=", start2, this.position));
      } else if (char === ">" && next === "=") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", ">=", start2, this.position));
      } else if (char === "&" && next === "&") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "&&", start2, this.position));
      } else if (char === "|" && next === "|") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "||", start2, this.position));
      } else if (char === "+" && next === "+") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "++", start2, this.position));
      } else if (char === "-" && next === "-") {
        this.position += 2;
        this.tokens.push(new Token("OPERATOR", "--", start2, this.position));
      } else {
        this.position++;
        const type = "()[]{},.;:?".includes(char) ? "PUNCTUATION" : "OPERATOR";
        this.tokens.push(new Token(type, char, start2, this.position));
      }
    }
  };
  var Parser = class {
    constructor(tokens) {
      this.tokens = tokens;
      this.position = 0;
    }
    parse() {
      if (this.isAtEnd()) {
        throw new Error("Empty expression");
      }
      const expr = this.parseExpression();
      this.match("PUNCTUATION", ";");
      if (!this.isAtEnd()) {
        throw new Error(`Unexpected token: ${this.current().value}`);
      }
      return expr;
    }
    parseExpression() {
      return this.parseAssignment();
    }
    parseAssignment() {
      const expr = this.parseTernary();
      if (this.match("OPERATOR", "=")) {
        const value = this.parseAssignment();
        if (expr.type === "Identifier" || expr.type === "MemberExpression") {
          return {
            type: "AssignmentExpression",
            left: expr,
            operator: "=",
            right: value
          };
        }
        throw new Error("Invalid assignment target");
      }
      return expr;
    }
    parseTernary() {
      const expr = this.parseLogicalOr();
      if (this.match("PUNCTUATION", "?")) {
        const consequent = this.parseExpression();
        this.consume("PUNCTUATION", ":");
        const alternate = this.parseExpression();
        return {
          type: "ConditionalExpression",
          test: expr,
          consequent,
          alternate
        };
      }
      return expr;
    }
    parseLogicalOr() {
      let expr = this.parseLogicalAnd();
      while (this.match("OPERATOR", "||")) {
        const operator = this.previous().value;
        const right = this.parseLogicalAnd();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseLogicalAnd() {
      let expr = this.parseEquality();
      while (this.match("OPERATOR", "&&")) {
        const operator = this.previous().value;
        const right = this.parseEquality();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseEquality() {
      let expr = this.parseRelational();
      while (this.match("OPERATOR", "==", "!=", "===", "!==")) {
        const operator = this.previous().value;
        const right = this.parseRelational();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseRelational() {
      let expr = this.parseAdditive();
      while (this.match("OPERATOR", "<", ">", "<=", ">=")) {
        const operator = this.previous().value;
        const right = this.parseAdditive();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseAdditive() {
      let expr = this.parseMultiplicative();
      while (this.match("OPERATOR", "+", "-")) {
        const operator = this.previous().value;
        const right = this.parseMultiplicative();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseMultiplicative() {
      let expr = this.parseUnary();
      while (this.match("OPERATOR", "*", "/", "%")) {
        const operator = this.previous().value;
        const right = this.parseUnary();
        expr = {
          type: "BinaryExpression",
          operator,
          left: expr,
          right
        };
      }
      return expr;
    }
    parseUnary() {
      if (this.match("OPERATOR", "++", "--")) {
        const operator = this.previous().value;
        const argument = this.parseUnary();
        return {
          type: "UpdateExpression",
          operator,
          argument,
          prefix: true
        };
      }
      if (this.match("OPERATOR", "!", "-", "+")) {
        const operator = this.previous().value;
        const argument = this.parseUnary();
        return {
          type: "UnaryExpression",
          operator,
          argument,
          prefix: true
        };
      }
      return this.parsePostfix();
    }
    parsePostfix() {
      let expr = this.parseMember();
      if (this.match("OPERATOR", "++", "--")) {
        const operator = this.previous().value;
        return {
          type: "UpdateExpression",
          operator,
          argument: expr,
          prefix: false
        };
      }
      return expr;
    }
    parseMember() {
      let expr = this.parsePrimary();
      while (true) {
        if (this.match("PUNCTUATION", ".")) {
          const property = this.consume("IDENTIFIER");
          expr = {
            type: "MemberExpression",
            object: expr,
            property: { type: "Identifier", name: property.value },
            computed: false
          };
        } else if (this.match("PUNCTUATION", "[")) {
          const property = this.parseExpression();
          this.consume("PUNCTUATION", "]");
          expr = {
            type: "MemberExpression",
            object: expr,
            property,
            computed: true
          };
        } else if (this.match("PUNCTUATION", "(")) {
          const args = this.parseArguments();
          expr = {
            type: "CallExpression",
            callee: expr,
            arguments: args
          };
        } else {
          break;
        }
      }
      return expr;
    }
    parseArguments() {
      const args = [];
      if (!this.check("PUNCTUATION", ")")) {
        do {
          args.push(this.parseExpression());
        } while (this.match("PUNCTUATION", ","));
      }
      this.consume("PUNCTUATION", ")");
      return args;
    }
    parsePrimary() {
      if (this.match("NUMBER")) {
        return { type: "Literal", value: this.previous().value };
      }
      if (this.match("STRING")) {
        return { type: "Literal", value: this.previous().value };
      }
      if (this.match("BOOLEAN")) {
        return { type: "Literal", value: this.previous().value };
      }
      if (this.match("NULL")) {
        return { type: "Literal", value: null };
      }
      if (this.match("UNDEFINED")) {
        return { type: "Literal", value: void 0 };
      }
      if (this.match("IDENTIFIER")) {
        return { type: "Identifier", name: this.previous().value };
      }
      if (this.match("PUNCTUATION", "(")) {
        const expr = this.parseExpression();
        this.consume("PUNCTUATION", ")");
        return expr;
      }
      if (this.match("PUNCTUATION", "[")) {
        return this.parseArrayLiteral();
      }
      if (this.match("PUNCTUATION", "{")) {
        return this.parseObjectLiteral();
      }
      throw new Error(`Unexpected token: ${this.current().type} "${this.current().value}"`);
    }
    parseArrayLiteral() {
      const elements = [];
      while (!this.check("PUNCTUATION", "]") && !this.isAtEnd()) {
        elements.push(this.parseExpression());
        if (this.match("PUNCTUATION", ",")) {
          if (this.check("PUNCTUATION", "]")) {
            break;
          }
        } else {
          break;
        }
      }
      this.consume("PUNCTUATION", "]");
      return {
        type: "ArrayExpression",
        elements
      };
    }
    parseObjectLiteral() {
      const properties = [];
      while (!this.check("PUNCTUATION", "}") && !this.isAtEnd()) {
        let key;
        let computed = false;
        if (this.match("STRING")) {
          key = { type: "Literal", value: this.previous().value };
        } else if (this.match("IDENTIFIER")) {
          const name = this.previous().value;
          key = { type: "Identifier", name };
        } else if (this.match("PUNCTUATION", "[")) {
          key = this.parseExpression();
          computed = true;
          this.consume("PUNCTUATION", "]");
        } else {
          throw new Error("Expected property key");
        }
        this.consume("PUNCTUATION", ":");
        const value = this.parseExpression();
        properties.push({
          type: "Property",
          key,
          value,
          computed,
          shorthand: false
        });
        if (this.match("PUNCTUATION", ",")) {
          if (this.check("PUNCTUATION", "}")) {
            break;
          }
        } else {
          break;
        }
      }
      this.consume("PUNCTUATION", "}");
      return {
        type: "ObjectExpression",
        properties
      };
    }
    match(...args) {
      for (let i2 = 0; i2 < args.length; i2++) {
        const arg = args[i2];
        if (i2 === 0 && args.length > 1) {
          const type = arg;
          for (let j = 1; j < args.length; j++) {
            if (this.check(type, args[j])) {
              this.advance();
              return true;
            }
          }
          return false;
        } else if (args.length === 1) {
          if (this.checkType(arg)) {
            this.advance();
            return true;
          }
          return false;
        }
      }
      return false;
    }
    check(type, value) {
      if (this.isAtEnd())
        return false;
      if (value !== void 0) {
        return this.current().type === type && this.current().value === value;
      }
      return this.current().type === type;
    }
    checkType(type) {
      if (this.isAtEnd())
        return false;
      return this.current().type === type;
    }
    advance() {
      if (!this.isAtEnd())
        this.position++;
      return this.previous();
    }
    isAtEnd() {
      return this.current().type === "EOF";
    }
    current() {
      return this.tokens[this.position];
    }
    previous() {
      return this.tokens[this.position - 1];
    }
    consume(type, value) {
      if (value !== void 0) {
        if (this.check(type, value))
          return this.advance();
        throw new Error(`Expected ${type} "${value}" but got ${this.current().type} "${this.current().value}"`);
      }
      if (this.check(type))
        return this.advance();
      throw new Error(`Expected ${type} but got ${this.current().type} "${this.current().value}"`);
    }
  };
  var Evaluator = class {
    evaluate({ node, scope: scope2 = {}, context = null, allowGlobal = false, forceBindingRootScopeToFunctions = true }) {
      switch (node.type) {
        case "Literal":
          return node.value;
        case "Identifier":
          if (node.name in scope2) {
            const value2 = scope2[node.name];
            if (typeof value2 === "function") {
              return value2.bind(scope2);
            }
            return value2;
          }
          if (allowGlobal && typeof globalThis[node.name] !== "undefined") {
            const value2 = globalThis[node.name];
            if (typeof value2 === "function") {
              return value2.bind(globalThis);
            }
            return value2;
          }
          throw new Error(`Undefined variable: ${node.name}`);
        case "MemberExpression":
          const object = this.evaluate({ node: node.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          if (object == null) {
            throw new Error("Cannot read property of null or undefined");
          }
          let memberValue;
          if (node.computed) {
            const property = this.evaluate({ node: node.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            memberValue = object[property];
          } else {
            memberValue = object[node.property.name];
          }
          if (typeof memberValue === "function") {
            if (forceBindingRootScopeToFunctions) {
              return memberValue.bind(scope2);
            } else {
              return memberValue.bind(object);
            }
          }
          return memberValue;
        case "CallExpression":
          const args = node.arguments.map((arg) => this.evaluate({ node: arg, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }));
          if (node.callee.type === "MemberExpression") {
            const obj = this.evaluate({ node: node.callee.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            let func;
            if (node.callee.computed) {
              const prop = this.evaluate({ node: node.callee.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
              func = obj[prop];
            } else {
              func = obj[node.callee.property.name];
            }
            if (typeof func !== "function") {
              throw new Error("Value is not a function");
            }
            return func.apply(obj, args);
          } else {
            if (node.callee.type === "Identifier") {
              const name = node.callee.name;
              let func;
              if (name in scope2) {
                func = scope2[name];
              } else if (allowGlobal && typeof globalThis[name] !== "undefined") {
                func = globalThis[name];
              } else {
                throw new Error(`Undefined variable: ${name}`);
              }
              if (typeof func !== "function") {
                throw new Error("Value is not a function");
              }
              const thisContext = context !== null ? context : scope2;
              return func.apply(thisContext, args);
            } else {
              const callee = this.evaluate({ node: node.callee, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
              if (typeof callee !== "function") {
                throw new Error("Value is not a function");
              }
              return callee.apply(context, args);
            }
          }
        case "UnaryExpression":
          const argument = this.evaluate({ node: node.argument, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          switch (node.operator) {
            case "!":
              return !argument;
            case "-":
              return -argument;
            case "+":
              return +argument;
            default:
              throw new Error(`Unknown unary operator: ${node.operator}`);
          }
        case "UpdateExpression":
          if (node.argument.type === "Identifier") {
            const name = node.argument.name;
            if (!(name in scope2)) {
              throw new Error(`Undefined variable: ${name}`);
            }
            const oldValue = scope2[name];
            if (node.operator === "++") {
              scope2[name] = oldValue + 1;
            } else if (node.operator === "--") {
              scope2[name] = oldValue - 1;
            }
            return node.prefix ? scope2[name] : oldValue;
          } else if (node.argument.type === "MemberExpression") {
            const obj = this.evaluate({ node: node.argument.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            const prop = node.argument.computed ? this.evaluate({ node: node.argument.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : node.argument.property.name;
            const oldValue = obj[prop];
            if (node.operator === "++") {
              obj[prop] = oldValue + 1;
            } else if (node.operator === "--") {
              obj[prop] = oldValue - 1;
            }
            return node.prefix ? obj[prop] : oldValue;
          }
          throw new Error("Invalid update expression target");
        case "BinaryExpression":
          const left = this.evaluate({ node: node.left, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          const right = this.evaluate({ node: node.right, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          switch (node.operator) {
            case "+":
              return left + right;
            case "-":
              return left - right;
            case "*":
              return left * right;
            case "/":
              return left / right;
            case "%":
              return left % right;
            case "==":
              return left == right;
            case "!=":
              return left != right;
            case "===":
              return left === right;
            case "!==":
              return left !== right;
            case "<":
              return left < right;
            case ">":
              return left > right;
            case "<=":
              return left <= right;
            case ">=":
              return left >= right;
            case "&&":
              return left && right;
            case "||":
              return left || right;
            default:
              throw new Error(`Unknown binary operator: ${node.operator}`);
          }
        case "ConditionalExpression":
          const test = this.evaluate({ node: node.test, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          return test ? this.evaluate({ node: node.consequent, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : this.evaluate({ node: node.alternate, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
        case "AssignmentExpression":
          const value = this.evaluate({ node: node.right, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
          if (node.left.type === "Identifier") {
            scope2[node.left.name] = value;
            return value;
          } else if (node.left.type === "MemberExpression") {
            const obj = this.evaluate({ node: node.left.object, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            if (node.left.computed) {
              const prop = this.evaluate({ node: node.left.property, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
              obj[prop] = value;
            } else {
              obj[node.left.property.name] = value;
            }
            return value;
          }
          throw new Error("Invalid assignment target");
        case "ArrayExpression":
          return node.elements.map((el) => this.evaluate({ node: el, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }));
        case "ObjectExpression":
          const result = {};
          for (const prop of node.properties) {
            const key = prop.computed ? this.evaluate({ node: prop.key, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions }) : prop.key.type === "Identifier" ? prop.key.name : this.evaluate({ node: prop.key, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            const value2 = this.evaluate({ node: prop.value, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
            result[key] = value2;
          }
          return result;
        default:
          throw new Error(`Unknown node type: ${node.type}`);
      }
    }
  };
  function generateRuntimeFunction(expression) {
    try {
      const tokenizer = new Tokenizer(expression);
      const tokens = tokenizer.tokenize();
      const parser = new Parser(tokens);
      const ast = parser.parse();
      const evaluator = new Evaluator();
      return function(options = {}) {
        const { scope: scope2 = {}, context = null, allowGlobal = false, forceBindingRootScopeToFunctions = false } = options;
        return evaluator.evaluate({ node: ast, scope: scope2, context, allowGlobal, forceBindingRootScopeToFunctions });
      };
    } catch (error2) {
      throw new Error(`CSP Parser Error: ${error2.message}`);
    }
  }
  function cspEvaluator(el, expression) {
    let dataStack = generateDataStack(el);
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluator(el, expression, dataStack);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateDataStack(el) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    return [overriddenMagics, ...closestDataStack(el)];
  }
  function generateEvaluator(el, expression, dataStack) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let completeScope = mergeProxies([scope2, ...dataStack]);
      let evaluate2 = generateRuntimeFunction(expression);
      let returnValue = evaluate2({
        scope: completeScope,
        allowGlobal: true,
        forceBindingRootScopeToFunctions: true
      });
      if (shouldAutoEvaluateFunctions && typeof returnValue === "function") {
        let nextReturnValue = returnValue.apply(returnValue, params);
        if (nextReturnValue instanceof Promise) {
          nextReturnValue.then((i2) => receiver(i2));
        } else {
          receiver(nextReturnValue);
        }
      } else if (typeof returnValue === "object" && returnValue instanceof Promise) {
        returnValue.then((i2) => receiver(i2));
      } else {
        receiver(returnValue);
      }
    };
  }
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i2 = 0; i2 < list.length; i2++) {
      map[list[i2]] = true;
    }
    return (val) => !!map[val];
  }
  var EMPTY_OBJ = Object.freeze({});
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol("iterate");
  var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i2 = 0; i2 < deps.length; i2++) {
        deps[i2].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys$1(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys: ownKeys$1
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v2) => Reflect.getPrototypeOf(v2);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = isMap(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r2) {
    return Boolean(r2 && r2.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i2) => value = i2);
      return value;
    };
    let unwatch = watch(getter, callback);
    cleanup2(unwatch);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    findClosest(el, (i2) => {
      if (i2._x_refs)
        refObjects.push(i2._x_refs);
    });
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id}-${key}` : `${name}-${id}`;
    });
  });
  interceptClone((from, to) => {
    if (from._x_id) {
      to._x_id = from._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i2) => result = i2);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone2.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e2) => {
          e2.stopPropagation();
          el.dispatchEvent(new e2.constructor(e2.type, e2));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    let placeInDom = (clone3, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone3, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone3, target2.nextSibling);
      } else {
        target2.appendChild(clone3);
      }
    };
    mutateDom(() => {
      placeInDom(clone2, target, modifiers);
      skipDuringClone(() => {
        initTree(clone2);
      })();
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(
      () => mutateDom(() => {
        clone2.remove();
        destroyTree(clone2);
      })
    );
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
    effect3(evaluateLater(el, expression));
  }));
  function on(el, event2, modifiers, callback) {
    let listenerTarget = el;
    let handler4 = (e2) => callback(e2);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
    if (modifiers.includes("dot"))
      event2 = dotSyntax(event2);
    if (modifiers.includes("camel"))
      event2 = camelCase2(event2);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.preventDefault();
        next(e2);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.stopPropagation();
        next(e2);
      });
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        next(e2);
        listenerTarget.removeEventListener(event2, handler4, options);
      });
    }
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (el.contains(e2.target))
          return;
        if (e2.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e2);
      });
    }
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.target === el && next(e2);
      });
    if (isKeyEvent(event2) || isClickEvent(event2)) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
          return;
        }
        next(e2);
      });
    }
    listenerTarget.addEventListener(event2, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event2, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event2) {
    return ["keydown", "keyup"].includes(event2);
  }
  function isClickEvent(event2) {
    return ["contextmenu", "click", "mouse"].some((i2) => event2.includes(i2));
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
    let keyModifiers = modifiers.filter((i2) => {
      return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(i2);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e2[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (isClickEvent(e2.type))
          return false;
        if (keyToModifiers(e2.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "comma": ",",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    let event2 = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener = isCloning ? () => {
    } : on(el, event2, modifiers, (e2) => {
      setValue(getInputValue(el, modifiers, e2, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
        setValue(
          getInputValue(el, modifiers, { target: el }, getValue())
        );
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e2) => {
        nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect3(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event2, currentValue) {
    return mutateDom(() => {
      if (event2 instanceof CustomEvent && event2.detail !== void 0)
        return event2.detail !== null && event2.detail !== void 0 ? event2.detail : event2.target.value;
      else if (isCheckbox(el)) {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event2.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event2.target.value);
          } else {
            newValue = event2.target.value;
          }
          return event2.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event2.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event2.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event2.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event2.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let newValue;
        if (isRadio$1(el)) {
          if (event2.target.checked) {
            newValue = event2.target.value;
          } else {
            newValue = currentValue;
          }
        } else {
          newValue = event2.target.value;
        }
        if (modifiers.includes("number")) {
          return safeParseNumber(newValue);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(newValue);
        } else if (modifiers.includes("trim")) {
          return newValue.trim();
        } else {
          return newValue;
        }
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
    cleanup2(() => {
      el._x_undoAddedClasses && el._x_undoAddedClasses();
      el._x_undoAddedStyles && el._x_undoAddedStyles();
    });
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate$1(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate$1(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate$1(el, reactiveData["destroy"]);
      undo();
    });
  });
  interceptClone((from, to) => {
    if (from._x_dataStack) {
      to._x_dataStack = from._x_dataStack;
      to.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => mutateDom(
        () => {
          destroyTree(el2);
          el2.remove();
        }
      ));
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i2) => i2 + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => {
            if (keys.includes(value2))
              warn("Duplicate key on x-for", el);
            keys.push(value2);
          }, { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i2 = 0; i2 < items.length; i2++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
          evaluateKey((value) => {
            if (keys.includes(value))
              warn("Duplicate key on x-for", el);
            keys.push(value);
          }, { scope: { index: i2, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i2 = 0; i2 < prevKeys.length; i2++) {
        let key = prevKeys[i2];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i2 = 0; i2 < keys.length; i2++) {
        let key = keys[i2];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i2, 0, key);
          adds.push([lastKey, i2]);
        } else if (prevIndex !== i2) {
          let keyInSpot = prevKeys.splice(i2, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i2, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i2 = 0; i2 < removes.length; i2++) {
        let key = removes[i2];
        if (!(key in lookup))
          continue;
        mutateDom(() => {
          destroyTree(lookup[key]);
          lookup[key].remove();
        });
        delete lookup[key];
      }
      for (let i2 = 0; i2 < moves.length; i2++) {
        let [keyInSpot, keyForSpot] = moves[i2];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i2 = 0; i2 < adds.length; i2++) {
        let [lastKey2, index] = adds[i2];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone2, reactiveScope, templateEl);
        clone2._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone2);
          skipDuringClone(() => initTree(clone2))();
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i2 = 0; i2 < sames.length; i2++) {
        lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
      names.forEach((name, i2) => {
        scopeVariables[name] = item[i2];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        mutateDom(() => {
          destroyTree(clone2);
          clone2.remove();
        });
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from, to) => {
    if (from._x_ids) {
      to._x_ids = from._x_ids;
    }
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e2) => {
      evaluate2(() => {
      }, { scope: { "$event": e2 }, params: [e2] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(cspEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default$3 = alpine_default;
  var module_default$3 = src_default$3;
  function src_default$2(Alpine2) {
    Alpine2.directive("collapse", collapse);
    collapse.inline = (el, { modifiers }) => {
      if (!modifiers.includes("min"))
        return;
      el._x_doShow = () => {
      };
      el._x_doHide = () => {
      };
    };
    function collapse(el, { modifiers }) {
      let duration = modifierValue(modifiers, "duration", 250) / 1e3;
      let floor = modifierValue(modifiers, "min", 0);
      let fullyHide = !modifiers.includes("min");
      if (!el._x_isShown)
        el.style.height = `${floor}px`;
      if (!el._x_isShown && fullyHide)
        el.hidden = true;
      if (!el._x_isShown)
        el.style.overflow = "hidden";
      let setFunction = (el2, styles) => {
        let revertFunction = Alpine2.setStyles(el2, styles);
        return styles.height ? () => {
        } : revertFunction;
      };
      let transitionStyles = {
        transitionProperty: "height",
        transitionDuration: `${duration}s`,
        transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
      };
      el._x_transition = {
        in(before = () => {
        }, after = () => {
        }) {
          if (fullyHide)
            el.hidden = false;
          if (fullyHide)
            el.style.display = null;
          let current = el.getBoundingClientRect().height;
          el.style.height = "auto";
          let full = el.getBoundingClientRect().height;
          if (current === full) {
            current = floor;
          }
          Alpine2.transition(el, Alpine2.setStyles, {
            during: transitionStyles,
            start: { height: current + "px" },
            end: { height: full + "px" }
          }, () => el._x_isShown = true, () => {
            if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
              el.style.overflow = null;
            }
          });
        },
        out(before = () => {
        }, after = () => {
        }) {
          let full = el.getBoundingClientRect().height;
          Alpine2.transition(el, setFunction, {
            during: transitionStyles,
            start: { height: full + "px" },
            end: { height: floor + "px" }
          }, () => el.style.overflow = "hidden", () => {
            el._x_isShown = false;
            if (el.style.height == `${floor}px` && fullyHide) {
              el.style.display = "none";
              el.hidden = true;
            }
          });
        }
      };
    }
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "min") {
      let match = rawValue.match(/([0-9]+)px/);
      if (match)
        return match[1];
    }
    return rawValue;
  }
  var module_default$2 = src_default$2;
  function src_default$1(Alpine2) {
    Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluate2 = evaluateLater2(expression);
      let options = {
        rootMargin: getRootMargin(modifiers),
        threshold: getThreshold(modifiers)
      };
      let observer2 = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting === (value === "leave"))
            return;
          evaluate2();
          modifiers.includes("once") && observer2.disconnect();
        });
      }, options);
      observer2.observe(el);
      cleanup2(() => {
        observer2.disconnect();
      });
    }));
  }
  function getThreshold(modifiers) {
    if (modifiers.includes("full"))
      return 0.99;
    if (modifiers.includes("half"))
      return 0.5;
    if (!modifiers.includes("threshold"))
      return 0;
    let threshold = modifiers[modifiers.indexOf("threshold") + 1];
    if (threshold === "100")
      return 1;
    if (threshold === "0")
      return 0;
    return Number(`.${threshold}`);
  }
  function getLengthValue(rawValue) {
    let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
    return match ? match[1] + (match[2] || "px") : void 0;
  }
  function getRootMargin(modifiers) {
    const key = "margin";
    const fallback = "0px 0px 0px 0px";
    const index = modifiers.indexOf(key);
    if (index === -1)
      return fallback;
    let values = [];
    for (let i2 = 1; i2 < 5; i2++) {
      values.push(getLengthValue(modifiers[index + i2] || ""));
    }
    values = values.filter((v2) => v2 !== void 0);
    return values.length ? values.join(" ").trim() : fallback;
  }
  var module_default$1 = src_default$1;
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
    return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r2;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === "full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (nodeIsAttached) {
        return !node.getClientRects().length;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = /* @__PURE__ */ function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e2) {
    return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e2) {
    return e2.key === "Tab" || e2.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i2) {
      if (fn(value)) {
        idx = i2;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event2) {
    return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2, config.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e2) {
      var target = getActualTarget(e2);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e2.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e2) {
      var target = getActualTarget(e2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e2.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e2.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e2.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e2) {
      if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
        e2.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e2)) {
        checkTab(e2);
        return;
      }
    };
    var checkClick = function checkClick2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };
  function src_default(Alpine2) {
    let lastFocused;
    let currentFocused;
    window.addEventListener("focusin", () => {
      lastFocused = currentFocused;
      currentFocused = document.activeElement;
    });
    Alpine2.magic("focus", (el) => {
      let within = el;
      return {
        __noscroll: false,
        __wrapAround: false,
        within(el2) {
          within = el2;
          return this;
        },
        withoutScrolling() {
          this.__noscroll = true;
          return this;
        },
        noscroll() {
          this.__noscroll = true;
          return this;
        },
        withWrapAround() {
          this.__wrapAround = true;
          return this;
        },
        wrap() {
          return this.withWrapAround();
        },
        focusable(el2) {
          return isFocusable(el2);
        },
        previouslyFocused() {
          return lastFocused;
        },
        lastFocused() {
          return lastFocused;
        },
        focused() {
          return currentFocused;
        },
        focusables() {
          if (Array.isArray(within))
            return within;
          return focusable(within, { displayCheck: "none" });
        },
        all() {
          return this.focusables();
        },
        isFirst(el2) {
          let els = this.all();
          return els[0] && els[0].isSameNode(el2);
        },
        isLast(el2) {
          let els = this.all();
          return els.length && els.slice(-1)[0].isSameNode(el2);
        },
        getFirst() {
          return this.all()[0];
        },
        getLast() {
          return this.all().slice(-1)[0];
        },
        getNext() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
            return list[0];
          }
          return list[list.indexOf(current) + 1];
        },
        getPrevious() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === 0) {
            return list.slice(-1)[0];
          }
          return list[list.indexOf(current) - 1];
        },
        first() {
          this.focus(this.getFirst());
        },
        last() {
          this.focus(this.getLast());
        },
        next() {
          this.focus(this.getNext());
        },
        previous() {
          this.focus(this.getPrevious());
        },
        prev() {
          return this.previous();
        },
        focus(el2) {
          if (!el2)
            return;
          setTimeout(() => {
            if (!el2.hasAttribute("tabindex"))
              el2.setAttribute("tabindex", "0");
            el2.focus({ preventScroll: this.__noscroll });
          });
        }
      };
    });
    Alpine2.directive("trap", Alpine2.skipDuringClone(
      (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
        let evaluator = evaluateLater2(expression);
        let oldValue = false;
        let options = {
          escapeDeactivates: false,
          allowOutsideClick: true,
          fallbackFocus: () => el
        };
        let undoInert = () => {
        };
        if (modifiers.includes("noautofocus")) {
          options.initialFocus = false;
        } else {
          let autofocusEl = el.querySelector("[autofocus]");
          if (autofocusEl)
            options.initialFocus = autofocusEl;
        }
        if (modifiers.includes("inert")) {
          options.onPostActivate = () => {
            Alpine2.nextTick(() => {
              undoInert = setInert(el);
            });
          };
        }
        let trap = createFocusTrap(el, options);
        let undoDisableScrolling = () => {
        };
        const releaseFocus = () => {
          undoInert();
          undoInert = () => {
          };
          undoDisableScrolling();
          undoDisableScrolling = () => {
          };
          trap.deactivate({
            returnFocus: !modifiers.includes("noreturn")
          });
        };
        effect3(() => evaluator((value) => {
          if (oldValue === value)
            return;
          if (value && !oldValue) {
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            setTimeout(() => {
              trap.activate();
            }, 15);
          }
          if (!value && oldValue) {
            releaseFocus();
          }
          oldValue = !!value;
        }));
        cleanup2(releaseFocus);
      },
      // When cloning, we only want to add aria-hidden attributes to the
      // DOM and not try to actually trap, as trapping can mess with the
      // live DOM and isn't just isolated to the cloned DOM.
      (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
        if (modifiers.includes("inert") && evaluate2(expression))
          setInert(el);
      }
    ));
  }
  function setInert(el) {
    let undos = [];
    crawlSiblingsUp(el, (sibling) => {
      let cache = sibling.hasAttribute("aria-hidden");
      sibling.setAttribute("aria-hidden", "true");
      undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
    });
    return () => {
      while (undos.length)
        undos.pop()();
    };
  }
  function crawlSiblingsUp(el, callback) {
    if (el.isSameNode(document.body) || !el.parentNode)
      return;
    Array.from(el.parentNode.children).forEach((sibling) => {
      if (sibling.isSameNode(el)) {
        crawlSiblingsUp(el.parentNode, callback);
      } else {
        callback(sibling);
      }
    });
  }
  function disableScrolling() {
    let overflow = document.documentElement.style.overflow;
    let paddingRight = document.documentElement.style.paddingRight;
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden";
    document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
    return () => {
      document.documentElement.style.overflow = overflow;
      document.documentElement.style.paddingRight = paddingRight;
    };
  }
  var module_default = src_default;
  /*! Bundled license information:
    tabbable/dist/index.esm.js:
      (*!
      * tabbable 5.3.3
      * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
      *)
    focus-trap/dist/focus-trap.esm.js:
      (*!
      * focus-trap 6.9.4
      * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
      *)
    */
  function eager() {
    return true;
  }
  function event({ component, argument }) {
    return new Promise((resolve) => {
      if (argument) {
        window.addEventListener(
          argument,
          () => resolve(),
          { once: true }
        );
      } else {
        const cb = (e2) => {
          if (e2.detail.id !== component.id) return;
          window.removeEventListener("async-alpine:load", cb);
          resolve();
        };
        window.addEventListener("async-alpine:load", cb);
      }
    });
  }
  function idle() {
    return new Promise((resolve) => {
      if ("requestIdleCallback" in window) {
        window.requestIdleCallback(resolve);
      } else {
        setTimeout(resolve, 200);
      }
    });
  }
  function media({ argument }) {
    return new Promise((resolve) => {
      if (!argument) {
        console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'");
        return resolve();
      }
      const mediaQuery = window.matchMedia(`(${argument})`);
      if (mediaQuery.matches) {
        resolve();
      } else {
        mediaQuery.addEventListener("change", resolve, { once: true });
      }
    });
  }
  function visible({ component, argument }) {
    return new Promise((resolve) => {
      const rootMargin = argument || "0px 0px 0px 0px";
      const observer2 = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          observer2.disconnect();
          resolve();
        }
      }, { rootMargin });
      observer2.observe(component.el);
    });
  }
  var strategies_default = {
    eager,
    event,
    idle,
    media,
    visible
  };
  async function awaitRequirements(component) {
    const requirements = parseRequirements(component.strategy);
    await generateRequirements(component, requirements);
  }
  async function generateRequirements(component, requirements) {
    if (requirements.type === "expression") {
      if (requirements.operator === "&&") {
        return Promise.all(
          requirements.parameters.map((param) => generateRequirements(component, param))
        );
      }
      if (requirements.operator === "||") {
        return Promise.any(
          requirements.parameters.map((param) => generateRequirements(component, param))
        );
      }
    }
    if (!strategies_default[requirements.method]) return false;
    return strategies_default[requirements.method]({
      component,
      argument: requirements.argument
    });
  }
  function parseRequirements(expression) {
    const tokens = tokenize(expression);
    let ast = parseExpression(tokens);
    if (ast.type === "method") {
      return {
        type: "expression",
        operator: "&&",
        parameters: [ast]
      };
    }
    return ast;
  }
  function tokenize(expression) {
    const regex = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g;
    const tokens = [];
    let match;
    while ((match = regex.exec(expression)) !== null) {
      const [_, parenthesis, operator, token] = match;
      if (parenthesis !== void 0) {
        tokens.push({ type: "parenthesis", value: parenthesis });
      } else if (operator !== void 0) {
        tokens.push({
          type: "operator",
          // we do the below to make operators backwards-compatible with previous
          // versions of Async Alpine, where '|' is equivalent to &&
          value: operator === "|" ? "&&" : operator
        });
      } else {
        const tokenObj = {
          type: "method",
          method: token.trim()
        };
        if (token.includes("(")) {
          tokenObj.method = token.substring(0, token.indexOf("(")).trim();
          tokenObj.argument = token.substring(
            token.indexOf("(") + 1,
            token.indexOf(")")
          );
        }
        if (token.method === "immediate") {
          token.method = "eager";
        }
        tokens.push(tokenObj);
      }
    }
    return tokens;
  }
  function parseExpression(tokens) {
    let ast = parseTerm(tokens);
    while (tokens.length > 0 && (tokens[0].value === "&&" || tokens[0].value === "|" || tokens[0].value === "||")) {
      const operator = tokens.shift().value;
      const right = parseTerm(tokens);
      if (ast.type === "expression" && ast.operator === operator) {
        ast.parameters.push(right);
      } else {
        ast = {
          type: "expression",
          operator,
          parameters: [ast, right]
        };
      }
    }
    return ast;
  }
  function parseTerm(tokens) {
    if (tokens[0].value === "(") {
      tokens.shift();
      const ast = parseExpression(tokens);
      if (tokens[0].value === ")") {
        tokens.shift();
      }
      return ast;
    } else {
      return tokens.shift();
    }
  }
  function async_alpine_default(Alpine2) {
    const directive2 = "load";
    const srcAttr = Alpine2.prefixed("load-src");
    const ignoreAttr = Alpine2.prefixed("ignore");
    let options = {
      defaultStrategy: "eager",
      keepRelativeURLs: false
    };
    let alias = false;
    let data2 = {};
    let realIndex = 0;
    function index() {
      return realIndex++;
    }
    Alpine2.asyncOptions = (opts) => {
      options = {
        ...options,
        ...opts
      };
    };
    Alpine2.asyncData = (name, download2 = false) => {
      data2[name] = {
        loaded: false,
        download: download2
      };
    };
    Alpine2.asyncUrl = (name, url) => {
      if (!name || !url || data2[name]) return;
      data2[name] = {
        loaded: false,
        download: () => import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          parseUrl(url)
        )
      };
    };
    Alpine2.asyncAlias = (path) => {
      alias = path;
    };
    const syncHandler = (el) => {
      Alpine2.skipDuringClone(() => {
        if (el._x_async) return;
        el._x_async = "init";
        el._x_ignore = true;
        el.setAttribute(ignoreAttr, "");
      })();
    };
    const handler4 = async (el) => {
      Alpine2.skipDuringClone(async () => {
        if (el._x_async !== "init") return;
        el._x_async = "await";
        const { name, strategy } = elementPrep(el);
        await awaitRequirements({
          name,
          strategy,
          el,
          id: el.id || index()
        });
        if (!el.isConnected) return;
        await download(name);
        if (!el.isConnected) return;
        activate(el);
        el._x_async = "loaded";
      })();
    };
    handler4.inline = syncHandler;
    Alpine2.directive(directive2, handler4).before("ignore");
    function elementPrep(el) {
      const name = parseName(el.getAttribute(Alpine2.prefixed("data")));
      const strategy = el.getAttribute(Alpine2.prefixed(directive2)) || options.defaultStrategy;
      const urlAttributeValue = el.getAttribute(srcAttr);
      if (urlAttributeValue) {
        Alpine2.asyncUrl(name, urlAttributeValue);
      }
      return {
        name,
        strategy
      };
    }
    async function download(name) {
      if (name.startsWith("_x_async_")) return;
      handleAlias(name);
      if (!data2[name] || data2[name].loaded) return;
      const module2 = await getModule(name);
      Alpine2.data(name, module2);
      data2[name].loaded = true;
    }
    async function getModule(name) {
      if (!data2[name]) return;
      const module2 = await data2[name].download(name);
      if (typeof module2 === "function") return module2;
      let whichExport = module2[name] || module2.default || Object.values(module2)[0] || false;
      return whichExport;
    }
    function activate(el) {
      Alpine2.destroyTree(el);
      el._x_ignore = false;
      el.removeAttribute(ignoreAttr);
      if (el.closest(`[${ignoreAttr}]`)) return;
      Alpine2.initTree(el);
    }
    function handleAlias(name) {
      if (!alias || data2[name]) return;
      if (typeof alias === "function") {
        Alpine2.asyncData(name, alias);
        return;
      }
      Alpine2.asyncUrl(name, alias.replaceAll("[name]", name));
    }
    function parseName(attribute) {
      const parsedName = (attribute || "").trim().split(/[({]/g)[0];
      const ourName = parsedName || `_x_async_${index()}`;
      return ourName;
    }
    function parseUrl(url) {
      if (options.keepRelativeURLs) return url;
      const absoluteReg = new RegExp("^(?:[a-z+]+:)?//", "i");
      if (!absoluteReg.test(url)) {
        return new URL(url, document.baseURI).href;
      }
      return url;
    }
  }
  function t(t2, e2) {
    if (!(t2 instanceof e2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function e(t2, e2) {
    for (var s2 = 0; s2 < e2.length; s2++) {
      var i2 = e2[s2];
      i2.enumerable = i2.enumerable || false;
      i2.configurable = true;
      if ("value" in i2) i2.writable = true;
      Object.defineProperty(t2, i2.key, i2);
    }
  }
  function s(t2, s2, i2) {
    if (s2) e(t2.prototype, s2);
    return t2;
  }
  var i = Object.defineProperty;
  var n = function(t2, e2) {
    return i(t2, "name", { value: e2, configurable: true });
  };
  var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
  var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
  var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var h = n(function(t2) {
    return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
  }, "stringToHTML"), d = n(function(t2) {
    var e2 = new DOMParser().parseFromString(t2, "application/xml");
    return document.importNode(e2.documentElement, true).outerHTML;
  }, "getSvgNode");
  var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
  var N = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
    }, 100);
  }, "fadeIn"), O = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "fadeOut"), T = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
    }, 100);
  }, "slideIn"), E = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "slideOut");
  var m = function() {
    function e2(s2) {
      var i2 = this;
      t(this, e2);
      this.notifyOut = n(function(t2) {
        t2(i2);
      }, "notifyOut");
      var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
      if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
        console.error("You must specify 'title' or 'text' at least.");
        return;
      }
      this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
    }
    s(e2, [{ key: "checkRequirements", value: function t2() {
      return !!(this.title || this.text);
    } }, { key: "setContainer", value: function t2() {
      var t3 = document.querySelector(".".concat(u.CONTAINER));
      t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
    } }, { key: "setPosition", value: function t2() {
      this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
    } }, { key: "setCloseButton", value: function t2() {
      var t3 = this;
      var e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
        t3.close();
      });
    } }, { key: "setWrapper", value: function t2() {
      var t3 = this;
      switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
        case p.OUTLINE:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
          break;
        case p.FILLED:
          this.wrapper.classList.add(u.NOTIFY_FILLED);
          break;
        default:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
      }
      switch (this.status) {
        case f.SUCCESS:
          this.wrapper.classList.add(u.NOTIFY_SUCCESS);
          break;
        case f.ERROR:
          this.wrapper.classList.add(u.NOTIFY_ERROR);
          break;
        case f.WARNING:
          this.wrapper.classList.add(u.NOTIFY_WARNING);
          break;
        case f.INFO:
          this.wrapper.classList.add(u.NOTIFY_INFO);
          break;
      }
      this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
        t3.wrapper.classList.add(e3);
      });
    } }, { key: "setContent", value: function t2() {
      var t3 = document.createElement("div");
      t3.classList.add(u.NOTIFY_CONTENT);
      var e3, s2;
      this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
    } }, { key: "setIcon", value: function t2() {
      var t3 = n(function(t4) {
        switch (t4) {
          case f.SUCCESS:
            return v.SUCCESS;
          case f.ERROR:
            return v.ERROR;
          case f.WARNING:
            return v.WARNING;
          case f.INFO:
            return v.INFO;
        }
      }, "computedIcon"), e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
    } }, { key: "setObserver", value: function t2() {
      var t3 = this;
      var e3 = new IntersectionObserver(function(e4) {
        if (e4[0].intersectionRatio <= 0) t3.close();
        else return;
      }, { threshold: 0 });
      setTimeout(function() {
        e3.observe(t3.wrapper);
      }, this.speed);
    } }, { key: "notifyIn", value: function t2(t2) {
      t2(this);
    } }, { key: "autoClose", value: function t2() {
      var t3 = this;
      setTimeout(function() {
        t3.close();
      }, this.autotimeout + this.speed);
    } }, { key: "close", value: function t2() {
      this.notifyOut(this.selectedNotifyOutEffect);
    } }, { key: "setEffect", value: function t2() {
      switch (this.effect) {
        case I.FADE:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
          break;
        case I.SLIDE:
          this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
          break;
        default:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
      }
    } }]);
    return e2;
  }();
  n(m, "Notify");
  var w = m;
  globalThis.Notify = w;
  const allowedStatuses = ["success", "error", "warning", "info"];
  const allowedPositions = [
    // Standard Corners
    "right top",
    "top right",
    "right bottom",
    "bottom right",
    "left top",
    "top left",
    "left bottom",
    "bottom left",
    // Centered Horizontally
    "center top",
    "x-center top",
    "center bottom",
    "x-center bottom",
    // Centered Vertically
    "left center",
    "left y-center",
    "y-center left",
    "right center",
    "right y-center",
    "y-center right",
    // Aliases for Centered Horizontally (already covered but good for robustness)
    "top center",
    "top x-center",
    "bottom center",
    "bottom x-center",
    // Absolute Center
    "center"
  ];
  const defaultConfig = {
    status: "info",
    title: "Notification",
    text: "",
    effect: "fade",
    speed: 300,
    autoclose: true,
    autotimeout: 4e3,
    position: "right top"
  };
  function renderToast(options = {}) {
    const config = {
      ...defaultConfig,
      ...options
    };
    if (!allowedStatuses.includes(config.status)) {
      console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
      config.status = "info";
    }
    if (!allowedPositions.includes(config.position)) {
      console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
      config.position = "right top";
    }
    new w(config);
  }
  const Toast = {
    custom: renderToast,
    success(text, title = "Success", options = {}) {
      renderToast({
        status: "success",
        title,
        text,
        ...options
      });
    },
    error(text, title = "Error", options = {}) {
      renderToast({
        status: "error",
        title,
        text,
        ...options
      });
    },
    warning(text, title = "Warning", options = {}) {
      renderToast({
        status: "warning",
        title,
        text,
        ...options
      });
    },
    info(text, title = "Info", options = {}) {
      renderToast({
        status: "info",
        title,
        text,
        ...options
      });
    },
    setDefaults(newDefaults = {}) {
      Object.assign(defaultConfig, newDefaults);
    },
    get allowedStatuses() {
      return [...allowedStatuses];
    },
    get allowedPositions() {
      return [...allowedPositions];
    }
  };
  const devnull = function() {
  }, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
  function subscribe(bundleIds, callbackFn) {
    bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
    const depsNotFound = [];
    let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
    fn = function(bundleId2, pathsNotFound) {
      if (pathsNotFound.length) depsNotFound.push(bundleId2);
      numWaiting--;
      if (!numWaiting) callbackFn(depsNotFound);
    };
    while (i2--) {
      bundleId = bundleIds[i2];
      r2 = bundleResultCache[bundleId];
      if (r2) {
        fn(bundleId, r2);
        continue;
      }
      q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
      q.push(fn);
    }
  }
  function publish(bundleId, pathsNotFound) {
    if (!bundleId) return;
    const q = bundleCallbackQueue[bundleId];
    bundleResultCache[bundleId] = pathsNotFound;
    if (!q) return;
    while (q.length) {
      q[0](bundleId, pathsNotFound);
      q.splice(0, 1);
    }
  }
  function executeCallbacks(args, depsNotFound) {
    if (typeof args === "function") args = { success: args };
    if (depsNotFound.length) (args.error || devnull)(depsNotFound);
    else (args.success || devnull)(args);
  }
  function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
    let result = ev.type[0];
    if (isLegacyIECss) {
      try {
        if (!e2.sheet.cssText.length) result = "e";
      } catch (x) {
        if (x.code !== 18) result = "e";
      }
    }
    if (result === "e") {
      numTries += 1;
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e2.rel === "preload" && e2.as === "style") {
      e2.rel = "stylesheet";
      return;
    }
    callbackFn(path, result, ev.defaultPrevented);
  }
  function loadFile(path, callbackFn, args, numTries) {
    const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
    let isLegacyIECss, hasModuleSupport, e2;
    numTries = numTries || 0;
    if (/(^css!|\.css$)/.test(pathname)) {
      e2 = doc.createElement("link");
      e2.rel = "stylesheet";
      e2.href = pathStripped;
      isLegacyIECss = "hideFocus" in e2;
      if (isLegacyIECss && e2.relList) {
        isLegacyIECss = 0;
        e2.rel = "preload";
        e2.as = "style";
      }
      if (args.inlineStyleNonce) {
        e2.setAttribute("nonce", args.inlineStyleNonce);
      }
    } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
      e2 = doc.createElement("img");
      e2.src = pathStripped;
    } else {
      e2 = doc.createElement("script");
      e2.src = pathStripped;
      e2.async = async === void 0 ? true : async;
      if (args.inlineScriptNonce) {
        e2.setAttribute("nonce", args.inlineScriptNonce);
      }
      hasModuleSupport = "noModule" in e2;
      if (/^module!/.test(pathname)) {
        if (!hasModuleSupport) return callbackFn(path, "l");
        e2.type = "module";
      } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
        return callbackFn(path, "l");
      }
    }
    const onEvent = function(ev) {
      handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
    };
    e2.addEventListener("load", onEvent, { once: true });
    e2.addEventListener("error", onEvent, { once: true });
    if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
  }
  function loadFiles(paths, callbackFn, args) {
    paths = Array.isArray(paths) ? paths : [paths];
    let numWaiting = paths.length, pathsNotFound = [];
    function fn(path, result, defaultPrevented) {
      if (result === "e") pathsNotFound.push(path);
      if (result === "b") {
        if (defaultPrevented) pathsNotFound.push(path);
        else return;
      }
      numWaiting--;
      if (!numWaiting) callbackFn(pathsNotFound);
    }
    for (let i2 = 0; i2 < paths.length; i2++) {
      loadFile(paths[i2], fn, args);
    }
  }
  function loadjs(paths, arg1, arg2) {
    let bundleId, args;
    if (arg1 && typeof arg1 === "string" && arg1.trim) {
      bundleId = arg1.trim();
    }
    args = (bundleId ? arg2 : arg1) || {};
    if (bundleId) {
      if (bundleId in bundleIdCache) {
        throw "LoadJS";
      } else {
        bundleIdCache[bundleId] = true;
      }
    }
    function loadFn(resolve, reject) {
      loadFiles(paths, function(pathsNotFound) {
        executeCallbacks(args, pathsNotFound);
        if (resolve) {
          executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
        }
        publish(bundleId, pathsNotFound);
      }, args);
    }
    if (args.returnPromise) {
      return new Promise(loadFn);
    } else {
      loadFn();
    }
  }
  loadjs.ready = function ready(deps, args) {
    subscribe(deps, function(depsNotFound) {
      executeCallbacks(args, depsNotFound);
    });
    return loadjs;
  };
  loadjs.done = function done(bundleId) {
    publish(bundleId, []);
  };
  loadjs.reset = function reset() {
    Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
    Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
    Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
  };
  loadjs.isDefined = function isDefined(bundleId) {
    return bundleId in bundleIdCache;
  };
  function $data(idOrElement) {
    if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
      console.error(
        "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
      );
      return void 0;
    }
    if (idOrElement instanceof Element) {
      const target = resolveProxy(idOrElement) || idOrElement;
      let alpineData = Alpine.$data(target);
      if (alpineData === void 0) {
        const nearest = target.closest?.("[x-data]");
        if (nearest) {
          alpineData = Alpine.$data(nearest);
        }
      }
      if (alpineData === void 0) {
        warnDataUndefined("element", target);
      }
      return alpineData;
    }
    if (typeof idOrElement === "string") {
      const componentId = idOrElement.trim();
      if (!componentId) {
        console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
        return void 0;
      }
      const selector = `[data-alpine-root="${cssEscapeSafe(componentId)}"]`;
      let root = null;
      const wrapper = document.getElementById(componentId);
      if (wrapper) {
        root = wrapper.matches(selector) ? wrapper : wrapper.querySelector(selector);
      }
      if (!root) {
        root = findAlpineRootById(componentId);
      }
      if (!root) {
        console.warn(
          `Rizzy.$data: Could not locate an Alpine root using ${selector} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${componentId}"' is present.`
        );
        return void 0;
      }
      const alpineData = Alpine.$data(root);
      if (alpineData === void 0) {
        warnDataUndefined(`data-alpine-root="${componentId}"`, root);
      }
      return alpineData;
    }
    console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
    return void 0;
  }
  function resolveProxy(el) {
    if (!(el instanceof Element)) return null;
    const isProxyTag = el.tagName?.toLowerCase?.() === "rz-proxy";
    const proxyFor = el.getAttribute?.("data-for");
    if (isProxyTag || proxyFor) {
      const id = proxyFor || "";
      if (!id) return el;
      const root = findAlpineRootById(id);
      if (!root) {
        console.warn(
          `Rizzy.$data: Proxy element could not resolve Alpine root for id "${id}". Ensure the teleported root rendered with data-alpine-root="${id}".`
        );
        return null;
      }
      return root;
    }
    return el;
  }
  function findAlpineRootById(id) {
    const sel = `[data-alpine-root="${cssEscapeSafe(id)}"]`;
    const candidates = document.querySelectorAll(sel);
    for (const n2 of candidates) {
      if (n2.hasAttribute("x-data")) return n2;
    }
    if (candidates.length > 0) return candidates[0];
    return document.getElementById(id) || null;
  }
  function cssEscapeSafe(s2) {
    try {
      if (window.CSS && typeof window.CSS.escape === "function") {
        return window.CSS.escape(s2);
      }
    } catch (_) {
    }
    return String(s2).replace(/"/g, '\\"');
  }
  function warnDataUndefined(origin, target) {
    const desc = `${target.tagName?.toLowerCase?.() || "node"}${target.id ? "#" + target.id : ""}${target.classList?.length ? "." + Array.from(target.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located target via ${origin} (${desc}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
    );
  }
  function registerRzAccordion(Alpine2) {
    Alpine2.data("rzAccordion", () => ({
      selected: "",
      // ID of the currently selected/opened section (if not allowMultiple)
      allowMultiple: false,
      // Whether multiple sections can be open
      init() {
        this.allowMultiple = this.$el.dataset.multiple === "true";
      },
      destroy() {
      }
    }));
  }
  function registerAccordionItem(Alpine2) {
    Alpine2.data("accordionItem", () => ({
      open: false,
      sectionId: "",
      expandedClass: "",
      init() {
        this.open = this.$el.dataset.isOpen === "true";
        this.sectionId = this.$el.dataset.sectionId;
        this.expandedClass = this.$el.dataset.expandedClass;
        const self2 = this;
        if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
          this.$watch("selected", (value, oldValue) => {
            if (value !== self2.sectionId && !self2.allowMultiple) {
              self2.open = false;
            }
          });
        } else {
          console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
        }
      },
      destroy() {
      },
      // Toggle the section's open state and update the parent's 'selected' state.
      toggle() {
        this.selected = this.sectionId;
        this.open = !this.open;
      },
      // Get the CSS classes for the expanded/collapsed chevron icon.
      getExpandedCss() {
        return this.open ? this.expandedClass : "";
      },
      // Get the value for aria-expanded attribute based on the 'open' state.
      getAriaExpanded() {
        return this.open ? "true" : "false";
      }
    }));
  }
  function registerRzAlert(Alpine2) {
    Alpine2.data("rzAlert", () => {
      return {
        parentElement: null,
        showAlert: true,
        init() {
          const alpineRoot = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
          this.parentElement = document.getElementById(alpineRoot);
        },
        dismiss() {
          this.showAlert = false;
          const self2 = this;
          setTimeout(() => {
            self2.parentElement.style.display = "none";
          }, 205);
        }
      };
    });
  }
  function registerRzAspectRatio(Alpine2) {
    Alpine2.data("rzAspectRatio", () => ({
      init() {
        const ratio = parseFloat(this.$el.dataset.ratio);
        if (!isNaN(ratio) && ratio > 0) {
          const paddingBottom = 100 / ratio + "%";
          this.$el.style.paddingBottom = paddingBottom;
        } else {
          this.$el.style.paddingBottom = "100%";
        }
      }
    }));
  }
  function registerRzBrowser(Alpine2) {
    Alpine2.data("rzBrowser", () => {
      return {
        screenSize: "",
        setDesktopScreenSize() {
          this.screenSize = "";
        },
        setTabletScreenSize() {
          this.screenSize = "max-w-2xl";
        },
        setPhoneScreenSize() {
          this.screenSize = "max-w-sm";
        },
        // Get CSS classes for browser border based on screen size
        getBrowserBorderCss() {
          return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
        },
        // Get CSS classes for desktop screen button styling
        getDesktopScreenCss() {
          return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for tablet screen button styling
        getTabletScreenCss() {
          return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for phone screen button styling
        getPhoneScreenCss() {
          return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        }
      };
    });
  }
  function registerRzCalendar(Alpine2, require) {
    Alpine2.data("rzCalendar", () => ({
      calendar: null,
      initialized: false,
      init() {
        const assets = JSON.parse(this.$el.dataset.assets || "[]");
        const configId = this.$el.dataset.configId;
        const nonce = this.$el.dataset.nonce;
        if (assets.length === 0) {
          console.warn("RzCalendar: No assets configured.");
          return;
        }
        require(assets, {
          success: () => {
            this.initCalendar(configId);
          },
          error: (e2) => console.error("RzCalendar: Failed to load assets", e2)
        }, nonce);
      },
      initCalendar(configId) {
        const configElement = document.getElementById(configId);
        if (!configElement) {
          console.error(`RzCalendar: Config element #${configId} not found.`);
          return;
        }
        let rawConfig = {};
        try {
          rawConfig = JSON.parse(configElement.textContent);
        } catch (e2) {
          console.error("RzCalendar: Failed to parse config JSON", e2);
          return;
        }
        const actionHandlers = {
          clickDay: (e2, self2) => this.dispatchCalendarEvent("clickDay", { event: e2, dates: self2.selectedDates }),
          clickWeekNumber: (e2, number, days, year) => this.dispatchCalendarEvent("clickWeekNumber", { event: e2, number, days, year }),
          clickMonth: (e2, month) => this.dispatchCalendarEvent("clickMonth", { event: e2, month }),
          clickYear: (e2, year) => this.dispatchCalendarEvent("clickYear", { event: e2, year }),
          clickArrow: (e2, year, month) => this.dispatchCalendarEvent("clickArrow", { event: e2, year, month }),
          changeTime: (e2, time, hours, minutes, keeping) => this.dispatchCalendarEvent("changeTime", { event: e2, time, hours, minutes, keeping }),
          changeView: (view) => this.dispatchCalendarEvent("changeView", { view }),
          getDays: (day, date, HTMLElement2, HTMLButtonElement, self2) => {
          }
        };
        const options = {
          ...rawConfig.options,
          styles: rawConfig.styles,
          // Correct property name for VCP
          actions: actionHandlers
        };
        if (window.VanillaCalendarPro) {
          this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, options);
          this.calendar.init();
          this.initialized = true;
          this.dispatchCalendarEvent("init", { instance: this.calendar });
        } else {
          console.error("RzCalendar: VanillaCalendar global not found.");
        }
      },
      dispatchCalendarEvent(eventName, detail) {
        this.$dispatch(`rz:calendar:${eventName}`, detail);
      },
      destroy() {
        if (this.calendar) {
          this.calendar.destroy();
          this.dispatchCalendarEvent("destroy", {});
        }
      }
    }));
  }
  function registerRzCarousel(Alpine2, require) {
    function parseJsonFromScriptId(id) {
      if (!id) return {};
      const el = document.getElementById(id);
      if (!el) {
        console.warn(`[rzCarousel] JSON script element #${id} not found.`);
        return {};
      }
      try {
        return JSON.parse(el.textContent || "{}");
      } catch (e2) {
        console.error(`[rzCarousel] Failed to parse JSON from #${id}:`, e2);
        return {};
      }
    }
    Alpine2.data("rzCarousel", () => ({
      emblaApi: null,
      canScrollPrev: false,
      canScrollNext: false,
      selectedIndex: 0,
      scrollSnaps: [],
      init() {
        const assetsToLoad = (() => {
          try {
            return JSON.parse(this.$el.dataset.assets || "[]");
          } catch (e2) {
            console.error("[rzCarousel] Bad assets JSON:", e2);
            return [];
          }
        })();
        const nonce = this.$el.dataset.nonce || "";
        const config = parseJsonFromScriptId(this.$el.dataset.config);
        const options = config.Options || {};
        const pluginsConfig = config.Plugins || [];
        const self2 = this;
        if (assetsToLoad.length > 0 && typeof require === "function") {
          require(
            assetsToLoad,
            {
              success() {
                if (window.EmblaCarousel) {
                  self2.initializeEmbla(options, pluginsConfig);
                } else {
                  console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
                }
              },
              error(err) {
                console.error("[rzCarousel] Failed to load EmblaCarousel assets.", err);
              }
            },
            nonce
          );
        } else {
          if (window.EmblaCarousel) {
            this.initializeEmbla(options, pluginsConfig);
          } else {
            console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
          }
        }
      },
      initializeEmbla(options, pluginsConfig) {
        const viewport = this.$el.querySelector('[x-ref="viewport"]');
        if (!viewport) {
          console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
          return;
        }
        const instantiatedPlugins = this.instantiatePlugins(pluginsConfig);
        this.emblaApi = window.EmblaCarousel(viewport, options, instantiatedPlugins);
        this.emblaApi.on("select", this.onSelect.bind(this));
        this.emblaApi.on("reInit", this.onSelect.bind(this));
        this.onSelect();
      },
      instantiatePlugins(pluginsConfig) {
        if (!Array.isArray(pluginsConfig) || pluginsConfig.length === 0) {
          return [];
        }
        return pluginsConfig.map((pluginInfo) => {
          const constructor = window[pluginInfo.Name];
          if (typeof constructor !== "function") {
            console.error(`[rzCarousel] Plugin constructor '${pluginInfo.Name}' not found on window object.`);
            return null;
          }
          try {
            return constructor(pluginInfo.Options || {});
          } catch (e2) {
            console.error(`[rzCarousel] Error instantiating plugin '${pluginInfo.Name}':`, e2);
            return null;
          }
        }).filter(Boolean);
      },
      destroy() {
        if (this.emblaApi) this.emblaApi.destroy();
      },
      onSelect() {
        if (!this.emblaApi) return;
        this.selectedIndex = this.emblaApi.selectedScrollSnap();
        this.canScrollPrev = this.emblaApi.canScrollPrev();
        this.canScrollNext = this.emblaApi.canScrollNext();
        this.scrollSnaps = this.emblaApi.scrollSnapList();
      },
      cannotScrollPrev() {
        return !this.canScrollPrev;
      },
      cannotScrollNext() {
        return !this.canScrollNext;
      },
      scrollPrev() {
        this.emblaApi?.scrollPrev();
      },
      scrollNext() {
        this.emblaApi?.scrollNext();
      },
      scrollTo(index) {
        this.emblaApi?.scrollTo(index);
      }
    }));
  }
  function registerRzCodeViewer(Alpine2, require) {
    Alpine2.data("rzCodeViewer", () => {
      return {
        expand: false,
        border: true,
        copied: false,
        copyTitle: "Copy",
        // Default title
        copiedTitle: "Copied!",
        // Default title
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const codeId = this.$el.dataset.codeid;
          const nonce = this.$el.dataset.nonce;
          this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
          this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
          require(assets, {
            success: function() {
              const codeBlock = document.getElementById(codeId);
              if (window.hljs && codeBlock) {
                window.hljs.highlightElement(codeBlock);
              }
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        },
        // Function to check if code is NOT copied (for x-show)
        notCopied() {
          return !this.copied;
        },
        // Function to reset the copied state (e.g., on blur)
        disableCopied() {
          this.copied = false;
        },
        // Function to toggle the expand state
        toggleExpand() {
          this.expand = !this.expand;
        },
        // Function to copy code to clipboard
        copyHTML() {
          navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
          this.copied = !this.copied;
        },
        // Get the title for the copy button (copy/copied)
        getCopiedTitle() {
          return this.copied ? this.copiedTitle : this.copyTitle;
        },
        // Get CSS classes for the copy button based on copied state
        getCopiedCss() {
          return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
        },
        // Get CSS classes for the code container based on expand state
        getExpandCss() {
          return [this.expand ? "" : "max-h-60"];
        },
        // Get CSS classes for the expand button icon based on expand state
        getExpandButtonCss() {
          return this.expand ? "rotate-180" : "rotate-0";
        }
      };
    });
  }
  function registerRzCollapsible(Alpine2) {
    Alpine2.data("rzCollapsible", () => ({
      isOpen: false,
      init() {
        this.isOpen = this.$el.dataset.defaultOpen === "true";
      },
      toggle() {
        this.isOpen = !this.isOpen;
      },
      state() {
        return this.isOpen ? "open" : "closed";
      }
    }));
  }
  function registerRzCombobox(Alpine2, require) {
    Alpine2.data("rzCombobox", () => ({
      tomSelect: null,
      init() {
        const assets = JSON.parse(this.$el.dataset.assets || "[]");
        const nonce = this.$el.dataset.nonce;
        if (assets.length > 0 && typeof require === "function") {
          require(assets, {
            success: () => this.initTomSelect(),
            error: (err) => console.error("RzCombobox: Failed to load assets.", err)
          }, nonce);
        } else if (window.TomSelect) {
          this.initTomSelect();
        }
      },
      initTomSelect() {
        const selectEl = this.$refs.selectInput;
        if (!selectEl) return;
        const configEl = document.getElementById(this.$el.dataset.configId);
        const config = configEl ? JSON.parse(configEl.textContent) : {};
        const render = {};
        const createAlpineRow = (templateRef, data2) => {
          if (!templateRef) return null;
          const div = document.createElement("div");
          let parsedItem = data2.item;
          if (typeof parsedItem === "string") {
            try {
              parsedItem = JSON.parse(parsedItem);
            } catch (e2) {
            }
          }
          const scope2 = {
            ...data2,
            item: parsedItem
          };
          if (Alpine2 && typeof Alpine2.addScopeToNode === "function") {
            Alpine2.addScopeToNode(div, scope2);
          } else {
            div._x_dataStack = [scope2];
          }
          div.innerHTML = templateRef.innerHTML;
          return div;
        };
        if (this.$refs.optionTemplate) {
          render.option = (data2, escape) => createAlpineRow(this.$refs.optionTemplate, data2);
        }
        if (this.$refs.itemTemplate) {
          render.item = (data2, escape) => createAlpineRow(this.$refs.itemTemplate, data2);
        }
        config.dataAttr = "data-item";
        this.tomSelect = new TomSelect(selectEl, {
          ...config,
          render,
          onInitialize: function() {
            this.sync();
          }
        });
      },
      destroy() {
        if (this.tomSelect) {
          this.tomSelect.destroy();
          this.tomSelect = null;
        }
      }
    }));
  }
  function registerRzDateEdit(Alpine2, require) {
    Alpine2.data("rzDateEdit", () => ({
      options: {},
      placeholder: "",
      prependText: "",
      init() {
        const cfgString = this.$el.dataset.config;
        const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
        if (cfgString) {
          const parsed = JSON.parse(cfgString);
          if (parsed) {
            this.options = parsed.options || {};
            this.placeholder = parsed.placeholder || "";
            this.prependText = parsed.prependText || "";
          }
        }
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require(assets, {
          success: function() {
            if (window.flatpickr && inputElem) {
              window.flatpickr(inputElem, this.options);
            }
          },
          error: function() {
            console.error("Failed to load Flatpickr assets.");
          }
        }, nonce);
      }
    }));
  }
  function registerRzDialog(Alpine2) {
    Alpine2.data("rzDialog", () => ({
      modalOpen: false,
      // Main state variable
      eventTriggerName: "",
      closeEventName: "rz:modal-close",
      // Default value, corresponds to Constants.Events.ModalClose
      closeOnEscape: true,
      closeOnClickOutside: true,
      modalId: "",
      bodyId: "",
      footerId: "",
      nonce: "",
      _escapeListener: null,
      _openListener: null,
      _closeEventListener: null,
      init() {
        this.modalId = this.$el.dataset.modalId || "";
        this.bodyId = this.$el.dataset.bodyId || "";
        this.footerId = this.$el.dataset.footerId || "";
        this.nonce = this.$el.dataset.nonce || "";
        this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
        this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
        this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
        this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
        this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
          detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
          bubbles: true
        }));
        if (this.eventTriggerName) {
          this._openListener = (e2) => {
            this.openModal(e2);
          };
          window.addEventListener(this.eventTriggerName, this._openListener);
        }
        this._closeEventListener = (event2) => {
          if (this.modalOpen) {
            this.closeModalInternally("event");
          }
        };
        window.addEventListener(this.closeEventName, this._closeEventListener);
        this._escapeListener = (e2) => {
          if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
            this.closeModalInternally("escape");
          }
        };
        window.addEventListener("keydown", this._escapeListener);
        this.$watch("modalOpen", (value) => {
          const currentWidth = document.body.offsetWidth;
          document.body.classList.toggle("overflow-hidden", value);
          const scrollBarWidth = document.body.offsetWidth - currentWidth;
          document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
          if (value) {
            this.$nextTick(() => {
              const dialogElement = this.$el.querySelector('[role="document"]');
              const focusable2 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
              focusable2?.focus();
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          } else {
            this.$nextTick(() => {
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          }
        });
      },
      notModalOpen() {
        return !this.modalOpen;
      },
      destroy() {
        if (this._openListener && this.eventTriggerName) {
          window.removeEventListener(this.eventTriggerName, this._openListener);
        }
        if (this._closeEventListener) {
          window.removeEventListener(this.closeEventName, this._closeEventListener);
        }
        if (this._escapeListener) {
          window.removeEventListener("keydown", this._escapeListener);
        }
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      },
      openModal(event2 = null) {
        const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
          detail: { modalId: this.modalId, originalEvent: event2 },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeOpenEvent);
        if (!beforeOpenEvent.defaultPrevented) {
          this.modalOpen = true;
        }
      },
      // Internal close function called by button, escape, backdrop, event
      closeModalInternally(reason = "unknown") {
        const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
          detail: { modalId: this.modalId, reason },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeCloseEvent);
        if (!beforeCloseEvent.defaultPrevented) {
          document.activeElement?.blur && document.activeElement.blur();
          this.modalOpen = false;
          document.body.classList.remove("overflow-hidden");
          document.body.style.setProperty("--page-scrollbar-width", `0px`);
        }
      },
      // Called only by the explicit close button in the template
      closeModal() {
        this.closeModalInternally("button");
      },
      // Method called by x-on:click.outside on the dialog element
      handleClickOutside() {
        if (this.closeOnClickOutside) {
          this.closeModalInternally("backdrop");
        }
      }
    }));
  }
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start2, value, end) {
    return max(start2, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data: data2,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data2
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const flip$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            var _overflowsData$;
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
            if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d2.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element.matches(selector);
      } catch (e2) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, []).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$1(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data2) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data2.floating);
    return {
      reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$1(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  const offset = offset$1;
  const shift = shift$1;
  const flip = flip$1;
  const computePosition = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  function registerRzDropdownMenu(Alpine2) {
    Alpine2.data("rzDropdownMenu", () => ({
      // --- STATE ---
      open: false,
      isModal: true,
      ariaExpanded: "false",
      trapActive: false,
      focusedIndex: null,
      menuItems: [],
      parentEl: null,
      triggerEl: null,
      contentEl: null,
      // Will be populated when menu opens
      anchor: "bottom",
      pixelOffset: 3,
      isSubmenuActive: false,
      navThrottle: 100,
      _lastNavAt: 0,
      selfId: null,
      // --- INIT ---
      init() {
        if (!this.$el.id) this.$el.id = crypto.randomUUID();
        this.selfId = this.$el.id;
        this.parentEl = this.$el;
        this.triggerEl = this.$refs.trigger;
        this.anchor = this.$el.dataset.anchor || "bottom";
        this.pixelOffset = parseInt(this.$el.dataset.offset) || 6;
        this.isModal = this.$el.dataset.modal !== "false";
        this.$watch("open", (value) => {
          if (value) {
            this._lastNavAt = 0;
            this.$nextTick(() => {
              this.contentEl = document.getElementById(`${this.selfId}-content`);
              if (!this.contentEl) return;
              this.updatePosition();
              this.menuItems = Array.from(
                this.contentEl.querySelectorAll(
                  '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
                )
              );
            });
            this.ariaExpanded = "true";
            this.triggerEl.dataset.state = "open";
            this.trapActive = this.isModal;
          } else {
            this.focusedIndex = null;
            this.closeAllSubmenus();
            this.ariaExpanded = "false";
            delete this.triggerEl.dataset.state;
            this.trapActive = false;
            this.contentEl = null;
          }
        });
      },
      // --- METHODS ---
      updatePosition() {
        if (!this.triggerEl || !this.contentEl) return;
        this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`);
        computePosition(this.triggerEl, this.contentEl, {
          placement: this.anchor,
          middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(this.contentEl.style, { left: `${x}px`, top: `${y}px` });
        });
      },
      toggle() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        } else {
          this.open = true;
          this.focusedIndex = -1;
        }
      },
      handleOutsideClick() {
        if (!this.open) return;
        this.open = false;
        let self2 = this;
        this.$nextTick(() => self2.triggerEl?.focus());
      },
      handleTriggerKeydown(event2) {
        if (["Enter", " ", "ArrowDown", "ArrowUp"].includes(event2.key)) {
          event2.preventDefault();
          this.open = true;
          this.$nextTick(() => {
            if (event2.key === "ArrowUp") this.focusLastItem();
            else this.focusFirstItem();
          });
        }
      },
      focusNextItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
        this.focusCurrentItem();
      },
      focusPreviousItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
        this.focusCurrentItem();
      },
      focusFirstItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = 0;
        this.focusCurrentItem();
      },
      focusLastItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = this.menuItems.length - 1;
        this.focusCurrentItem();
      },
      focusCurrentItem() {
        if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
          this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
        }
      },
      focusSelectedItem(item) {
        if (!item || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        const index = this.menuItems.indexOf(item);
        if (index !== -1) {
          this.focusedIndex = index;
          item.focus();
        }
      },
      handleItemClick(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.open = false;
        let self2 = this;
        this.$nextTick(() => self2.triggerEl?.focus());
      },
      handleItemMouseEnter(event2) {
        const item = event2.currentTarget;
        this.focusSelectedItem(item);
        if (item.getAttribute("aria-haspopup") !== "menu") {
          this.closeAllSubmenus();
        }
      },
      handleWindowEscape() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        }
      },
      handleContentTabKey() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        }
      },
      handleTriggerMouseover() {
        let self2 = this;
        this.$nextTick(() => self2.$el.firstElementChild?.focus());
      },
      closeAllSubmenus() {
        const submenus = this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        submenus.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
        this.isSubmenuActive = false;
      }
    }));
    Alpine2.data("rzDropdownSubmenu", () => ({
      // --- STATE ---
      open: false,
      ariaExpanded: "false",
      parentDropdown: null,
      triggerEl: null,
      contentEl: null,
      // Will be populated when submenu opens
      menuItems: [],
      focusedIndex: null,
      anchor: "right-start",
      pixelOffset: 0,
      navThrottle: 100,
      _lastNavAt: 0,
      selfId: null,
      siblingContainer: null,
      closeTimeout: null,
      closeDelay: 150,
      // --- INIT ---
      init() {
        if (!this.$el.id) this.$el.id = crypto.randomUUID();
        this.selfId = this.$el.id;
        const parentId = this.$el.dataset.parentId;
        if (parentId) {
          const parentEl = document.getElementById(parentId);
          if (parentEl) {
            this.parentDropdown = Alpine2.$data(parentEl);
          }
        }
        if (!this.parentDropdown) {
          console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
          return;
        }
        this.triggerEl = this.$refs.subTrigger;
        this.siblingContainer = this.$el.parentElement;
        this.anchor = this.$el.dataset.subAnchor || this.anchor;
        this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset;
        this.$watch("open", (value) => {
          if (value) {
            this._lastNavAt = 0;
            this.parentDropdown.isSubmenuActive = true;
            this.$nextTick(() => {
              this.contentEl = document.getElementById(`${this.selfId}-subcontent`);
              if (!this.contentEl) return;
              this.updatePosition(this.contentEl);
              this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])'));
            });
            this.ariaExpanded = "true";
            this.triggerEl.dataset.state = "open";
          } else {
            this.focusedIndex = null;
            this.ariaExpanded = "false";
            delete this.triggerEl.dataset.state;
            this.$nextTick(() => {
              const anySubmenuIsOpen = this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]');
              if (!anySubmenuIsOpen) this.parentDropdown.isSubmenuActive = false;
            });
            this.contentEl = null;
          }
        });
      },
      // --- METHODS ---
      updatePosition(contentEl) {
        if (!this.triggerEl || !contentEl) return;
        computePosition(this.triggerEl, contentEl, {
          placement: this.anchor,
          middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(contentEl.style, { left: `${x}px`, top: `${y}px` });
        });
      },
      handleTriggerMouseEnter() {
        clearTimeout(this.closeTimeout);
        this.triggerEl.focus();
        this.openSubmenu();
      },
      handleTriggerMouseLeave() {
        this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
      },
      handleContentMouseEnter() {
        clearTimeout(this.closeTimeout);
      },
      handleContentMouseLeave() {
        const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        if (childSubmenus) {
          const isAnyChildOpen = Array.from(childSubmenus).some((el) => Alpine2.$data(el)?.open);
          if (isAnyChildOpen) {
            return;
          }
        }
        this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
      },
      openSubmenu(focusFirst = false) {
        if (this.open) return;
        this.closeSiblingSubmenus();
        this.open = true;
        if (focusFirst) {
          this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem()));
        }
      },
      closeSubmenu() {
        const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        childSubmenus?.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
        this.open = false;
      },
      closeSiblingSubmenus() {
        if (!this.siblingContainer) return;
        const siblings = Array.from(this.siblingContainer.children).filter(
          (el) => el.hasAttribute("x-data") && el.getAttribute("x-data").startsWith("rzDropdownSubmenu") && el.id !== this.selfId
        );
        siblings.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
      },
      toggleSubmenu() {
        this.open ? this.closeSubmenu() : this.openSubmenu();
      },
      openSubmenuAndFocusFirst() {
        this.openSubmenu(true);
      },
      handleTriggerKeydown(e2) {
        if (["ArrowRight", "Enter", " "].includes(e2.key)) {
          e2.preventDefault();
          this.openSubmenuAndFocusFirst();
        }
      },
      focusNextItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
        this.focusCurrentItem();
      },
      focusPreviousItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
        this.focusCurrentItem();
      },
      focusFirstItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = 0;
        this.focusCurrentItem();
      },
      focusLastItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = this.menuItems.length - 1;
        this.focusCurrentItem();
      },
      focusCurrentItem() {
        if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
          this.menuItems[this.focusedIndex].focus();
        }
      },
      handleItemClick(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.parentDropdown.open = false;
        this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
      },
      handleItemMouseEnter(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        const index = this.menuItems.indexOf(item);
        if (index !== -1) {
          this.focusedIndex = index;
          item.focus();
        }
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu();
        } else {
          this.closeSiblingSubmenus();
        }
      },
      handleSubmenuEscape() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      },
      handleSubmenuArrowLeft() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      }
    }));
  }
  function registerRzDarkModeToggle(Alpine2) {
    Alpine2.data("rzDarkModeToggle", () => ({
      // Proxy all properties to the reactive store
      get mode() {
        return this.$store.theme.mode;
      },
      get prefersDark() {
        return this.$store.theme.prefersDark;
      },
      get effectiveDark() {
        return this.$store.theme.effectiveDark;
      },
      // Proxy properties from the store (isDark/isLight are getters on the store)
      get isDark() {
        return this.$store.theme.isDark;
      },
      get isLight() {
        return this.$store.theme.isLight;
      },
      // Proxy methods
      setLight() {
        this.$store.theme.setLight();
      },
      setDark() {
        this.$store.theme.setDark();
      },
      setAuto() {
        this.$store.theme.setAuto();
      },
      toggle() {
        this.$store.theme.toggle();
      }
    }));
  }
  function registerRzEmbeddedPreview(Alpine2) {
    Alpine2.data("rzEmbeddedPreview", () => {
      return {
        iframe: null,
        onDarkModeToggle: null,
        init() {
          try {
            this.iframe = this.$refs.iframe;
            const resize = this.debounce(() => {
              this.resizeIframe(this.iframe);
            }, 50);
            this.resizeIframe(this.iframe);
            const resizeObserver = new ResizeObserver((entries) => {
              for (let entry of entries) {
                resize();
              }
            });
            resizeObserver.observe(this.iframe);
            const iframe = this.iframe;
            this.onDarkModeToggle = (event2) => {
              iframe.contentWindow.postMessage(event2.detail, "*");
            };
            window.addEventListener("darkModeToggle", this.onDarkModeToggle);
          } catch (error2) {
            console.error("Cannot access iframe content");
          }
        },
        // Adjusts the iframe height based on its content
        resizeIframe(iframe) {
          if (iframe) {
            try {
              const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDocument) {
                const iframeBody = iframeDocument.body;
                if (!iframeBody) {
                  setInterval(() => {
                    this.resizeIframe(iframe);
                  }, 150);
                } else {
                  const newHeight = iframeBody.scrollHeight + 15;
                  iframe.style.height = newHeight + "px";
                }
              }
            } catch (error2) {
              console.error("Error resizing iframe:", error2);
            }
          }
        },
        // Debounce helper to limit function calls
        debounce(func, timeout = 300) {
          let timer;
          return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
              func.apply(this, args);
            }, timeout);
          };
        },
        destroy() {
          window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
        }
      };
    });
  }
  function registerRzEmpty(Alpine2) {
    Alpine2.data("rzEmpty", () => {
    });
  }
  function registerRzHeading(Alpine2) {
    Alpine2.data("rzHeading", () => {
      return {
        observer: null,
        headingId: "",
        init() {
          this.headingId = this.$el.dataset.alpineRoot;
          const self2 = this;
          if (typeof this.setCurrentHeading === "function") {
            const callback = (entries, observer2) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  self2.setCurrentHeading(self2.headingId);
                }
              });
            };
            const options = { threshold: 0.5 };
            this.observer = new IntersectionObserver(callback, options);
            this.observer.observe(this.$el);
          } else {
            console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
          }
        },
        destroy() {
          if (this.observer != null)
            this.observer.disconnect();
        }
      };
    });
  }
  function registerRzIndicator(Alpine2) {
    Alpine2.data("rzIndicator", () => ({
      visible: false,
      init() {
        const colorValue = this.$el.dataset.color;
        if (colorValue) {
          this.$el.style.backgroundColor = colorValue;
        } else {
          this.$el.style.backgroundColor = "var(--color-success)";
        }
        if (this.$el.dataset.visible === "true") {
          this.visible = true;
        }
      },
      notVisible() {
        return !this.visible;
      },
      setVisible(value) {
        this.visible = value;
      }
    }));
  }
  function registerRzInputGroupAddon(Alpine2) {
    Alpine2.data("rzInputGroupAddon", () => ({
      handleClick(event2) {
        if (event2.target.closest("button")) {
          return;
        }
        const parent = this.$el.parentElement;
        if (parent) {
          const input = parent.querySelector("input, textarea");
          input?.focus();
        }
      }
    }));
  }
  function registerRzMarkdown(Alpine2, require) {
    Alpine2.data("rzMarkdown", () => {
      return {
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const nonce = this.$el.dataset.nonce;
          require(assets, {
            success: function() {
              window.hljs.highlightAll();
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        }
      };
    });
  }
  function registerRzNavigationMenu(Alpine2, $data2) {
    Alpine2.data("rzNavigationMenu", () => ({
      activeItemId: null,
      open: false,
      closeTimeout: null,
      prevIndex: null,
      list: null,
      isClosing: false,
      /* ---------- helpers ---------- */
      _triggerIndex(id) {
        if (!this.list) return -1;
        const triggers = Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]'));
        return triggers.findIndex((t2) => t2.getAttribute("x-ref") === `trigger_${id}`);
      },
      _contentEl(id) {
        return document.getElementById(`${id}-content`);
      },
      /* ---------- lifecycle ---------- */
      init() {
        const contentEls = this.$el.querySelectorAll("[data-popover]");
        contentEls.forEach((el) => {
          el.style.display = "none";
        });
        this.$nextTick(() => {
          this.list = this.$refs.list;
        });
      },
      /* ---------- event handlers (from events with no params) ---------- */
      toggleActive(e2) {
        const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
        this.activeItemId === id && this.open ? this.closeMenu() : this.openMenu(id);
      },
      handleTriggerEnter(e2) {
        const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
        this.cancelClose();
        if (this.activeItemId !== id && !this.isClosing) {
          requestAnimationFrame(() => this.openMenu(id));
        }
      },
      handleItemEnter(e2) {
        const item = e2.currentTarget;
        if (!item) return;
        this.cancelClose();
        const trigger2 = item.querySelector('[x-ref^="trigger_"]');
        if (trigger2) {
          const id = trigger2.getAttribute("x-ref").replace("trigger_", "");
          if (this.activeItemId !== id && !this.isClosing) {
            requestAnimationFrame(() => this.openMenu(id));
          }
        } else {
          if (this.open && !this.isClosing) {
            this.closeMenu();
          }
        }
      },
      handleContentEnter() {
        this.cancelClose();
      },
      scheduleClose() {
        if (this.isClosing || this.closeTimeout) return;
        this.closeTimeout = setTimeout(() => this.closeMenu(), 150);
      },
      cancelClose() {
        if (this.closeTimeout) {
          clearTimeout(this.closeTimeout);
          this.closeTimeout = null;
        }
        this.isClosing = false;
      },
      /* ---------- open / close logic with direct DOM manipulation ---------- */
      openMenu(id) {
        this.cancelClose();
        this.isClosing = false;
        const newIdx = this._triggerIndex(id);
        const dir = newIdx > (this.prevIndex ?? newIdx) ? "end" : "start";
        const isFirstOpen = this.prevIndex === null;
        if (this.open && this.activeItemId && this.activeItemId !== id) {
          const oldTrig = this.$refs[`trigger_${this.activeItemId}`];
          if (oldTrig) delete oldTrig.dataset.state;
          const oldEl = this._contentEl(this.activeItemId);
          if (oldEl) {
            const outgoingDirection = dir === "end" ? "start" : "end";
            oldEl.setAttribute("data-motion", `to-${outgoingDirection}`);
            setTimeout(() => {
              oldEl.style.display = "none";
            }, 150);
          }
        }
        this.activeItemId = id;
        this.open = true;
        this.prevIndex = newIdx;
        const newTrig = this.$refs[`trigger_${id}`];
        const newContentEl = this._contentEl(id);
        if (!newTrig || !newContentEl) return;
        computePosition(newTrig, newContentEl, {
          placement: "bottom-start",
          middleware: [offset(6), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(newContentEl.style, { left: `${x}px`, top: `${y}px` });
        });
        newContentEl.style.display = "block";
        if (isFirstOpen) {
          newContentEl.setAttribute("data-motion", "fade-in");
        } else {
          newContentEl.setAttribute("data-motion", `from-${dir}`);
        }
        this.$nextTick(() => {
          newTrig.setAttribute("aria-expanded", "true");
          newTrig.dataset.state = "open";
        });
      },
      closeMenu() {
        if (!this.open || this.isClosing) return;
        this.isClosing = true;
        this.cancelClose();
        const activeId = this.activeItemId;
        if (!activeId) {
          this.isClosing = false;
          return;
        }
        const trig = this.$refs[`trigger_${activeId}`];
        if (trig) {
          trig.setAttribute("aria-expanded", "false");
          delete trig.dataset.state;
        }
        const contentEl = this._contentEl(activeId);
        if (contentEl) {
          contentEl.setAttribute("data-motion", "fade-out");
          setTimeout(() => {
            contentEl.style.display = "none";
          }, 150);
        }
        this.open = false;
        this.activeItemId = null;
        this.prevIndex = null;
        setTimeout(() => {
          this.isClosing = false;
        }, 150);
      }
    }));
  }
  function registerRzPopover(Alpine2) {
    Alpine2.data("rzPopover", () => ({
      open: false,
      ariaExpanded: "false",
      triggerEl: null,
      contentEl: null,
      init() {
        this.triggerEl = this.$refs.trigger;
        this.contentEl = this.$refs.content;
        this.$watch("open", (value) => {
          this.ariaExpanded = value.toString();
          if (value) {
            this.$nextTick(() => this.updatePosition());
          }
        });
      },
      updatePosition() {
        if (!this.triggerEl || !this.contentEl) return;
        const anchor = this.$el.dataset.anchor || "bottom";
        const mainOffset = parseInt(this.$el.dataset.offset) || 0;
        const crossAxisOffset = parseInt(this.$el.dataset.crossAxisOffset) || 0;
        const alignmentAxisOffset = parseInt(this.$el.dataset.alignmentAxisOffset) || null;
        const strategy = this.$el.dataset.strategy || "absolute";
        const enableFlip = this.$el.dataset.enableFlip !== "false";
        const enableShift = this.$el.dataset.enableShift !== "false";
        const shiftPadding = parseInt(this.$el.dataset.shiftPadding) || 8;
        let middleware = [];
        middleware.push(offset({
          mainAxis: mainOffset,
          crossAxis: crossAxisOffset,
          alignmentAxis: alignmentAxisOffset
        }));
        if (enableFlip) {
          middleware.push(flip());
        }
        if (enableShift) {
          middleware.push(shift({ padding: shiftPadding }));
        }
        computePosition(this.triggerEl, this.contentEl, {
          placement: anchor,
          strategy,
          middleware
        }).then(({ x, y }) => {
          Object.assign(this.contentEl.style, {
            left: `${x}px`,
            top: `${y}px`
          });
        });
      },
      toggle() {
        this.open = !this.open;
      },
      handleOutsideClick() {
        if (!this.open) return;
        this.open = false;
      },
      handleWindowEscape() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      }
    }));
  }
  function registerRzPrependInput(Alpine2) {
    Alpine2.data("rzPrependInput", () => {
      return {
        prependContainer: null,
        textInput: null,
        init() {
          this.prependContainer = this.$refs.prependContainer;
          this.textInput = this.$refs.textInput;
          let self2 = this;
          setTimeout(() => {
            self2.updatePadding();
          }, 50);
          window.addEventListener("resize", this.updatePadding);
        },
        destroy() {
          window.removeEventListener("resize", this.updatePadding);
        },
        updatePadding() {
          const prependDiv = this.prependContainer;
          const inputElem = this.textInput;
          if (!prependDiv || !inputElem) {
            if (inputElem) {
              inputElem.classList.remove("text-transparent");
            }
            return;
          }
          const prependWidth = prependDiv.offsetWidth;
          const leftPadding = prependWidth + 10;
          inputElem.style.paddingLeft = leftPadding + "px";
          inputElem.classList.remove("text-transparent");
        }
      };
    });
  }
  function registerRzProgress(Alpine2) {
    Alpine2.data("rzProgress", () => ({
      currentVal: 0,
      minVal: 0,
      maxVal: 100,
      percentage: 0,
      label: "",
      init() {
        const element = this.$el;
        this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
        this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
        this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
        this.label = element.getAttribute("data-label");
        this.calculatePercentage();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuemin", this.minVal);
        element.setAttribute("aria-valuemax", this.maxVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
        this.updateProgressBar();
        const resizeObserver = new ResizeObserver((entries) => {
          this.updateProgressBar();
        });
        resizeObserver.observe(element);
        this.$watch("currentVal", () => {
          this.calculatePercentage();
          this.updateProgressBar();
          element.setAttribute("aria-valuenow", this.currentVal);
          element.setAttribute("aria-valuetext", `${this.percentage}%`);
        });
      },
      calculatePercentage() {
        if (this.maxVal === this.minVal) {
          this.percentage = 0;
        } else {
          this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
        }
      },
      buildLabel() {
        var label = this.label || "{percent}%";
        this.calculatePercentage();
        return label.replace("{percent}", this.percentage);
      },
      buildInsideLabelPosition() {
        const progressBar = this.$refs.progressBar;
        const barLabel = this.$refs.progressBarLabel;
        const innerLabel = this.$refs.innerLabel;
        if (barLabel && progressBar && innerLabel) {
          innerLabel.innerText = this.buildLabel();
          if (barLabel.clientWidth > progressBar.clientWidth) {
            barLabel.style.left = progressBar.clientWidth + 10 + "px";
          } else {
            barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
          }
        }
      },
      getLabelCss() {
        const barLabel = this.$refs.progressBarLabel;
        const progressBar = this.$refs.progressBar;
        if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
          return "text-foreground dark:text-foreground";
        }
        return "";
      },
      updateProgressBar() {
        const progressBar = this.$refs.progressBar;
        if (progressBar) {
          progressBar.style.width = `${this.percentage}%`;
          this.buildInsideLabelPosition();
        }
      },
      // Methods to set, increment, or decrement the progress value
      setProgress(value) {
        this.currentVal = value;
      },
      increment(val = 1) {
        this.currentVal = Math.min(this.currentVal + val, this.maxVal);
      },
      decrement(val = 1) {
        this.currentVal = Math.max(this.currentVal - val, this.minVal);
      }
    }));
  }
  function registerRzQuickReferenceContainer(Alpine2) {
    Alpine2.data("rzQuickReferenceContainer", () => {
      return {
        headings: [],
        // Array of heading IDs
        currentHeadingId: "",
        // ID of the currently highlighted heading
        // Initializes the component with headings and the initial current heading from data attributes.
        init() {
          this.headings = JSON.parse(this.$el.dataset.headings || "[]");
          this.currentHeadingId = this.$el.dataset.currentheadingid || "";
        },
        // Handles click events on quick reference links.
        handleHeadingClick() {
          const id = this.$el.dataset.headingid;
          window.requestAnimationFrame(() => {
            this.currentHeadingId = id;
          });
        },
        // Sets the current heading ID based on intersection observer events from rzHeading.
        setCurrentHeading(id) {
          if (this.headings.includes(id)) {
            this.currentHeadingId = id;
          }
        },
        // Provides CSS classes for a link based on whether it's the current heading.
        // Returns an object suitable for :class binding.
        getSelectedCss() {
          const id = this.$el.dataset.headingid;
          return {
            "font-bold": this.currentHeadingId === id
            // Apply 'font-bold' if current
          };
        },
        // Determines the value for the aria-current attribute.
        getSelectedAriaCurrent() {
          const id = this.$el.dataset.headingid;
          return this.currentHeadingId === id ? "true" : null;
        }
      };
    });
  }
  function registerRzSheet(Alpine2) {
    Alpine2.data("rzSheet", () => ({
      open: false,
      init() {
        this.open = this.$el.dataset.defaultOpen === "true";
      },
      toggle() {
        this.open = !this.open;
      },
      close() {
        this.open = false;
      },
      show() {
        this.open = true;
      },
      state() {
        return this.open ? "open" : "closed";
      }
    }));
  }
  function registerRzTabs(Alpine2) {
    Alpine2.data("rzTabs", () => ({
      selectedTab: "",
      _triggers: [],
      _observer: null,
      init() {
        const defaultValue = this.$el.dataset.defaultValue;
        this._observer = new MutationObserver(() => this.refreshTriggers());
        this._observer.observe(this.$el, { childList: true, subtree: true });
        this.refreshTriggers();
        if (defaultValue && this._triggers.some((t2) => t2.dataset.value === defaultValue)) {
          this.selectedTab = defaultValue;
        } else if (this._triggers.length > 0) {
          this.selectedTab = this._triggers[0].dataset.value;
        }
      },
      destroy() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },
      refreshTriggers() {
        this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
      },
      onTriggerClick(e2) {
        const value = e2.currentTarget?.dataset?.value;
        if (!value || e2.currentTarget.getAttribute("aria-disabled") === "true") {
          return;
        }
        this.selectedTab = value;
        this.$dispatch("rz:tabs-change", { value: this.selectedTab });
      },
      isSelected(value) {
        return this.selectedTab === value;
      },
      bindTrigger() {
        this.selectedTab;
        const value = this.$el.dataset.value;
        const active = this.isSelected(value);
        const disabled = this.$el.getAttribute("aria-disabled") === "true";
        return {
          "aria-selected": String(active),
          "tabindex": active ? "0" : "-1",
          "data-state": active ? "active" : "inactive",
          ...disabled && { "disabled": true }
        };
      },
      _attrDisabled() {
        return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
      },
      _attrAriaSelected() {
        return String(this.$el.dataset.value === this.selectedTab);
      },
      _attrHidden() {
        return this.$el.dataset.value === this.selectedTab ? null : "true";
      },
      _attrAriaHidden() {
        return String(this.selectedTab !== this.$el.dataset.value);
      },
      _attrDataState() {
        return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
      },
      _attrTabIndex() {
        return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
      },
      onListKeydown(e2) {
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(e2.key)) {
          e2.preventDefault();
          const availableTriggers = this._triggers.filter((t2) => t2.getAttribute("aria-disabled") !== "true");
          if (availableTriggers.length === 0) return;
          const activeIndex = availableTriggers.findIndex((t2) => t2.dataset.value === this.selectedTab);
          if (activeIndex === -1) return;
          const isVertical = e2.currentTarget?.getAttribute("aria-orientation") === "vertical";
          const prevKey = isVertical ? "ArrowUp" : "ArrowLeft";
          const nextKey = isVertical ? "ArrowDown" : "ArrowRight";
          let newIndex = activeIndex;
          switch (e2.key) {
            case prevKey:
              newIndex = activeIndex - 1 < 0 ? availableTriggers.length - 1 : activeIndex - 1;
              break;
            case nextKey:
              newIndex = (activeIndex + 1) % availableTriggers.length;
              break;
            case "Home":
              newIndex = 0;
              break;
            case "End":
              newIndex = availableTriggers.length - 1;
              break;
          }
          if (newIndex >= 0 && newIndex < availableTriggers.length) {
            const newTrigger = availableTriggers[newIndex];
            this.selectedTab = newTrigger.dataset.value;
            this.$nextTick(() => newTrigger.focus());
          }
        }
      }
    }));
  }
  function registerRzSidebar(Alpine2) {
    Alpine2.data("rzSidebar", () => ({
      open: false,
      openMobile: false,
      isMobile: false,
      collapsible: "offcanvas",
      shortcut: "b",
      cookieName: "sidebar_state",
      mobileBreakpoint: 768,
      init() {
        this.collapsible = this.$el.dataset.collapsible || "offcanvas";
        this.shortcut = this.$el.dataset.shortcut || "b";
        this.cookieName = this.$el.dataset.cookieName || "sidebar_state";
        this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
        const savedState = this.cookieName ? document.cookie.split("; ").find((row) => row.startsWith(`${this.cookieName}=`))?.split("=")[1] : null;
        const defaultOpen = this.$el.dataset.defaultOpen === "true";
        this.open = savedState !== null ? savedState === "true" : defaultOpen;
        this.checkIfMobile();
        window.addEventListener("keydown", (e2) => {
          if ((e2.ctrlKey || e2.metaKey) && e2.key.toLowerCase() === this.shortcut.toLowerCase()) {
            e2.preventDefault();
            this.toggle();
          }
        });
        this.$watch("open", (value) => {
          if (this.cookieName) {
            document.cookie = `${this.cookieName}=${value}; path=/; max-age=31536000`;
          }
        });
      },
      checkIfMobile() {
        this.isMobile = window.innerWidth < this.mobileBreakpoint;
      },
      toggle() {
        if (this.isMobile) {
          this.openMobile = !this.openMobile;
        } else {
          this.open = !this.open;
        }
      },
      close() {
        if (this.isMobile) {
          this.openMobile = false;
        }
      },
      isMobileOpen() {
        return this.openMobile;
      },
      desktopState() {
        return this.open ? "expanded" : "collapsed";
      },
      mobileState() {
        return this.openMobile ? "open" : "closed";
      },
      getCollapsibleAttribute() {
        return this.desktopState() === "collapsed" ? this.collapsible : "";
      }
    }));
  }
  function registerRzCommand(Alpine2) {
    Alpine2.data("rzCommand", () => ({
      // --- STATE ---
      search: "",
      selectedValue: null,
      selectedIndex: -1,
      items: [],
      filteredItems: [],
      groupTemplates: /* @__PURE__ */ new Map(),
      activeDescendantId: null,
      isOpen: false,
      isEmpty: true,
      firstRender: true,
      isLoading: false,
      error: null,
      // --- CONFIG ---
      loop: false,
      shouldFilter: true,
      itemsUrl: null,
      fetchTrigger: "immediate",
      serverFiltering: false,
      dataItemTemplateId: null,
      _dataFetched: false,
      _debounceTimer: null,
      // --- COMPUTED (CSP-Compliant Methods) ---
      showLoading() {
        return this.isLoading;
      },
      hasError() {
        return this.error !== null;
      },
      notHasError() {
        return this.error == null;
      },
      shouldShowEmpty() {
        return this.isEmpty && this.search && !this.isLoading && !this.error;
      },
      shouldShowEmptyOrError() {
        return this.isEmpty && this.search && !this.isLoading || this.error !== null;
      },
      // --- LIFECYCLE ---
      init() {
        this.loop = this.$el.dataset.loop === "true";
        this.shouldFilter = this.$el.dataset.shouldFilter !== "false";
        this.selectedValue = this.$el.dataset.selectedValue || null;
        this.itemsUrl = this.$el.dataset.itemsUrl || null;
        this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate";
        this.serverFiltering = this.$el.dataset.serverFiltering === "true";
        this.dataItemTemplateId = this.$el.dataset.templateId || null;
        const itemsScriptId = this.$el.dataset.itemsId;
        let staticItems = [];
        if (itemsScriptId) {
          const itemsScript = document.getElementById(itemsScriptId);
          if (itemsScript) {
            try {
              staticItems = JSON.parse(itemsScript.textContent || "[]");
            } catch (e2) {
              console.error(`RzCommand: Failed to parse JSON from script tag #${itemsScriptId}`, e2);
            }
          }
        }
        if (staticItems.length > 0 && !this.dataItemTemplateId) {
          console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them.");
        }
        staticItems.forEach((item) => {
          item.id = item.id || `static-item-${crypto.randomUUID()}`;
          item.isDataItem = true;
          this.registerItem(item);
        });
        if (this.itemsUrl && this.fetchTrigger === "immediate") {
          this.fetchItems();
        }
        this.$watch("search", (newValue) => {
          this.firstRender = false;
          if (this.serverFiltering) {
            clearTimeout(this._debounceTimer);
            this._debounceTimer = setTimeout(() => {
              this.fetchItems(newValue);
            }, 300);
          } else {
            this.filterAndSortItems();
          }
        });
        this.$watch("selectedIndex", (newIndex, oldIndex) => {
          if (oldIndex > -1) {
            const oldItem = this.filteredItems[oldIndex];
            if (oldItem) {
              const oldEl = this.$el.querySelector(`[data-command-item-id="${oldItem.id}"]`);
              if (oldEl) {
                oldEl.removeAttribute("data-selected");
                oldEl.setAttribute("aria-selected", "false");
              }
            }
          }
          if (newIndex > -1 && this.filteredItems[newIndex]) {
            const selectedItem = this.filteredItems[newIndex];
            this.activeDescendantId = selectedItem.id;
            const el = this.$el.querySelector(`[data-command-item-id="${selectedItem.id}"]`);
            if (el) {
              el.setAttribute("data-selected", "true");
              el.setAttribute("aria-selected", "true");
              el.scrollIntoView({ block: "nearest" });
            }
            const newValue = selectedItem.value;
            if (this.selectedValue !== newValue) {
              this.selectedValue = newValue;
              this.$dispatch("rz:command:select", { value: newValue });
            }
          } else {
            this.activeDescendantId = null;
            this.selectedValue = null;
          }
        });
        this.$watch("selectedValue", (newValue) => {
          const index = this.filteredItems.findIndex((item) => item.value === newValue);
          if (this.selectedIndex !== index) {
            this.selectedIndex = index;
          }
        });
        this.$watch("filteredItems", (items) => {
          this.isOpen = items.length > 0 || this.isLoading;
          this.isEmpty = items.length === 0;
          if (!this.firstRender) {
            window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
              detail: {
                items: this.filteredItems,
                groups: this.groupTemplates,
                commandId: this.$el.id
              }
            }));
          }
        });
      },
      // --- METHODS ---
      async fetchItems(query = "") {
        if (!this.itemsUrl) return;
        if (!this.dataItemTemplateId) {
          console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data.");
          this.error = "Configuration error: No data template found.";
          return;
        }
        this.isLoading = true;
        this.error = null;
        try {
          const url = new URL(this.itemsUrl, window.location.origin);
          if (this.serverFiltering && query) {
            url.searchParams.append("q", query);
          }
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
          }
          const data2 = await response.json();
          if (this.serverFiltering) {
            this.items = this.items.filter((i2) => !i2.isDataItem);
          }
          data2.forEach((item) => {
            item.id = item.id || `data-item-${crypto.randomUUID()}`;
            item.isDataItem = true;
            this.registerItem(item);
          });
          this._dataFetched = true;
        } catch (e2) {
          this.error = e2.message || "Failed to fetch command items.";
          console.error("RzCommand:", this.error);
        } finally {
          this.isLoading = false;
          this.filterAndSortItems();
        }
      },
      handleInteraction() {
        if (this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched) {
          this.fetchItems();
        }
      },
      registerItem(item) {
        if (this.items.some((i2) => i2.id === item.id)) return;
        item._order = this.items.length;
        this.items.push(item);
        if (this.selectedIndex === -1)
          this.selectedIndex = 0;
        if (!this.serverFiltering) {
          this.filterAndSortItems();
        }
      },
      unregisterItem(itemId) {
        this.items = this.items.filter((i2) => i2.id !== itemId);
        this.filterAndSortItems();
      },
      registerGroupTemplate(name, templateId) {
        if (!this.groupTemplates.has(name)) {
          this.groupTemplates.set(name, templateId);
        }
      },
      filterAndSortItems() {
        if (this.serverFiltering && this._dataFetched) {
          this.filteredItems = this.items;
          this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
          return;
        }
        let items;
        if (!this.shouldFilter || !this.search) {
          items = this.items.map((item) => ({ ...item, score: 1 }));
        } else {
          items = this.items.map((item) => ({
            ...item,
            score: item.forceMount ? 0 : this.commandScore(item.name, this.search, item.keywords)
          })).filter((item) => item.score > 0 || item.forceMount).sort((a2, b) => {
            if (a2.forceMount && !b.forceMount) return 1;
            if (!a2.forceMount && b.forceMount) return -1;
            if (b.score !== a2.score) return b.score - a2.score;
            return (a2._order || 0) - (b._order || 0);
          });
        }
        this.filteredItems = items;
        if (this.selectedValue) {
          const newIndex = this.filteredItems.findIndex((item) => item.value === this.selectedValue);
          this.selectedIndex = newIndex > -1 ? newIndex : this.filteredItems.length > 0 ? 0 : -1;
        } else {
          this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        }
      },
      // --- EVENT HANDLERS ---
      handleItemClick(event2) {
        const host = event2.target.closest("[data-command-item-id]");
        if (!host) return;
        const itemId = host.dataset.commandItemId;
        const index = this.filteredItems.findIndex((item) => item.id === itemId);
        if (index > -1) {
          const item = this.filteredItems[index];
          if (item && !item.disabled) {
            this.selectedIndex = index;
            this.$dispatch("rz:command:execute", { value: item.value });
          }
        }
      },
      handleItemHover(event2) {
        const host = event2.target.closest("[data-command-item-id]");
        if (!host) return;
        const itemId = host.dataset.commandItemId;
        const index = this.filteredItems.findIndex((item) => item.id === itemId);
        if (index > -1) {
          const item = this.filteredItems[index];
          if (item && !item.disabled) {
            if (this.selectedIndex !== index) {
              this.selectedIndex = index;
            }
          }
        }
      },
      // --- KEYBOARD NAVIGATION ---
      handleKeydown(e2) {
        switch (e2.key) {
          case "ArrowDown":
            e2.preventDefault();
            this.selectNext();
            break;
          case "ArrowUp":
            e2.preventDefault();
            this.selectPrev();
            break;
          case "Home":
            e2.preventDefault();
            this.selectFirst();
            break;
          case "End":
            e2.preventDefault();
            this.selectLast();
            break;
          case "Enter":
            e2.preventDefault();
            const item = this.filteredItems[this.selectedIndex];
            if (item && !item.disabled) {
              this.$dispatch("rz:command:execute", { value: item.value });
            }
            break;
        }
      },
      selectNext() {
        if (this.filteredItems.length === 0) return;
        let i2 = this.selectedIndex, count = 0;
        do {
          i2 = i2 + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : i2 + 1;
          count++;
          if (!this.filteredItems[i2]?.disabled) {
            this.selectedIndex = i2;
            return;
          }
          if (!this.loop && i2 === this.filteredItems.length - 1) return;
        } while (count <= this.filteredItems.length);
      },
      selectPrev() {
        if (this.filteredItems.length === 0) return;
        let i2 = this.selectedIndex, count = 0;
        do {
          i2 = i2 - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : i2 - 1;
          count++;
          if (!this.filteredItems[i2]?.disabled) {
            this.selectedIndex = i2;
            return;
          }
          if (!this.loop && i2 === 0) return;
        } while (count <= this.filteredItems.length);
      },
      selectFirst() {
        if (this.filteredItems.length > 0) {
          const firstEnabledIndex = this.filteredItems.findIndex((item) => !item.disabled);
          if (firstEnabledIndex > -1) this.selectedIndex = firstEnabledIndex;
        }
      },
      selectLast() {
        if (this.filteredItems.length > 0) {
          const lastEnabledIndex = this.filteredItems.map((item) => item.disabled).lastIndexOf(false);
          if (lastEnabledIndex > -1) this.selectedIndex = lastEnabledIndex;
        }
      },
      // --- SCORING ALGORITHM (Adapted from cmdk) ---
      commandScore(string, search, keywords = []) {
        const SCORE_CONTINUE_MATCH = 1;
        const SCORE_SPACE_WORD_JUMP = 0.9;
        const SCORE_NON_SPACE_WORD_JUMP = 0.8;
        const SCORE_CHARACTER_JUMP = 0.17;
        const PENALTY_SKIPPED = 0.999;
        const PENALTY_CASE_MISMATCH = 0.9999;
        const PENALTY_NOT_COMPLETE = 0.99;
        const IS_GAP_REGEXP = /[\\/_+.#"@[\(\{&]/;
        const IS_SPACE_REGEXP = /[\s-]/;
        const fullString = `${string} ${keywords ? keywords.join(" ") : ""}`;
        function formatInput(str) {
          return str.toLowerCase().replace(/[\s-]/g, " ");
        }
        function commandScoreInner(str, abbr, lowerStr, lowerAbbr, strIndex, abbrIndex, memo) {
          if (abbrIndex === abbr.length) {
            return strIndex === str.length ? SCORE_CONTINUE_MATCH : PENALTY_NOT_COMPLETE;
          }
          const memoKey = `${strIndex},${abbrIndex}`;
          if (memo[memoKey] !== void 0) return memo[memoKey];
          const abbrChar = lowerAbbr.charAt(abbrIndex);
          let index = lowerStr.indexOf(abbrChar, strIndex);
          let highScore = 0;
          while (index >= 0) {
            let score = commandScoreInner(str, abbr, lowerStr, lowerAbbr, index + 1, abbrIndex + 1, memo);
            if (score > highScore) {
              if (index === strIndex) {
                score *= SCORE_CONTINUE_MATCH;
              } else if (IS_GAP_REGEXP.test(str.charAt(index - 1))) {
                score *= SCORE_NON_SPACE_WORD_JUMP;
              } else if (IS_SPACE_REGEXP.test(str.charAt(index - 1))) {
                score *= SCORE_SPACE_WORD_JUMP;
              } else {
                score *= SCORE_CHARACTER_JUMP;
                if (strIndex > 0) {
                  score *= Math.pow(PENALTY_SKIPPED, index - strIndex);
                }
              }
              if (str.charAt(index) !== abbr.charAt(abbrIndex)) {
                score *= PENALTY_CASE_MISMATCH;
              }
            }
            if (score > highScore) {
              highScore = score;
            }
            index = lowerStr.indexOf(abbrChar, index + 1);
          }
          memo[memoKey] = highScore;
          return highScore;
        }
        return commandScoreInner(fullString, search, formatInput(fullString), formatInput(search), 0, 0, {});
      }
    }));
  }
  function registerRzCommandItem(Alpine2) {
    Alpine2.data("rzCommandItem", () => ({
      parent: null,
      itemData: {},
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandItem must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        this.itemData = {
          id: this.$el.id,
          value: this.$el.dataset.value || this.$el.textContent.trim(),
          name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
          keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
          group: this.$el.dataset.group || null,
          templateId: this.$el.id + "-template",
          disabled: this.$el.dataset.disabled === "true",
          forceMount: this.$el.dataset.forceMount === "true"
        };
        this.parent.registerItem(this.itemData);
      },
      destroy() {
        if (this.parent) {
          this.parent.unregisterItem(this.itemData.id);
        }
      }
    }));
  }
  function registerRzCommandList(Alpine2) {
    Alpine2.data("rzCommandList", () => ({
      parent: null,
      dataItemTemplate: null,
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandList must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        if (this.parent.dataItemTemplateId) {
          this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId);
        }
      },
      renderList(event2) {
        if (event2.detail.commandId !== this.parent.$el.id) return;
        const items = event2.detail.items || [];
        const groups = event2.detail.groups || /* @__PURE__ */ new Map();
        const container = this.$el;
        container.querySelectorAll("[data-dynamic-item]").forEach((el) => el.remove());
        const groupedItems = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
        items.forEach((item) => {
          const groupName = item.group || "__ungrouped__";
          if (!groupedItems.has(groupName)) {
            groupedItems.set(groupName, []);
          }
          groupedItems.get(groupName).push(item);
        });
        groupedItems.forEach((groupItems, groupName) => {
          if (groupItems.length === 0) return;
          const groupContainer = document.createElement("div");
          groupContainer.setAttribute("role", "group");
          groupContainer.setAttribute("data-dynamic-item", "true");
          groupContainer.setAttribute("data-slot", "command-group");
          if (groupName !== "__ungrouped__") {
            const headingTemplateId = groups.get(groupName);
            if (headingTemplateId) {
              const headingTemplate = document.getElementById(headingTemplateId);
              if (headingTemplate && headingTemplate.content) {
                const headingClone = headingTemplate.content.cloneNode(true);
                const headingEl = headingClone.firstElementChild;
                if (headingEl) {
                  groupContainer.setAttribute("aria-labelledby", headingEl.id);
                  groupContainer.appendChild(headingClone);
                }
              }
            }
          }
          groupItems.forEach((item) => {
            const itemIndex = this.parent.filteredItems.indexOf(item);
            let itemEl;
            if (item.isDataItem) {
              if (!this.dataItemTemplate) {
                return;
              }
              const clone2 = this.dataItemTemplate.content.cloneNode(true);
              itemEl = clone2.firstElementChild;
              Alpine2.addScopeToNode(itemEl, { item });
            } else {
              const template = document.getElementById(item.templateId);
              if (template && template.content) {
                const clone2 = template.content.cloneNode(true);
                itemEl = clone2.querySelector(`[data-command-item-id="${item.id}"]`);
              }
            }
            if (itemEl) {
              itemEl.setAttribute("data-command-item-id", item.id);
              itemEl.setAttribute("data-value", item.value);
              if (item.keywords) itemEl.setAttribute("data-keywords", JSON.stringify(item.keywords));
              if (item.group) itemEl.setAttribute("data-group", item.group);
              if (item.disabled) itemEl.setAttribute("data-disabled", "true");
              if (item.forceMount) itemEl.setAttribute("data-force-mount", "true");
              itemEl.setAttribute("role", "option");
              itemEl.setAttribute("aria-selected", this.parent.selectedIndex === itemIndex);
              if (item.disabled) {
                itemEl.setAttribute("aria-disabled", "true");
              }
              if (this.parent.selectedIndex === itemIndex) {
                itemEl.setAttribute("data-selected", "true");
              }
              groupContainer.appendChild(itemEl);
              Alpine2.initTree(itemEl);
            }
          });
          container.appendChild(groupContainer);
        });
      }
    }));
  }
  function registerRzCommandGroup(Alpine2) {
    Alpine2.data("rzCommandGroup", () => ({
      parent: null,
      heading: "",
      templateId: "",
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandGroup must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        this.heading = this.$el.dataset.heading;
        this.templateId = this.$el.dataset.templateId;
        if (this.heading && this.templateId) {
          this.parent.registerGroupTemplate(this.heading, this.templateId);
        }
      }
    }));
  }
  async function generateBundleId(paths) {
    paths = [...paths].sort();
    const joinedPaths = paths.join("|");
    const encoder = new TextEncoder();
    const data2 = encoder.encode(joinedPaths);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  function rizzyRequire(paths, callbackOrNonce, nonce) {
    let cbObj = void 0;
    let csp = void 0;
    if (typeof callbackOrNonce === "function") {
      cbObj = { success: callbackOrNonce };
    } else if (callbackOrNonce && typeof callbackOrNonce === "object") {
      cbObj = callbackOrNonce;
    } else if (typeof callbackOrNonce === "string") {
      csp = callbackOrNonce;
    }
    if (!csp && typeof nonce === "string") csp = nonce;
    const files = Array.isArray(paths) ? paths : [paths];
    return generateBundleId(files).then((bundleId) => {
      if (!loadjs.isDefined(bundleId)) {
        loadjs(files, bundleId, {
          // keep scripts ordered unless you explicitly change this later
          async: false,
          // pass CSP nonce to both script and style tags as your loader expects
          inlineScriptNonce: csp,
          inlineStyleNonce: csp
        });
      }
      return new Promise((resolve, reject) => {
        loadjs.ready(bundleId, {
          success: () => {
            try {
              if (cbObj && typeof cbObj.success === "function") cbObj.success();
            } catch (e2) {
              console.error("[rizzyRequire] success callback threw:", e2);
            }
            resolve({ bundleId });
          },
          error: (depsNotFound) => {
            try {
              if (cbObj && typeof cbObj.error === "function") {
                cbObj.error(depsNotFound);
              }
            } catch (e2) {
              console.error("[rizzyRequire] error callback threw:", e2);
            }
            reject(
              new Error(
                `[rizzyRequire] Failed to load bundle ${bundleId} (missing: ${Array.isArray(depsNotFound) ? depsNotFound.join(", ") : String(depsNotFound)})`
              )
            );
          }
        });
      });
    });
  }
  function registerComponents(Alpine2) {
    registerRzAccordion(Alpine2);
    registerAccordionItem(Alpine2);
    registerRzAlert(Alpine2);
    registerRzAspectRatio(Alpine2);
    registerRzBrowser(Alpine2);
    registerRzCalendar(Alpine2, rizzyRequire);
    registerRzCarousel(Alpine2, rizzyRequire);
    registerRzCodeViewer(Alpine2, rizzyRequire);
    registerRzCollapsible(Alpine2);
    registerRzCombobox(Alpine2, rizzyRequire);
    registerRzDateEdit(Alpine2, rizzyRequire);
    registerRzDialog(Alpine2);
    registerRzDropdownMenu(Alpine2);
    registerRzDarkModeToggle(Alpine2);
    registerRzEmbeddedPreview(Alpine2);
    registerRzEmpty(Alpine2);
    registerRzHeading(Alpine2);
    registerRzIndicator(Alpine2);
    registerRzInputGroupAddon(Alpine2);
    registerRzMarkdown(Alpine2, rizzyRequire);
    registerRzNavigationMenu(Alpine2);
    registerRzPopover(Alpine2);
    registerRzPrependInput(Alpine2);
    registerRzProgress(Alpine2);
    registerRzQuickReferenceContainer(Alpine2);
    registerRzSheet(Alpine2);
    registerRzTabs(Alpine2);
    registerRzSidebar(Alpine2);
    registerRzCommand(Alpine2);
    registerRzCommandItem(Alpine2);
    registerRzCommandList(Alpine2);
    registerRzCommandGroup(Alpine2);
  }
  function props(alpineRootElement) {
    if (!(alpineRootElement instanceof Element)) {
      console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el).");
      return {};
    }
    const propsScriptId = alpineRootElement.dataset.propsId;
    if (!propsScriptId) {
      return {};
    }
    const propsScriptEl = document.getElementById(propsScriptId);
    if (!propsScriptEl) {
      console.warn(`[Rizzy.props] Could not find the props script tag with ID '${propsScriptId}'.`);
      return {};
    }
    try {
      return JSON.parse(propsScriptEl.textContent || "{}");
    } catch (e2) {
      console.error(`[Rizzy.props] Failed to parse JSON from script tag #${propsScriptId}.`, e2);
      return {};
    }
  }
  const _registered = /* @__PURE__ */ new Map();
  const _importCache = /* @__PURE__ */ new Map();
  let _onAlpineInitAttached = false;
  function onceImport(path) {
    if (!_importCache.has(path)) {
      _importCache.set(
        path,
        import(path).catch((err) => {
          _importCache.delete(path);
          throw err;
        })
      );
    }
    return _importCache.get(path);
  }
  function setAsyncLoader(name, path) {
    const Alpine2 = globalThis.Alpine;
    if (!(Alpine2 && typeof Alpine2.asyncData === "function")) {
      console.error(
        `[RizzyUI] Could not register async component '${name}'. AsyncAlpine not available.`
      );
      return false;
    }
    Alpine2.asyncData(
      name,
      () => onceImport(path).catch((error2) => {
        console.error(
          `[RizzyUI] Failed to load Alpine module '${name}' from '${path}'.`,
          error2
        );
        return () => ({
          _error: true,
          _errorMessage: `Module '${name}' failed to load.`
        });
      })
    );
    return true;
  }
  function registerAsyncComponent(name, path) {
    if (!name || !path) {
      console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
      return;
    }
    const prev = _registered.get(name);
    if (prev && prev.path !== path) {
      console.warn(
        `[RizzyUI] Re-registering '${name}' with a different path.
  Previous: ${prev.path}
  New:      ${path}`
      );
    }
    const Alpine2 = globalThis.Alpine;
    if (Alpine2 && Alpine2.version) {
      const changedPath = !prev || prev.path !== path;
      const alreadySet = prev && prev.loaderSet && !changedPath;
      if (!alreadySet) {
        const ok = setAsyncLoader(name, path);
        _registered.set(name, { path, loaderSet: ok });
      }
      return;
    }
    _registered.set(name, { path, loaderSet: false });
    if (!_onAlpineInitAttached) {
      _onAlpineInitAttached = true;
      document.addEventListener(
        "alpine:init",
        () => {
          for (const [n2, info] of _registered) {
            if (!info.loaderSet) {
              const ok = setAsyncLoader(n2, info.path);
              info.loaderSet = ok;
            }
          }
        },
        { once: true }
      );
    }
  }
  function registerMobileDirective(Alpine2) {
    Alpine2.directive("mobile", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
      const bpMod = modifiers.find((m2) => m2.startsWith("bp-"));
      const BREAKPOINT = bpMod ? parseInt(bpMod.slice(3), 10) : 768;
      const ASSIGN_PROP = !!(expression && expression.length > 0);
      if (typeof window === "undefined" || !window.matchMedia) {
        el.dataset.mobile = "false";
        el.dataset.screen = "desktop";
        return;
      }
      const isMobileNow = () => window.innerWidth < BREAKPOINT;
      const reflect = (val) => {
        el.dataset.mobile = val ? "true" : "false";
        el.dataset.screen = val ? "mobile" : "desktop";
      };
      const getComponentData = () => {
        if (typeof Alpine2.$data === "function") return Alpine2.$data(el);
        return el.__x ? el.__x.$data : null;
      };
      const setProp = (val) => {
        if (!ASSIGN_PROP) return;
        const data2 = getComponentData();
        if (data2) data2[expression] = val;
      };
      const dispatch2 = (val) => {
        el.dispatchEvent(
          new CustomEvent("screen:change", {
            bubbles: true,
            detail: { isMobile: val, width: window.innerWidth, breakpoint: BREAKPOINT }
          })
        );
      };
      const mql = window.matchMedia(`(max-width: ${BREAKPOINT - 1}px)`);
      const update = () => {
        const val = isMobileNow();
        reflect(val);
        setProp(val);
        dispatch2(val);
      };
      update();
      const onChange = () => update();
      const onResize = () => update();
      mql.addEventListener("change", onChange);
      window.addEventListener("resize", onResize, { passive: true });
      cleanup2(() => {
        mql.removeEventListener("change", onChange);
        window.removeEventListener("resize", onResize);
      });
    });
  }
  function registerSyncDirective(Alpine2) {
    const handler4 = (el, { expression, modifiers }, { cleanup: cleanup2, effect: effect3 }) => {
      if (!expression || typeof expression !== "string") return;
      const setAtPath = (obj, path, value) => {
        const norm = path.replace(/\[(\d+)\]/g, ".$1");
        const keys = norm.split(".");
        const last = keys.pop();
        let cur = obj;
        for (const k of keys) {
          if (cur[k] == null || typeof cur[k] !== "object") cur[k] = isFinite(+k) ? [] : {};
          cur = cur[k];
        }
        cur[last] = value;
      };
      const stack = Alpine2.closestDataStack(el) || [];
      const childData = stack[0] || null;
      const parentData = stack[1] || null;
      if (!childData || !parentData) {
        if (void 0) {
          console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
        }
        return;
      }
      const pairs = expression.split(",").map((s2) => s2.trim()).filter(Boolean).map((s2) => {
        const m2 = s2.split("->").map((x) => x.trim());
        if (m2.length !== 2) {
          console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', s2);
          return null;
        }
        return { parentPath: m2[0], childPath: m2[1] };
      }).filter(Boolean);
      const initChildWins = modifiers.includes("init-child") || modifiers.includes("child") || modifiers.includes("childWins");
      const guard = pairs.map(() => ({
        fromParent: false,
        fromChild: false,
        skipChildOnce: initChildWins
        // avoid redundant first child->parent write
      }));
      const stops = [];
      pairs.forEach((pair, idx) => {
        const g = guard[idx];
        if (initChildWins) {
          const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
          g.fromChild = true;
          setAtPath(parentData, pair.parentPath, childVal);
          queueMicrotask(() => {
            g.fromChild = false;
          });
        } else {
          const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
          g.fromParent = true;
          setAtPath(childData, pair.childPath, parentVal);
          queueMicrotask(() => {
            g.fromParent = false;
          });
        }
        const stop1 = effect3(() => {
          const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
          if (g.fromChild) return;
          g.fromParent = true;
          setAtPath(childData, pair.childPath, parentVal);
          queueMicrotask(() => {
            g.fromParent = false;
          });
        });
        const stop2 = effect3(() => {
          const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
          if (g.fromParent) return;
          if (g.skipChildOnce) {
            g.skipChildOnce = false;
            return;
          }
          g.fromChild = true;
          setAtPath(parentData, pair.parentPath, childVal);
          queueMicrotask(() => {
            g.fromChild = false;
          });
        });
        stops.push(stop1, stop2);
      });
      cleanup2(() => {
        for (const stop2 of stops) {
          try {
            stop2 && stop2();
          } catch {
          }
        }
      });
    };
    Alpine2.directive("syncprop", handler4);
  }
  class ThemeController {
    constructor() {
      this.storageKey = "darkMode";
      this.eventName = "rz:theme-change";
      this.darkClass = "dark";
      this._mode = "auto";
      this._mq = null;
      this._initialized = false;
      this._onMqChange = null;
      this._onStorage = null;
      this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
    }
    init() {
      if (this._initialized) return;
      if (typeof window === "undefined") return;
      this._initialized = true;
      this._mq = typeof window.matchMedia === "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
      const raw2 = this._safeReadStorage(this.storageKey);
      this._mode = this._normalizeMode(raw2 ?? "auto");
      this._sync();
      this._onMqChange = () => {
        this._sync();
      };
      if (this._mq) {
        if (typeof this._mq.addEventListener === "function") {
          this._mq.addEventListener("change", this._onMqChange);
        } else if (typeof this._mq.addListener === "function") {
          this._mq.addListener(this._onMqChange);
        }
      }
      this._onStorage = (e2) => {
        if (e2.key !== this.storageKey) return;
        const next = this._normalizeMode(e2.newValue ?? "auto");
        if (next !== this._mode) {
          this._mode = next;
          this._sync();
        }
      };
      window.addEventListener("storage", this._onStorage);
    }
    destroy() {
      if (!this._initialized) return;
      this._initialized = false;
      if (this._mq && this._onMqChange) {
        if (typeof this._mq.removeEventListener === "function") {
          this._mq.removeEventListener("change", this._onMqChange);
        } else if (typeof this._mq.removeListener === "function") {
          this._mq.removeListener(this._onMqChange);
        }
      }
      if (typeof window !== "undefined" && this._onStorage) {
        window.removeEventListener("storage", this._onStorage);
      }
      this._onMqChange = null;
      this._onStorage = null;
      this._mq = null;
      this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
    }
    // ----- Public State Accessors -----
    get mode() {
      return this._mode;
    }
    get prefersDark() {
      return !!this._mq?.matches;
    }
    get effectiveDark() {
      return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
    }
    // ----- Public API Surface -----
    isDark() {
      return this.effectiveDark;
    }
    isLight() {
      return !this.effectiveDark;
    }
    setLight() {
      this._setMode("light");
    }
    setDark() {
      this._setMode("dark");
    }
    setAuto() {
      this._setMode("auto");
    }
    toggle() {
      const currentlyDark = this.effectiveDark;
      this._setMode(currentlyDark ? "light" : "dark");
    }
    // ----- Internals -----
    _setMode(value) {
      this._mode = this._normalizeMode(value);
      this._persist();
      this._sync();
    }
    _normalizeMode(value) {
      return value === "light" || value === "dark" || value === "auto" ? value : "auto";
    }
    _safeReadStorage(key) {
      try {
        return window?.localStorage?.getItem(key);
      } catch (e2) {
        return null;
      }
    }
    _persist() {
      try {
        window?.localStorage?.setItem(this.storageKey, this._mode);
      } catch (e2) {
      }
    }
    _sync() {
      const effectiveDark = this.effectiveDark;
      const mode = this._mode;
      const prefersDark = this.prefersDark;
      const root = typeof document !== "undefined" ? document.documentElement : null;
      const domMatchesState = root ? root.classList.contains(this.darkClass) === effectiveDark && root.style.colorScheme === (effectiveDark ? "dark" : "light") : true;
      if (this._lastSnapshot.mode === mode && this._lastSnapshot.effectiveDark === effectiveDark && this._lastSnapshot.prefersDark === prefersDark && domMatchesState) {
        return;
      }
      this._lastSnapshot = { mode, effectiveDark, prefersDark };
      if (root) {
        root.classList.toggle(this.darkClass, effectiveDark);
        root.style.colorScheme = effectiveDark ? "dark" : "light";
      }
      if (typeof window !== "undefined") {
        window.dispatchEvent(
          new CustomEvent(this.eventName, {
            detail: {
              mode,
              darkMode: effectiveDark,
              // External API uses 'darkMode' convention
              prefersDark,
              source: "RizzyUI"
            }
          })
        );
      }
    }
  }
  const themeController = new ThemeController();
  function registerStores(Alpine2) {
    themeController.init();
    Alpine2.store("theme", {
      // Reactive state mirrors
      // We mirror ALL derived properties to ensure Alpine reactivity works 
      // for bindings like x-show="prefersDark" or x-text="mode".
      _mode: themeController.mode,
      _prefersDark: themeController.prefersDark,
      _effectiveDark: themeController.effectiveDark,
      // Listener reference to prevent duplicate registration
      _onThemeChange: null,
      init() {
        if (!this._onThemeChange) {
          this._onThemeChange = () => this._refresh();
          window.addEventListener(themeController.eventName, this._onThemeChange);
        }
        this._refresh();
      },
      _refresh() {
        this._mode = themeController.mode;
        this._prefersDark = themeController.prefersDark;
        this._effectiveDark = themeController.effectiveDark;
      },
      // ----- Reactive Getters -----
      // These return the reactive properties from the store, ensuring Alpine
      // properly tracks dependencies.
      get mode() {
        return this._mode;
      },
      get effectiveDark() {
        return this._effectiveDark;
      },
      get prefersDark() {
        return this._prefersDark;
      },
      // Expose as getters (not methods) for consistency
      get isDark() {
        return this._effectiveDark;
      },
      get isLight() {
        return !this._effectiveDark;
      },
      // ----- Proxy Methods -----
      setLight() {
        themeController.setLight();
      },
      setDark() {
        themeController.setDark();
      },
      setAuto() {
        themeController.setAuto();
      },
      toggle() {
        themeController.toggle();
      }
    });
  }
  let cachedRizzyUI = null;
  function bootstrapRizzyUI(Alpine2) {
    if (cachedRizzyUI) return cachedRizzyUI;
    Alpine2.plugin(module_default$2);
    Alpine2.plugin(module_default$1);
    Alpine2.plugin(module_default);
    Alpine2.plugin(async_alpine_default);
    if (typeof document !== "undefined") {
      document.addEventListener("alpine:init", () => {
        registerStores(Alpine2);
      });
    }
    registerComponents(Alpine2);
    registerMobileDirective(Alpine2);
    registerSyncDirective(Alpine2);
    cachedRizzyUI = {
      Alpine: Alpine2,
      require: rizzyRequire,
      toast: Toast,
      $data,
      props,
      registerAsyncComponent,
      theme: themeController
    };
    if (typeof window !== "undefined") {
      themeController.init();
      window.Alpine = Alpine2;
      window.Rizzy = { ...window.Rizzy || {}, ...cachedRizzyUI };
      document.dispatchEvent(new CustomEvent("rz:init", {
        detail: { Rizzy: window.Rizzy }
      }));
    }
    return cachedRizzyUI;
  }
  const RizzyUI = bootstrapRizzyUI(module_default$3);
  module_default$3.start();
  return RizzyUI;
});
//# sourceMappingURL=rizzyui-csp.js.map
</file>

<file path="wwwroot/js/rizzyui-csp.min.es.js">
var Vt = !1, Wt = !1, fe = [], qt = -1;
function us(e) {
  ds(e);
}
function ds(e) {
  fe.includes(e) || fe.push(e), hs();
}
function fs(e) {
  let t = fe.indexOf(e);
  t !== -1 && t > qt && fe.splice(t, 1);
}
function hs() {
  !Wt && !Vt && (Vt = !0, queueMicrotask(ps));
}
function ps() {
  Vt = !1, Wt = !0;
  for (let e = 0; e < fe.length; e++)
    fe[e](), qt = e;
  fe.length = 0, qt = -1, Wt = !1;
}
var Te, _e, Se, yn, Ht = !0;
function ms(e) {
  Ht = !1, e(), Ht = !0;
}
function gs(e) {
  Te = e.reactive, Se = e.release, _e = (t) => e.effect(t, { scheduler: (i) => {
    Ht ? us(i) : i();
  } }), yn = e.raw;
}
function Mi(e) {
  _e = e;
}
function vs(e) {
  let t = () => {
  };
  return [(n) => {
    let r = _e(n);
    return e._x_effects || (e._x_effects = /* @__PURE__ */ new Set(), e._x_runEffects = () => {
      e._x_effects.forEach((s) => s());
    }), e._x_effects.add(r), t = () => {
      r !== void 0 && (e._x_effects.delete(r), Se(r));
    }, r;
  }, () => {
    t();
  }];
}
function wn(e, t) {
  let i = !0, n, r = _e(() => {
    let s = e();
    JSON.stringify(s), i ? n = s : queueMicrotask(() => {
      t(s, n), n = s;
    }), i = !1;
  });
  return () => Se(r);
}
var _n = [], xn = [], En = [];
function bs(e) {
  En.push(e);
}
function hi(e, t) {
  typeof t == "function" ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, xn.push(t));
}
function In(e) {
  _n.push(e);
}
function Cn(e, t, i) {
  e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(i);
}
function Tn(e, t) {
  e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach(([i, n]) => {
    (t === void 0 || t.includes(i)) && (n.forEach((r) => r()), delete e._x_attributeCleanups[i]);
  });
}
function ys(e) {
  for (e._x_effects?.forEach(fs); e._x_cleanups?.length; )
    e._x_cleanups.pop()();
}
var pi = new MutationObserver(bi), mi = !1;
function gi() {
  pi.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), mi = !0;
}
function Sn() {
  ws(), pi.disconnect(), mi = !1;
}
var Re = [];
function ws() {
  let e = pi.takeRecords();
  Re.push(() => e.length > 0 && bi(e));
  let t = Re.length;
  queueMicrotask(() => {
    if (Re.length === t)
      for (; Re.length > 0; )
        Re.shift()();
  });
}
function $(e) {
  if (!mi)
    return e();
  Sn();
  let t = e();
  return gi(), t;
}
var vi = !1, ct = [];
function _s() {
  vi = !0;
}
function xs() {
  vi = !1, bi(ct), ct = [];
}
function bi(e) {
  if (vi) {
    ct = ct.concat(e);
    return;
  }
  let t = [], i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (let s = 0; s < e.length; s++)
    if (!e[s].target._x_ignoreMutationObserver && (e[s].type === "childList" && (e[s].removedNodes.forEach((o) => {
      o.nodeType === 1 && o._x_marker && i.add(o);
    }), e[s].addedNodes.forEach((o) => {
      if (o.nodeType === 1) {
        if (i.has(o)) {
          i.delete(o);
          return;
        }
        o._x_marker || t.push(o);
      }
    })), e[s].type === "attributes")) {
      let o = e[s].target, a = e[s].attributeName, l = e[s].oldValue, c = () => {
        n.has(o) || n.set(o, []), n.get(o).push({ name: a, value: o.getAttribute(a) });
      }, u = () => {
        r.has(o) || r.set(o, []), r.get(o).push(a);
      };
      o.hasAttribute(a) && l === null ? c() : o.hasAttribute(a) ? (u(), c()) : u();
    }
  r.forEach((s, o) => {
    Tn(o, s);
  }), n.forEach((s, o) => {
    _n.forEach((a) => a(o, s));
  });
  for (let s of i)
    t.some((o) => o.contains(s)) || xn.forEach((o) => o(s));
  for (let s of t)
    s.isConnected && En.forEach((o) => o(s));
  t = null, i = null, n = null, r = null;
}
function An(e) {
  return Ae(ve(e));
}
function Je(e, t, i) {
  return e._x_dataStack = [t, ...ve(i || e)], () => {
    e._x_dataStack = e._x_dataStack.filter((n) => n !== t);
  };
}
function ve(e) {
  return e._x_dataStack ? e._x_dataStack : typeof ShadowRoot == "function" && e instanceof ShadowRoot ? ve(e.host) : e.parentNode ? ve(e.parentNode) : [];
}
function Ae(e) {
  return new Proxy({ objects: e }, Es);
}
var Es = {
  ownKeys({ objects: e }) {
    return Array.from(
      new Set(e.flatMap((t) => Object.keys(t)))
    );
  },
  has({ objects: e }, t) {
    return t == Symbol.unscopables ? !1 : e.some(
      (i) => Object.prototype.hasOwnProperty.call(i, t) || Reflect.has(i, t)
    );
  },
  get({ objects: e }, t, i) {
    return t == "toJSON" ? Is : Reflect.get(
      e.find(
        (n) => Reflect.has(n, t)
      ) || {},
      t,
      i
    );
  },
  set({ objects: e }, t, i, n) {
    const r = e.find(
      (o) => Object.prototype.hasOwnProperty.call(o, t)
    ) || e[e.length - 1], s = Object.getOwnPropertyDescriptor(r, t);
    return s?.set && s?.get ? s.set.call(n, i) || !0 : Reflect.set(r, t, i);
  }
};
function Is() {
  return Reflect.ownKeys(this).reduce((t, i) => (t[i] = Reflect.get(this, i), t), {});
}
function On(e) {
  let t = (n) => typeof n == "object" && !Array.isArray(n) && n !== null, i = (n, r = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(n)).forEach(([s, { value: o, enumerable: a }]) => {
      if (a === !1 || o === void 0 || typeof o == "object" && o !== null && o.__v_skip)
        return;
      let l = r === "" ? s : `${r}.${s}`;
      typeof o == "object" && o !== null && o._x_interceptor ? n[s] = o.initialize(e, l, s) : t(o) && o !== n && !(o instanceof Element) && i(o, l);
    });
  };
  return i(e);
}
function $n(e, t = () => {
}) {
  let i = {
    initialValue: void 0,
    _x_interceptor: !0,
    initialize(n, r, s) {
      return e(this.initialValue, () => Cs(n, r), (o) => Kt(n, r, o), r, s);
    }
  };
  return t(i), (n) => {
    if (typeof n == "object" && n !== null && n._x_interceptor) {
      let r = i.initialize.bind(i);
      i.initialize = (s, o, a) => {
        let l = n.initialize(s, o, a);
        return i.initialValue = l, r(s, o, a);
      };
    } else
      i.initialValue = n;
    return i;
  };
}
function Cs(e, t) {
  return t.split(".").reduce((i, n) => i[n], e);
}
function Kt(e, t, i) {
  if (typeof t == "string" && (t = t.split(".")), t.length === 1)
    e[t[0]] = i;
  else {
    if (t.length === 0)
      throw error;
    return e[t[0]] || (e[t[0]] = {}), Kt(e[t[0]], t.slice(1), i);
  }
}
var Nn = {};
function q(e, t) {
  Nn[e] = t;
}
function ut(e, t) {
  let i = Ts(t);
  return Object.entries(Nn).forEach(([n, r]) => {
    Object.defineProperty(e, `$${n}`, {
      get() {
        return r(t, i);
      },
      enumerable: !1
    });
  }), e;
}
function Ts(e) {
  let [t, i] = zn(e), n = { interceptor: $n, ...t };
  return hi(e, i), n;
}
function kn(e, t, i, ...n) {
  try {
    return i(...n);
  } catch (r) {
    qe(r, e, t);
  }
}
function qe(e, t, i = void 0) {
  e = Object.assign(
    e ?? { message: "No error message given." },
    { el: t, expression: i }
  ), console.warn(`Alpine Expression Error: ${e.message}
${i ? 'Expression: "' + i + `"
` : ""}`, t), setTimeout(() => {
    throw e;
  }, 0);
}
var je = !0;
function Rn(e) {
  let t = je;
  je = !1;
  let i = e();
  return je = t, i;
}
function he(e, t, i = {}) {
  let n;
  return R(e, t)((r) => n = r, i), n;
}
function R(...e) {
  return Ln(...e);
}
var Ln = As;
function Ss(e) {
  Ln = e;
}
function As(e, t) {
  let i = {};
  ut(i, e);
  let n = [i, ...ve(e)], r = typeof t == "function" ? Pn(n, t) : $s(n, t, e);
  return kn.bind(null, e, t, r);
}
function Pn(e, t) {
  return (i = () => {
  }, { scope: n = {}, params: r = [], context: s } = {}) => {
    let o = t.apply(Ae([n, ...e]), r);
    dt(i, o);
  };
}
var Dt = {};
function Os(e, t) {
  if (Dt[e])
    return Dt[e];
  let i = Object.getPrototypeOf(async function() {
  }).constructor, n = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e, s = (() => {
    try {
      let o = new i(
        ["__self", "scope"],
        `with (scope) { __self.result = ${n} }; __self.finished = true; return __self.result;`
      );
      return Object.defineProperty(o, "name", {
        value: `[Alpine] ${e}`
      }), o;
    } catch (o) {
      return qe(o, t, e), Promise.resolve();
    }
  })();
  return Dt[e] = s, s;
}
function $s(e, t, i) {
  let n = Os(t, i);
  return (r = () => {
  }, { scope: s = {}, params: o = [], context: a } = {}) => {
    n.result = void 0, n.finished = !1;
    let l = Ae([s, ...e]);
    if (typeof n == "function") {
      let c = n.call(a, n, l).catch((u) => qe(u, i, t));
      n.finished ? (dt(r, n.result, l, o, i), n.result = void 0) : c.then((u) => {
        dt(r, u, l, o, i);
      }).catch((u) => qe(u, i, t)).finally(() => n.result = void 0);
    }
  };
}
function dt(e, t, i, n, r) {
  if (je && typeof t == "function") {
    let s = t.apply(i, n);
    s instanceof Promise ? s.then((o) => dt(e, o, i, n)).catch((o) => qe(o, r, t)) : e(s);
  } else typeof t == "object" && t instanceof Promise ? t.then((s) => e(s)) : e(t);
}
var yi = "x-";
function Oe(e = "") {
  return yi + e;
}
function Ns(e) {
  yi = e;
}
var ft = {};
function N(e, t) {
  return ft[e] = t, {
    before(i) {
      if (!ft[i]) {
        console.warn(String.raw`Cannot find directive \`${i}\`. \`${e}\` will use the default order of execution`);
        return;
      }
      const n = de.indexOf(i);
      de.splice(n >= 0 ? n : de.indexOf("DEFAULT"), 0, e);
    }
  };
}
function ks(e) {
  return Object.keys(ft).includes(e);
}
function wi(e, t, i) {
  if (t = Array.from(t), e._x_virtualDirectives) {
    let s = Object.entries(e._x_virtualDirectives).map(([a, l]) => ({ name: a, value: l })), o = Dn(s);
    s = s.map((a) => o.find((l) => l.name === a.name) ? {
      name: `x-bind:${a.name}`,
      value: `"${a.value}"`
    } : a), t = t.concat(s);
  }
  let n = {};
  return t.map(Bn((s, o) => n[s] = o)).filter(Vn).map(Ps(n, i)).sort(Ds).map((s) => Ls(e, s));
}
function Dn(e) {
  return Array.from(e).map(Bn()).filter((t) => !Vn(t));
}
var Yt = !1, Be = /* @__PURE__ */ new Map(), Mn = Symbol();
function Rs(e) {
  Yt = !0;
  let t = Symbol();
  Mn = t, Be.set(t, []);
  let i = () => {
    for (; Be.get(t).length; )
      Be.get(t).shift()();
    Be.delete(t);
  }, n = () => {
    Yt = !1, i();
  };
  e(i), n();
}
function zn(e) {
  let t = [], i = (a) => t.push(a), [n, r] = vs(e);
  return t.push(r), [{
    Alpine: Ze,
    effect: n,
    cleanup: i,
    evaluateLater: R.bind(R, e),
    evaluate: he.bind(he, e)
  }, () => t.forEach((a) => a())];
}
function Ls(e, t) {
  let i = () => {
  }, n = ft[t.type] || i, [r, s] = zn(e);
  Cn(e, t.original, s);
  let o = () => {
    e._x_ignore || e._x_ignoreSelf || (n.inline && n.inline(e, t, r), n = n.bind(n, e, t, r), Yt ? Be.get(Mn).push(n) : n());
  };
  return o.runCleanups = s, o;
}
var Fn = (e, t) => ({ name: i, value: n }) => (i.startsWith(e) && (i = i.replace(e, t)), { name: i, value: n }), Un = (e) => e;
function Bn(e = () => {
}) {
  return ({ name: t, value: i }) => {
    let { name: n, value: r } = jn.reduce((s, o) => o(s), { name: t, value: i });
    return n !== t && e(n, t), { name: n, value: r };
  };
}
var jn = [];
function _i(e) {
  jn.push(e);
}
function Vn({ name: e }) {
  return Wn().test(e);
}
var Wn = () => new RegExp(`^${yi}([^:^.]+)\\b`);
function Ps(e, t) {
  return ({ name: i, value: n }) => {
    let r = i.match(Wn()), s = i.match(/:([a-zA-Z0-9\-_:]+)/), o = i.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], a = t || e[i] || i;
    return {
      type: r ? r[1] : null,
      value: s ? s[1] : null,
      modifiers: o.map((l) => l.replace(".", "")),
      expression: n,
      original: a
    };
  };
}
var Jt = "DEFAULT", de = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  Jt,
  "teleport"
];
function Ds(e, t) {
  let i = de.indexOf(e.type) === -1 ? Jt : e.type, n = de.indexOf(t.type) === -1 ? Jt : t.type;
  return de.indexOf(i) - de.indexOf(n);
}
function Ve(e, t, i = {}) {
  e.dispatchEvent(
    new CustomEvent(t, {
      detail: i,
      bubbles: !0,
      // Allows events to pass the shadow DOM barrier.
      composed: !0,
      cancelable: !0
    })
  );
}
function be(e, t) {
  if (typeof ShadowRoot == "function" && e instanceof ShadowRoot) {
    Array.from(e.children).forEach((r) => be(r, t));
    return;
  }
  let i = !1;
  if (t(e, () => i = !0), i)
    return;
  let n = e.firstElementChild;
  for (; n; )
    be(n, t), n = n.nextElementSibling;
}
function U(e, ...t) {
  console.warn(`Alpine Warning: ${e}`, ...t);
}
var zi = !1;
function Ms() {
  zi && U("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), zi = !0, document.body || U("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), Ve(document, "alpine:init"), Ve(document, "alpine:initializing"), gi(), bs((t) => G(t, be)), hi((t) => Ne(t)), In((t, i) => {
    wi(t, i).forEach((n) => n());
  });
  let e = (t) => !It(t.parentElement, !0);
  Array.from(document.querySelectorAll(Kn().join(","))).filter(e).forEach((t) => {
    G(t);
  }), Ve(document, "alpine:initialized"), setTimeout(() => {
    Bs();
  });
}
var xi = [], qn = [];
function Hn() {
  return xi.map((e) => e());
}
function Kn() {
  return xi.concat(qn).map((e) => e());
}
function Yn(e) {
  xi.push(e);
}
function Jn(e) {
  qn.push(e);
}
function It(e, t = !1) {
  return $e(e, (i) => {
    if ((t ? Kn() : Hn()).some((r) => i.matches(r)))
      return !0;
  });
}
function $e(e, t) {
  if (e) {
    if (t(e))
      return e;
    if (e._x_teleportBack && (e = e._x_teleportBack), !!e.parentElement)
      return $e(e.parentElement, t);
  }
}
function zs(e) {
  return Hn().some((t) => e.matches(t));
}
var Zn = [];
function Fs(e) {
  Zn.push(e);
}
var Us = 1;
function G(e, t = be, i = () => {
}) {
  $e(e, (n) => n._x_ignore) || Rs(() => {
    t(e, (n, r) => {
      n._x_marker || (i(n, r), Zn.forEach((s) => s(n, r)), wi(n, n.attributes).forEach((s) => s()), n._x_ignore || (n._x_marker = Us++), n._x_ignore && r());
    });
  });
}
function Ne(e, t = be) {
  t(e, (i) => {
    ys(i), Tn(i), delete i._x_marker;
  });
}
function Bs() {
  [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ].forEach(([t, i, n]) => {
    ks(i) || n.some((r) => {
      if (document.querySelector(r))
        return U(`found "${r}", but missing ${t} plugin`), !0;
    });
  });
}
var Zt = [], Ei = !1;
function Ii(e = () => {
}) {
  return queueMicrotask(() => {
    Ei || setTimeout(() => {
      Gt();
    });
  }), new Promise((t) => {
    Zt.push(() => {
      e(), t();
    });
  });
}
function Gt() {
  for (Ei = !1; Zt.length; )
    Zt.shift()();
}
function js() {
  Ei = !0;
}
function Ci(e, t) {
  return Array.isArray(t) ? Fi(e, t.join(" ")) : typeof t == "object" && t !== null ? Vs(e, t) : typeof t == "function" ? Ci(e, t()) : Fi(e, t);
}
function Fi(e, t) {
  let i = (r) => r.split(" ").filter((s) => !e.classList.contains(s)).filter(Boolean), n = (r) => (e.classList.add(...r), () => {
    e.classList.remove(...r);
  });
  return t = t === !0 ? t = "" : t || "", n(i(t));
}
function Vs(e, t) {
  let i = (a) => a.split(" ").filter(Boolean), n = Object.entries(t).flatMap(([a, l]) => l ? i(a) : !1).filter(Boolean), r = Object.entries(t).flatMap(([a, l]) => l ? !1 : i(a)).filter(Boolean), s = [], o = [];
  return r.forEach((a) => {
    e.classList.contains(a) && (e.classList.remove(a), o.push(a));
  }), n.forEach((a) => {
    e.classList.contains(a) || (e.classList.add(a), s.push(a));
  }), () => {
    o.forEach((a) => e.classList.add(a)), s.forEach((a) => e.classList.remove(a));
  };
}
function Ct(e, t) {
  return typeof t == "object" && t !== null ? Ws(e, t) : qs(e, t);
}
function Ws(e, t) {
  let i = {};
  return Object.entries(t).forEach(([n, r]) => {
    i[n] = e.style[n], n.startsWith("--") || (n = Hs(n)), e.style.setProperty(n, r);
  }), setTimeout(() => {
    e.style.length === 0 && e.removeAttribute("style");
  }), () => {
    Ct(e, i);
  };
}
function qs(e, t) {
  let i = e.getAttribute("style", t);
  return e.setAttribute("style", t), () => {
    e.setAttribute("style", i || "");
  };
}
function Hs(e) {
  return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Xt(e, t = () => {
}) {
  let i = !1;
  return function() {
    i ? t.apply(this, arguments) : (i = !0, e.apply(this, arguments));
  };
}
N("transition", (e, { value: t, modifiers: i, expression: n }, { evaluate: r }) => {
  typeof n == "function" && (n = r(n)), n !== !1 && (!n || typeof n == "boolean" ? Ys(e, i, t) : Ks(e, n, t));
});
function Ks(e, t, i) {
  Gn(e, Ci, ""), {
    enter: (r) => {
      e._x_transition.enter.during = r;
    },
    "enter-start": (r) => {
      e._x_transition.enter.start = r;
    },
    "enter-end": (r) => {
      e._x_transition.enter.end = r;
    },
    leave: (r) => {
      e._x_transition.leave.during = r;
    },
    "leave-start": (r) => {
      e._x_transition.leave.start = r;
    },
    "leave-end": (r) => {
      e._x_transition.leave.end = r;
    }
  }[i](t);
}
function Ys(e, t, i) {
  Gn(e, Ct);
  let n = !t.includes("in") && !t.includes("out") && !i, r = n || t.includes("in") || ["enter"].includes(i), s = n || t.includes("out") || ["leave"].includes(i);
  t.includes("in") && !n && (t = t.filter((b, h) => h < t.indexOf("out"))), t.includes("out") && !n && (t = t.filter((b, h) => h > t.indexOf("out")));
  let o = !t.includes("opacity") && !t.includes("scale"), a = o || t.includes("opacity"), l = o || t.includes("scale"), c = a ? 0 : 1, u = l ? Le(t, "scale", 95) / 100 : 1, d = Le(t, "delay", 0) / 1e3, f = Le(t, "origin", "center"), y = "opacity, transform", m = Le(t, "duration", 150) / 1e3, v = Le(t, "duration", 75) / 1e3, p = "cubic-bezier(0.4, 0.0, 0.2, 1)";
  r && (e._x_transition.enter.during = {
    transformOrigin: f,
    transitionDelay: `${d}s`,
    transitionProperty: y,
    transitionDuration: `${m}s`,
    transitionTimingFunction: p
  }, e._x_transition.enter.start = {
    opacity: c,
    transform: `scale(${u})`
  }, e._x_transition.enter.end = {
    opacity: 1,
    transform: "scale(1)"
  }), s && (e._x_transition.leave.during = {
    transformOrigin: f,
    transitionDelay: `${d}s`,
    transitionProperty: y,
    transitionDuration: `${v}s`,
    transitionTimingFunction: p
  }, e._x_transition.leave.start = {
    opacity: 1,
    transform: "scale(1)"
  }, e._x_transition.leave.end = {
    opacity: c,
    transform: `scale(${u})`
  });
}
function Gn(e, t, i = {}) {
  e._x_transition || (e._x_transition = {
    enter: { during: i, start: i, end: i },
    leave: { during: i, start: i, end: i },
    in(n = () => {
    }, r = () => {
    }) {
      Qt(e, t, {
        during: this.enter.during,
        start: this.enter.start,
        end: this.enter.end
      }, n, r);
    },
    out(n = () => {
    }, r = () => {
    }) {
      Qt(e, t, {
        during: this.leave.during,
        start: this.leave.start,
        end: this.leave.end
      }, n, r);
    }
  });
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(e, t, i, n) {
  const r = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let s = () => r(i);
  if (t) {
    e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(i) : s() : e._x_transition ? e._x_transition.in(i) : s();
    return;
  }
  e._x_hidePromise = e._x_transition ? new Promise((o, a) => {
    e._x_transition.out(() => {
    }, () => o(n)), e._x_transitioning && e._x_transitioning.beforeCancel(() => a({ isFromCancelledTransition: !0 }));
  }) : Promise.resolve(n), queueMicrotask(() => {
    let o = Xn(e);
    o ? (o._x_hideChildren || (o._x_hideChildren = []), o._x_hideChildren.push(e)) : r(() => {
      let a = (l) => {
        let c = Promise.all([
          l._x_hidePromise,
          ...(l._x_hideChildren || []).map(a)
        ]).then(([u]) => u?.());
        return delete l._x_hidePromise, delete l._x_hideChildren, c;
      };
      a(e).catch((l) => {
        if (!l.isFromCancelledTransition)
          throw l;
      });
    });
  });
};
function Xn(e) {
  let t = e.parentNode;
  if (t)
    return t._x_hidePromise ? t : Xn(t);
}
function Qt(e, t, { during: i, start: n, end: r } = {}, s = () => {
}, o = () => {
}) {
  if (e._x_transitioning && e._x_transitioning.cancel(), Object.keys(i).length === 0 && Object.keys(n).length === 0 && Object.keys(r).length === 0) {
    s(), o();
    return;
  }
  let a, l, c;
  Js(e, {
    start() {
      a = t(e, n);
    },
    during() {
      l = t(e, i);
    },
    before: s,
    end() {
      a(), c = t(e, r);
    },
    after: o,
    cleanup() {
      l(), c();
    }
  });
}
function Js(e, t) {
  let i, n, r, s = Xt(() => {
    $(() => {
      i = !0, n || t.before(), r || (t.end(), Gt()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning;
    });
  });
  e._x_transitioning = {
    beforeCancels: [],
    beforeCancel(o) {
      this.beforeCancels.push(o);
    },
    cancel: Xt(function() {
      for (; this.beforeCancels.length; )
        this.beforeCancels.shift()();
      s();
    }),
    finish: s
  }, $(() => {
    t.start(), t.during();
  }), js(), requestAnimationFrame(() => {
    if (i)
      return;
    let o = Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, a = Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    o === 0 && (o = Number(getComputedStyle(e).animationDuration.replace("s", "")) * 1e3), $(() => {
      t.before();
    }), n = !0, requestAnimationFrame(() => {
      i || ($(() => {
        t.end();
      }), Gt(), setTimeout(e._x_transitioning.finish, o + a), r = !0);
    });
  });
}
function Le(e, t, i) {
  if (e.indexOf(t) === -1)
    return i;
  const n = e[e.indexOf(t) + 1];
  if (!n || t === "scale" && isNaN(n))
    return i;
  if (t === "duration" || t === "delay") {
    let r = n.match(/([0-9]+)ms/);
    if (r)
      return r[1];
  }
  return t === "origin" && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [n, e[e.indexOf(t) + 2]].join(" ") : n;
}
var re = !1;
function ae(e, t = () => {
}) {
  return (...i) => re ? t(...i) : e(...i);
}
function Zs(e) {
  return (...t) => re && e(...t);
}
var Qn = [];
function Tt(e) {
  Qn.push(e);
}
function Gs(e, t) {
  Qn.forEach((i) => i(e, t)), re = !0, er(() => {
    G(t, (i, n) => {
      n(i, () => {
      });
    });
  }), re = !1;
}
var ei = !1;
function Xs(e, t) {
  t._x_dataStack || (t._x_dataStack = e._x_dataStack), re = !0, ei = !0, er(() => {
    Qs(t);
  }), re = !1, ei = !1;
}
function Qs(e) {
  let t = !1;
  G(e, (n, r) => {
    be(n, (s, o) => {
      if (t && zs(s))
        return o();
      t = !0, r(s, o);
    });
  });
}
function er(e) {
  let t = _e;
  Mi((i, n) => {
    let r = t(i);
    return Se(r), () => {
    };
  }), e(), Mi(t);
}
function tr(e, t, i, n = []) {
  switch (e._x_bindings || (e._x_bindings = Te({})), e._x_bindings[t] = i, t = n.includes("camel") ? ao(t) : t, t) {
    case "value":
      eo(e, i);
      break;
    case "style":
      io(e, i);
      break;
    case "class":
      to(e, i);
      break;
    case "selected":
    case "checked":
      no(e, t, i);
      break;
    default:
      ir(e, t, i);
      break;
  }
}
function eo(e, t) {
  if (sr(e))
    e.attributes.value === void 0 && (e.value = t), window.fromModel && (typeof t == "boolean" ? e.checked = at(e.value) === t : e.checked = Ui(e.value, t));
  else if (Ti(e))
    Number.isInteger(t) ? e.value = t : !Array.isArray(t) && typeof t != "boolean" && ![null, void 0].includes(t) ? e.value = String(t) : Array.isArray(t) ? e.checked = t.some((i) => Ui(i, e.value)) : e.checked = !!t;
  else if (e.tagName === "SELECT")
    oo(e, t);
  else {
    if (e.value === t)
      return;
    e.value = t === void 0 ? "" : t;
  }
}
function to(e, t) {
  e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedClasses = Ci(e, t);
}
function io(e, t) {
  e._x_undoAddedStyles && e._x_undoAddedStyles(), e._x_undoAddedStyles = Ct(e, t);
}
function no(e, t, i) {
  ir(e, t, i), so(e, t, i);
}
function ir(e, t, i) {
  [null, void 0, !1].includes(i) && co(t) ? e.removeAttribute(t) : (nr(t) && (i = t), ro(e, t, i));
}
function ro(e, t, i) {
  e.getAttribute(t) != i && e.setAttribute(t, i);
}
function so(e, t, i) {
  e[t] !== i && (e[t] = i);
}
function oo(e, t) {
  const i = [].concat(t).map((n) => n + "");
  Array.from(e.options).forEach((n) => {
    n.selected = i.includes(n.value);
  });
}
function ao(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, i) => i.toUpperCase());
}
function Ui(e, t) {
  return e == t;
}
function at(e) {
  return [1, "1", "true", "on", "yes", !0].includes(e) ? !0 : [0, "0", "false", "off", "no", !1].includes(e) ? !1 : e ? !!e : null;
}
var lo = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function nr(e) {
  return lo.has(e);
}
function co(e) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e);
}
function uo(e, t, i) {
  return e._x_bindings && e._x_bindings[t] !== void 0 ? e._x_bindings[t] : rr(e, t, i);
}
function fo(e, t, i, n = !0) {
  if (e._x_bindings && e._x_bindings[t] !== void 0)
    return e._x_bindings[t];
  if (e._x_inlineBindings && e._x_inlineBindings[t] !== void 0) {
    let r = e._x_inlineBindings[t];
    return r.extract = n, Rn(() => he(e, r.expression));
  }
  return rr(e, t, i);
}
function rr(e, t, i) {
  let n = e.getAttribute(t);
  return n === null ? typeof i == "function" ? i() : i : n === "" ? !0 : nr(t) ? !![t, "true"].includes(n) : n;
}
function Ti(e) {
  return e.type === "checkbox" || e.localName === "ui-checkbox" || e.localName === "ui-switch";
}
function sr(e) {
  return e.type === "radio" || e.localName === "ui-radio";
}
function or(e, t) {
  let i;
  return function() {
    const n = this, r = arguments, s = function() {
      i = null, e.apply(n, r);
    };
    clearTimeout(i), i = setTimeout(s, t);
  };
}
function ar(e, t) {
  let i;
  return function() {
    let n = this, r = arguments;
    i || (e.apply(n, r), i = !0, setTimeout(() => i = !1, t));
  };
}
function lr({ get: e, set: t }, { get: i, set: n }) {
  let r = !0, s, o = _e(() => {
    let a = e(), l = i();
    if (r)
      n(Mt(a)), r = !1;
    else {
      let c = JSON.stringify(a), u = JSON.stringify(l);
      c !== s ? n(Mt(a)) : c !== u && t(Mt(l));
    }
    s = JSON.stringify(e()), JSON.stringify(i());
  });
  return () => {
    Se(o);
  };
}
function Mt(e) {
  return typeof e == "object" ? JSON.parse(JSON.stringify(e)) : e;
}
function ho(e) {
  (Array.isArray(e) ? e : [e]).forEach((i) => i(Ze));
}
var ce = {}, Bi = !1;
function po(e, t) {
  if (Bi || (ce = Te(ce), Bi = !0), t === void 0)
    return ce[e];
  ce[e] = t, On(ce[e]), typeof t == "object" && t !== null && t.hasOwnProperty("init") && typeof t.init == "function" && ce[e].init();
}
function mo() {
  return ce;
}
var cr = {};
function go(e, t) {
  let i = typeof t != "function" ? () => t : t;
  return e instanceof Element ? ur(e, i()) : (cr[e] = i, () => {
  });
}
function vo(e) {
  return Object.entries(cr).forEach(([t, i]) => {
    Object.defineProperty(e, t, {
      get() {
        return (...n) => i(...n);
      }
    });
  }), e;
}
function ur(e, t, i) {
  let n = [];
  for (; n.length; )
    n.pop()();
  let r = Object.entries(t).map(([o, a]) => ({ name: o, value: a })), s = Dn(r);
  return r = r.map((o) => s.find((a) => a.name === o.name) ? {
    name: `x-bind:${o.name}`,
    value: `"${o.value}"`
  } : o), wi(e, r, i).map((o) => {
    n.push(o.runCleanups), o();
  }), () => {
    for (; n.length; )
      n.pop()();
  };
}
var dr = {};
function bo(e, t) {
  dr[e] = t;
}
function yo(e, t) {
  return Object.entries(dr).forEach(([i, n]) => {
    Object.defineProperty(e, i, {
      get() {
        return (...r) => n.bind(t)(...r);
      },
      enumerable: !1
    });
  }), e;
}
var wo = {
  get reactive() {
    return Te;
  },
  get release() {
    return Se;
  },
  get effect() {
    return _e;
  },
  get raw() {
    return yn;
  },
  version: "3.15.0",
  flushAndStopDeferringMutations: xs,
  dontAutoEvaluateFunctions: Rn,
  disableEffectScheduling: ms,
  startObservingMutations: gi,
  stopObservingMutations: Sn,
  setReactivityEngine: gs,
  onAttributeRemoved: Cn,
  onAttributesAdded: In,
  closestDataStack: ve,
  skipDuringClone: ae,
  onlyDuringClone: Zs,
  addRootSelector: Yn,
  addInitSelector: Jn,
  interceptClone: Tt,
  addScopeToNode: Je,
  deferMutations: _s,
  mapAttributes: _i,
  evaluateLater: R,
  interceptInit: Fs,
  setEvaluator: Ss,
  mergeProxies: Ae,
  extractProp: fo,
  findClosest: $e,
  onElRemoved: hi,
  closestRoot: It,
  destroyTree: Ne,
  interceptor: $n,
  // INTERNAL: not public API and is subject to change without major release.
  transition: Qt,
  // INTERNAL
  setStyles: Ct,
  // INTERNAL
  mutateDom: $,
  directive: N,
  entangle: lr,
  throttle: ar,
  debounce: or,
  evaluate: he,
  initTree: G,
  nextTick: Ii,
  prefixed: Oe,
  prefix: Ns,
  plugin: ho,
  magic: q,
  store: po,
  start: Ms,
  clone: Xs,
  // INTERNAL
  cloneNode: Gs,
  // INTERNAL
  bound: uo,
  $data: An,
  watch: wn,
  walk: be,
  data: bo,
  bind: go
}, Ze = wo, k = class {
  constructor(e, t, i, n) {
    this.type = e, this.value = t, this.start = i, this.end = n;
  }
}, _o = class {
  constructor(e) {
    this.input = e, this.position = 0, this.tokens = [];
  }
  tokenize() {
    for (; this.position < this.input.length && (this.skipWhitespace(), !(this.position >= this.input.length)); ) {
      const e = this.input[this.position];
      this.isDigit(e) ? this.readNumber() : this.isAlpha(e) || e === "_" || e === "$" ? this.readIdentifierOrKeyword() : e === '"' || e === "'" ? this.readString() : e === "/" && this.peek() === "/" ? this.skipLineComment() : this.readOperatorOrPunctuation();
    }
    return this.tokens.push(new k("EOF", null, this.position, this.position)), this.tokens;
  }
  skipWhitespace() {
    for (; this.position < this.input.length && /\s/.test(this.input[this.position]); )
      this.position++;
  }
  skipLineComment() {
    for (; this.position < this.input.length && this.input[this.position] !== `
`; )
      this.position++;
  }
  isDigit(e) {
    return /[0-9]/.test(e);
  }
  isAlpha(e) {
    return /[a-zA-Z]/.test(e);
  }
  isAlphaNumeric(e) {
    return /[a-zA-Z0-9_$]/.test(e);
  }
  peek(e = 1) {
    return this.input[this.position + e] || "";
  }
  readNumber() {
    const e = this.position;
    let t = !1;
    for (; this.position < this.input.length; ) {
      const n = this.input[this.position];
      if (this.isDigit(n))
        this.position++;
      else if (n === "." && !t)
        t = !0, this.position++;
      else
        break;
    }
    const i = this.input.slice(e, this.position);
    this.tokens.push(new k("NUMBER", parseFloat(i), e, this.position));
  }
  readIdentifierOrKeyword() {
    const e = this.position;
    for (; this.position < this.input.length && this.isAlphaNumeric(this.input[this.position]); )
      this.position++;
    const t = this.input.slice(e, this.position);
    ["true", "false", "null", "undefined", "new", "typeof", "void", "delete", "in", "instanceof"].includes(t) ? t === "true" || t === "false" ? this.tokens.push(new k("BOOLEAN", t === "true", e, this.position)) : t === "null" ? this.tokens.push(new k("NULL", null, e, this.position)) : t === "undefined" ? this.tokens.push(new k("UNDEFINED", void 0, e, this.position)) : this.tokens.push(new k("KEYWORD", t, e, this.position)) : this.tokens.push(new k("IDENTIFIER", t, e, this.position));
  }
  readString() {
    const e = this.position, t = this.input[this.position];
    this.position++;
    let i = "", n = !1;
    for (; this.position < this.input.length; ) {
      const r = this.input[this.position];
      if (n) {
        switch (r) {
          case "n":
            i += `
`;
            break;
          case "t":
            i += "	";
            break;
          case "r":
            i += "\r";
            break;
          case "\\":
            i += "\\";
            break;
          case t:
            i += t;
            break;
          default:
            i += r;
        }
        n = !1;
      } else if (r === "\\")
        n = !0;
      else if (r === t) {
        this.position++, this.tokens.push(new k("STRING", i, e, this.position));
        return;
      } else
        i += r;
      this.position++;
    }
    throw new Error(`Unterminated string starting at position ${e}`);
  }
  readOperatorOrPunctuation() {
    const e = this.position, t = this.input[this.position], i = this.peek(), n = this.peek(2);
    if (t === "=" && i === "=" && n === "=")
      this.position += 3, this.tokens.push(new k("OPERATOR", "===", e, this.position));
    else if (t === "!" && i === "=" && n === "=")
      this.position += 3, this.tokens.push(new k("OPERATOR", "!==", e, this.position));
    else if (t === "=" && i === "=")
      this.position += 2, this.tokens.push(new k("OPERATOR", "==", e, this.position));
    else if (t === "!" && i === "=")
      this.position += 2, this.tokens.push(new k("OPERATOR", "!=", e, this.position));
    else if (t === "<" && i === "=")
      this.position += 2, this.tokens.push(new k("OPERATOR", "<=", e, this.position));
    else if (t === ">" && i === "=")
      this.position += 2, this.tokens.push(new k("OPERATOR", ">=", e, this.position));
    else if (t === "&" && i === "&")
      this.position += 2, this.tokens.push(new k("OPERATOR", "&&", e, this.position));
    else if (t === "|" && i === "|")
      this.position += 2, this.tokens.push(new k("OPERATOR", "||", e, this.position));
    else if (t === "+" && i === "+")
      this.position += 2, this.tokens.push(new k("OPERATOR", "++", e, this.position));
    else if (t === "-" && i === "-")
      this.position += 2, this.tokens.push(new k("OPERATOR", "--", e, this.position));
    else {
      this.position++;
      const r = "()[]{},.;:?".includes(t) ? "PUNCTUATION" : "OPERATOR";
      this.tokens.push(new k(r, t, e, this.position));
    }
  }
}, xo = class {
  constructor(e) {
    this.tokens = e, this.position = 0;
  }
  parse() {
    if (this.isAtEnd())
      throw new Error("Empty expression");
    const e = this.parseExpression();
    if (this.match("PUNCTUATION", ";"), !this.isAtEnd())
      throw new Error(`Unexpected token: ${this.current().value}`);
    return e;
  }
  parseExpression() {
    return this.parseAssignment();
  }
  parseAssignment() {
    const e = this.parseTernary();
    if (this.match("OPERATOR", "=")) {
      const t = this.parseAssignment();
      if (e.type === "Identifier" || e.type === "MemberExpression")
        return {
          type: "AssignmentExpression",
          left: e,
          operator: "=",
          right: t
        };
      throw new Error("Invalid assignment target");
    }
    return e;
  }
  parseTernary() {
    const e = this.parseLogicalOr();
    if (this.match("PUNCTUATION", "?")) {
      const t = this.parseExpression();
      this.consume("PUNCTUATION", ":");
      const i = this.parseExpression();
      return {
        type: "ConditionalExpression",
        test: e,
        consequent: t,
        alternate: i
      };
    }
    return e;
  }
  parseLogicalOr() {
    let e = this.parseLogicalAnd();
    for (; this.match("OPERATOR", "||"); ) {
      const t = this.previous().value, i = this.parseLogicalAnd();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseLogicalAnd() {
    let e = this.parseEquality();
    for (; this.match("OPERATOR", "&&"); ) {
      const t = this.previous().value, i = this.parseEquality();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseEquality() {
    let e = this.parseRelational();
    for (; this.match("OPERATOR", "==", "!=", "===", "!=="); ) {
      const t = this.previous().value, i = this.parseRelational();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseRelational() {
    let e = this.parseAdditive();
    for (; this.match("OPERATOR", "<", ">", "<=", ">="); ) {
      const t = this.previous().value, i = this.parseAdditive();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseAdditive() {
    let e = this.parseMultiplicative();
    for (; this.match("OPERATOR", "+", "-"); ) {
      const t = this.previous().value, i = this.parseMultiplicative();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseMultiplicative() {
    let e = this.parseUnary();
    for (; this.match("OPERATOR", "*", "/", "%"); ) {
      const t = this.previous().value, i = this.parseUnary();
      e = {
        type: "BinaryExpression",
        operator: t,
        left: e,
        right: i
      };
    }
    return e;
  }
  parseUnary() {
    if (this.match("OPERATOR", "++", "--")) {
      const e = this.previous().value, t = this.parseUnary();
      return {
        type: "UpdateExpression",
        operator: e,
        argument: t,
        prefix: !0
      };
    }
    if (this.match("OPERATOR", "!", "-", "+")) {
      const e = this.previous().value, t = this.parseUnary();
      return {
        type: "UnaryExpression",
        operator: e,
        argument: t,
        prefix: !0
      };
    }
    return this.parsePostfix();
  }
  parsePostfix() {
    let e = this.parseMember();
    return this.match("OPERATOR", "++", "--") ? {
      type: "UpdateExpression",
      operator: this.previous().value,
      argument: e,
      prefix: !1
    } : e;
  }
  parseMember() {
    let e = this.parsePrimary();
    for (; ; )
      if (this.match("PUNCTUATION", ".")) {
        const t = this.consume("IDENTIFIER");
        e = {
          type: "MemberExpression",
          object: e,
          property: { type: "Identifier", name: t.value },
          computed: !1
        };
      } else if (this.match("PUNCTUATION", "[")) {
        const t = this.parseExpression();
        this.consume("PUNCTUATION", "]"), e = {
          type: "MemberExpression",
          object: e,
          property: t,
          computed: !0
        };
      } else if (this.match("PUNCTUATION", "(")) {
        const t = this.parseArguments();
        e = {
          type: "CallExpression",
          callee: e,
          arguments: t
        };
      } else
        break;
    return e;
  }
  parseArguments() {
    const e = [];
    if (!this.check("PUNCTUATION", ")"))
      do
        e.push(this.parseExpression());
      while (this.match("PUNCTUATION", ","));
    return this.consume("PUNCTUATION", ")"), e;
  }
  parsePrimary() {
    if (this.match("NUMBER"))
      return { type: "Literal", value: this.previous().value };
    if (this.match("STRING"))
      return { type: "Literal", value: this.previous().value };
    if (this.match("BOOLEAN"))
      return { type: "Literal", value: this.previous().value };
    if (this.match("NULL"))
      return { type: "Literal", value: null };
    if (this.match("UNDEFINED"))
      return { type: "Literal", value: void 0 };
    if (this.match("IDENTIFIER"))
      return { type: "Identifier", name: this.previous().value };
    if (this.match("PUNCTUATION", "(")) {
      const e = this.parseExpression();
      return this.consume("PUNCTUATION", ")"), e;
    }
    if (this.match("PUNCTUATION", "["))
      return this.parseArrayLiteral();
    if (this.match("PUNCTUATION", "{"))
      return this.parseObjectLiteral();
    throw new Error(`Unexpected token: ${this.current().type} "${this.current().value}"`);
  }
  parseArrayLiteral() {
    const e = [];
    for (; !this.check("PUNCTUATION", "]") && !this.isAtEnd() && (e.push(this.parseExpression()), this.match("PUNCTUATION", ",")); )
      if (this.check("PUNCTUATION", "]"))
        break;
    return this.consume("PUNCTUATION", "]"), {
      type: "ArrayExpression",
      elements: e
    };
  }
  parseObjectLiteral() {
    const e = [];
    for (; !this.check("PUNCTUATION", "}") && !this.isAtEnd(); ) {
      let t, i = !1;
      if (this.match("STRING"))
        t = { type: "Literal", value: this.previous().value };
      else if (this.match("IDENTIFIER"))
        t = { type: "Identifier", name: this.previous().value };
      else if (this.match("PUNCTUATION", "["))
        t = this.parseExpression(), i = !0, this.consume("PUNCTUATION", "]");
      else
        throw new Error("Expected property key");
      this.consume("PUNCTUATION", ":");
      const n = this.parseExpression();
      if (e.push({
        type: "Property",
        key: t,
        value: n,
        computed: i,
        shorthand: !1
      }), this.match("PUNCTUATION", ",")) {
        if (this.check("PUNCTUATION", "}"))
          break;
      } else
        break;
    }
    return this.consume("PUNCTUATION", "}"), {
      type: "ObjectExpression",
      properties: e
    };
  }
  match(...e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      if (t === 0 && e.length > 1) {
        const n = i;
        for (let r = 1; r < e.length; r++)
          if (this.check(n, e[r]))
            return this.advance(), !0;
        return !1;
      } else if (e.length === 1)
        return this.checkType(i) ? (this.advance(), !0) : !1;
    }
    return !1;
  }
  check(e, t) {
    return this.isAtEnd() ? !1 : t !== void 0 ? this.current().type === e && this.current().value === t : this.current().type === e;
  }
  checkType(e) {
    return this.isAtEnd() ? !1 : this.current().type === e;
  }
  advance() {
    return this.isAtEnd() || this.position++, this.previous();
  }
  isAtEnd() {
    return this.current().type === "EOF";
  }
  current() {
    return this.tokens[this.position];
  }
  previous() {
    return this.tokens[this.position - 1];
  }
  consume(e, t) {
    if (t !== void 0) {
      if (this.check(e, t))
        return this.advance();
      throw new Error(`Expected ${e} "${t}" but got ${this.current().type} "${this.current().value}"`);
    }
    if (this.check(e))
      return this.advance();
    throw new Error(`Expected ${e} but got ${this.current().type} "${this.current().value}"`);
  }
}, Eo = class {
  evaluate({ node: e, scope: t = {}, context: i = null, allowGlobal: n = !1, forceBindingRootScopeToFunctions: r = !0 }) {
    switch (e.type) {
      case "Literal":
        return e.value;
      case "Identifier":
        if (e.name in t) {
          const m = t[e.name];
          return typeof m == "function" ? m.bind(t) : m;
        }
        if (n && typeof globalThis[e.name] < "u") {
          const m = globalThis[e.name];
          return typeof m == "function" ? m.bind(globalThis) : m;
        }
        throw new Error(`Undefined variable: ${e.name}`);
      case "MemberExpression":
        const s = this.evaluate({ node: e.object, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
        if (s == null)
          throw new Error("Cannot read property of null or undefined");
        let o;
        if (e.computed) {
          const m = this.evaluate({ node: e.property, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
          o = s[m];
        } else
          o = s[e.property.name];
        return typeof o == "function" ? r ? o.bind(t) : o.bind(s) : o;
      case "CallExpression":
        const a = e.arguments.map((m) => this.evaluate({ node: m, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }));
        if (e.callee.type === "MemberExpression") {
          const m = this.evaluate({ node: e.callee.object, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
          let v;
          if (e.callee.computed) {
            const p = this.evaluate({ node: e.callee.property, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
            v = m[p];
          } else
            v = m[e.callee.property.name];
          if (typeof v != "function")
            throw new Error("Value is not a function");
          return v.apply(m, a);
        } else if (e.callee.type === "Identifier") {
          const m = e.callee.name;
          let v;
          if (m in t)
            v = t[m];
          else if (n && typeof globalThis[m] < "u")
            v = globalThis[m];
          else
            throw new Error(`Undefined variable: ${m}`);
          if (typeof v != "function")
            throw new Error("Value is not a function");
          const p = i !== null ? i : t;
          return v.apply(p, a);
        } else {
          const m = this.evaluate({ node: e.callee, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
          if (typeof m != "function")
            throw new Error("Value is not a function");
          return m.apply(i, a);
        }
      case "UnaryExpression":
        const l = this.evaluate({ node: e.argument, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
        switch (e.operator) {
          case "!":
            return !l;
          case "-":
            return -l;
          case "+":
            return +l;
          default:
            throw new Error(`Unknown unary operator: ${e.operator}`);
        }
      case "UpdateExpression":
        if (e.argument.type === "Identifier") {
          const m = e.argument.name;
          if (!(m in t))
            throw new Error(`Undefined variable: ${m}`);
          const v = t[m];
          return e.operator === "++" ? t[m] = v + 1 : e.operator === "--" && (t[m] = v - 1), e.prefix ? t[m] : v;
        } else if (e.argument.type === "MemberExpression") {
          const m = this.evaluate({ node: e.argument.object, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }), v = e.argument.computed ? this.evaluate({ node: e.argument.property, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }) : e.argument.property.name, p = m[v];
          return e.operator === "++" ? m[v] = p + 1 : e.operator === "--" && (m[v] = p - 1), e.prefix ? m[v] : p;
        }
        throw new Error("Invalid update expression target");
      case "BinaryExpression":
        const c = this.evaluate({ node: e.left, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }), u = this.evaluate({ node: e.right, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
        switch (e.operator) {
          case "+":
            return c + u;
          case "-":
            return c - u;
          case "*":
            return c * u;
          case "/":
            return c / u;
          case "%":
            return c % u;
          case "==":
            return c == u;
          case "!=":
            return c != u;
          case "===":
            return c === u;
          case "!==":
            return c !== u;
          case "<":
            return c < u;
          case ">":
            return c > u;
          case "<=":
            return c <= u;
          case ">=":
            return c >= u;
          case "&&":
            return c && u;
          case "||":
            return c || u;
          default:
            throw new Error(`Unknown binary operator: ${e.operator}`);
        }
      case "ConditionalExpression":
        return this.evaluate({ node: e.test, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }) ? this.evaluate({ node: e.consequent, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }) : this.evaluate({ node: e.alternate, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
      case "AssignmentExpression":
        const f = this.evaluate({ node: e.right, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
        if (e.left.type === "Identifier")
          return t[e.left.name] = f, f;
        if (e.left.type === "MemberExpression") {
          const m = this.evaluate({ node: e.left.object, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
          if (e.left.computed) {
            const v = this.evaluate({ node: e.left.property, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
            m[v] = f;
          } else
            m[e.left.property.name] = f;
          return f;
        }
        throw new Error("Invalid assignment target");
      case "ArrayExpression":
        return e.elements.map((m) => this.evaluate({ node: m, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }));
      case "ObjectExpression":
        const y = {};
        for (const m of e.properties) {
          const v = m.computed ? this.evaluate({ node: m.key, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }) : m.key.type === "Identifier" ? m.key.name : this.evaluate({ node: m.key, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r }), p = this.evaluate({ node: m.value, scope: t, context: i, allowGlobal: n, forceBindingRootScopeToFunctions: r });
          y[v] = p;
        }
        return y;
      default:
        throw new Error(`Unknown node type: ${e.type}`);
    }
  }
};
function Io(e) {
  try {
    const i = new _o(e).tokenize(), r = new xo(i).parse(), s = new Eo();
    return function(o = {}) {
      const { scope: a = {}, context: l = null, allowGlobal: c = !1, forceBindingRootScopeToFunctions: u = !1 } = o;
      return s.evaluate({ node: r, scope: a, context: l, allowGlobal: c, forceBindingRootScopeToFunctions: u });
    };
  } catch (t) {
    throw new Error(`CSP Parser Error: ${t.message}`);
  }
}
function Co(e, t) {
  let i = To(e);
  if (typeof t == "function")
    return Pn(i, t);
  let n = So(e, t, i);
  return kn.bind(null, e, t, n);
}
function To(e) {
  let t = {};
  return ut(t, e), [t, ...ve(e)];
}
function So(e, t, i) {
  return (n = () => {
  }, { scope: r = {}, params: s = [] } = {}) => {
    let o = Ae([r, ...i]), l = Io(t)({
      scope: o,
      allowGlobal: !0,
      forceBindingRootScopeToFunctions: !0
    });
    if (je && typeof l == "function") {
      let c = l.apply(l, s);
      c instanceof Promise ? c.then((u) => n(u)) : n(c);
    } else typeof l == "object" && l instanceof Promise ? l.then((c) => n(c)) : n(l);
  };
}
function Ao(e, t) {
  const i = /* @__PURE__ */ Object.create(null), n = e.split(",");
  for (let r = 0; r < n.length; r++)
    i[n[r]] = !0;
  return (r) => !!i[r];
}
var Oo = Object.freeze({}), $o = Object.prototype.hasOwnProperty, St = (e, t) => $o.call(e, t), pe = Array.isArray, We = (e) => fr(e) === "[object Map]", No = (e) => typeof e == "string", Si = (e) => typeof e == "symbol", At = (e) => e !== null && typeof e == "object", ko = Object.prototype.toString, fr = (e) => ko.call(e), hr = (e) => fr(e).slice(8, -1), Ai = (e) => No(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Ro = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (i) => t[i] || (t[i] = e(i));
}, Lo = Ro((e) => e.charAt(0).toUpperCase() + e.slice(1)), pr = (e, t) => e !== t && (e === e || t === t), ti = /* @__PURE__ */ new WeakMap(), Pe = [], Y, me = Symbol("iterate"), ii = Symbol("Map key iterate");
function Po(e) {
  return e && e._isEffect === !0;
}
function Do(e, t = Oo) {
  Po(e) && (e = e.raw);
  const i = Fo(e, t);
  return t.lazy || i(), i;
}
function Mo(e) {
  e.active && (mr(e), e.options.onStop && e.options.onStop(), e.active = !1);
}
var zo = 0;
function Fo(e, t) {
  const i = function() {
    if (!i.active)
      return e();
    if (!Pe.includes(i)) {
      mr(i);
      try {
        return Bo(), Pe.push(i), Y = i, e();
      } finally {
        Pe.pop(), gr(), Y = Pe[Pe.length - 1];
      }
    }
  };
  return i.id = zo++, i.allowRecurse = !!t.allowRecurse, i._isEffect = !0, i.active = !0, i.raw = e, i.deps = [], i.options = t, i;
}
function mr(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let i = 0; i < t.length; i++)
      t[i].delete(e);
    t.length = 0;
  }
}
var Ie = !0, Oi = [];
function Uo() {
  Oi.push(Ie), Ie = !1;
}
function Bo() {
  Oi.push(Ie), Ie = !0;
}
function gr() {
  const e = Oi.pop();
  Ie = e === void 0 ? !0 : e;
}
function j(e, t, i) {
  if (!Ie || Y === void 0)
    return;
  let n = ti.get(e);
  n || ti.set(e, n = /* @__PURE__ */ new Map());
  let r = n.get(i);
  r || n.set(i, r = /* @__PURE__ */ new Set()), r.has(Y) || (r.add(Y), Y.deps.push(r), Y.options.onTrack && Y.options.onTrack({
    effect: Y,
    target: e,
    type: t,
    key: i
  }));
}
function se(e, t, i, n, r, s) {
  const o = ti.get(e);
  if (!o)
    return;
  const a = /* @__PURE__ */ new Set(), l = (u) => {
    u && u.forEach((d) => {
      (d !== Y || d.allowRecurse) && a.add(d);
    });
  };
  if (t === "clear")
    o.forEach(l);
  else if (i === "length" && pe(e))
    o.forEach((u, d) => {
      (d === "length" || d >= n) && l(u);
    });
  else
    switch (i !== void 0 && l(o.get(i)), t) {
      case "add":
        pe(e) ? Ai(i) && l(o.get("length")) : (l(o.get(me)), We(e) && l(o.get(ii)));
        break;
      case "delete":
        pe(e) || (l(o.get(me)), We(e) && l(o.get(ii)));
        break;
      case "set":
        We(e) && l(o.get(me));
        break;
    }
  const c = (u) => {
    u.options.onTrigger && u.options.onTrigger({
      effect: u,
      target: e,
      key: i,
      type: t,
      newValue: n,
      oldValue: r,
      oldTarget: s
    }), u.options.scheduler ? u.options.scheduler(u) : u();
  };
  a.forEach(c);
}
var jo = /* @__PURE__ */ Ao("__proto__,__v_isRef,__isVue"), vr = new Set(Object.getOwnPropertyNames(Symbol).map((e) => Symbol[e]).filter(Si)), Vo = /* @__PURE__ */ br(), Wo = /* @__PURE__ */ br(!0), ji = /* @__PURE__ */ qo();
function qo() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...i) {
      const n = O(this);
      for (let s = 0, o = this.length; s < o; s++)
        j(n, "get", s + "");
      const r = n[t](...i);
      return r === -1 || r === !1 ? n[t](...i.map(O)) : r;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...i) {
      Uo();
      const n = O(this)[t].apply(this, i);
      return gr(), n;
    };
  }), e;
}
function br(e = !1, t = !1) {
  return function(n, r, s) {
    if (r === "__v_isReactive")
      return !e;
    if (r === "__v_isReadonly")
      return e;
    if (r === "__v_raw" && s === (e ? t ? sa : xr : t ? ra : _r).get(n))
      return n;
    const o = pe(n);
    if (!e && o && St(ji, r))
      return Reflect.get(ji, r, s);
    const a = Reflect.get(n, r, s);
    return (Si(r) ? vr.has(r) : jo(r)) || (e || j(n, "get", r), t) ? a : ni(a) ? !o || !Ai(r) ? a.value : a : At(a) ? e ? Er(a) : Ri(a) : a;
  };
}
var Ho = /* @__PURE__ */ Ko();
function Ko(e = !1) {
  return function(i, n, r, s) {
    let o = i[n];
    if (!e && (r = O(r), o = O(o), !pe(i) && ni(o) && !ni(r)))
      return o.value = r, !0;
    const a = pe(i) && Ai(n) ? Number(n) < i.length : St(i, n), l = Reflect.set(i, n, r, s);
    return i === O(s) && (a ? pr(r, o) && se(i, "set", n, r, o) : se(i, "add", n, r)), l;
  };
}
function Yo(e, t) {
  const i = St(e, t), n = e[t], r = Reflect.deleteProperty(e, t);
  return r && i && se(e, "delete", t, void 0, n), r;
}
function Jo(e, t) {
  const i = Reflect.has(e, t);
  return (!Si(t) || !vr.has(t)) && j(e, "has", t), i;
}
function Zo(e) {
  return j(e, "iterate", pe(e) ? "length" : me), Reflect.ownKeys(e);
}
var Go = {
  get: Vo,
  set: Ho,
  deleteProperty: Yo,
  has: Jo,
  ownKeys: Zo
}, Xo = {
  get: Wo,
  set(e, t) {
    return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  },
  deleteProperty(e, t) {
    return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  }
}, $i = (e) => At(e) ? Ri(e) : e, Ni = (e) => At(e) ? Er(e) : e, ki = (e) => e, Ot = (e) => Reflect.getPrototypeOf(e);
function Xe(e, t, i = !1, n = !1) {
  e = e.__v_raw;
  const r = O(e), s = O(t);
  t !== s && !i && j(r, "get", t), !i && j(r, "get", s);
  const { has: o } = Ot(r), a = n ? ki : i ? Ni : $i;
  if (o.call(r, t))
    return a(e.get(t));
  if (o.call(r, s))
    return a(e.get(s));
  e !== r && e.get(t);
}
function Qe(e, t = !1) {
  const i = this.__v_raw, n = O(i), r = O(e);
  return e !== r && !t && j(n, "has", e), !t && j(n, "has", r), e === r ? i.has(e) : i.has(e) || i.has(r);
}
function et(e, t = !1) {
  return e = e.__v_raw, !t && j(O(e), "iterate", me), Reflect.get(e, "size", e);
}
function Vi(e) {
  e = O(e);
  const t = O(this);
  return Ot(t).has.call(t, e) || (t.add(e), se(t, "add", e, e)), this;
}
function Wi(e, t) {
  t = O(t);
  const i = O(this), { has: n, get: r } = Ot(i);
  let s = n.call(i, e);
  s ? wr(i, n, e) : (e = O(e), s = n.call(i, e));
  const o = r.call(i, e);
  return i.set(e, t), s ? pr(t, o) && se(i, "set", e, t, o) : se(i, "add", e, t), this;
}
function qi(e) {
  const t = O(this), { has: i, get: n } = Ot(t);
  let r = i.call(t, e);
  r ? wr(t, i, e) : (e = O(e), r = i.call(t, e));
  const s = n ? n.call(t, e) : void 0, o = t.delete(e);
  return r && se(t, "delete", e, void 0, s), o;
}
function Hi() {
  const e = O(this), t = e.size !== 0, i = We(e) ? new Map(e) : new Set(e), n = e.clear();
  return t && se(e, "clear", void 0, void 0, i), n;
}
function tt(e, t) {
  return function(n, r) {
    const s = this, o = s.__v_raw, a = O(o), l = t ? ki : e ? Ni : $i;
    return !e && j(a, "iterate", me), o.forEach((c, u) => n.call(r, l(c), l(u), s));
  };
}
function it(e, t, i) {
  return function(...n) {
    const r = this.__v_raw, s = O(r), o = We(s), a = e === "entries" || e === Symbol.iterator && o, l = e === "keys" && o, c = r[e](...n), u = i ? ki : t ? Ni : $i;
    return !t && j(s, "iterate", l ? ii : me), {
      // iterator protocol
      next() {
        const { value: d, done: f } = c.next();
        return f ? { value: d, done: f } : {
          value: a ? [u(d[0]), u(d[1])] : u(d),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function te(e) {
  return function(...t) {
    {
      const i = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(`${Lo(e)} operation ${i}failed: target is readonly.`, O(this));
    }
    return e === "delete" ? !1 : this;
  };
}
function Qo() {
  const e = {
    get(s) {
      return Xe(this, s);
    },
    get size() {
      return et(this);
    },
    has: Qe,
    add: Vi,
    set: Wi,
    delete: qi,
    clear: Hi,
    forEach: tt(!1, !1)
  }, t = {
    get(s) {
      return Xe(this, s, !1, !0);
    },
    get size() {
      return et(this);
    },
    has: Qe,
    add: Vi,
    set: Wi,
    delete: qi,
    clear: Hi,
    forEach: tt(!1, !0)
  }, i = {
    get(s) {
      return Xe(this, s, !0);
    },
    get size() {
      return et(this, !0);
    },
    has(s) {
      return Qe.call(this, s, !0);
    },
    add: te(
      "add"
      /* ADD */
    ),
    set: te(
      "set"
      /* SET */
    ),
    delete: te(
      "delete"
      /* DELETE */
    ),
    clear: te(
      "clear"
      /* CLEAR */
    ),
    forEach: tt(!0, !1)
  }, n = {
    get(s) {
      return Xe(this, s, !0, !0);
    },
    get size() {
      return et(this, !0);
    },
    has(s) {
      return Qe.call(this, s, !0);
    },
    add: te(
      "add"
      /* ADD */
    ),
    set: te(
      "set"
      /* SET */
    ),
    delete: te(
      "delete"
      /* DELETE */
    ),
    clear: te(
      "clear"
      /* CLEAR */
    ),
    forEach: tt(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = it(s, !1, !1), i[s] = it(s, !0, !1), t[s] = it(s, !1, !0), n[s] = it(s, !0, !0);
  }), [
    e,
    i,
    t,
    n
  ];
}
var [ea, ta, Wc, qc] = /* @__PURE__ */ Qo();
function yr(e, t) {
  const i = e ? ta : ea;
  return (n, r, s) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? n : Reflect.get(St(i, r) && r in n ? i : n, r, s);
}
var ia = {
  get: /* @__PURE__ */ yr(!1)
}, na = {
  get: /* @__PURE__ */ yr(!0)
};
function wr(e, t, i) {
  const n = O(i);
  if (n !== i && t.call(e, n)) {
    const r = hr(e);
    console.warn(`Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var _r = /* @__PURE__ */ new WeakMap(), ra = /* @__PURE__ */ new WeakMap(), xr = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap();
function oa(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function aa(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : oa(hr(e));
}
function Ri(e) {
  return e && e.__v_isReadonly ? e : Ir(e, !1, Go, ia, _r);
}
function Er(e) {
  return Ir(e, !0, Xo, na, xr);
}
function Ir(e, t, i, n, r) {
  if (!At(e))
    return console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = r.get(e);
  if (s)
    return s;
  const o = aa(e);
  if (o === 0)
    return e;
  const a = new Proxy(e, o === 2 ? n : i);
  return r.set(e, a), a;
}
function O(e) {
  return e && O(e.__v_raw) || e;
}
function ni(e) {
  return !!(e && e.__v_isRef === !0);
}
q("nextTick", () => Ii);
q("dispatch", (e) => Ve.bind(Ve, e));
q("watch", (e, { evaluateLater: t, cleanup: i }) => (n, r) => {
  let s = t(n), a = wn(() => {
    let l;
    return s((c) => l = c), l;
  }, r);
  i(a);
});
q("store", mo);
q("data", (e) => An(e));
q("root", (e) => It(e));
q("refs", (e) => (e._x_refs_proxy || (e._x_refs_proxy = Ae(la(e))), e._x_refs_proxy));
function la(e) {
  let t = [];
  return $e(e, (i) => {
    i._x_refs && t.push(i._x_refs);
  }), t;
}
var zt = {};
function Cr(e) {
  return zt[e] || (zt[e] = 0), ++zt[e];
}
function ca(e, t) {
  return $e(e, (i) => {
    if (i._x_ids && i._x_ids[t])
      return !0;
  });
}
function ua(e, t) {
  e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = Cr(t));
}
q("id", (e, { cleanup: t }) => (i, n = null) => {
  let r = `${i}${n ? `-${n}` : ""}`;
  return da(e, r, t, () => {
    let s = ca(e, i), o = s ? s._x_ids[i] : Cr(i);
    return n ? `${i}-${o}-${n}` : `${i}-${o}`;
  });
});
Tt((e, t) => {
  e._x_id && (t._x_id = e._x_id);
});
function da(e, t, i, n) {
  if (e._x_id || (e._x_id = {}), e._x_id[t])
    return e._x_id[t];
  let r = n();
  return e._x_id[t] = r, i(() => {
    delete e._x_id[t];
  }), r;
}
q("el", (e) => e);
Tr("Focus", "focus", "focus");
Tr("Persist", "persist", "persist");
function Tr(e, t, i) {
  q(t, (n) => U(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${i}`, n));
}
N("modelable", (e, { expression: t }, { effect: i, evaluateLater: n, cleanup: r }) => {
  let s = n(t), o = () => {
    let u;
    return s((d) => u = d), u;
  }, a = n(`${t} = __placeholder`), l = (u) => a(() => {
  }, { scope: { __placeholder: u } }), c = o();
  l(c), queueMicrotask(() => {
    if (!e._x_model)
      return;
    e._x_removeModelListeners.default();
    let u = e._x_model.get, d = e._x_model.set, f = lr(
      {
        get() {
          return u();
        },
        set(y) {
          d(y);
        }
      },
      {
        get() {
          return o();
        },
        set(y) {
          l(y);
        }
      }
    );
    r(f);
  });
});
N("teleport", (e, { modifiers: t, expression: i }, { cleanup: n }) => {
  e.tagName.toLowerCase() !== "template" && U("x-teleport can only be used on a <template> tag", e);
  let r = Ki(i), s = e.content.cloneNode(!0).firstElementChild;
  e._x_teleport = s, s._x_teleportBack = e, e.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), e._x_forwardEvents && e._x_forwardEvents.forEach((a) => {
    s.addEventListener(a, (l) => {
      l.stopPropagation(), e.dispatchEvent(new l.constructor(l.type, l));
    });
  }), Je(s, {}, e);
  let o = (a, l, c) => {
    c.includes("prepend") ? l.parentNode.insertBefore(a, l) : c.includes("append") ? l.parentNode.insertBefore(a, l.nextSibling) : l.appendChild(a);
  };
  $(() => {
    o(s, r, t), ae(() => {
      G(s);
    })();
  }), e._x_teleportPutBack = () => {
    let a = Ki(i);
    $(() => {
      o(e._x_teleport, a, t);
    });
  }, n(
    () => $(() => {
      s.remove(), Ne(s);
    })
  );
});
var fa = document.createElement("div");
function Ki(e) {
  let t = ae(() => document.querySelector(e), () => fa)();
  return t || U(`Cannot find x-teleport element for selector: "${e}"`), t;
}
var Sr = () => {
};
Sr.inline = (e, { modifiers: t }, { cleanup: i }) => {
  t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, i(() => {
    t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore;
  });
};
N("ignore", Sr);
N("effect", ae((e, { expression: t }, { effect: i }) => {
  i(R(e, t));
}));
function ri(e, t, i, n) {
  let r = e, s = (l) => n(l), o = {}, a = (l, c) => (u) => c(l, u);
  if (i.includes("dot") && (t = ha(t)), i.includes("camel") && (t = pa(t)), i.includes("passive") && (o.passive = !0), i.includes("capture") && (o.capture = !0), i.includes("window") && (r = window), i.includes("document") && (r = document), i.includes("debounce")) {
    let l = i[i.indexOf("debounce") + 1] || "invalid-wait", c = ht(l.split("ms")[0]) ? Number(l.split("ms")[0]) : 250;
    s = or(s, c);
  }
  if (i.includes("throttle")) {
    let l = i[i.indexOf("throttle") + 1] || "invalid-wait", c = ht(l.split("ms")[0]) ? Number(l.split("ms")[0]) : 250;
    s = ar(s, c);
  }
  return i.includes("prevent") && (s = a(s, (l, c) => {
    c.preventDefault(), l(c);
  })), i.includes("stop") && (s = a(s, (l, c) => {
    c.stopPropagation(), l(c);
  })), i.includes("once") && (s = a(s, (l, c) => {
    l(c), r.removeEventListener(t, s, o);
  })), (i.includes("away") || i.includes("outside")) && (r = document, s = a(s, (l, c) => {
    e.contains(c.target) || c.target.isConnected !== !1 && (e.offsetWidth < 1 && e.offsetHeight < 1 || e._x_isShown !== !1 && l(c));
  })), i.includes("self") && (s = a(s, (l, c) => {
    c.target === e && l(c);
  })), (ga(t) || Ar(t)) && (s = a(s, (l, c) => {
    va(c, i) || l(c);
  })), r.addEventListener(t, s, o), () => {
    r.removeEventListener(t, s, o);
  };
}
function ha(e) {
  return e.replace(/-/g, ".");
}
function pa(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, i) => i.toUpperCase());
}
function ht(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function ma(e) {
  return [" ", "_"].includes(
    e
  ) ? e : e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function ga(e) {
  return ["keydown", "keyup"].includes(e);
}
function Ar(e) {
  return ["contextmenu", "click", "mouse"].some((t) => e.includes(t));
}
function va(e, t) {
  let i = t.filter((s) => !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(s));
  if (i.includes("debounce")) {
    let s = i.indexOf("debounce");
    i.splice(s, ht((i[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (i.includes("throttle")) {
    let s = i.indexOf("throttle");
    i.splice(s, ht((i[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (i.length === 0 || i.length === 1 && Yi(e.key).includes(i[0]))
    return !1;
  const r = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter((s) => i.includes(s));
  return i = i.filter((s) => !r.includes(s)), !(r.length > 0 && r.filter((o) => ((o === "cmd" || o === "super") && (o = "meta"), e[`${o}Key`])).length === r.length && (Ar(e.type) || Yi(e.key).includes(i[0])));
}
function Yi(e) {
  if (!e)
    return [];
  e = ma(e);
  let t = {
    ctrl: "control",
    slash: "/",
    space: " ",
    spacebar: " ",
    cmd: "meta",
    esc: "escape",
    up: "arrow-up",
    down: "arrow-down",
    left: "arrow-left",
    right: "arrow-right",
    period: ".",
    comma: ",",
    equal: "=",
    minus: "-",
    underscore: "_"
  };
  return t[e] = e, Object.keys(t).map((i) => {
    if (t[i] === e)
      return i;
  }).filter((i) => i);
}
N("model", (e, { modifiers: t, expression: i }, { effect: n, cleanup: r }) => {
  let s = e;
  t.includes("parent") && (s = e.parentNode);
  let o = R(s, i), a;
  typeof i == "string" ? a = R(s, `${i} = __placeholder`) : typeof i == "function" && typeof i() == "string" ? a = R(s, `${i()} = __placeholder`) : a = () => {
  };
  let l = () => {
    let f;
    return o((y) => f = y), Ji(f) ? f.get() : f;
  }, c = (f) => {
    let y;
    o((m) => y = m), Ji(y) ? y.set(f) : a(() => {
    }, {
      scope: { __placeholder: f }
    });
  };
  typeof i == "string" && e.type === "radio" && $(() => {
    e.hasAttribute("name") || e.setAttribute("name", i);
  });
  let u = e.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input", d = re ? () => {
  } : ri(e, u, t, (f) => {
    c(Ft(e, t, f, l()));
  });
  if (t.includes("fill") && ([void 0, null, ""].includes(l()) || Ti(e) && Array.isArray(l()) || e.tagName.toLowerCase() === "select" && e.multiple) && c(
    Ft(e, t, { target: e }, l())
  ), e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = d, r(() => e._x_removeModelListeners.default()), e.form) {
    let f = ri(e.form, "reset", [], (y) => {
      Ii(() => e._x_model && e._x_model.set(Ft(e, t, { target: e }, l())));
    });
    r(() => f());
  }
  e._x_model = {
    get() {
      return l();
    },
    set(f) {
      c(f);
    }
  }, e._x_forceModelUpdate = (f) => {
    f === void 0 && typeof i == "string" && i.match(/\./) && (f = ""), window.fromModel = !0, $(() => tr(e, "value", f)), delete window.fromModel;
  }, n(() => {
    let f = l();
    t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate(f);
  });
});
function Ft(e, t, i, n) {
  return $(() => {
    if (i instanceof CustomEvent && i.detail !== void 0)
      return i.detail !== null && i.detail !== void 0 ? i.detail : i.target.value;
    if (Ti(e))
      if (Array.isArray(n)) {
        let r = null;
        return t.includes("number") ? r = Ut(i.target.value) : t.includes("boolean") ? r = at(i.target.value) : r = i.target.value, i.target.checked ? n.includes(r) ? n : n.concat([r]) : n.filter((s) => !ba(s, r));
      } else
        return i.target.checked;
    else {
      if (e.tagName.toLowerCase() === "select" && e.multiple)
        return t.includes("number") ? Array.from(i.target.selectedOptions).map((r) => {
          let s = r.value || r.text;
          return Ut(s);
        }) : t.includes("boolean") ? Array.from(i.target.selectedOptions).map((r) => {
          let s = r.value || r.text;
          return at(s);
        }) : Array.from(i.target.selectedOptions).map((r) => r.value || r.text);
      {
        let r;
        return sr(e) ? i.target.checked ? r = i.target.value : r = n : r = i.target.value, t.includes("number") ? Ut(r) : t.includes("boolean") ? at(r) : t.includes("trim") ? r.trim() : r;
      }
    }
  });
}
function Ut(e) {
  let t = e ? parseFloat(e) : null;
  return ya(t) ? t : e;
}
function ba(e, t) {
  return e == t;
}
function ya(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function Ji(e) {
  return e !== null && typeof e == "object" && typeof e.get == "function" && typeof e.set == "function";
}
N("cloak", (e) => queueMicrotask(() => $(() => e.removeAttribute(Oe("cloak")))));
Jn(() => `[${Oe("init")}]`);
N("init", ae((e, { expression: t }, { evaluate: i }) => typeof t == "string" ? !!t.trim() && i(t, {}, !1) : i(t, {}, !1)));
N("text", (e, { expression: t }, { effect: i, evaluateLater: n }) => {
  let r = n(t);
  i(() => {
    r((s) => {
      $(() => {
        e.textContent = s;
      });
    });
  });
});
N("html", (e, { expression: t }, { effect: i, evaluateLater: n }) => {
  let r = n(t);
  i(() => {
    r((s) => {
      $(() => {
        e.innerHTML = s, e._x_ignoreSelf = !0, G(e), delete e._x_ignoreSelf;
      });
    });
  });
});
_i(Fn(":", Un(Oe("bind:"))));
var Or = (e, { value: t, modifiers: i, expression: n, original: r }, { effect: s, cleanup: o }) => {
  if (!t) {
    let l = {};
    vo(l), R(e, n)((u) => {
      ur(e, u, r);
    }, { scope: l });
    return;
  }
  if (t === "key")
    return wa(e, n);
  if (e._x_inlineBindings && e._x_inlineBindings[t] && e._x_inlineBindings[t].extract)
    return;
  let a = R(e, n);
  s(() => a((l) => {
    l === void 0 && typeof n == "string" && n.match(/\./) && (l = ""), $(() => tr(e, t, l, i));
  })), o(() => {
    e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedStyles && e._x_undoAddedStyles();
  });
};
Or.inline = (e, { value: t, modifiers: i, expression: n }) => {
  t && (e._x_inlineBindings || (e._x_inlineBindings = {}), e._x_inlineBindings[t] = { expression: n, extract: !1 });
};
N("bind", Or);
function wa(e, t) {
  e._x_keyExpression = t;
}
Yn(() => `[${Oe("data")}]`);
N("data", (e, { expression: t }, { cleanup: i }) => {
  if (_a(e))
    return;
  t = t === "" ? "{}" : t;
  let n = {};
  ut(n, e);
  let r = {};
  yo(r, n);
  let s = he(e, t, { scope: r });
  (s === void 0 || s === !0) && (s = {}), ut(s, e);
  let o = Te(s);
  On(o);
  let a = Je(e, o);
  o.init && he(e, o.init), i(() => {
    o.destroy && he(e, o.destroy), a();
  });
});
Tt((e, t) => {
  e._x_dataStack && (t._x_dataStack = e._x_dataStack, t.setAttribute("data-has-alpine-state", !0));
});
function _a(e) {
  return re ? ei ? !0 : e.hasAttribute("data-has-alpine-state") : !1;
}
N("show", (e, { modifiers: t, expression: i }, { effect: n }) => {
  let r = R(e, i);
  e._x_doHide || (e._x_doHide = () => {
    $(() => {
      e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0);
    });
  }), e._x_doShow || (e._x_doShow = () => {
    $(() => {
      e.style.length === 1 && e.style.display === "none" ? e.removeAttribute("style") : e.style.removeProperty("display");
    });
  });
  let s = () => {
    e._x_doHide(), e._x_isShown = !1;
  }, o = () => {
    e._x_doShow(), e._x_isShown = !0;
  }, a = () => setTimeout(o), l = Xt(
    (d) => d ? o() : s(),
    (d) => {
      typeof e._x_toggleAndCascadeWithTransitions == "function" ? e._x_toggleAndCascadeWithTransitions(e, d, o, s) : d ? a() : s();
    }
  ), c, u = !0;
  n(() => r((d) => {
    !u && d === c || (t.includes("immediate") && (d ? a() : s()), l(d), c = d, u = !1);
  }));
});
N("for", (e, { expression: t }, { effect: i, cleanup: n }) => {
  let r = Ea(t), s = R(e, r.items), o = R(
    e,
    // the x-bind:key expression is stored for our use instead of evaluated.
    e._x_keyExpression || "index"
  );
  e._x_prevKeys = [], e._x_lookup = {}, i(() => xa(e, r, s, o)), n(() => {
    Object.values(e._x_lookup).forEach((a) => $(
      () => {
        Ne(a), a.remove();
      }
    )), delete e._x_prevKeys, delete e._x_lookup;
  });
});
function xa(e, t, i, n) {
  let r = (o) => typeof o == "object" && !Array.isArray(o), s = e;
  i((o) => {
    Ia(o) && o >= 0 && (o = Array.from(Array(o).keys(), (p) => p + 1)), o === void 0 && (o = []);
    let a = e._x_lookup, l = e._x_prevKeys, c = [], u = [];
    if (r(o))
      o = Object.entries(o).map(([p, b]) => {
        let h = Zi(t, b, p, o);
        n((_) => {
          u.includes(_) && U("Duplicate key on x-for", e), u.push(_);
        }, { scope: { index: p, ...h } }), c.push(h);
      });
    else
      for (let p = 0; p < o.length; p++) {
        let b = Zi(t, o[p], p, o);
        n((h) => {
          u.includes(h) && U("Duplicate key on x-for", e), u.push(h);
        }, { scope: { index: p, ...b } }), c.push(b);
      }
    let d = [], f = [], y = [], m = [];
    for (let p = 0; p < l.length; p++) {
      let b = l[p];
      u.indexOf(b) === -1 && y.push(b);
    }
    l = l.filter((p) => !y.includes(p));
    let v = "template";
    for (let p = 0; p < u.length; p++) {
      let b = u[p], h = l.indexOf(b);
      if (h === -1)
        l.splice(p, 0, b), d.push([v, p]);
      else if (h !== p) {
        let _ = l.splice(p, 1)[0], E = l.splice(h - 1, 1)[0];
        l.splice(p, 0, E), l.splice(h, 0, _), f.push([_, E]);
      } else
        m.push(b);
      v = b;
    }
    for (let p = 0; p < y.length; p++) {
      let b = y[p];
      b in a && ($(() => {
        Ne(a[b]), a[b].remove();
      }), delete a[b]);
    }
    for (let p = 0; p < f.length; p++) {
      let [b, h] = f[p], _ = a[b], E = a[h], x = document.createElement("div");
      $(() => {
        E || U('x-for ":key" is undefined or invalid', s, h, a), E.after(x), _.after(E), E._x_currentIfEl && E.after(E._x_currentIfEl), x.before(_), _._x_currentIfEl && _.after(_._x_currentIfEl), x.remove();
      }), E._x_refreshXForScope(c[u.indexOf(h)]);
    }
    for (let p = 0; p < d.length; p++) {
      let [b, h] = d[p], _ = b === "template" ? s : a[b];
      _._x_currentIfEl && (_ = _._x_currentIfEl);
      let E = c[h], x = u[h], g = document.importNode(s.content, !0).firstElementChild, w = Te(E);
      Je(g, w, s), g._x_refreshXForScope = (I) => {
        Object.entries(I).forEach(([C, T]) => {
          w[C] = T;
        });
      }, $(() => {
        _.after(g), ae(() => G(g))();
      }), typeof x == "object" && U("x-for key cannot be an object, it must be a string or an integer", s), a[x] = g;
    }
    for (let p = 0; p < m.length; p++)
      a[m[p]]._x_refreshXForScope(c[u.indexOf(m[p])]);
    s._x_prevKeys = u;
  });
}
function Ea(e) {
  let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, i = /^\s*\(|\)\s*$/g, n = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, r = e.match(n);
  if (!r)
    return;
  let s = {};
  s.items = r[2].trim();
  let o = r[1].replace(i, "").trim(), a = o.match(t);
  return a ? (s.item = o.replace(t, "").trim(), s.index = a[1].trim(), a[2] && (s.collection = a[2].trim())) : s.item = o, s;
}
function Zi(e, t, i, n) {
  let r = {};
  return /^\[.*\]$/.test(e.item) && Array.isArray(t) ? e.item.replace("[", "").replace("]", "").split(",").map((o) => o.trim()).forEach((o, a) => {
    r[o] = t[a];
  }) : /^\{.*\}$/.test(e.item) && !Array.isArray(t) && typeof t == "object" ? e.item.replace("{", "").replace("}", "").split(",").map((o) => o.trim()).forEach((o) => {
    r[o] = t[o];
  }) : r[e.item] = t, e.index && (r[e.index] = i), e.collection && (r[e.collection] = n), r;
}
function Ia(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function $r() {
}
$r.inline = (e, { expression: t }, { cleanup: i }) => {
  let n = It(e);
  n._x_refs || (n._x_refs = {}), n._x_refs[t] = e, i(() => delete n._x_refs[t]);
};
N("ref", $r);
N("if", (e, { expression: t }, { effect: i, cleanup: n }) => {
  e.tagName.toLowerCase() !== "template" && U("x-if can only be used on a <template> tag", e);
  let r = R(e, t), s = () => {
    if (e._x_currentIfEl)
      return e._x_currentIfEl;
    let a = e.content.cloneNode(!0).firstElementChild;
    return Je(a, {}, e), $(() => {
      e.after(a), ae(() => G(a))();
    }), e._x_currentIfEl = a, e._x_undoIf = () => {
      $(() => {
        Ne(a), a.remove();
      }), delete e._x_currentIfEl;
    }, a;
  }, o = () => {
    e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf);
  };
  i(() => r((a) => {
    a ? s() : o();
  })), n(() => e._x_undoIf && e._x_undoIf());
});
N("id", (e, { expression: t }, { evaluate: i }) => {
  i(t).forEach((r) => ua(e, r));
});
Tt((e, t) => {
  e._x_ids && (t._x_ids = e._x_ids);
});
_i(Fn("@", Un(Oe("on:"))));
N("on", ae((e, { value: t, modifiers: i, expression: n }, { cleanup: r }) => {
  let s = n ? R(e, n) : () => {
  };
  e.tagName.toLowerCase() === "template" && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t));
  let o = ri(e, t, i, (a) => {
    s(() => {
    }, { scope: { $event: a }, params: [a] });
  });
  r(() => o());
}));
$t("Collapse", "collapse", "collapse");
$t("Intersect", "intersect", "intersect");
$t("Focus", "trap", "focus");
$t("Mask", "mask", "mask");
function $t(e, t, i) {
  N(t, (n) => U(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${i}`, n));
}
Ze.setEvaluator(Co);
Ze.setReactivityEngine({ reactive: Ri, effect: Do, release: Mo, raw: O });
var Ca = Ze, Nr = Ca;
function Ta(e) {
  e.directive("collapse", t), t.inline = (i, { modifiers: n }) => {
    n.includes("min") && (i._x_doShow = () => {
    }, i._x_doHide = () => {
    });
  };
  function t(i, { modifiers: n }) {
    let r = Gi(n, "duration", 250) / 1e3, s = Gi(n, "min", 0), o = !n.includes("min");
    i._x_isShown || (i.style.height = `${s}px`), !i._x_isShown && o && (i.hidden = !0), i._x_isShown || (i.style.overflow = "hidden");
    let a = (c, u) => {
      let d = e.setStyles(c, u);
      return u.height ? () => {
      } : d;
    }, l = {
      transitionProperty: "height",
      transitionDuration: `${r}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    i._x_transition = {
      in(c = () => {
      }, u = () => {
      }) {
        o && (i.hidden = !1), o && (i.style.display = null);
        let d = i.getBoundingClientRect().height;
        i.style.height = "auto";
        let f = i.getBoundingClientRect().height;
        d === f && (d = s), e.transition(i, e.setStyles, {
          during: l,
          start: { height: d + "px" },
          end: { height: f + "px" }
        }, () => i._x_isShown = !0, () => {
          Math.abs(i.getBoundingClientRect().height - f) < 1 && (i.style.overflow = null);
        });
      },
      out(c = () => {
      }, u = () => {
      }) {
        let d = i.getBoundingClientRect().height;
        e.transition(i, a, {
          during: l,
          start: { height: d + "px" },
          end: { height: s + "px" }
        }, () => i.style.overflow = "hidden", () => {
          i._x_isShown = !1, i.style.height == `${s}px` && o && (i.style.display = "none", i.hidden = !0);
        });
      }
    };
  }
}
function Gi(e, t, i) {
  if (e.indexOf(t) === -1)
    return i;
  const n = e[e.indexOf(t) + 1];
  if (!n)
    return i;
  if (t === "duration") {
    let r = n.match(/([0-9]+)ms/);
    if (r)
      return r[1];
  }
  if (t === "min") {
    let r = n.match(/([0-9]+)px/);
    if (r)
      return r[1];
  }
  return n;
}
var Sa = Ta;
function Aa(e) {
  e.directive("intersect", e.skipDuringClone((t, { value: i, expression: n, modifiers: r }, { evaluateLater: s, cleanup: o }) => {
    let a = s(n), l = {
      rootMargin: Na(r),
      threshold: Oa(r)
    }, c = new IntersectionObserver((u) => {
      u.forEach((d) => {
        d.isIntersecting !== (i === "leave") && (a(), r.includes("once") && c.disconnect());
      });
    }, l);
    c.observe(t), o(() => {
      c.disconnect();
    });
  }));
}
function Oa(e) {
  if (e.includes("full"))
    return 0.99;
  if (e.includes("half"))
    return 0.5;
  if (!e.includes("threshold"))
    return 0;
  let t = e[e.indexOf("threshold") + 1];
  return t === "100" ? 1 : t === "0" ? 0 : +`.${t}`;
}
function $a(e) {
  let t = e.match(/^(-?[0-9]+)(px|%)?$/);
  return t ? t[1] + (t[2] || "px") : void 0;
}
function Na(e) {
  const t = "margin", i = "0px 0px 0px 0px", n = e.indexOf(t);
  if (n === -1)
    return i;
  let r = [];
  for (let s = 1; s < 5; s++)
    r.push($a(e[n + s] || ""));
  return r = r.filter((s) => s !== void 0), r.length ? r.join(" ").trim() : i;
}
var ka = Aa, kr = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], pt = /* @__PURE__ */ kr.join(","), Rr = typeof Element > "u", ye = Rr ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, si = !Rr && Element.prototype.getRootNode ? function(e) {
  return e.getRootNode();
} : function(e) {
  return e.ownerDocument;
}, Lr = function(t, i, n) {
  var r = Array.prototype.slice.apply(t.querySelectorAll(pt));
  return i && ye.call(t, pt) && r.unshift(t), r = r.filter(n), r;
}, Pr = function e(t, i, n) {
  for (var r = [], s = Array.from(t); s.length; ) {
    var o = s.shift();
    if (o.tagName === "SLOT") {
      var a = o.assignedElements(), l = a.length ? a : o.children, c = e(l, !0, n);
      n.flatten ? r.push.apply(r, c) : r.push({
        scope: o,
        candidates: c
      });
    } else {
      var u = ye.call(o, pt);
      u && n.filter(o) && (i || !t.includes(o)) && r.push(o);
      var d = o.shadowRoot || // check for an undisclosed shadow
      typeof n.getShadowRoot == "function" && n.getShadowRoot(o), f = !n.shadowRootFilter || n.shadowRootFilter(o);
      if (d && f) {
        var y = e(d === !0 ? o.children : d.children, !0, n);
        n.flatten ? r.push.apply(r, y) : r.push({
          scope: o,
          candidates: y
        });
      } else
        s.unshift.apply(s, o.children);
    }
  }
  return r;
}, Dr = function(t, i) {
  return t.tabIndex < 0 && (i || /^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || t.isContentEditable) && isNaN(parseInt(t.getAttribute("tabindex"), 10)) ? 0 : t.tabIndex;
}, Ra = function(t, i) {
  return t.tabIndex === i.tabIndex ? t.documentOrder - i.documentOrder : t.tabIndex - i.tabIndex;
}, Mr = function(t) {
  return t.tagName === "INPUT";
}, La = function(t) {
  return Mr(t) && t.type === "hidden";
}, Pa = function(t) {
  var i = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return i;
}, Da = function(t, i) {
  for (var n = 0; n < t.length; n++)
    if (t[n].checked && t[n].form === i)
      return t[n];
}, Ma = function(t) {
  if (!t.name)
    return !0;
  var i = t.form || si(t), n = function(a) {
    return i.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, r;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    r = n(window.CSS.escape(t.name));
  else
    try {
      r = n(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var s = Da(r, t.form);
  return !s || s === t;
}, za = function(t) {
  return Mr(t) && t.type === "radio";
}, Fa = function(t) {
  return za(t) && !Ma(t);
}, Xi = function(t) {
  var i = t.getBoundingClientRect(), n = i.width, r = i.height;
  return n === 0 && r === 0;
}, Ua = function(t, i) {
  var n = i.displayCheck, r = i.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var s = ye.call(t, "details>summary:first-of-type"), o = s ? t.parentElement : t;
  if (ye.call(o, "details:not([open]) *"))
    return !0;
  var a = si(t).host, l = a?.ownerDocument.contains(a) || t.ownerDocument.contains(t);
  if (!n || n === "full") {
    if (typeof r == "function") {
      for (var c = t; t; ) {
        var u = t.parentElement, d = si(t);
        if (u && !u.shadowRoot && r(u) === !0)
          return Xi(t);
        t.assignedSlot ? t = t.assignedSlot : !u && d !== t.ownerDocument ? t = d.host : t = u;
      }
      t = c;
    }
    if (l)
      return !t.getClientRects().length;
  } else if (n === "non-zero-area")
    return Xi(t);
  return !1;
}, Ba = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var i = t.parentElement; i; ) {
      if (i.tagName === "FIELDSET" && i.disabled) {
        for (var n = 0; n < i.children.length; n++) {
          var r = i.children.item(n);
          if (r.tagName === "LEGEND")
            return ye.call(i, "fieldset[disabled] *") ? !0 : !r.contains(t);
        }
        return !0;
      }
      i = i.parentElement;
    }
  return !1;
}, mt = function(t, i) {
  return !(i.disabled || La(i) || Ua(i, t) || // For a details element with a summary, the summary element gets the focus
  Pa(i) || Ba(i));
}, oi = function(t, i) {
  return !(Fa(i) || Dr(i) < 0 || !mt(t, i));
}, ja = function(t) {
  var i = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(i) || i >= 0);
}, Va = function e(t) {
  var i = [], n = [];
  return t.forEach(function(r, s) {
    var o = !!r.scope, a = o ? r.scope : r, l = Dr(a, o), c = o ? e(r.candidates) : a;
    l === 0 ? o ? i.push.apply(i, c) : i.push(a) : n.push({
      documentOrder: s,
      tabIndex: l,
      item: r,
      isScope: o,
      content: c
    });
  }), n.sort(Ra).reduce(function(r, s) {
    return s.isScope ? r.push.apply(r, s.content) : r.push(s.content), r;
  }, []).concat(i);
}, Wa = function(t, i) {
  i = i || {};
  var n;
  return i.getShadowRoot ? n = Pr([t], i.includeContainer, {
    filter: oi.bind(null, i),
    flatten: !1,
    getShadowRoot: i.getShadowRoot,
    shadowRootFilter: ja
  }) : n = Lr(t, i.includeContainer, oi.bind(null, i)), Va(n);
}, zr = function(t, i) {
  i = i || {};
  var n;
  return i.getShadowRoot ? n = Pr([t], i.includeContainer, {
    filter: mt.bind(null, i),
    flatten: !0,
    getShadowRoot: i.getShadowRoot
  }) : n = Lr(t, i.includeContainer, mt.bind(null, i)), n;
}, nt = function(t, i) {
  if (i = i || {}, !t)
    throw new Error("No node provided");
  return ye.call(t, pt) === !1 ? !1 : oi(i, t);
}, qa = /* @__PURE__ */ kr.concat("iframe").join(","), lt = function(t, i) {
  if (i = i || {}, !t)
    throw new Error("No node provided");
  return ye.call(t, qa) === !1 ? !1 : mt(i, t);
};
function Qi(e, t) {
  var i = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function en(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qi(Object(i), !0).forEach(function(n) {
      Ha(e, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Qi(Object(i)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return e;
}
function Ha(e, t, i) {
  return t in e ? Object.defineProperty(e, t, {
    value: i,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = i, e;
}
var tn = /* @__PURE__ */ function() {
  var e = [];
  return {
    activateTrap: function(i) {
      if (e.length > 0) {
        var n = e[e.length - 1];
        n !== i && n.pause();
      }
      var r = e.indexOf(i);
      r === -1 || e.splice(r, 1), e.push(i);
    },
    deactivateTrap: function(i) {
      var n = e.indexOf(i);
      n !== -1 && e.splice(n, 1), e.length > 0 && e[e.length - 1].unpause();
    }
  };
}(), Ka = function(t) {
  return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function";
}, Ya = function(t) {
  return t.key === "Escape" || t.key === "Esc" || t.keyCode === 27;
}, Ja = function(t) {
  return t.key === "Tab" || t.keyCode === 9;
}, nn = function(t) {
  return setTimeout(t, 0);
}, rn = function(t, i) {
  var n = -1;
  return t.every(function(r, s) {
    return i(r) ? (n = s, !1) : !0;
  }), n;
}, De = function(t) {
  for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), r = 1; r < i; r++)
    n[r - 1] = arguments[r];
  return typeof t == "function" ? t.apply(void 0, n) : t;
}, rt = function(t) {
  return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target;
}, Za = function(t, i) {
  var n = i?.document || document, r = en({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0
  }, i), s = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  }, o, a = function(g, w, I) {
    return g && g[w] !== void 0 ? g[w] : r[I || w];
  }, l = function(g) {
    return s.containerGroups.findIndex(function(w) {
      var I = w.container, C = w.tabbableNodes;
      return I.contains(g) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      C.find(function(T) {
        return T === g;
      });
    });
  }, c = function(g) {
    var w = r[g];
    if (typeof w == "function") {
      for (var I = arguments.length, C = new Array(I > 1 ? I - 1 : 0), T = 1; T < I; T++)
        C[T - 1] = arguments[T];
      w = w.apply(void 0, C);
    }
    if (w === !0 && (w = void 0), !w) {
      if (w === void 0 || w === !1)
        return w;
      throw new Error("`".concat(g, "` was specified but was not a node, or did not return a node"));
    }
    var S = w;
    if (typeof w == "string" && (S = n.querySelector(w), !S))
      throw new Error("`".concat(g, "` as selector refers to no known node"));
    return S;
  }, u = function() {
    var g = c("initialFocus");
    if (g === !1)
      return !1;
    if (g === void 0)
      if (l(n.activeElement) >= 0)
        g = n.activeElement;
      else {
        var w = s.tabbableGroups[0], I = w && w.firstTabbableNode;
        g = I || c("fallbackFocus");
      }
    if (!g)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return g;
  }, d = function() {
    if (s.containerGroups = s.containers.map(function(g) {
      var w = Wa(g, r.tabbableOptions), I = zr(g, r.tabbableOptions);
      return {
        container: g,
        tabbableNodes: w,
        focusableNodes: I,
        firstTabbableNode: w.length > 0 ? w[0] : null,
        lastTabbableNode: w.length > 0 ? w[w.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(T) {
          var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, L = I.findIndex(function(P) {
            return P === T;
          });
          if (!(L < 0))
            return S ? I.slice(L + 1).find(function(P) {
              return nt(P, r.tabbableOptions);
            }) : I.slice(0, L).reverse().find(function(P) {
              return nt(P, r.tabbableOptions);
            });
        }
      };
    }), s.tabbableGroups = s.containerGroups.filter(function(g) {
      return g.tabbableNodes.length > 0;
    }), s.tabbableGroups.length <= 0 && !c("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
  }, f = function x(g) {
    if (g !== !1 && g !== n.activeElement) {
      if (!g || !g.focus) {
        x(u());
        return;
      }
      g.focus({
        preventScroll: !!r.preventScroll
      }), s.mostRecentlyFocusedNode = g, Ka(g) && g.select();
    }
  }, y = function(g) {
    var w = c("setReturnFocus", g);
    return w || (w === !1 ? !1 : g);
  }, m = function(g) {
    var w = rt(g);
    if (!(l(w) >= 0)) {
      if (De(r.clickOutsideDeactivates, g)) {
        o.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: r.returnFocusOnDeactivate && !lt(w, r.tabbableOptions)
        });
        return;
      }
      De(r.allowOutsideClick, g) || g.preventDefault();
    }
  }, v = function(g) {
    var w = rt(g), I = l(w) >= 0;
    I || w instanceof Document ? I && (s.mostRecentlyFocusedNode = w) : (g.stopImmediatePropagation(), f(s.mostRecentlyFocusedNode || u()));
  }, p = function(g) {
    var w = rt(g);
    d();
    var I = null;
    if (s.tabbableGroups.length > 0) {
      var C = l(w), T = C >= 0 ? s.containerGroups[C] : void 0;
      if (C < 0)
        g.shiftKey ? I = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : I = s.tabbableGroups[0].firstTabbableNode;
      else if (g.shiftKey) {
        var S = rn(s.tabbableGroups, function(B) {
          var F = B.firstTabbableNode;
          return w === F;
        });
        if (S < 0 && (T.container === w || lt(w, r.tabbableOptions) && !nt(w, r.tabbableOptions) && !T.nextTabbableNode(w, !1)) && (S = C), S >= 0) {
          var L = S === 0 ? s.tabbableGroups.length - 1 : S - 1, P = s.tabbableGroups[L];
          I = P.lastTabbableNode;
        }
      } else {
        var H = rn(s.tabbableGroups, function(B) {
          var F = B.lastTabbableNode;
          return w === F;
        });
        if (H < 0 && (T.container === w || lt(w, r.tabbableOptions) && !nt(w, r.tabbableOptions) && !T.nextTabbableNode(w)) && (H = C), H >= 0) {
          var z = H === s.tabbableGroups.length - 1 ? 0 : H + 1, le = s.tabbableGroups[z];
          I = le.firstTabbableNode;
        }
      }
    } else
      I = c("fallbackFocus");
    I && (g.preventDefault(), f(I));
  }, b = function(g) {
    if (Ya(g) && De(r.escapeDeactivates, g) !== !1) {
      g.preventDefault(), o.deactivate();
      return;
    }
    if (Ja(g)) {
      p(g);
      return;
    }
  }, h = function(g) {
    var w = rt(g);
    l(w) >= 0 || De(r.clickOutsideDeactivates, g) || De(r.allowOutsideClick, g) || (g.preventDefault(), g.stopImmediatePropagation());
  }, _ = function() {
    if (s.active)
      return tn.activateTrap(o), s.delayInitialFocusTimer = r.delayInitialFocus ? nn(function() {
        f(u());
      }) : f(u()), n.addEventListener("focusin", v, !0), n.addEventListener("mousedown", m, {
        capture: !0,
        passive: !1
      }), n.addEventListener("touchstart", m, {
        capture: !0,
        passive: !1
      }), n.addEventListener("click", h, {
        capture: !0,
        passive: !1
      }), n.addEventListener("keydown", b, {
        capture: !0,
        passive: !1
      }), o;
  }, E = function() {
    if (s.active)
      return n.removeEventListener("focusin", v, !0), n.removeEventListener("mousedown", m, !0), n.removeEventListener("touchstart", m, !0), n.removeEventListener("click", h, !0), n.removeEventListener("keydown", b, !0), o;
  };
  return o = {
    get active() {
      return s.active;
    },
    get paused() {
      return s.paused;
    },
    activate: function(g) {
      if (s.active)
        return this;
      var w = a(g, "onActivate"), I = a(g, "onPostActivate"), C = a(g, "checkCanFocusTrap");
      C || d(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = n.activeElement, w && w();
      var T = function() {
        C && d(), _(), I && I();
      };
      return C ? (C(s.containers.concat()).then(T, T), this) : (T(), this);
    },
    deactivate: function(g) {
      if (!s.active)
        return this;
      var w = en({
        onDeactivate: r.onDeactivate,
        onPostDeactivate: r.onPostDeactivate,
        checkCanReturnFocus: r.checkCanReturnFocus
      }, g);
      clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, E(), s.active = !1, s.paused = !1, tn.deactivateTrap(o);
      var I = a(w, "onDeactivate"), C = a(w, "onPostDeactivate"), T = a(w, "checkCanReturnFocus"), S = a(w, "returnFocus", "returnFocusOnDeactivate");
      I && I();
      var L = function() {
        nn(function() {
          S && f(y(s.nodeFocusedBeforeActivation)), C && C();
        });
      };
      return S && T ? (T(y(s.nodeFocusedBeforeActivation)).then(L, L), this) : (L(), this);
    },
    pause: function() {
      return s.paused || !s.active ? this : (s.paused = !0, E(), this);
    },
    unpause: function() {
      return !s.paused || !s.active ? this : (s.paused = !1, d(), _(), this);
    },
    updateContainerElements: function(g) {
      var w = [].concat(g).filter(Boolean);
      return s.containers = w.map(function(I) {
        return typeof I == "string" ? n.querySelector(I) : I;
      }), s.active && d(), this;
    }
  }, o.updateContainerElements(t), o;
};
function Ga(e) {
  let t, i;
  window.addEventListener("focusin", () => {
    t = i, i = document.activeElement;
  }), e.magic("focus", (n) => {
    let r = n;
    return {
      __noscroll: !1,
      __wrapAround: !1,
      within(s) {
        return r = s, this;
      },
      withoutScrolling() {
        return this.__noscroll = !0, this;
      },
      noscroll() {
        return this.__noscroll = !0, this;
      },
      withWrapAround() {
        return this.__wrapAround = !0, this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(s) {
        return lt(s);
      },
      previouslyFocused() {
        return t;
      },
      lastFocused() {
        return t;
      },
      focused() {
        return i;
      },
      focusables() {
        return Array.isArray(r) ? r : zr(r, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(s) {
        let o = this.all();
        return o[0] && o[0].isSameNode(s);
      },
      isLast(s) {
        let o = this.all();
        return o.length && o.slice(-1)[0].isSameNode(s);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let s = this.all(), o = document.activeElement;
        if (s.indexOf(o) !== -1)
          return this.__wrapAround && s.indexOf(o) === s.length - 1 ? s[0] : s[s.indexOf(o) + 1];
      },
      getPrevious() {
        let s = this.all(), o = document.activeElement;
        if (s.indexOf(o) !== -1)
          return this.__wrapAround && s.indexOf(o) === 0 ? s.slice(-1)[0] : s[s.indexOf(o) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(s) {
        s && setTimeout(() => {
          s.hasAttribute("tabindex") || s.setAttribute("tabindex", "0"), s.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  }), e.directive("trap", e.skipDuringClone(
    (n, { expression: r, modifiers: s }, { effect: o, evaluateLater: a, cleanup: l }) => {
      let c = a(r), u = !1, d = {
        escapeDeactivates: !1,
        allowOutsideClick: !0,
        fallbackFocus: () => n
      }, f = () => {
      };
      if (s.includes("noautofocus"))
        d.initialFocus = !1;
      else {
        let p = n.querySelector("[autofocus]");
        p && (d.initialFocus = p);
      }
      s.includes("inert") && (d.onPostActivate = () => {
        e.nextTick(() => {
          f = sn(n);
        });
      });
      let y = Za(n, d), m = () => {
      };
      const v = () => {
        f(), f = () => {
        }, m(), m = () => {
        }, y.deactivate({
          returnFocus: !s.includes("noreturn")
        });
      };
      o(() => c((p) => {
        u !== p && (p && !u && (s.includes("noscroll") && (m = Xa()), setTimeout(() => {
          y.activate();
        }, 15)), !p && u && v(), u = !!p);
      })), l(v);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (n, { expression: r, modifiers: s }, { evaluate: o }) => {
      s.includes("inert") && o(r) && sn(n);
    }
  ));
}
function sn(e) {
  let t = [];
  return Fr(e, (i) => {
    let n = i.hasAttribute("aria-hidden");
    i.setAttribute("aria-hidden", "true"), t.push(() => n || i.removeAttribute("aria-hidden"));
  }), () => {
    for (; t.length; )
      t.pop()();
  };
}
function Fr(e, t) {
  e.isSameNode(document.body) || !e.parentNode || Array.from(e.parentNode.children).forEach((i) => {
    i.isSameNode(e) ? Fr(e.parentNode, t) : t(i);
  });
}
function Xa() {
  let e = document.documentElement.style.overflow, t = document.documentElement.style.paddingRight, i = window.innerWidth - document.documentElement.clientWidth;
  return document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${i}px`, () => {
    document.documentElement.style.overflow = e, document.documentElement.style.paddingRight = t;
  };
}
var Qa = Ga;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function el() {
  return !0;
}
function tl({ component: e, argument: t }) {
  return new Promise((i) => {
    if (t)
      window.addEventListener(
        t,
        () => i(),
        { once: !0 }
      );
    else {
      const n = (r) => {
        r.detail.id === e.id && (window.removeEventListener("async-alpine:load", n), i());
      };
      window.addEventListener("async-alpine:load", n);
    }
  });
}
function il() {
  return new Promise((e) => {
    "requestIdleCallback" in window ? window.requestIdleCallback(e) : setTimeout(e, 200);
  });
}
function nl({ argument: e }) {
  return new Promise((t) => {
    if (!e)
      return console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'"), t();
    const i = window.matchMedia(`(${e})`);
    i.matches ? t() : i.addEventListener("change", t, { once: !0 });
  });
}
function rl({ component: e, argument: t }) {
  return new Promise((i) => {
    const n = t || "0px 0px 0px 0px", r = new IntersectionObserver((s) => {
      s[0].isIntersecting && (r.disconnect(), i());
    }, { rootMargin: n });
    r.observe(e.el);
  });
}
var on = {
  eager: el,
  event: tl,
  idle: il,
  media: nl,
  visible: rl
};
async function sl(e) {
  const t = ol(e.strategy);
  await ai(e, t);
}
async function ai(e, t) {
  if (t.type === "expression") {
    if (t.operator === "&&")
      return Promise.all(
        t.parameters.map((i) => ai(e, i))
      );
    if (t.operator === "||")
      return Promise.any(
        t.parameters.map((i) => ai(e, i))
      );
  }
  return on[t.method] ? on[t.method]({
    component: e,
    argument: t.argument
  }) : !1;
}
function ol(e) {
  const t = al(e);
  let i = Ur(t);
  return i.type === "method" ? {
    type: "expression",
    operator: "&&",
    parameters: [i]
  } : i;
}
function al(e) {
  const t = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g, i = [];
  let n;
  for (; (n = t.exec(e)) !== null; ) {
    const [r, s, o, a] = n;
    if (s !== void 0)
      i.push({ type: "parenthesis", value: s });
    else if (o !== void 0)
      i.push({
        type: "operator",
        // we do the below to make operators backwards-compatible with previous
        // versions of Async Alpine, where '|' is equivalent to &&
        value: o === "|" ? "&&" : o
      });
    else {
      const l = {
        type: "method",
        method: a.trim()
      };
      a.includes("(") && (l.method = a.substring(0, a.indexOf("(")).trim(), l.argument = a.substring(
        a.indexOf("(") + 1,
        a.indexOf(")")
      )), a.method === "immediate" && (a.method = "eager"), i.push(l);
    }
  }
  return i;
}
function Ur(e) {
  let t = an(e);
  for (; e.length > 0 && (e[0].value === "&&" || e[0].value === "|" || e[0].value === "||"); ) {
    const i = e.shift().value, n = an(e);
    t.type === "expression" && t.operator === i ? t.parameters.push(n) : t = {
      type: "expression",
      operator: i,
      parameters: [t, n]
    };
  }
  return t;
}
function an(e) {
  if (e[0].value === "(") {
    e.shift();
    const t = Ur(e);
    return e[0].value === ")" && e.shift(), t;
  } else
    return e.shift();
}
function ll(e) {
  const t = "load", i = e.prefixed("load-src"), n = e.prefixed("ignore");
  let r = {
    defaultStrategy: "eager",
    keepRelativeURLs: !1
  }, s = !1, o = {}, a = 0;
  function l() {
    return a++;
  }
  e.asyncOptions = (h) => {
    r = {
      ...r,
      ...h
    };
  }, e.asyncData = (h, _ = !1) => {
    o[h] = {
      loaded: !1,
      download: _
    };
  }, e.asyncUrl = (h, _) => {
    !h || !_ || o[h] || (o[h] = {
      loaded: !1,
      download: () => import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        b(_)
      )
    });
  }, e.asyncAlias = (h) => {
    s = h;
  };
  const c = (h) => {
    e.skipDuringClone(() => {
      h._x_async || (h._x_async = "init", h._x_ignore = !0, h.setAttribute(n, ""));
    })();
  }, u = async (h) => {
    e.skipDuringClone(async () => {
      if (h._x_async !== "init") return;
      h._x_async = "await";
      const { name: _, strategy: E } = d(h);
      await sl({
        name: _,
        strategy: E,
        el: h,
        id: h.id || l()
      }), h.isConnected && (await f(_), h.isConnected && (m(h), h._x_async = "loaded"));
    })();
  };
  u.inline = c, e.directive(t, u).before("ignore");
  function d(h) {
    const _ = p(h.getAttribute(e.prefixed("data"))), E = h.getAttribute(e.prefixed(t)) || r.defaultStrategy, x = h.getAttribute(i);
    return x && e.asyncUrl(_, x), {
      name: _,
      strategy: E
    };
  }
  async function f(h) {
    if (h.startsWith("_x_async_") || (v(h), !o[h] || o[h].loaded)) return;
    const _ = await y(h);
    e.data(h, _), o[h].loaded = !0;
  }
  async function y(h) {
    if (!o[h]) return;
    const _ = await o[h].download(h);
    return typeof _ == "function" ? _ : _[h] || _.default || Object.values(_)[0] || !1;
  }
  function m(h) {
    e.destroyTree(h), h._x_ignore = !1, h.removeAttribute(n), !h.closest(`[${n}]`) && e.initTree(h);
  }
  function v(h) {
    if (!(!s || o[h])) {
      if (typeof s == "function") {
        e.asyncData(h, s);
        return;
      }
      e.asyncUrl(h, s.replaceAll("[name]", h));
    }
  }
  function p(h) {
    return (h || "").trim().split(/[({]/g)[0] || `_x_async_${l()}`;
  }
  function b(h) {
    return r.keepRelativeURLs || new RegExp("^(?:[a-z+]+:)?//", "i").test(h) ? h : new URL(h, document.baseURI).href;
  }
}
function cl(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ul(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function dl(e, t, i) {
  return t && ul(e.prototype, t), e;
}
var fl = Object.defineProperty, X = function(e, t) {
  return fl(e, "name", { value: t, configurable: !0 });
}, hl = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`, pl = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`, ml = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, gl = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, vl = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`, bl = X(function(e) {
  return new DOMParser().parseFromString(e, "text/html").body.childNodes[0];
}, "stringToHTML"), Me = X(function(e) {
  var t = new DOMParser().parseFromString(e, "application/xml");
  return document.importNode(t.documentElement, !0).outerHTML;
}, "getSvgNode"), A = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, ie = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, ln = { OUTLINE: "outline", FILLED: "filled" }, Bt = { FADE: "fade", SLIDE: "slide" }, ze = { CLOSE: Me(hl), SUCCESS: Me(gl), ERROR: Me(pl), WARNING: Me(vl), INFO: Me(ml) }, cn = X(function(e) {
  e.wrapper.classList.add(A.NOTIFY_FADE), setTimeout(function() {
    e.wrapper.classList.add(A.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), un = X(function(e) {
  e.wrapper.classList.remove(A.NOTIFY_FADE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "fadeOut"), yl = X(function(e) {
  e.wrapper.classList.add(A.NOTIFY_SLIDE), setTimeout(function() {
    e.wrapper.classList.add(A.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), wl = X(function(e) {
  e.wrapper.classList.remove(A.NOTIFY_SLIDE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "slideOut"), Br = function() {
  function e(t) {
    var i = this;
    cl(this, e), this.notifyOut = X(function(B) {
      B(i);
    }, "notifyOut");
    var n = t.notificationsGap, r = n === void 0 ? 20 : n, s = t.notificationsPadding, o = s === void 0 ? 20 : s, a = t.status, l = a === void 0 ? "success" : a, c = t.effect, u = c === void 0 ? Bt.FADE : c, d = t.type, f = d === void 0 ? "outline" : d, y = t.title, m = t.text, v = t.showIcon, p = v === void 0 ? !0 : v, b = t.customIcon, h = b === void 0 ? "" : b, _ = t.customClass, E = _ === void 0 ? "" : _, x = t.speed, g = x === void 0 ? 500 : x, w = t.showCloseButton, I = w === void 0 ? !0 : w, C = t.autoclose, T = C === void 0 ? !0 : C, S = t.autotimeout, L = S === void 0 ? 3e3 : S, P = t.position, H = P === void 0 ? "right top" : P, z = t.customWrapper, le = z === void 0 ? "" : z;
    if (this.customWrapper = le, this.status = l, this.title = y, this.text = m, this.showIcon = p, this.customIcon = h, this.customClass = E, this.speed = g, this.effect = u, this.showCloseButton = I, this.autoclose = T, this.autotimeout = L, this.notificationsGap = r, this.notificationsPadding = o, this.type = f, this.position = H, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  return dl(e, [{ key: "checkRequirements", value: function() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function() {
    var i = document.querySelector(".".concat(A.CONTAINER));
    i ? this.container = i : (this.container = document.createElement("div"), this.container.classList.add(A.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function() {
    this.container.classList[this.position === "center" ? "add" : "remove"](A.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](A.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](A.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](A.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](A.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](A.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](A.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function() {
    var i = this, n = document.createElement("div");
    n.classList.add(A.NOTIFY_CLOSE), n.innerHTML = ze.CLOSE, this.wrapper.appendChild(n), n.addEventListener("click", function() {
      i.close();
    });
  } }, { key: "setWrapper", value: function() {
    var i = this;
    switch (this.customWrapper ? this.wrapper = bl(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(A.NOTIFY), this.type) {
      case ln.OUTLINE:
        this.wrapper.classList.add(A.NOTIFY_OUTLINE);
        break;
      case ln.FILLED:
        this.wrapper.classList.add(A.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(A.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case ie.SUCCESS:
        this.wrapper.classList.add(A.NOTIFY_SUCCESS);
        break;
      case ie.ERROR:
        this.wrapper.classList.add(A.NOTIFY_ERROR);
        break;
      case ie.WARNING:
        this.wrapper.classList.add(A.NOTIFY_WARNING);
        break;
      case ie.INFO:
        this.wrapper.classList.add(A.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(A.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(n) {
      i.wrapper.classList.add(n);
    });
  } }, { key: "setContent", value: function() {
    var i = document.createElement("div");
    i.classList.add(A.NOTIFY_CONTENT);
    var n, r;
    this.title && (n = document.createElement("div"), n.classList.add(A.NOTIFY_TITLE), n.textContent = this.title.trim(), this.showCloseButton || (n.style.paddingRight = "0")), this.text && (r = document.createElement("div"), r.classList.add(A.NOTIFY_TEXT), r.innerHTML = this.text.trim(), this.title || (r.style.marginTop = "0")), this.wrapper.appendChild(i), this.title && i.appendChild(n), this.text && i.appendChild(r);
  } }, { key: "setIcon", value: function() {
    var i = X(function(r) {
      switch (r) {
        case ie.SUCCESS:
          return ze.SUCCESS;
        case ie.ERROR:
          return ze.ERROR;
        case ie.WARNING:
          return ze.WARNING;
        case ie.INFO:
          return ze.INFO;
      }
    }, "computedIcon"), n = document.createElement("div");
    n.classList.add(A.NOTIFY_ICON), n.innerHTML = this.customIcon || i(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(n);
  } }, { key: "setObserver", value: function() {
    var i = this, n = new IntersectionObserver(function(r) {
      if (r[0].intersectionRatio <= 0) i.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      n.observe(i.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function(t) {
    t(this);
  } }, { key: "autoClose", value: function() {
    var i = this;
    setTimeout(function() {
      i.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function() {
    switch (this.effect) {
      case Bt.FADE:
        this.selectedNotifyInEffect = cn, this.selectedNotifyOutEffect = un;
        break;
      case Bt.SLIDE:
        this.selectedNotifyInEffect = yl, this.selectedNotifyOutEffect = wl;
        break;
      default:
        this.selectedNotifyInEffect = cn, this.selectedNotifyOutEffect = un;
    }
  } }]), e;
}();
X(Br, "Notify");
var jr = Br;
globalThis.Notify = jr;
const Vr = ["success", "error", "warning", "info"], Wr = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
], qr = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: !0,
  autotimeout: 4e3,
  position: "right top"
};
function Fe(e = {}) {
  const t = {
    ...qr,
    ...e
  };
  Vr.includes(t.status) || (console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`), t.status = "info"), Wr.includes(t.position) || (console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`), t.position = "right top"), new jr(t);
}
const _l = {
  custom: Fe,
  success(e, t = "Success", i = {}) {
    Fe({
      status: "success",
      title: t,
      text: e,
      ...i
    });
  },
  error(e, t = "Error", i = {}) {
    Fe({
      status: "error",
      title: t,
      text: e,
      ...i
    });
  },
  warning(e, t = "Warning", i = {}) {
    Fe({
      status: "warning",
      title: t,
      text: e,
      ...i
    });
  },
  info(e, t = "Info", i = {}) {
    Fe({
      status: "info",
      title: t,
      text: e,
      ...i
    });
  },
  setDefaults(e = {}) {
    Object.assign(qr, e);
  },
  get allowedStatuses() {
    return [...Vr];
  },
  get allowedPositions() {
    return [...Wr];
  }
}, li = function() {
}, He = {}, gt = {}, Ke = {};
function xl(e, t) {
  e = Array.isArray(e) ? e : [e];
  const i = [];
  let n = e.length, r = n, s, o, a, l;
  for (s = function(c, u) {
    u.length && i.push(c), r--, r || t(i);
  }; n--; ) {
    if (o = e[n], a = gt[o], a) {
      s(o, a);
      continue;
    }
    l = Ke[o] = Ke[o] || [], l.push(s);
  }
}
function Hr(e, t) {
  if (!e) return;
  const i = Ke[e];
  if (gt[e] = t, !!i)
    for (; i.length; )
      i[0](e, t), i.splice(0, 1);
}
function ci(e, t) {
  typeof e == "function" && (e = { success: e }), t.length ? (e.error || li)(t) : (e.success || li)(e);
}
function El(e, t, i, n, r, s, o, a) {
  let l = e.type[0];
  if (a)
    try {
      i.sheet.cssText.length || (l = "e");
    } catch (c) {
      c.code !== 18 && (l = "e");
    }
  if (l === "e") {
    if (s += 1, s < o)
      return Kr(t, n, r, s);
  } else if (i.rel === "preload" && i.as === "style") {
    i.rel = "stylesheet";
    return;
  }
  n(t, l, e.defaultPrevented);
}
function Kr(e, t, i, n) {
  const r = document, s = i.async, o = (i.numRetries || 0) + 1, a = i.before || li, l = e.replace(/[\?|#].*$/, ""), c = e.replace(/^(css|img|module|nomodule)!/, "");
  let u, d, f;
  if (n = n || 0, /(^css!|\.css$)/.test(l))
    f = r.createElement("link"), f.rel = "stylesheet", f.href = c, u = "hideFocus" in f, u && f.relList && (u = 0, f.rel = "preload", f.as = "style"), i.inlineStyleNonce && f.setAttribute("nonce", i.inlineStyleNonce);
  else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l))
    f = r.createElement("img"), f.src = c;
  else if (f = r.createElement("script"), f.src = c, f.async = s === void 0 ? !0 : s, i.inlineScriptNonce && f.setAttribute("nonce", i.inlineScriptNonce), d = "noModule" in f, /^module!/.test(l)) {
    if (!d) return t(e, "l");
    f.type = "module";
  } else if (/^nomodule!/.test(l) && d)
    return t(e, "l");
  const y = function(m) {
    El(m, e, f, t, i, n, o, u);
  };
  f.addEventListener("load", y, { once: !0 }), f.addEventListener("error", y, { once: !0 }), a(e, f) !== !1 && r.head.appendChild(f);
}
function Il(e, t, i) {
  e = Array.isArray(e) ? e : [e];
  let n = e.length, r = [];
  function s(o, a, l) {
    if (a === "e" && r.push(o), a === "b")
      if (l) r.push(o);
      else return;
    n--, n || t(r);
  }
  for (let o = 0; o < e.length; o++)
    Kr(e[o], s, i);
}
function ne(e, t, i) {
  let n, r;
  if (t && typeof t == "string" && t.trim && (n = t.trim()), r = (n ? i : t) || {}, n) {
    if (n in He)
      throw "LoadJS";
    He[n] = !0;
  }
  function s(o, a) {
    Il(e, function(l) {
      ci(r, l), o && ci({ success: o, error: a }, l), Hr(n, l);
    }, r);
  }
  if (r.returnPromise)
    return new Promise(s);
  s();
}
ne.ready = function(t, i) {
  return xl(t, function(n) {
    ci(i, n);
  }), ne;
};
ne.done = function(t) {
  Hr(t, []);
};
ne.reset = function() {
  Object.keys(He).forEach((t) => delete He[t]), Object.keys(gt).forEach((t) => delete gt[t]), Object.keys(Ke).forEach((t) => delete Ke[t]);
};
ne.isDefined = function(t) {
  return t in He;
};
function Cl(e) {
  if (typeof Alpine > "u" || typeof Alpine.$data != "function") {
    console.error(
      "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
    );
    return;
  }
  if (e instanceof Element) {
    const t = Tl(e) || e;
    let i = Alpine.$data(t);
    if (i === void 0) {
      const n = t.closest?.("[x-data]");
      n && (i = Alpine.$data(n));
    }
    return i === void 0 && dn("element", t), i;
  }
  if (typeof e == "string") {
    const t = e.trim();
    if (!t) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return;
    }
    const i = `[data-alpine-root="${Jr(t)}"]`;
    let n = null;
    const r = document.getElementById(t);
    if (r && (n = r.matches(i) ? r : r.querySelector(i)), n || (n = Yr(t)), !n) {
      console.warn(
        `Rizzy.$data: Could not locate an Alpine root using ${i} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${t}"' is present.`
      );
      return;
    }
    const s = Alpine.$data(n);
    return s === void 0 && dn(`data-alpine-root="${t}"`, n), s;
  }
  console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
}
function Tl(e) {
  if (!(e instanceof Element)) return null;
  const t = e.tagName?.toLowerCase?.() === "rz-proxy", i = e.getAttribute?.("data-for");
  if (t || i) {
    const n = i || "";
    if (!n) return e;
    const r = Yr(n);
    return r || (console.warn(
      `Rizzy.$data: Proxy element could not resolve Alpine root for id "${n}". Ensure the teleported root rendered with data-alpine-root="${n}".`
    ), null);
  }
  return e;
}
function Yr(e) {
  const t = `[data-alpine-root="${Jr(e)}"]`, i = document.querySelectorAll(t);
  for (const n of i)
    if (n.hasAttribute("x-data")) return n;
  return i.length > 0 ? i[0] : document.getElementById(e) || null;
}
function Jr(e) {
  try {
    if (window.CSS && typeof window.CSS.escape == "function")
      return window.CSS.escape(e);
  } catch {
  }
  return String(e).replace(/"/g, '\\"');
}
function dn(e, t) {
  const i = `${t.tagName?.toLowerCase?.() || "node"}${t.id ? "#" + t.id : ""}${t.classList?.length ? "." + Array.from(t.classList).join(".") : ""}`;
  console.warn(
    `Rizzy.$data: Located target via ${e} (${i}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
  );
}
function Sl(e) {
  e.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: !1,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function Al(e) {
  e.data("accordionItem", () => ({
    open: !1,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true", this.sectionId = this.$el.dataset.sectionId, this.expandedClass = this.$el.dataset.expandedClass;
      const t = this;
      typeof this.selected < "u" && typeof this.allowMultiple < "u" ? this.$watch("selected", (i, n) => {
        i !== t.sectionId && !t.allowMultiple && (t.open = !1);
      }) : console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId, this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function Ol(e) {
  e.data("rzAlert", () => ({
    parentElement: null,
    showAlert: !0,
    init() {
      const t = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
      this.parentElement = document.getElementById(t);
    },
    dismiss() {
      this.showAlert = !1;
      const t = this;
      setTimeout(() => {
        t.parentElement.style.display = "none";
      }, 205);
    }
  }));
}
function $l(e) {
  e.data("rzAspectRatio", () => ({
    init() {
      const t = parseFloat(this.$el.dataset.ratio);
      if (!isNaN(t) && t > 0) {
        const i = 100 / t + "%";
        this.$el.style.paddingBottom = i;
      } else
        this.$el.style.paddingBottom = "100%";
    }
  }));
}
function Nl(e) {
  e.data("rzBrowser", () => ({
    screenSize: "",
    setDesktopScreenSize() {
      this.screenSize = "";
    },
    setTabletScreenSize() {
      this.screenSize = "max-w-2xl";
    },
    setPhoneScreenSize() {
      this.screenSize = "max-w-sm";
    },
    // Get CSS classes for browser border based on screen size
    getBrowserBorderCss() {
      return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
    },
    // Get CSS classes for desktop screen button styling
    getDesktopScreenCss() {
      return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for tablet screen button styling
    getTabletScreenCss() {
      return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for phone screen button styling
    getPhoneScreenCss() {
      return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    }
  }));
}
function kl(e, t) {
  e.data("rzCalendar", () => ({
    calendar: null,
    initialized: !1,
    init() {
      const i = JSON.parse(this.$el.dataset.assets || "[]"), n = this.$el.dataset.configId, r = this.$el.dataset.nonce;
      if (i.length === 0) {
        console.warn("RzCalendar: No assets configured.");
        return;
      }
      t(i, {
        success: () => {
          this.initCalendar(n);
        },
        error: (s) => console.error("RzCalendar: Failed to load assets", s)
      }, r);
    },
    initCalendar(i) {
      const n = document.getElementById(i);
      if (!n) {
        console.error(`RzCalendar: Config element #${i} not found.`);
        return;
      }
      let r = {};
      try {
        r = JSON.parse(n.textContent);
      } catch (a) {
        console.error("RzCalendar: Failed to parse config JSON", a);
        return;
      }
      const s = {
        clickDay: (a, l) => this.dispatchCalendarEvent("clickDay", { event: a, dates: l.selectedDates }),
        clickWeekNumber: (a, l, c, u) => this.dispatchCalendarEvent("clickWeekNumber", { event: a, number: l, days: c, year: u }),
        clickMonth: (a, l) => this.dispatchCalendarEvent("clickMonth", { event: a, month: l }),
        clickYear: (a, l) => this.dispatchCalendarEvent("clickYear", { event: a, year: l }),
        clickArrow: (a, l, c) => this.dispatchCalendarEvent("clickArrow", { event: a, year: l, month: c }),
        changeTime: (a, l, c, u, d) => this.dispatchCalendarEvent("changeTime", { event: a, time: l, hours: c, minutes: u, keeping: d }),
        changeView: (a) => this.dispatchCalendarEvent("changeView", { view: a }),
        getDays: (a, l, c, u, d) => {
        }
      }, o = {
        ...r.options,
        styles: r.styles,
        // Correct property name for VCP
        actions: s
      };
      window.VanillaCalendarPro ? (this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, o), this.calendar.init(), this.initialized = !0, this.dispatchCalendarEvent("init", { instance: this.calendar })) : console.error("RzCalendar: VanillaCalendar global not found.");
    },
    dispatchCalendarEvent(i, n) {
      this.$dispatch(`rz:calendar:${i}`, n);
    },
    destroy() {
      this.calendar && (this.calendar.destroy(), this.dispatchCalendarEvent("destroy", {}));
    }
  }));
}
function Rl(e, t) {
  function i(n) {
    if (!n) return {};
    const r = document.getElementById(n);
    if (!r)
      return console.warn(`[rzCarousel] JSON script element #${n} not found.`), {};
    try {
      return JSON.parse(r.textContent || "{}");
    } catch (s) {
      return console.error(`[rzCarousel] Failed to parse JSON from #${n}:`, s), {};
    }
  }
  e.data("rzCarousel", () => ({
    emblaApi: null,
    canScrollPrev: !1,
    canScrollNext: !1,
    selectedIndex: 0,
    scrollSnaps: [],
    init() {
      const n = (() => {
        try {
          return JSON.parse(this.$el.dataset.assets || "[]");
        } catch (c) {
          return console.error("[rzCarousel] Bad assets JSON:", c), [];
        }
      })(), r = this.$el.dataset.nonce || "", s = i(this.$el.dataset.config), o = s.Options || {}, a = s.Plugins || [], l = this;
      n.length > 0 && typeof t == "function" ? t(
        n,
        {
          success() {
            window.EmblaCarousel ? l.initializeEmbla(o, a) : console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
          },
          error(c) {
            console.error("[rzCarousel] Failed to load EmblaCarousel assets.", c);
          }
        },
        r
      ) : window.EmblaCarousel ? this.initializeEmbla(o, a) : console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
    },
    initializeEmbla(n, r) {
      const s = this.$el.querySelector('[x-ref="viewport"]');
      if (!s) {
        console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
        return;
      }
      const o = this.instantiatePlugins(r);
      this.emblaApi = window.EmblaCarousel(s, n, o), this.emblaApi.on("select", this.onSelect.bind(this)), this.emblaApi.on("reInit", this.onSelect.bind(this)), this.onSelect();
    },
    instantiatePlugins(n) {
      return !Array.isArray(n) || n.length === 0 ? [] : n.map((r) => {
        const s = window[r.Name];
        if (typeof s != "function")
          return console.error(`[rzCarousel] Plugin constructor '${r.Name}' not found on window object.`), null;
        try {
          return s(r.Options || {});
        } catch (o) {
          return console.error(`[rzCarousel] Error instantiating plugin '${r.Name}':`, o), null;
        }
      }).filter(Boolean);
    },
    destroy() {
      this.emblaApi && this.emblaApi.destroy();
    },
    onSelect() {
      this.emblaApi && (this.selectedIndex = this.emblaApi.selectedScrollSnap(), this.canScrollPrev = this.emblaApi.canScrollPrev(), this.canScrollNext = this.emblaApi.canScrollNext(), this.scrollSnaps = this.emblaApi.scrollSnapList());
    },
    cannotScrollPrev() {
      return !this.canScrollPrev;
    },
    cannotScrollNext() {
      return !this.canScrollNext;
    },
    scrollPrev() {
      this.emblaApi?.scrollPrev();
    },
    scrollNext() {
      this.emblaApi?.scrollNext();
    },
    scrollTo(n) {
      this.emblaApi?.scrollTo(n);
    }
  }));
}
function Ll(e, t) {
  e.data("rzCodeViewer", () => ({
    expand: !1,
    border: !0,
    copied: !1,
    copyTitle: "Copy",
    // Default title
    copiedTitle: "Copied!",
    // Default title
    init() {
      const i = JSON.parse(this.$el.dataset.assets), n = this.$el.dataset.codeid, r = this.$el.dataset.nonce;
      this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle, this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle, t(i, {
        success: function() {
          const s = document.getElementById(n);
          window.hljs && s && window.hljs.highlightElement(s);
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, r);
    },
    // Function to check if code is NOT copied (for x-show)
    notCopied() {
      return !this.copied;
    },
    // Function to reset the copied state (e.g., on blur)
    disableCopied() {
      this.copied = !1;
    },
    // Function to toggle the expand state
    toggleExpand() {
      this.expand = !this.expand;
    },
    // Function to copy code to clipboard
    copyHTML() {
      navigator.clipboard.writeText(this.$refs.codeBlock.textContent), this.copied = !this.copied;
    },
    // Get the title for the copy button (copy/copied)
    getCopiedTitle() {
      return this.copied ? this.copiedTitle : this.copyTitle;
    },
    // Get CSS classes for the copy button based on copied state
    getCopiedCss() {
      return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
    },
    // Get CSS classes for the code container based on expand state
    getExpandCss() {
      return [this.expand ? "" : "max-h-60"];
    },
    // Get CSS classes for the expand button icon based on expand state
    getExpandButtonCss() {
      return this.expand ? "rotate-180" : "rotate-0";
    }
  }));
}
function Pl(e) {
  e.data("rzCollapsible", () => ({
    isOpen: !1,
    init() {
      this.isOpen = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.isOpen = !this.isOpen;
    },
    state() {
      return this.isOpen ? "open" : "closed";
    }
  }));
}
function Dl(e, t) {
  e.data("rzCombobox", () => ({
    tomSelect: null,
    init() {
      const i = JSON.parse(this.$el.dataset.assets || "[]"), n = this.$el.dataset.nonce;
      i.length > 0 && typeof t == "function" ? t(i, {
        success: () => this.initTomSelect(),
        error: (r) => console.error("RzCombobox: Failed to load assets.", r)
      }, n) : window.TomSelect && this.initTomSelect();
    },
    initTomSelect() {
      const i = this.$refs.selectInput;
      if (!i) return;
      const n = document.getElementById(this.$el.dataset.configId), r = n ? JSON.parse(n.textContent) : {}, s = {}, o = (a, l) => {
        if (!a) return null;
        const c = document.createElement("div");
        let u = l.item;
        if (typeof u == "string")
          try {
            u = JSON.parse(u);
          } catch {
          }
        const d = {
          ...l,
          item: u
        };
        return e && typeof e.addScopeToNode == "function" ? e.addScopeToNode(c, d) : c._x_dataStack = [d], c.innerHTML = a.innerHTML, c;
      };
      this.$refs.optionTemplate && (s.option = (a, l) => o(this.$refs.optionTemplate, a)), this.$refs.itemTemplate && (s.item = (a, l) => o(this.$refs.itemTemplate, a)), r.dataAttr = "data-item", this.tomSelect = new TomSelect(i, {
        ...r,
        render: s,
        onInitialize: function() {
          this.sync();
        }
      });
    },
    destroy() {
      this.tomSelect && (this.tomSelect.destroy(), this.tomSelect = null);
    }
  }));
}
function Ml(e, t) {
  e.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const i = this.$el.dataset.config, n = document.getElementById(this.$el.dataset.uid + "-input");
      if (i) {
        const o = JSON.parse(i);
        o && (this.options = o.options || {}, this.placeholder = o.placeholder || "", this.prependText = o.prependText || "");
      }
      const r = JSON.parse(this.$el.dataset.assets), s = this.$el.dataset.nonce;
      t(r, {
        success: function() {
          window.flatpickr && n && window.flatpickr(n, this.options);
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, s);
    }
  }));
}
function zl(e) {
  e.data("rzDialog", () => ({
    modalOpen: !1,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: !0,
    closeOnClickOutside: !0,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "", this.bodyId = this.$el.dataset.bodyId || "", this.footerId = this.$el.dataset.footerId || "", this.nonce = this.$el.dataset.nonce || "", this.eventTriggerName = this.$el.dataset.eventTriggerName || "", this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName, this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false", this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false", this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: !0
      })), this.eventTriggerName && (this._openListener = (t) => {
        this.openModal(t);
      }, window.addEventListener(this.eventTriggerName, this._openListener)), this._closeEventListener = (t) => {
        this.modalOpen && this.closeModalInternally("event");
      }, window.addEventListener(this.closeEventName, this._closeEventListener), this._escapeListener = (t) => {
        this.modalOpen && this.closeOnEscape && t.key === "Escape" && this.closeModalInternally("escape");
      }, window.addEventListener("keydown", this._escapeListener), this.$watch("modalOpen", (t) => {
        const i = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", t);
        const n = document.body.offsetWidth - i;
        document.body.style.setProperty("--page-scrollbar-width", `${n}px`), t ? this.$nextTick(() => {
          this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(), this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        }) : this.$nextTick(() => {
          this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        });
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      this._openListener && this.eventTriggerName && window.removeEventListener(this.eventTriggerName, this._openListener), this._closeEventListener && window.removeEventListener(this.closeEventName, this._closeEventListener), this._escapeListener && window.removeEventListener("keydown", this._escapeListener), document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px");
    },
    openModal(t = null) {
      const i = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(i), i.defaultPrevented || (this.modalOpen = !0);
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(t = "unknown") {
      const i = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(i), i.defaultPrevented || (document.activeElement?.blur && document.activeElement.blur(), this.modalOpen = !1, document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px"));
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      this.closeOnClickOutside && this.closeModalInternally("backdrop");
    }
  }));
}
const ui = Math.min, xe = Math.max, vt = Math.round, J = (e) => ({
  x: e,
  y: e
}), Fl = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Ul = {
  start: "end",
  end: "start"
};
function fn(e, t, i) {
  return xe(e, ui(t, i));
}
function Nt(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function we(e) {
  return e.split("-")[0];
}
function kt(e) {
  return e.split("-")[1];
}
function Zr(e) {
  return e === "x" ? "y" : "x";
}
function Gr(e) {
  return e === "y" ? "height" : "width";
}
function ge(e) {
  return ["top", "bottom"].includes(we(e)) ? "y" : "x";
}
function Xr(e) {
  return Zr(ge(e));
}
function Bl(e, t, i) {
  i === void 0 && (i = !1);
  const n = kt(e), r = Xr(e), s = Gr(r);
  let o = r === "x" ? n === (i ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = bt(o)), [o, bt(o)];
}
function jl(e) {
  const t = bt(e);
  return [di(e), t, di(t)];
}
function di(e) {
  return e.replace(/start|end/g, (t) => Ul[t]);
}
function Vl(e, t, i) {
  const n = ["left", "right"], r = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return i ? t ? r : n : t ? n : r;
    case "left":
    case "right":
      return t ? s : o;
    default:
      return [];
  }
}
function Wl(e, t, i, n) {
  const r = kt(e);
  let s = Vl(we(e), i === "start", n);
  return r && (s = s.map((o) => o + "-" + r), t && (s = s.concat(s.map(di)))), s;
}
function bt(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Fl[t]);
}
function ql(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Hl(e) {
  return typeof e != "number" ? ql(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function yt(e) {
  const {
    x: t,
    y: i,
    width: n,
    height: r
  } = e;
  return {
    width: n,
    height: r,
    top: i,
    left: t,
    right: t + n,
    bottom: i + r,
    x: t,
    y: i
  };
}
function hn(e, t, i) {
  let {
    reference: n,
    floating: r
  } = e;
  const s = ge(t), o = Xr(t), a = Gr(o), l = we(t), c = s === "y", u = n.x + n.width / 2 - r.width / 2, d = n.y + n.height / 2 - r.height / 2, f = n[a] / 2 - r[a] / 2;
  let y;
  switch (l) {
    case "top":
      y = {
        x: u,
        y: n.y - r.height
      };
      break;
    case "bottom":
      y = {
        x: u,
        y: n.y + n.height
      };
      break;
    case "right":
      y = {
        x: n.x + n.width,
        y: d
      };
      break;
    case "left":
      y = {
        x: n.x - r.width,
        y: d
      };
      break;
    default:
      y = {
        x: n.x,
        y: n.y
      };
  }
  switch (kt(t)) {
    case "start":
      y[o] -= f * (i && c ? -1 : 1);
      break;
    case "end":
      y[o] += f * (i && c ? -1 : 1);
      break;
  }
  return y;
}
const Kl = async (e, t, i) => {
  const {
    placement: n = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: o
  } = i, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: d
  } = hn(c, n, l), f = n, y = {}, m = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: p,
      fn: b
    } = a[v], {
      x: h,
      y: _,
      data: E,
      reset: x
    } = await b({
      x: u,
      y: d,
      initialPlacement: n,
      placement: f,
      strategy: r,
      middlewareData: y,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = h ?? u, d = _ ?? d, y = {
      ...y,
      [p]: {
        ...y[p],
        ...E
      }
    }, x && m <= 50 && (m++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (c = x.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : x.rects), {
      x: u,
      y: d
    } = hn(c, f, l)), v = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: r,
    middlewareData: y
  };
};
async function Qr(e, t) {
  var i;
  t === void 0 && (t = {});
  const {
    x: n,
    y: r,
    platform: s,
    rects: o,
    elements: a,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: y = 0
  } = Nt(t, e), m = Hl(y), p = a[f ? d === "floating" ? "reference" : "floating" : d], b = yt(await s.getClippingRect({
    element: (i = await (s.isElement == null ? void 0 : s.isElement(p))) == null || i ? p : p.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), h = d === "floating" ? {
    x: n,
    y: r,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, _ = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), E = await (s.isElement == null ? void 0 : s.isElement(_)) ? await (s.getScale == null ? void 0 : s.getScale(_)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = yt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: h,
    offsetParent: _,
    strategy: l
  }) : h);
  return {
    top: (b.top - x.top + m.top) / E.y,
    bottom: (x.bottom - b.bottom + m.bottom) / E.y,
    left: (b.left - x.left + m.left) / E.x,
    right: (x.right - b.right + m.right) / E.x
  };
}
const Yl = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var i, n;
      const {
        placement: r,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: v = !0,
        ...p
      } = Nt(e, t);
      if ((i = s.arrow) != null && i.alignmentOffset)
        return {};
      const b = we(r), h = ge(a), _ = we(a) === a, E = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), x = f || (_ || !v ? [bt(a)] : jl(a)), g = m !== "none";
      !f && g && x.push(...Wl(a, v, m, E));
      const w = [a, ...x], I = await Qr(t, p), C = [];
      let T = ((n = s.flip) == null ? void 0 : n.overflows) || [];
      if (u && C.push(I[b]), d) {
        const z = Bl(r, o, E);
        C.push(I[z[0]], I[z[1]]);
      }
      if (T = [...T, {
        placement: r,
        overflows: C
      }], !C.every((z) => z <= 0)) {
        var S, L;
        const z = (((S = s.flip) == null ? void 0 : S.index) || 0) + 1, le = w[z];
        if (le) {
          var P;
          const F = d === "alignment" ? h !== ge(le) : !1, K = ((P = T[0]) == null ? void 0 : P.overflows[0]) > 0;
          if (!F || K)
            return {
              data: {
                index: z,
                overflows: T
              },
              reset: {
                placement: le
              }
            };
        }
        let B = (L = T.filter((F) => F.overflows[0] <= 0).sort((F, K) => F.overflows[1] - K.overflows[1])[0]) == null ? void 0 : L.placement;
        if (!B)
          switch (y) {
            case "bestFit": {
              var H;
              const F = (H = T.filter((K) => {
                if (g) {
                  const ee = ge(K.placement);
                  return ee === h || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  ee === "y";
                }
                return !0;
              }).map((K) => [K.placement, K.overflows.filter((ee) => ee > 0).reduce((ee, cs) => ee + cs, 0)]).sort((K, ee) => K[1] - ee[1])[0]) == null ? void 0 : H[0];
              F && (B = F);
              break;
            }
            case "initialPlacement":
              B = a;
              break;
          }
        if (r !== B)
          return {
            reset: {
              placement: B
            }
          };
      }
      return {};
    }
  };
};
async function Jl(e, t) {
  const {
    placement: i,
    platform: n,
    elements: r
  } = e, s = await (n.isRTL == null ? void 0 : n.isRTL(r.floating)), o = we(i), a = kt(i), l = ge(i) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = s && l ? -1 : 1, d = Nt(t, e);
  let {
    mainAxis: f,
    crossAxis: y,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof m == "number" && (y = a === "end" ? m * -1 : m), l ? {
    x: y * u,
    y: f * c
  } : {
    x: f * c,
    y: y * u
  };
}
const Zl = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var i, n;
      const {
        x: r,
        y: s,
        placement: o,
        middlewareData: a
      } = t, l = await Jl(t, e);
      return o === ((i = a.offset) == null ? void 0 : i.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
        x: r + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, Gl = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: i,
        y: n,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (p) => {
            let {
              x: b,
              y: h
            } = p;
            return {
              x: b,
              y: h
            };
          }
        },
        ...l
      } = Nt(e, t), c = {
        x: i,
        y: n
      }, u = await Qr(t, l), d = ge(we(r)), f = Zr(d);
      let y = c[f], m = c[d];
      if (s) {
        const p = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", h = y + u[p], _ = y - u[b];
        y = fn(h, y, _);
      }
      if (o) {
        const p = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", h = m + u[p], _ = m - u[b];
        m = fn(h, m, _);
      }
      const v = a.fn({
        ...t,
        [f]: y,
        [d]: m
      });
      return {
        ...v,
        data: {
          x: v.x - i,
          y: v.y - n,
          enabled: {
            [f]: s,
            [d]: o
          }
        }
      };
    }
  };
};
function Rt() {
  return typeof window < "u";
}
function ke(e) {
  return es(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function M(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Q(e) {
  var t;
  return (t = (es(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function es(e) {
  return Rt() ? e instanceof Node || e instanceof M(e).Node : !1;
}
function V(e) {
  return Rt() ? e instanceof Element || e instanceof M(e).Element : !1;
}
function Z(e) {
  return Rt() ? e instanceof HTMLElement || e instanceof M(e).HTMLElement : !1;
}
function pn(e) {
  return !Rt() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof M(e).ShadowRoot;
}
function Ge(e) {
  const {
    overflow: t,
    overflowX: i,
    overflowY: n,
    display: r
  } = W(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + n + i) && !["inline", "contents"].includes(r);
}
function Xl(e) {
  return ["table", "td", "th"].includes(ke(e));
}
function Lt(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Li(e) {
  const t = Pi(), i = V(e) ? W(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((n) => i[n] ? i[n] !== "none" : !1) || (i.containerType ? i.containerType !== "normal" : !1) || !t && (i.backdropFilter ? i.backdropFilter !== "none" : !1) || !t && (i.filter ? i.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((n) => (i.willChange || "").includes(n)) || ["paint", "layout", "strict", "content"].some((n) => (i.contain || "").includes(n));
}
function Ql(e) {
  let t = oe(e);
  for (; Z(t) && !Ce(t); ) {
    if (Li(t))
      return t;
    if (Lt(t))
      return null;
    t = oe(t);
  }
  return null;
}
function Pi() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ce(e) {
  return ["html", "body", "#document"].includes(ke(e));
}
function W(e) {
  return M(e).getComputedStyle(e);
}
function Pt(e) {
  return V(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function oe(e) {
  if (ke(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    pn(e) && e.host || // Fallback.
    Q(e)
  );
  return pn(t) ? t.host : t;
}
function ts(e) {
  const t = oe(e);
  return Ce(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Z(t) && Ge(t) ? t : ts(t);
}
function is(e, t, i) {
  var n;
  t === void 0 && (t = []);
  const r = ts(e), s = r === ((n = e.ownerDocument) == null ? void 0 : n.body), o = M(r);
  return s ? (fi(o), t.concat(o, o.visualViewport || [], Ge(r) ? r : [], [])) : t.concat(r, is(r, []));
}
function fi(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ns(e) {
  const t = W(e);
  let i = parseFloat(t.width) || 0, n = parseFloat(t.height) || 0;
  const r = Z(e), s = r ? e.offsetWidth : i, o = r ? e.offsetHeight : n, a = vt(i) !== s || vt(n) !== o;
  return a && (i = s, n = o), {
    width: i,
    height: n,
    $: a
  };
}
function rs(e) {
  return V(e) ? e : e.contextElement;
}
function Ee(e) {
  const t = rs(e);
  if (!Z(t))
    return J(1);
  const i = t.getBoundingClientRect(), {
    width: n,
    height: r,
    $: s
  } = ns(t);
  let o = (s ? vt(i.width) : i.width) / n, a = (s ? vt(i.height) : i.height) / r;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const ec = /* @__PURE__ */ J(0);
function ss(e) {
  const t = M(e);
  return !Pi() || !t.visualViewport ? ec : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function tc(e, t, i) {
  return t === void 0 && (t = !1), !i || t && i !== M(e) ? !1 : t;
}
function Ye(e, t, i, n) {
  t === void 0 && (t = !1), i === void 0 && (i = !1);
  const r = e.getBoundingClientRect(), s = rs(e);
  let o = J(1);
  t && (n ? V(n) && (o = Ee(n)) : o = Ee(e));
  const a = tc(s, i, n) ? ss(s) : J(0);
  let l = (r.left + a.x) / o.x, c = (r.top + a.y) / o.y, u = r.width / o.x, d = r.height / o.y;
  if (s) {
    const f = M(s), y = n && V(n) ? M(n) : n;
    let m = f, v = fi(m);
    for (; v && n && y !== m; ) {
      const p = Ee(v), b = v.getBoundingClientRect(), h = W(v), _ = b.left + (v.clientLeft + parseFloat(h.paddingLeft)) * p.x, E = b.top + (v.clientTop + parseFloat(h.paddingTop)) * p.y;
      l *= p.x, c *= p.y, u *= p.x, d *= p.y, l += _, c += E, m = M(v), v = fi(m);
    }
  }
  return yt({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function Di(e, t) {
  const i = Pt(e).scrollLeft;
  return t ? t.left + i : Ye(Q(e)).left + i;
}
function os(e, t, i) {
  i === void 0 && (i = !1);
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - (i ? 0 : (
    // RTL <body> scrollbar.
    Di(e, n)
  )), s = n.top + t.scrollTop;
  return {
    x: r,
    y: s
  };
}
function ic(e) {
  let {
    elements: t,
    rect: i,
    offsetParent: n,
    strategy: r
  } = e;
  const s = r === "fixed", o = Q(n), a = t ? Lt(t.floating) : !1;
  if (n === o || a && s)
    return i;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = J(1);
  const u = J(0), d = Z(n);
  if ((d || !d && !s) && ((ke(n) !== "body" || Ge(o)) && (l = Pt(n)), Z(n))) {
    const y = Ye(n);
    c = Ee(n), u.x = y.x + n.clientLeft, u.y = y.y + n.clientTop;
  }
  const f = o && !d && !s ? os(o, l, !0) : J(0);
  return {
    width: i.width * c.x,
    height: i.height * c.y,
    x: i.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: i.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function nc(e) {
  return Array.from(e.getClientRects());
}
function rc(e) {
  const t = Q(e), i = Pt(e), n = e.ownerDocument.body, r = xe(t.scrollWidth, t.clientWidth, n.scrollWidth, n.clientWidth), s = xe(t.scrollHeight, t.clientHeight, n.scrollHeight, n.clientHeight);
  let o = -i.scrollLeft + Di(e);
  const a = -i.scrollTop;
  return W(n).direction === "rtl" && (o += xe(t.clientWidth, n.clientWidth) - r), {
    width: r,
    height: s,
    x: o,
    y: a
  };
}
function sc(e, t) {
  const i = M(e), n = Q(e), r = i.visualViewport;
  let s = n.clientWidth, o = n.clientHeight, a = 0, l = 0;
  if (r) {
    s = r.width, o = r.height;
    const c = Pi();
    (!c || c && t === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function oc(e, t) {
  const i = Ye(e, !0, t === "fixed"), n = i.top + e.clientTop, r = i.left + e.clientLeft, s = Z(e) ? Ee(e) : J(1), o = e.clientWidth * s.x, a = e.clientHeight * s.y, l = r * s.x, c = n * s.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function mn(e, t, i) {
  let n;
  if (t === "viewport")
    n = sc(e, i);
  else if (t === "document")
    n = rc(Q(e));
  else if (V(t))
    n = oc(t, i);
  else {
    const r = ss(e);
    n = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return yt(n);
}
function as(e, t) {
  const i = oe(e);
  return i === t || !V(i) || Ce(i) ? !1 : W(i).position === "fixed" || as(i, t);
}
function ac(e, t) {
  const i = t.get(e);
  if (i)
    return i;
  let n = is(e, []).filter((a) => V(a) && ke(a) !== "body"), r = null;
  const s = W(e).position === "fixed";
  let o = s ? oe(e) : e;
  for (; V(o) && !Ce(o); ) {
    const a = W(o), l = Li(o);
    !l && a.position === "fixed" && (r = null), (s ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || Ge(o) && !l && as(e, o)) ? n = n.filter((u) => u !== o) : r = a, o = oe(o);
  }
  return t.set(e, n), n;
}
function lc(e) {
  let {
    element: t,
    boundary: i,
    rootBoundary: n,
    strategy: r
  } = e;
  const o = [...i === "clippingAncestors" ? Lt(t) ? [] : ac(t, this._c) : [].concat(i), n], a = o[0], l = o.reduce((c, u) => {
    const d = mn(t, u, r);
    return c.top = xe(d.top, c.top), c.right = ui(d.right, c.right), c.bottom = ui(d.bottom, c.bottom), c.left = xe(d.left, c.left), c;
  }, mn(t, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function cc(e) {
  const {
    width: t,
    height: i
  } = ns(e);
  return {
    width: t,
    height: i
  };
}
function uc(e, t, i) {
  const n = Z(t), r = Q(t), s = i === "fixed", o = Ye(e, !0, s, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = J(0);
  function c() {
    l.x = Di(r);
  }
  if (n || !n && !s)
    if ((ke(t) !== "body" || Ge(r)) && (a = Pt(t)), n) {
      const y = Ye(t, !0, s, t);
      l.x = y.x + t.clientLeft, l.y = y.y + t.clientTop;
    } else r && c();
  s && !n && r && c();
  const u = r && !n && !s ? os(r, a) : J(0), d = o.left + a.scrollLeft - l.x - u.x, f = o.top + a.scrollTop - l.y - u.y;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function jt(e) {
  return W(e).position === "static";
}
function gn(e, t) {
  if (!Z(e) || W(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let i = e.offsetParent;
  return Q(e) === i && (i = i.ownerDocument.body), i;
}
function ls(e, t) {
  const i = M(e);
  if (Lt(e))
    return i;
  if (!Z(e)) {
    let r = oe(e);
    for (; r && !Ce(r); ) {
      if (V(r) && !jt(r))
        return r;
      r = oe(r);
    }
    return i;
  }
  let n = gn(e, t);
  for (; n && Xl(n) && jt(n); )
    n = gn(n, t);
  return n && Ce(n) && jt(n) && !Li(n) ? i : n || Ql(e) || i;
}
const dc = async function(e) {
  const t = this.getOffsetParent || ls, i = this.getDimensions, n = await i(e.floating);
  return {
    reference: uc(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: n.width,
      height: n.height
    }
  };
};
function fc(e) {
  return W(e).direction === "rtl";
}
const hc = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ic,
  getDocumentElement: Q,
  getClippingRect: lc,
  getOffsetParent: ls,
  getElementRects: dc,
  getClientRects: nc,
  getDimensions: cc,
  getScale: Ee,
  isElement: V,
  isRTL: fc
}, wt = Zl, _t = Gl, xt = Yl, Et = (e, t, i) => {
  const n = /* @__PURE__ */ new Map(), r = {
    platform: hc,
    ...i
  }, s = {
    ...r.platform,
    _c: n
  };
  return Kl(e, t, {
    ...r,
    platform: s
  });
};
function pc(e) {
  e.data("rzDropdownMenu", () => ({
    // --- STATE ---
    open: !1,
    isModal: !0,
    ariaExpanded: "false",
    trapActive: !1,
    focusedIndex: null,
    menuItems: [],
    parentEl: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when menu opens
    anchor: "bottom",
    pixelOffset: 3,
    isSubmenuActive: !1,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    // --- INIT ---
    init() {
      this.$el.id || (this.$el.id = crypto.randomUUID()), this.selfId = this.$el.id, this.parentEl = this.$el, this.triggerEl = this.$refs.trigger, this.anchor = this.$el.dataset.anchor || "bottom", this.pixelOffset = parseInt(this.$el.dataset.offset) || 6, this.isModal = this.$el.dataset.modal !== "false", this.$watch("open", (t) => {
        t ? (this._lastNavAt = 0, this.$nextTick(() => {
          this.contentEl = document.getElementById(`${this.selfId}-content`), this.contentEl && (this.updatePosition(), this.menuItems = Array.from(
            this.contentEl.querySelectorAll(
              '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
            )
          ));
        }), this.ariaExpanded = "true", this.triggerEl.dataset.state = "open", this.trapActive = this.isModal) : (this.focusedIndex = null, this.closeAllSubmenus(), this.ariaExpanded = "false", delete this.triggerEl.dataset.state, this.trapActive = !1, this.contentEl = null);
      });
    },
    // --- METHODS ---
    updatePosition() {
      !this.triggerEl || !this.contentEl || (this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`), Et(this.triggerEl, this.contentEl, {
        placement: this.anchor,
        middleware: [wt(this.pixelOffset), xt(), _t({ padding: 8 })]
      }).then(({ x: t, y: i }) => {
        Object.assign(this.contentEl.style, { left: `${t}px`, top: `${i}px` });
      }));
    },
    toggle() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      } else
        this.open = !0, this.focusedIndex = -1;
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = !1;
      let t = this;
      this.$nextTick(() => t.triggerEl?.focus());
    },
    handleTriggerKeydown(t) {
      ["Enter", " ", "ArrowDown", "ArrowUp"].includes(t.key) && (t.preventDefault(), this.open = !0, this.$nextTick(() => {
        t.key === "ArrowUp" ? this.focusLastItem() : this.focusFirstItem();
      }));
    },
    focusNextItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1, this.focusCurrentItem()));
    },
    focusPreviousItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1, this.focusCurrentItem()));
    },
    focusFirstItem() {
      this.menuItems.length && (this.focusedIndex = 0, this.focusCurrentItem());
    },
    focusLastItem() {
      this.menuItems.length && (this.focusedIndex = this.menuItems.length - 1, this.focusCurrentItem());
    },
    focusCurrentItem() {
      this.focusedIndex !== null && this.menuItems[this.focusedIndex] && this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
    },
    focusSelectedItem(t) {
      if (!t || t.getAttribute("aria-disabled") === "true" || t.hasAttribute("disabled")) return;
      const i = this.menuItems.indexOf(t);
      i !== -1 && (this.focusedIndex = i, t.focus());
    },
    handleItemClick(t) {
      const i = t.currentTarget;
      if (i.getAttribute("aria-disabled") === "true" || i.hasAttribute("disabled")) return;
      if (i.getAttribute("aria-haspopup") === "menu") {
        e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.open = !1;
      let n = this;
      this.$nextTick(() => n.triggerEl?.focus());
    },
    handleItemMouseEnter(t) {
      const i = t.currentTarget;
      this.focusSelectedItem(i), i.getAttribute("aria-haspopup") !== "menu" && this.closeAllSubmenus();
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      }
    },
    handleContentTabKey() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      }
    },
    handleTriggerMouseover() {
      let t = this;
      this.$nextTick(() => t.$el.firstElementChild?.focus());
    },
    closeAllSubmenus() {
      this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]').forEach((i) => {
        e.$data(i)?.closeSubmenu();
      }), this.isSubmenuActive = !1;
    }
  })), e.data("rzDropdownSubmenu", () => ({
    // --- STATE ---
    open: !1,
    ariaExpanded: "false",
    parentDropdown: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when submenu opens
    menuItems: [],
    focusedIndex: null,
    anchor: "right-start",
    pixelOffset: 0,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    siblingContainer: null,
    closeTimeout: null,
    closeDelay: 150,
    // --- INIT ---
    init() {
      this.$el.id || (this.$el.id = crypto.randomUUID()), this.selfId = this.$el.id;
      const t = this.$el.dataset.parentId;
      if (t) {
        const i = document.getElementById(t);
        i && (this.parentDropdown = e.$data(i));
      }
      if (!this.parentDropdown) {
        console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
        return;
      }
      this.triggerEl = this.$refs.subTrigger, this.siblingContainer = this.$el.parentElement, this.anchor = this.$el.dataset.subAnchor || this.anchor, this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset, this.$watch("open", (i) => {
        i ? (this._lastNavAt = 0, this.parentDropdown.isSubmenuActive = !0, this.$nextTick(() => {
          this.contentEl = document.getElementById(`${this.selfId}-subcontent`), this.contentEl && (this.updatePosition(this.contentEl), this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])')));
        }), this.ariaExpanded = "true", this.triggerEl.dataset.state = "open") : (this.focusedIndex = null, this.ariaExpanded = "false", delete this.triggerEl.dataset.state, this.$nextTick(() => {
          this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]') || (this.parentDropdown.isSubmenuActive = !1);
        }), this.contentEl = null);
      });
    },
    // --- METHODS ---
    updatePosition(t) {
      !this.triggerEl || !t || Et(this.triggerEl, t, {
        placement: this.anchor,
        middleware: [wt(this.pixelOffset), xt(), _t({ padding: 8 })]
      }).then(({ x: i, y: n }) => {
        Object.assign(t.style, { left: `${i}px`, top: `${n}px` });
      });
    },
    handleTriggerMouseEnter() {
      clearTimeout(this.closeTimeout), this.triggerEl.focus(), this.openSubmenu();
    },
    handleTriggerMouseLeave() {
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    handleContentMouseEnter() {
      clearTimeout(this.closeTimeout);
    },
    handleContentMouseLeave() {
      const t = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      t && Array.from(t).some((n) => e.$data(n)?.open) || (this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay));
    },
    openSubmenu(t = !1) {
      this.open || (this.closeSiblingSubmenus(), this.open = !0, t && this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem())));
    },
    closeSubmenu() {
      this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]')?.forEach((i) => {
        e.$data(i)?.closeSubmenu();
      }), this.open = !1;
    },
    closeSiblingSubmenus() {
      if (!this.siblingContainer) return;
      Array.from(this.siblingContainer.children).filter(
        (i) => i.hasAttribute("x-data") && i.getAttribute("x-data").startsWith("rzDropdownSubmenu") && i.id !== this.selfId
      ).forEach((i) => {
        e.$data(i)?.closeSubmenu();
      });
    },
    toggleSubmenu() {
      this.open ? this.closeSubmenu() : this.openSubmenu();
    },
    openSubmenuAndFocusFirst() {
      this.openSubmenu(!0);
    },
    handleTriggerKeydown(t) {
      ["ArrowRight", "Enter", " "].includes(t.key) && (t.preventDefault(), this.openSubmenuAndFocusFirst());
    },
    focusNextItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1, this.focusCurrentItem()));
    },
    focusPreviousItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1, this.focusCurrentItem()));
    },
    focusFirstItem() {
      this.menuItems.length && (this.focusedIndex = 0, this.focusCurrentItem());
    },
    focusLastItem() {
      this.menuItems.length && (this.focusedIndex = this.menuItems.length - 1, this.focusCurrentItem());
    },
    focusCurrentItem() {
      this.focusedIndex !== null && this.menuItems[this.focusedIndex] && this.menuItems[this.focusedIndex].focus();
    },
    handleItemClick(t) {
      const i = t.currentTarget;
      if (!(i.getAttribute("aria-disabled") === "true" || i.hasAttribute("disabled"))) {
        if (i.getAttribute("aria-haspopup") === "menu") {
          e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.parentDropdown.open = !1, this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
      }
    },
    handleItemMouseEnter(t) {
      const i = t.currentTarget;
      if (i.getAttribute("aria-disabled") === "true" || i.hasAttribute("disabled")) return;
      const n = this.menuItems.indexOf(i);
      n !== -1 && (this.focusedIndex = n, i.focus()), i.getAttribute("aria-haspopup") === "menu" ? e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu() : this.closeSiblingSubmenus();
    },
    handleSubmenuEscape() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    },
    handleSubmenuArrowLeft() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    }
  }));
}
function mc(e) {
  e.data("rzDarkModeToggle", () => ({
    // Proxy all properties to the reactive store
    get mode() {
      return this.$store.theme.mode;
    },
    get prefersDark() {
      return this.$store.theme.prefersDark;
    },
    get effectiveDark() {
      return this.$store.theme.effectiveDark;
    },
    // Proxy properties from the store (isDark/isLight are getters on the store)
    get isDark() {
      return this.$store.theme.isDark;
    },
    get isLight() {
      return this.$store.theme.isLight;
    },
    // Proxy methods
    setLight() {
      this.$store.theme.setLight();
    },
    setDark() {
      this.$store.theme.setDark();
    },
    setAuto() {
      this.$store.theme.setAuto();
    },
    toggle() {
      this.$store.theme.toggle();
    }
  }));
}
function gc(e) {
  e.data("rzEmbeddedPreview", () => ({
    iframe: null,
    onDarkModeToggle: null,
    init() {
      try {
        this.iframe = this.$refs.iframe;
        const t = this.debounce(() => {
          this.resizeIframe(this.iframe);
        }, 50);
        this.resizeIframe(this.iframe), new ResizeObserver((r) => {
          for (let s of r)
            t();
        }).observe(this.iframe);
        const n = this.iframe;
        this.onDarkModeToggle = (r) => {
          n.contentWindow.postMessage(r.detail, "*");
        }, window.addEventListener("darkModeToggle", this.onDarkModeToggle);
      } catch {
        console.error("Cannot access iframe content");
      }
    },
    // Adjusts the iframe height based on its content
    resizeIframe(t) {
      if (t)
        try {
          const i = t.contentDocument || t.contentWindow?.document;
          if (i) {
            const n = i.body;
            if (!n)
              setInterval(() => {
                this.resizeIframe(t);
              }, 150);
            else {
              const r = n.scrollHeight + 15;
              t.style.height = r + "px";
            }
          }
        } catch (i) {
          console.error("Error resizing iframe:", i);
        }
    },
    // Debounce helper to limit function calls
    debounce(t, i = 300) {
      let n;
      return (...r) => {
        clearTimeout(n), n = setTimeout(() => {
          t.apply(this, r);
        }, i);
      };
    },
    destroy() {
      window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
    }
  }));
}
function vc(e) {
  e.data("rzEmpty", () => {
  });
}
function bc(e) {
  e.data("rzHeading", () => ({
    observer: null,
    headingId: "",
    init() {
      this.headingId = this.$el.dataset.alpineRoot;
      const t = this;
      if (typeof this.setCurrentHeading == "function") {
        const i = (r, s) => {
          r.forEach((o) => {
            o.isIntersecting && t.setCurrentHeading(t.headingId);
          });
        }, n = { threshold: 0.5 };
        this.observer = new IntersectionObserver(i, n), this.observer.observe(this.$el);
      } else
        console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
    },
    destroy() {
      this.observer != null && this.observer.disconnect();
    }
  }));
}
function yc(e) {
  e.data("rzIndicator", () => ({
    visible: !1,
    init() {
      const t = this.$el.dataset.color;
      t ? this.$el.style.backgroundColor = t : this.$el.style.backgroundColor = "var(--color-success)", this.$el.dataset.visible === "true" && (this.visible = !0);
    },
    notVisible() {
      return !this.visible;
    },
    setVisible(t) {
      this.visible = t;
    }
  }));
}
function wc(e) {
  e.data("rzInputGroupAddon", () => ({
    handleClick(t) {
      if (t.target.closest("button"))
        return;
      const i = this.$el.parentElement;
      i && i.querySelector("input, textarea")?.focus();
    }
  }));
}
function _c(e, t) {
  e.data("rzMarkdown", () => ({
    init() {
      const i = JSON.parse(this.$el.dataset.assets), n = this.$el.dataset.nonce;
      t(i, {
        success: function() {
          window.hljs.highlightAll();
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, n);
    }
  }));
}
function xc(e, t) {
  e.data("rzNavigationMenu", () => ({
    activeItemId: null,
    open: !1,
    closeTimeout: null,
    prevIndex: null,
    list: null,
    isClosing: !1,
    /* ---------- helpers ---------- */
    _triggerIndex(i) {
      return this.list ? Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]')).findIndex((r) => r.getAttribute("x-ref") === `trigger_${i}`) : -1;
    },
    _contentEl(i) {
      return document.getElementById(`${i}-content`);
    },
    /* ---------- lifecycle ---------- */
    init() {
      this.$el.querySelectorAll("[data-popover]").forEach((n) => {
        n.style.display = "none";
      }), this.$nextTick(() => {
        this.list = this.$refs.list;
      });
    },
    /* ---------- event handlers (from events with no params) ---------- */
    toggleActive(i) {
      const n = i.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.activeItemId === n && this.open ? this.closeMenu() : this.openMenu(n);
    },
    handleTriggerEnter(i) {
      const n = i.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.cancelClose(), this.activeItemId !== n && !this.isClosing && requestAnimationFrame(() => this.openMenu(n));
    },
    handleItemEnter(i) {
      const n = i.currentTarget;
      if (!n) return;
      this.cancelClose();
      const r = n.querySelector('[x-ref^="trigger_"]');
      if (r) {
        const s = r.getAttribute("x-ref").replace("trigger_", "");
        this.activeItemId !== s && !this.isClosing && requestAnimationFrame(() => this.openMenu(s));
      } else
        this.open && !this.isClosing && this.closeMenu();
    },
    handleContentEnter() {
      this.cancelClose();
    },
    scheduleClose() {
      this.isClosing || this.closeTimeout || (this.closeTimeout = setTimeout(() => this.closeMenu(), 150));
    },
    cancelClose() {
      this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null), this.isClosing = !1;
    },
    /* ---------- open / close logic with direct DOM manipulation ---------- */
    openMenu(i) {
      this.cancelClose(), this.isClosing = !1;
      const n = this._triggerIndex(i), r = n > (this.prevIndex ?? n) ? "end" : "start", s = this.prevIndex === null;
      if (this.open && this.activeItemId && this.activeItemId !== i) {
        const l = this.$refs[`trigger_${this.activeItemId}`];
        l && delete l.dataset.state;
        const c = this._contentEl(this.activeItemId);
        if (c) {
          const u = r === "end" ? "start" : "end";
          c.setAttribute("data-motion", `to-${u}`), setTimeout(() => {
            c.style.display = "none";
          }, 150);
        }
      }
      this.activeItemId = i, this.open = !0, this.prevIndex = n;
      const o = this.$refs[`trigger_${i}`], a = this._contentEl(i);
      !o || !a || (Et(o, a, {
        placement: "bottom-start",
        middleware: [wt(6), xt(), _t({ padding: 8 })]
      }).then(({ x: l, y: c }) => {
        Object.assign(a.style, { left: `${l}px`, top: `${c}px` });
      }), a.style.display = "block", s ? a.setAttribute("data-motion", "fade-in") : a.setAttribute("data-motion", `from-${r}`), this.$nextTick(() => {
        o.setAttribute("aria-expanded", "true"), o.dataset.state = "open";
      }));
    },
    closeMenu() {
      if (!this.open || this.isClosing) return;
      this.isClosing = !0, this.cancelClose();
      const i = this.activeItemId;
      if (!i) {
        this.isClosing = !1;
        return;
      }
      const n = this.$refs[`trigger_${i}`];
      n && (n.setAttribute("aria-expanded", "false"), delete n.dataset.state);
      const r = this._contentEl(i);
      r && (r.setAttribute("data-motion", "fade-out"), setTimeout(() => {
        r.style.display = "none";
      }, 150)), this.open = !1, this.activeItemId = null, this.prevIndex = null, setTimeout(() => {
        this.isClosing = !1;
      }, 150);
    }
  }));
}
function Ec(e) {
  e.data("rzPopover", () => ({
    open: !1,
    ariaExpanded: "false",
    triggerEl: null,
    contentEl: null,
    init() {
      this.triggerEl = this.$refs.trigger, this.contentEl = this.$refs.content, this.$watch("open", (t) => {
        this.ariaExpanded = t.toString(), t && this.$nextTick(() => this.updatePosition());
      });
    },
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      const t = this.$el.dataset.anchor || "bottom", i = parseInt(this.$el.dataset.offset) || 0, n = parseInt(this.$el.dataset.crossAxisOffset) || 0, r = parseInt(this.$el.dataset.alignmentAxisOffset) || null, s = this.$el.dataset.strategy || "absolute", o = this.$el.dataset.enableFlip !== "false", a = this.$el.dataset.enableShift !== "false", l = parseInt(this.$el.dataset.shiftPadding) || 8;
      let c = [];
      c.push(wt({
        mainAxis: i,
        crossAxis: n,
        alignmentAxis: r
      })), o && c.push(xt()), a && c.push(_t({ padding: l })), Et(this.triggerEl, this.contentEl, {
        placement: t,
        strategy: s,
        middleware: c
      }).then(({ x: u, y: d }) => {
        Object.assign(this.contentEl.style, {
          left: `${u}px`,
          top: `${d}px`
        });
      });
    },
    toggle() {
      this.open = !this.open;
    },
    handleOutsideClick() {
      this.open && (this.open = !1);
    },
    handleWindowEscape() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    }
  }));
}
function Ic(e) {
  e.data("rzPrependInput", () => ({
    prependContainer: null,
    textInput: null,
    init() {
      this.prependContainer = this.$refs.prependContainer, this.textInput = this.$refs.textInput;
      let t = this;
      setTimeout(() => {
        t.updatePadding();
      }, 50), window.addEventListener("resize", this.updatePadding);
    },
    destroy() {
      window.removeEventListener("resize", this.updatePadding);
    },
    updatePadding() {
      const t = this.prependContainer, i = this.textInput;
      if (!t || !i) {
        i && i.classList.remove("text-transparent");
        return;
      }
      const r = t.offsetWidth + 10;
      i.style.paddingLeft = r + "px", i.classList.remove("text-transparent");
    }
  }));
}
function Cc(e) {
  e.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const t = this.$el;
      this.currentVal = parseInt(t.getAttribute("data-current-val")) || 0, this.minVal = parseInt(t.getAttribute("data-min-val")) || 0, this.maxVal = parseInt(t.getAttribute("data-max-val")) || 100, this.label = t.getAttribute("data-label"), this.calculatePercentage(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuemin", this.minVal), t.setAttribute("aria-valuemax", this.maxVal), t.setAttribute("aria-valuetext", `${this.percentage}%`), this.updateProgressBar(), new ResizeObserver((n) => {
        this.updateProgressBar();
      }).observe(t), this.$watch("currentVal", () => {
        this.calculatePercentage(), this.updateProgressBar(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      this.maxVal === this.minVal ? this.percentage = 0 : this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
    },
    buildLabel() {
      var t = this.label || "{percent}%";
      return this.calculatePercentage(), t.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const t = this.$refs.progressBar, i = this.$refs.progressBarLabel, n = this.$refs.innerLabel;
      i && t && n && (n.innerText = this.buildLabel(), i.clientWidth > t.clientWidth ? i.style.left = t.clientWidth + 10 + "px" : i.style.left = t.clientWidth / 2 - i.clientWidth / 2 + "px");
    },
    getLabelCss() {
      const t = this.$refs.progressBarLabel, i = this.$refs.progressBar;
      return t && i && t.clientWidth > i.clientWidth ? "text-foreground dark:text-foreground" : "";
    },
    updateProgressBar() {
      const t = this.$refs.progressBar;
      t && (t.style.width = `${this.percentage}%`, this.buildInsideLabelPosition());
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(t) {
      this.currentVal = t;
    },
    increment(t = 1) {
      this.currentVal = Math.min(this.currentVal + t, this.maxVal);
    },
    decrement(t = 1) {
      this.currentVal = Math.max(this.currentVal - t, this.minVal);
    }
  }));
}
function Tc(e) {
  e.data("rzQuickReferenceContainer", () => ({
    headings: [],
    // Array of heading IDs
    currentHeadingId: "",
    // ID of the currently highlighted heading
    // Initializes the component with headings and the initial current heading from data attributes.
    init() {
      this.headings = JSON.parse(this.$el.dataset.headings || "[]"), this.currentHeadingId = this.$el.dataset.currentheadingid || "";
    },
    // Handles click events on quick reference links.
    handleHeadingClick() {
      const t = this.$el.dataset.headingid;
      window.requestAnimationFrame(() => {
        this.currentHeadingId = t;
      });
    },
    // Sets the current heading ID based on intersection observer events from rzHeading.
    setCurrentHeading(t) {
      this.headings.includes(t) && (this.currentHeadingId = t);
    },
    // Provides CSS classes for a link based on whether it's the current heading.
    // Returns an object suitable for :class binding.
    getSelectedCss() {
      const t = this.$el.dataset.headingid;
      return {
        "font-bold": this.currentHeadingId === t
        // Apply 'font-bold' if current
      };
    },
    // Determines the value for the aria-current attribute.
    getSelectedAriaCurrent() {
      const t = this.$el.dataset.headingid;
      return this.currentHeadingId === t ? "true" : null;
    }
  }));
}
function Sc(e) {
  e.data("rzSheet", () => ({
    open: !1,
    init() {
      this.open = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.open = !this.open;
    },
    close() {
      this.open = !1;
    },
    show() {
      this.open = !0;
    },
    state() {
      return this.open ? "open" : "closed";
    }
  }));
}
function Ac(e) {
  e.data("rzTabs", () => ({
    selectedTab: "",
    _triggers: [],
    _observer: null,
    init() {
      const t = this.$el.dataset.defaultValue;
      this._observer = new MutationObserver(() => this.refreshTriggers()), this._observer.observe(this.$el, { childList: !0, subtree: !0 }), this.refreshTriggers(), t && this._triggers.some((i) => i.dataset.value === t) ? this.selectedTab = t : this._triggers.length > 0 && (this.selectedTab = this._triggers[0].dataset.value);
    },
    destroy() {
      this._observer && this._observer.disconnect();
    },
    refreshTriggers() {
      this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
    },
    onTriggerClick(t) {
      const i = t.currentTarget?.dataset?.value;
      !i || t.currentTarget.getAttribute("aria-disabled") === "true" || (this.selectedTab = i, this.$dispatch("rz:tabs-change", { value: this.selectedTab }));
    },
    isSelected(t) {
      return this.selectedTab === t;
    },
    bindTrigger() {
      this.selectedTab;
      const t = this.$el.dataset.value, i = this.isSelected(t), n = this.$el.getAttribute("aria-disabled") === "true";
      return {
        "aria-selected": String(i),
        tabindex: i ? "0" : "-1",
        "data-state": i ? "active" : "inactive",
        ...n && { disabled: !0 }
      };
    },
    _attrDisabled() {
      return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
    },
    _attrAriaSelected() {
      return String(this.$el.dataset.value === this.selectedTab);
    },
    _attrHidden() {
      return this.$el.dataset.value === this.selectedTab ? null : "true";
    },
    _attrAriaHidden() {
      return String(this.selectedTab !== this.$el.dataset.value);
    },
    _attrDataState() {
      return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
    },
    _attrTabIndex() {
      return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
    },
    onListKeydown(t) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(t.key)) {
        t.preventDefault();
        const i = this._triggers.filter((l) => l.getAttribute("aria-disabled") !== "true");
        if (i.length === 0) return;
        const n = i.findIndex((l) => l.dataset.value === this.selectedTab);
        if (n === -1) return;
        const r = t.currentTarget?.getAttribute("aria-orientation") === "vertical", s = r ? "ArrowUp" : "ArrowLeft", o = r ? "ArrowDown" : "ArrowRight";
        let a = n;
        switch (t.key) {
          case s:
            a = n - 1 < 0 ? i.length - 1 : n - 1;
            break;
          case o:
            a = (n + 1) % i.length;
            break;
          case "Home":
            a = 0;
            break;
          case "End":
            a = i.length - 1;
            break;
        }
        if (a >= 0 && a < i.length) {
          const l = i[a];
          this.selectedTab = l.dataset.value, this.$nextTick(() => l.focus());
        }
      }
    }
  }));
}
function Oc(e) {
  e.data("rzSidebar", () => ({
    open: !1,
    openMobile: !1,
    isMobile: !1,
    collapsible: "offcanvas",
    shortcut: "b",
    cookieName: "sidebar_state",
    mobileBreakpoint: 768,
    init() {
      this.collapsible = this.$el.dataset.collapsible || "offcanvas", this.shortcut = this.$el.dataset.shortcut || "b", this.cookieName = this.$el.dataset.cookieName || "sidebar_state", this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
      const t = this.cookieName ? document.cookie.split("; ").find((n) => n.startsWith(`${this.cookieName}=`))?.split("=")[1] : null, i = this.$el.dataset.defaultOpen === "true";
      this.open = t !== null ? t === "true" : i, this.checkIfMobile(), window.addEventListener("keydown", (n) => {
        (n.ctrlKey || n.metaKey) && n.key.toLowerCase() === this.shortcut.toLowerCase() && (n.preventDefault(), this.toggle());
      }), this.$watch("open", (n) => {
        this.cookieName && (document.cookie = `${this.cookieName}=${n}; path=/; max-age=31536000`);
      });
    },
    checkIfMobile() {
      this.isMobile = window.innerWidth < this.mobileBreakpoint;
    },
    toggle() {
      this.isMobile ? this.openMobile = !this.openMobile : this.open = !this.open;
    },
    close() {
      this.isMobile && (this.openMobile = !1);
    },
    isMobileOpen() {
      return this.openMobile;
    },
    desktopState() {
      return this.open ? "expanded" : "collapsed";
    },
    mobileState() {
      return this.openMobile ? "open" : "closed";
    },
    getCollapsibleAttribute() {
      return this.desktopState() === "collapsed" ? this.collapsible : "";
    }
  }));
}
function $c(e) {
  e.data("rzCommand", () => ({
    // --- STATE ---
    search: "",
    selectedValue: null,
    selectedIndex: -1,
    items: [],
    filteredItems: [],
    groupTemplates: /* @__PURE__ */ new Map(),
    activeDescendantId: null,
    isOpen: !1,
    isEmpty: !0,
    firstRender: !0,
    isLoading: !1,
    error: null,
    // --- CONFIG ---
    loop: !1,
    shouldFilter: !0,
    itemsUrl: null,
    fetchTrigger: "immediate",
    serverFiltering: !1,
    dataItemTemplateId: null,
    _dataFetched: !1,
    _debounceTimer: null,
    // --- COMPUTED (CSP-Compliant Methods) ---
    showLoading() {
      return this.isLoading;
    },
    hasError() {
      return this.error !== null;
    },
    notHasError() {
      return this.error == null;
    },
    shouldShowEmpty() {
      return this.isEmpty && this.search && !this.isLoading && !this.error;
    },
    shouldShowEmptyOrError() {
      return this.isEmpty && this.search && !this.isLoading || this.error !== null;
    },
    // --- LIFECYCLE ---
    init() {
      this.loop = this.$el.dataset.loop === "true", this.shouldFilter = this.$el.dataset.shouldFilter !== "false", this.selectedValue = this.$el.dataset.selectedValue || null, this.itemsUrl = this.$el.dataset.itemsUrl || null, this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate", this.serverFiltering = this.$el.dataset.serverFiltering === "true", this.dataItemTemplateId = this.$el.dataset.templateId || null;
      const t = this.$el.dataset.itemsId;
      let i = [];
      if (t) {
        const n = document.getElementById(t);
        if (n)
          try {
            i = JSON.parse(n.textContent || "[]");
          } catch (r) {
            console.error(`RzCommand: Failed to parse JSON from script tag #${t}`, r);
          }
      }
      i.length > 0 && !this.dataItemTemplateId && console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them."), i.forEach((n) => {
        n.id = n.id || `static-item-${crypto.randomUUID()}`, n.isDataItem = !0, this.registerItem(n);
      }), this.itemsUrl && this.fetchTrigger === "immediate" && this.fetchItems(), this.$watch("search", (n) => {
        this.firstRender = !1, this.serverFiltering ? (clearTimeout(this._debounceTimer), this._debounceTimer = setTimeout(() => {
          this.fetchItems(n);
        }, 300)) : this.filterAndSortItems();
      }), this.$watch("selectedIndex", (n, r) => {
        if (r > -1) {
          const s = this.filteredItems[r];
          if (s) {
            const o = this.$el.querySelector(`[data-command-item-id="${s.id}"]`);
            o && (o.removeAttribute("data-selected"), o.setAttribute("aria-selected", "false"));
          }
        }
        if (n > -1 && this.filteredItems[n]) {
          const s = this.filteredItems[n];
          this.activeDescendantId = s.id;
          const o = this.$el.querySelector(`[data-command-item-id="${s.id}"]`);
          o && (o.setAttribute("data-selected", "true"), o.setAttribute("aria-selected", "true"), o.scrollIntoView({ block: "nearest" }));
          const a = s.value;
          this.selectedValue !== a && (this.selectedValue = a, this.$dispatch("rz:command:select", { value: a }));
        } else
          this.activeDescendantId = null, this.selectedValue = null;
      }), this.$watch("selectedValue", (n) => {
        const r = this.filteredItems.findIndex((s) => s.value === n);
        this.selectedIndex !== r && (this.selectedIndex = r);
      }), this.$watch("filteredItems", (n) => {
        this.isOpen = n.length > 0 || this.isLoading, this.isEmpty = n.length === 0, this.firstRender || window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
          detail: {
            items: this.filteredItems,
            groups: this.groupTemplates,
            commandId: this.$el.id
          }
        }));
      });
    },
    // --- METHODS ---
    async fetchItems(t = "") {
      if (this.itemsUrl) {
        if (!this.dataItemTemplateId) {
          console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data."), this.error = "Configuration error: No data template found.";
          return;
        }
        this.isLoading = !0, this.error = null;
        try {
          const i = new URL(this.itemsUrl, window.location.origin);
          this.serverFiltering && t && i.searchParams.append("q", t);
          const n = await fetch(i);
          if (!n.ok)
            throw new Error(`Network response was not ok: ${n.statusText}`);
          const r = await n.json();
          this.serverFiltering && (this.items = this.items.filter((s) => !s.isDataItem)), r.forEach((s) => {
            s.id = s.id || `data-item-${crypto.randomUUID()}`, s.isDataItem = !0, this.registerItem(s);
          }), this._dataFetched = !0;
        } catch (i) {
          this.error = i.message || "Failed to fetch command items.", console.error("RzCommand:", this.error);
        } finally {
          this.isLoading = !1, this.filterAndSortItems();
        }
      }
    },
    handleInteraction() {
      this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched && this.fetchItems();
    },
    registerItem(t) {
      this.items.some((i) => i.id === t.id) || (t._order = this.items.length, this.items.push(t), this.selectedIndex === -1 && (this.selectedIndex = 0), this.serverFiltering || this.filterAndSortItems());
    },
    unregisterItem(t) {
      this.items = this.items.filter((i) => i.id !== t), this.filterAndSortItems();
    },
    registerGroupTemplate(t, i) {
      this.groupTemplates.has(t) || this.groupTemplates.set(t, i);
    },
    filterAndSortItems() {
      if (this.serverFiltering && this._dataFetched) {
        this.filteredItems = this.items, this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        return;
      }
      let t;
      if (!this.shouldFilter || !this.search ? t = this.items.map((i) => ({ ...i, score: 1 })) : t = this.items.map((i) => ({
        ...i,
        score: i.forceMount ? 0 : this.commandScore(i.name, this.search, i.keywords)
      })).filter((i) => i.score > 0 || i.forceMount).sort((i, n) => i.forceMount && !n.forceMount ? 1 : !i.forceMount && n.forceMount ? -1 : n.score !== i.score ? n.score - i.score : (i._order || 0) - (n._order || 0)), this.filteredItems = t, this.selectedValue) {
        const i = this.filteredItems.findIndex((n) => n.value === this.selectedValue);
        this.selectedIndex = i > -1 ? i : this.filteredItems.length > 0 ? 0 : -1;
      } else
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
    },
    // --- EVENT HANDLERS ---
    handleItemClick(t) {
      const i = t.target.closest("[data-command-item-id]");
      if (!i) return;
      const n = i.dataset.commandItemId, r = this.filteredItems.findIndex((s) => s.id === n);
      if (r > -1) {
        const s = this.filteredItems[r];
        s && !s.disabled && (this.selectedIndex = r, this.$dispatch("rz:command:execute", { value: s.value }));
      }
    },
    handleItemHover(t) {
      const i = t.target.closest("[data-command-item-id]");
      if (!i) return;
      const n = i.dataset.commandItemId, r = this.filteredItems.findIndex((s) => s.id === n);
      if (r > -1) {
        const s = this.filteredItems[r];
        s && !s.disabled && this.selectedIndex !== r && (this.selectedIndex = r);
      }
    },
    // --- KEYBOARD NAVIGATION ---
    handleKeydown(t) {
      switch (t.key) {
        case "ArrowDown":
          t.preventDefault(), this.selectNext();
          break;
        case "ArrowUp":
          t.preventDefault(), this.selectPrev();
          break;
        case "Home":
          t.preventDefault(), this.selectFirst();
          break;
        case "End":
          t.preventDefault(), this.selectLast();
          break;
        case "Enter":
          t.preventDefault();
          const i = this.filteredItems[this.selectedIndex];
          i && !i.disabled && this.$dispatch("rz:command:execute", { value: i.value });
          break;
      }
    },
    selectNext() {
      if (this.filteredItems.length === 0) return;
      let t = this.selectedIndex, i = 0;
      do {
        if (t = t + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : t + 1, i++, !this.filteredItems[t]?.disabled) {
          this.selectedIndex = t;
          return;
        }
        if (!this.loop && t === this.filteredItems.length - 1) return;
      } while (i <= this.filteredItems.length);
    },
    selectPrev() {
      if (this.filteredItems.length === 0) return;
      let t = this.selectedIndex, i = 0;
      do {
        if (t = t - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : t - 1, i++, !this.filteredItems[t]?.disabled) {
          this.selectedIndex = t;
          return;
        }
        if (!this.loop && t === 0) return;
      } while (i <= this.filteredItems.length);
    },
    selectFirst() {
      if (this.filteredItems.length > 0) {
        const t = this.filteredItems.findIndex((i) => !i.disabled);
        t > -1 && (this.selectedIndex = t);
      }
    },
    selectLast() {
      if (this.filteredItems.length > 0) {
        const t = this.filteredItems.map((i) => i.disabled).lastIndexOf(!1);
        t > -1 && (this.selectedIndex = t);
      }
    },
    // --- SCORING ALGORITHM (Adapted from cmdk) ---
    commandScore(t, i, n = []) {
      const d = /[\\/_+.#"@[\(\{&]/, f = /[\s-]/, y = `${t} ${n ? n.join(" ") : ""}`;
      function m(p) {
        return p.toLowerCase().replace(/[\s-]/g, " ");
      }
      function v(p, b, h, _, E, x, g) {
        if (x === b.length)
          return E === p.length ? 1 : 0.99;
        const w = `${E},${x}`;
        if (g[w] !== void 0) return g[w];
        const I = _.charAt(x);
        let C = h.indexOf(I, E), T = 0;
        for (; C >= 0; ) {
          let S = v(p, b, h, _, C + 1, x + 1, g);
          S > T && (C === E ? S *= 1 : d.test(p.charAt(C - 1)) ? S *= 0.8 : f.test(p.charAt(C - 1)) ? S *= 0.9 : (S *= 0.17, E > 0 && (S *= Math.pow(0.999, C - E))), p.charAt(C) !== b.charAt(x) && (S *= 0.9999)), S > T && (T = S), C = h.indexOf(I, C + 1);
        }
        return g[w] = T, T;
      }
      return v(y, i, m(y), m(i), 0, 0, {});
    }
  }));
}
function Nc(e) {
  e.data("rzCommandItem", () => ({
    parent: null,
    itemData: {},
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandItem must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.itemData = {
        id: this.$el.id,
        value: this.$el.dataset.value || this.$el.textContent.trim(),
        name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
        keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
        group: this.$el.dataset.group || null,
        templateId: this.$el.id + "-template",
        disabled: this.$el.dataset.disabled === "true",
        forceMount: this.$el.dataset.forceMount === "true"
      }, this.parent.registerItem(this.itemData);
    },
    destroy() {
      this.parent && this.parent.unregisterItem(this.itemData.id);
    }
  }));
}
function kc(e) {
  e.data("rzCommandList", () => ({
    parent: null,
    dataItemTemplate: null,
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandList must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.parent.dataItemTemplateId && (this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId));
    },
    renderList(t) {
      if (t.detail.commandId !== this.parent.$el.id) return;
      const i = t.detail.items || [], n = t.detail.groups || /* @__PURE__ */ new Map(), r = this.$el;
      r.querySelectorAll("[data-dynamic-item]").forEach((o) => o.remove());
      const s = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
      i.forEach((o) => {
        const a = o.group || "__ungrouped__";
        s.has(a) || s.set(a, []), s.get(a).push(o);
      }), s.forEach((o, a) => {
        if (o.length === 0) return;
        const l = document.createElement("div");
        if (l.setAttribute("role", "group"), l.setAttribute("data-dynamic-item", "true"), l.setAttribute("data-slot", "command-group"), a !== "__ungrouped__") {
          const c = n.get(a);
          if (c) {
            const u = document.getElementById(c);
            if (u && u.content) {
              const d = u.content.cloneNode(!0), f = d.firstElementChild;
              f && (l.setAttribute("aria-labelledby", f.id), l.appendChild(d));
            }
          }
        }
        o.forEach((c) => {
          const u = this.parent.filteredItems.indexOf(c);
          let d;
          if (c.isDataItem) {
            if (!this.dataItemTemplate)
              return;
            d = this.dataItemTemplate.content.cloneNode(!0).firstElementChild, e.addScopeToNode(d, { item: c });
          } else {
            const f = document.getElementById(c.templateId);
            f && f.content && (d = f.content.cloneNode(!0).querySelector(`[data-command-item-id="${c.id}"]`));
          }
          d && (d.setAttribute("data-command-item-id", c.id), d.setAttribute("data-value", c.value), c.keywords && d.setAttribute("data-keywords", JSON.stringify(c.keywords)), c.group && d.setAttribute("data-group", c.group), c.disabled && d.setAttribute("data-disabled", "true"), c.forceMount && d.setAttribute("data-force-mount", "true"), d.setAttribute("role", "option"), d.setAttribute("aria-selected", this.parent.selectedIndex === u), c.disabled && d.setAttribute("aria-disabled", "true"), this.parent.selectedIndex === u && d.setAttribute("data-selected", "true"), l.appendChild(d), e.initTree(d));
        }), r.appendChild(l);
      });
    }
  }));
}
function Rc(e) {
  e.data("rzCommandGroup", () => ({
    parent: null,
    heading: "",
    templateId: "",
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandGroup must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.heading = this.$el.dataset.heading, this.templateId = this.$el.dataset.templateId, this.heading && this.templateId && this.parent.registerGroupTemplate(this.heading, this.templateId);
    }
  }));
}
async function Lc(e) {
  e = [...e].sort();
  const t = e.join("|"), n = new TextEncoder().encode(t), r = await crypto.subtle.digest("SHA-256", n);
  return Array.from(new Uint8Array(r)).map((o) => o.toString(16).padStart(2, "0")).join("");
}
function ue(e, t, i) {
  let n, r;
  typeof t == "function" ? n = { success: t } : t && typeof t == "object" ? n = t : typeof t == "string" && (r = t), !r && typeof i == "string" && (r = i);
  const s = Array.isArray(e) ? e : [e];
  return Lc(s).then((o) => (ne.isDefined(o) || ne(s, o, {
    // keep scripts ordered unless you explicitly change this later
    async: !1,
    // pass CSP nonce to both script and style tags as your loader expects
    inlineScriptNonce: r,
    inlineStyleNonce: r
  }), new Promise((a, l) => {
    ne.ready(o, {
      success: () => {
        try {
          n && typeof n.success == "function" && n.success();
        } catch (c) {
          console.error("[rizzyRequire] success callback threw:", c);
        }
        a({ bundleId: o });
      },
      error: (c) => {
        try {
          n && typeof n.error == "function" && n.error(c);
        } catch (u) {
          console.error("[rizzyRequire] error callback threw:", u);
        }
        l(
          new Error(
            `[rizzyRequire] Failed to load bundle ${o} (missing: ${Array.isArray(c) ? c.join(", ") : String(c)})`
          )
        );
      }
    });
  })));
}
function Pc(e) {
  Sl(e), Al(e), Ol(e), $l(e), Nl(e), kl(e, ue), Rl(e, ue), Ll(e, ue), Pl(e), Dl(e, ue), Ml(e, ue), zl(e), pc(e), mc(e), gc(e), vc(e), bc(e), yc(e), wc(e), _c(e, ue), xc(e), Ec(e), Ic(e), Cc(e), Tc(e), Sc(e), Ac(e), Oc(e), $c(e), Nc(e), kc(e), Rc(e);
}
function Dc(e) {
  if (!(e instanceof Element))
    return console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el)."), {};
  const t = e.dataset.propsId;
  if (!t)
    return {};
  const i = document.getElementById(t);
  if (!i)
    return console.warn(`[Rizzy.props] Could not find the props script tag with ID '${t}'.`), {};
  try {
    return JSON.parse(i.textContent || "{}");
  } catch (n) {
    return console.error(`[Rizzy.props] Failed to parse JSON from script tag #${t}.`, n), {};
  }
}
const st = /* @__PURE__ */ new Map(), ot = /* @__PURE__ */ new Map();
let vn = !1;
function Mc(e) {
  return ot.has(e) || ot.set(
    e,
    import(e).catch((t) => {
      throw ot.delete(e), t;
    })
  ), ot.get(e);
}
function bn(e, t) {
  const i = globalThis.Alpine;
  return i && typeof i.asyncData == "function" ? (i.asyncData(
    e,
    () => Mc(t).catch((n) => (console.error(
      `[RizzyUI] Failed to load Alpine module '${e}' from '${t}'.`,
      n
    ), () => ({
      _error: !0,
      _errorMessage: `Module '${e}' failed to load.`
    })))
  ), !0) : (console.error(
    `[RizzyUI] Could not register async component '${e}'. AsyncAlpine not available.`
  ), !1);
}
function zc(e, t) {
  if (!e || !t) {
    console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
    return;
  }
  const i = st.get(e);
  i && i.path !== t && console.warn(
    `[RizzyUI] Re-registering '${e}' with a different path.
  Previous: ${i.path}
  New:      ${t}`
  );
  const n = globalThis.Alpine;
  if (n && n.version) {
    const r = !i || i.path !== t;
    if (!(i && i.loaderSet && !r)) {
      const o = bn(e, t);
      st.set(e, { path: t, loaderSet: o });
    }
    return;
  }
  st.set(e, { path: t, loaderSet: !1 }), vn || (vn = !0, document.addEventListener(
    "alpine:init",
    () => {
      for (const [r, s] of st)
        if (!s.loaderSet) {
          const o = bn(r, s.path);
          s.loaderSet = o;
        }
    },
    { once: !0 }
  ));
}
function Fc(e) {
  e.directive("mobile", (t, { modifiers: i, expression: n }, { cleanup: r }) => {
    const s = i.find((b) => b.startsWith("bp-")), o = s ? parseInt(s.slice(3), 10) : 768, a = !!(n && n.length > 0);
    if (typeof window > "u" || !window.matchMedia) {
      t.dataset.mobile = "false", t.dataset.screen = "desktop";
      return;
    }
    const l = () => window.innerWidth < o, c = (b) => {
      t.dataset.mobile = b ? "true" : "false", t.dataset.screen = b ? "mobile" : "desktop";
    }, u = () => typeof e.$data == "function" ? e.$data(t) : t.__x ? t.__x.$data : null, d = (b) => {
      if (!a) return;
      const h = u();
      h && (h[n] = b);
    }, f = (b) => {
      t.dispatchEvent(
        new CustomEvent("screen:change", {
          bubbles: !0,
          detail: { isMobile: b, width: window.innerWidth, breakpoint: o }
        })
      );
    }, y = window.matchMedia(`(max-width: ${o - 1}px)`), m = () => {
      const b = l();
      c(b), d(b), f(b);
    };
    m();
    const v = () => m(), p = () => m();
    y.addEventListener("change", v), window.addEventListener("resize", p, { passive: !0 }), r(() => {
      y.removeEventListener("change", v), window.removeEventListener("resize", p);
    });
  });
}
function Uc(e) {
  const t = (i, { expression: n, modifiers: r }, { cleanup: s, effect: o }) => {
    if (!n || typeof n != "string") return;
    const a = (v, p, b) => {
      const _ = p.replace(/\[(\d+)\]/g, ".$1").split("."), E = _.pop();
      let x = v;
      for (const g of _)
        (x[g] == null || typeof x[g] != "object") && (x[g] = isFinite(+g) ? [] : {}), x = x[g];
      x[E] = b;
    }, l = e.closestDataStack(i) || [], c = l[0] || null, u = l[1] || null;
    if (!c || !u) {
      import.meta?.env?.DEV && console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
      return;
    }
    const d = n.split(",").map((v) => v.trim()).filter(Boolean).map((v) => {
      const p = v.split("->").map((b) => b.trim());
      return p.length !== 2 ? (console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', v), null) : { parentPath: p[0], childPath: p[1] };
    }).filter(Boolean), f = r.includes("init-child") || r.includes("child") || r.includes("childWins"), y = d.map(() => ({
      fromParent: !1,
      fromChild: !1,
      skipChildOnce: f
      // avoid redundant first child->parent write
    })), m = [];
    d.forEach((v, p) => {
      const b = y[p];
      if (f) {
        const E = e.evaluate(i, v.childPath, { scope: c });
        b.fromChild = !0, a(u, v.parentPath, E), queueMicrotask(() => {
          b.fromChild = !1;
        });
      } else {
        const E = e.evaluate(i, v.parentPath, { scope: u });
        b.fromParent = !0, a(c, v.childPath, E), queueMicrotask(() => {
          b.fromParent = !1;
        });
      }
      const h = o(() => {
        const E = e.evaluate(i, v.parentPath, { scope: u });
        b.fromChild || (b.fromParent = !0, a(c, v.childPath, E), queueMicrotask(() => {
          b.fromParent = !1;
        }));
      }), _ = o(() => {
        const E = e.evaluate(i, v.childPath, { scope: c });
        if (!b.fromParent) {
          if (b.skipChildOnce) {
            b.skipChildOnce = !1;
            return;
          }
          b.fromChild = !0, a(u, v.parentPath, E), queueMicrotask(() => {
            b.fromChild = !1;
          });
        }
      });
      m.push(h, _);
    }), s(() => {
      for (const v of m)
        try {
          v && v();
        } catch {
        }
    });
  };
  e.directive("syncprop", t);
}
class Bc {
  constructor() {
    this.storageKey = "darkMode", this.eventName = "rz:theme-change", this.darkClass = "dark", this._mode = "auto", this._mq = null, this._initialized = !1, this._onMqChange = null, this._onStorage = null, this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  init() {
    if (this._initialized || typeof window > "u") return;
    this._initialized = !0, this._mq = typeof window.matchMedia == "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
    const t = this._safeReadStorage(this.storageKey);
    this._mode = this._normalizeMode(t ?? "auto"), this._sync(), this._onMqChange = () => {
      this._sync();
    }, this._mq && (typeof this._mq.addEventListener == "function" ? this._mq.addEventListener("change", this._onMqChange) : typeof this._mq.addListener == "function" && this._mq.addListener(this._onMqChange)), this._onStorage = (i) => {
      if (i.key !== this.storageKey) return;
      const n = this._normalizeMode(i.newValue ?? "auto");
      n !== this._mode && (this._mode = n, this._sync());
    }, window.addEventListener("storage", this._onStorage);
  }
  destroy() {
    this._initialized && (this._initialized = !1, this._mq && this._onMqChange && (typeof this._mq.removeEventListener == "function" ? this._mq.removeEventListener("change", this._onMqChange) : typeof this._mq.removeListener == "function" && this._mq.removeListener(this._onMqChange)), typeof window < "u" && this._onStorage && window.removeEventListener("storage", this._onStorage), this._onMqChange = null, this._onStorage = null, this._mq = null, this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null });
  }
  // ----- Public State Accessors -----
  get mode() {
    return this._mode;
  }
  get prefersDark() {
    return !!this._mq?.matches;
  }
  get effectiveDark() {
    return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
  }
  // ----- Public API Surface -----
  isDark() {
    return this.effectiveDark;
  }
  isLight() {
    return !this.effectiveDark;
  }
  setLight() {
    this._setMode("light");
  }
  setDark() {
    this._setMode("dark");
  }
  setAuto() {
    this._setMode("auto");
  }
  toggle() {
    const t = this.effectiveDark;
    this._setMode(t ? "light" : "dark");
  }
  // ----- Internals -----
  _setMode(t) {
    this._mode = this._normalizeMode(t), this._persist(), this._sync();
  }
  _normalizeMode(t) {
    return t === "light" || t === "dark" || t === "auto" ? t : "auto";
  }
  _safeReadStorage(t) {
    try {
      return window?.localStorage?.getItem(t);
    } catch {
      return null;
    }
  }
  _persist() {
    try {
      window?.localStorage?.setItem(this.storageKey, this._mode);
    } catch {
    }
  }
  _sync() {
    const t = this.effectiveDark, i = this._mode, n = this.prefersDark, r = typeof document < "u" ? document.documentElement : null, s = r ? r.classList.contains(this.darkClass) === t && r.style.colorScheme === (t ? "dark" : "light") : !0;
    this._lastSnapshot.mode === i && this._lastSnapshot.effectiveDark === t && this._lastSnapshot.prefersDark === n && s || (this._lastSnapshot = { mode: i, effectiveDark: t, prefersDark: n }, r && (r.classList.toggle(this.darkClass, t), r.style.colorScheme = t ? "dark" : "light"), typeof window < "u" && window.dispatchEvent(
      new CustomEvent(this.eventName, {
        detail: {
          mode: i,
          darkMode: t,
          // External API uses 'darkMode' convention
          prefersDark: n,
          source: "RizzyUI"
        }
      })
    ));
  }
}
const D = new Bc();
function jc(e) {
  D.init(), e.store("theme", {
    // Reactive state mirrors
    // We mirror ALL derived properties to ensure Alpine reactivity works 
    // for bindings like x-show="prefersDark" or x-text="mode".
    _mode: D.mode,
    _prefersDark: D.prefersDark,
    _effectiveDark: D.effectiveDark,
    // Listener reference to prevent duplicate registration
    _onThemeChange: null,
    init() {
      this._onThemeChange || (this._onThemeChange = () => this._refresh(), window.addEventListener(D.eventName, this._onThemeChange)), this._refresh();
    },
    _refresh() {
      this._mode = D.mode, this._prefersDark = D.prefersDark, this._effectiveDark = D.effectiveDark;
    },
    // ----- Reactive Getters -----
    // These return the reactive properties from the store, ensuring Alpine
    // properly tracks dependencies.
    get mode() {
      return this._mode;
    },
    get effectiveDark() {
      return this._effectiveDark;
    },
    get prefersDark() {
      return this._prefersDark;
    },
    // Expose as getters (not methods) for consistency
    get isDark() {
      return this._effectiveDark;
    },
    get isLight() {
      return !this._effectiveDark;
    },
    // ----- Proxy Methods -----
    setLight() {
      D.setLight();
    },
    setDark() {
      D.setDark();
    },
    setAuto() {
      D.setAuto();
    },
    toggle() {
      D.toggle();
    }
  });
}
let Ue = null;
function Vc(e) {
  return Ue || (e.plugin(Sa), e.plugin(ka), e.plugin(Qa), e.plugin(ll), typeof document < "u" && document.addEventListener("alpine:init", () => {
    jc(e);
  }), Pc(e), Fc(e), Uc(e), Ue = {
    Alpine: e,
    require: ue,
    toast: _l,
    $data: Cl,
    props: Dc,
    registerAsyncComponent: zc,
    theme: D
  }, typeof window < "u" && (D.init(), window.Alpine = e, window.Rizzy = { ...window.Rizzy || {}, ...Ue }, document.dispatchEvent(new CustomEvent("rz:init", {
    detail: { Rizzy: window.Rizzy }
  }))), Ue);
}
const Hc = Vc(Nr);
Nr.start();
export {
  Hc as default
};
</file>

<file path="wwwroot/js/rizzyui-csp.min.js">
(function(le,ce){typeof exports=="object"&&typeof module<"u"?module.exports=ce():typeof define=="function"&&define.amd?define(ce):(le=typeof globalThis<"u"?globalThis:le||self,le.RizzyUICsp=ce())})(this,function(){"use strict";var le=!1,ce=!1,ue=[],zt=-1;function cs(e){us(e)}function us(e){ue.includes(e)||ue.push(e),fs()}function ds(e){let t=ue.indexOf(e);t!==-1&&t>zt&&ue.splice(t,1)}function fs(){!ce&&!le&&(le=!0,queueMicrotask(hs))}function hs(){le=!1,ce=!0;for(let e=0;e<ue.length;e++)ue[e](),zt=e;ue.length=0,zt=-1,ce=!1}var Ie,de,Ce,Mi,Ft=!0;function ps(e){Ft=!1,e(),Ft=!0}function ms(e){Ie=e.reactive,Ce=e.release,de=t=>e.effect(t,{scheduler:i=>{Ft?cs(i):i()}}),Mi=e.raw}function zi(e){de=e}function gs(e){let t=()=>{};return[n=>{let r=de(n);return e._x_effects||(e._x_effects=new Set,e._x_runEffects=()=>{e._x_effects.forEach(s=>s())}),e._x_effects.add(r),t=()=>{r!==void 0&&(e._x_effects.delete(r),Ce(r))},r},()=>{t()}]}function Fi(e,t){let i=!0,n,r=de(()=>{let s=e();JSON.stringify(s),i?n=s:queueMicrotask(()=>{t(s,n),n=s}),i=!1});return()=>Ce(r)}var Ui=[],Bi=[],ji=[];function vs(e){ji.push(e)}function Ut(e,t){typeof t=="function"?(e._x_cleanups||(e._x_cleanups=[]),e._x_cleanups.push(t)):(t=e,Bi.push(t))}function Vi(e){Ui.push(e)}function Wi(e,t,i){e._x_attributeCleanups||(e._x_attributeCleanups={}),e._x_attributeCleanups[t]||(e._x_attributeCleanups[t]=[]),e._x_attributeCleanups[t].push(i)}function qi(e,t){e._x_attributeCleanups&&Object.entries(e._x_attributeCleanups).forEach(([i,n])=>{(t===void 0||t.includes(i))&&(n.forEach(r=>r()),delete e._x_attributeCleanups[i])})}function bs(e){for(e._x_effects?.forEach(ds);e._x_cleanups?.length;)e._x_cleanups.pop()()}var Bt=new MutationObserver(qt),jt=!1;function Vt(){Bt.observe(document,{subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0}),jt=!0}function Hi(){ys(),Bt.disconnect(),jt=!1}var Pe=[];function ys(){let e=Bt.takeRecords();Pe.push(()=>e.length>0&&qt(e));let t=Pe.length;queueMicrotask(()=>{if(Pe.length===t)for(;Pe.length>0;)Pe.shift()()})}function $(e){if(!jt)return e();Hi();let t=e();return Vt(),t}var Wt=!1,et=[];function ws(){Wt=!0}function _s(){Wt=!1,qt(et),et=[]}function qt(e){if(Wt){et=et.concat(e);return}let t=[],i=new Set,n=new Map,r=new Map;for(let s=0;s<e.length;s++)if(!e[s].target._x_ignoreMutationObserver&&(e[s].type==="childList"&&(e[s].removedNodes.forEach(o=>{o.nodeType===1&&o._x_marker&&i.add(o)}),e[s].addedNodes.forEach(o=>{if(o.nodeType===1){if(i.has(o)){i.delete(o);return}o._x_marker||t.push(o)}})),e[s].type==="attributes")){let o=e[s].target,a=e[s].attributeName,l=e[s].oldValue,c=()=>{n.has(o)||n.set(o,[]),n.get(o).push({name:a,value:o.getAttribute(a)})},u=()=>{r.has(o)||r.set(o,[]),r.get(o).push(a)};o.hasAttribute(a)&&l===null?c():o.hasAttribute(a)?(u(),c()):u()}r.forEach((s,o)=>{qi(o,s)}),n.forEach((s,o)=>{Ui.forEach(a=>a(o,s))});for(let s of i)t.some(o=>o.contains(s))||Bi.forEach(o=>o(s));for(let s of t)s.isConnected&&ji.forEach(o=>o(s));t=null,i=null,n=null,r=null}function Ki(e){return Te(fe(e))}function De(e,t,i){return e._x_dataStack=[t,...fe(i||e)],()=>{e._x_dataStack=e._x_dataStack.filter(n=>n!==t)}}function fe(e){return e._x_dataStack?e._x_dataStack:typeof ShadowRoot=="function"&&e instanceof ShadowRoot?fe(e.host):e.parentNode?fe(e.parentNode):[]}function Te(e){return new Proxy({objects:e},xs)}var xs={ownKeys({objects:e}){return Array.from(new Set(e.flatMap(t=>Object.keys(t))))},has({objects:e},t){return t==Symbol.unscopables?!1:e.some(i=>Object.prototype.hasOwnProperty.call(i,t)||Reflect.has(i,t))},get({objects:e},t,i){return t=="toJSON"?Es:Reflect.get(e.find(n=>Reflect.has(n,t))||{},t,i)},set({objects:e},t,i,n){const r=e.find(o=>Object.prototype.hasOwnProperty.call(o,t))||e[e.length-1],s=Object.getOwnPropertyDescriptor(r,t);return s?.set&&s?.get?s.set.call(n,i)||!0:Reflect.set(r,t,i)}};function Es(){return Reflect.ownKeys(this).reduce((t,i)=>(t[i]=Reflect.get(this,i),t),{})}function Yi(e){let t=n=>typeof n=="object"&&!Array.isArray(n)&&n!==null,i=(n,r="")=>{Object.entries(Object.getOwnPropertyDescriptors(n)).forEach(([s,{value:o,enumerable:a}])=>{if(a===!1||o===void 0||typeof o=="object"&&o!==null&&o.__v_skip)return;let l=r===""?s:`${r}.${s}`;typeof o=="object"&&o!==null&&o._x_interceptor?n[s]=o.initialize(e,l,s):t(o)&&o!==n&&!(o instanceof Element)&&i(o,l)})};return i(e)}function Ji(e,t=()=>{}){let i={initialValue:void 0,_x_interceptor:!0,initialize(n,r,s){return e(this.initialValue,()=>Is(n,r),o=>Ht(n,r,o),r,s)}};return t(i),n=>{if(typeof n=="object"&&n!==null&&n._x_interceptor){let r=i.initialize.bind(i);i.initialize=(s,o,a)=>{let l=n.initialize(s,o,a);return i.initialValue=l,r(s,o,a)}}else i.initialValue=n;return i}}function Is(e,t){return t.split(".").reduce((i,n)=>i[n],e)}function Ht(e,t,i){if(typeof t=="string"&&(t=t.split(".")),t.length===1)e[t[0]]=i;else{if(t.length===0)throw error;return e[t[0]]||(e[t[0]]={}),Ht(e[t[0]],t.slice(1),i)}}var Zi={};function B(e,t){Zi[e]=t}function tt(e,t){let i=Cs(t);return Object.entries(Zi).forEach(([n,r])=>{Object.defineProperty(e,`$${n}`,{get(){return r(t,i)},enumerable:!1})}),e}function Cs(e){let[t,i]=rn(e),n={interceptor:Ji,...t};return Ut(e,i),n}function Gi(e,t,i,...n){try{return i(...n)}catch(r){Me(r,e,t)}}function Me(e,t,i=void 0){e=Object.assign(e??{message:"No error message given."},{el:t,expression:i}),console.warn(`Alpine Expression Error: ${e.message}
${i?'Expression: "'+i+`"
`:""}`,t),setTimeout(()=>{throw e},0)}var ze=!0;function Xi(e){let t=ze;ze=!1;let i=e();return ze=t,i}function he(e,t,i={}){let n;return R(e,t)(r=>n=r,i),n}function R(...e){return Qi(...e)}var Qi=Ss;function Ts(e){Qi=e}function Ss(e,t){let i={};tt(i,e);let n=[i,...fe(e)],r=typeof t=="function"?en(n,t):Os(n,t,e);return Gi.bind(null,e,t,r)}function en(e,t){return(i=()=>{},{scope:n={},params:r=[],context:s}={})=>{let o=t.apply(Te([n,...e]),r);it(i,o)}}var Kt={};function As(e,t){if(Kt[e])return Kt[e];let i=Object.getPrototypeOf(async function(){}).constructor,n=/^[\n\s]*if.*\(.*\)/.test(e.trim())||/^(let|const)\s/.test(e.trim())?`(async()=>{ ${e} })()`:e,s=(()=>{try{let o=new i(["__self","scope"],`with (scope) { __self.result = ${n} }; __self.finished = true; return __self.result;`);return Object.defineProperty(o,"name",{value:`[Alpine] ${e}`}),o}catch(o){return Me(o,t,e),Promise.resolve()}})();return Kt[e]=s,s}function Os(e,t,i){let n=As(t,i);return(r=()=>{},{scope:s={},params:o=[],context:a}={})=>{n.result=void 0,n.finished=!1;let l=Te([s,...e]);if(typeof n=="function"){let c=n.call(a,n,l).catch(u=>Me(u,i,t));n.finished?(it(r,n.result,l,o,i),n.result=void 0):c.then(u=>{it(r,u,l,o,i)}).catch(u=>Me(u,i,t)).finally(()=>n.result=void 0)}}}function it(e,t,i,n,r){if(ze&&typeof t=="function"){let s=t.apply(i,n);s instanceof Promise?s.then(o=>it(e,o,i,n)).catch(o=>Me(o,r,t)):e(s)}else typeof t=="object"&&t instanceof Promise?t.then(s=>e(s)):e(t)}var Yt="x-";function Se(e=""){return Yt+e}function $s(e){Yt=e}var nt={};function N(e,t){return nt[e]=t,{before(i){if(!nt[i]){console.warn(String.raw`Cannot find directive \`${i}\`. \`${e}\` will use the default order of execution`);return}const n=pe.indexOf(i);pe.splice(n>=0?n:pe.indexOf("DEFAULT"),0,e)}}}function Ns(e){return Object.keys(nt).includes(e)}function Jt(e,t,i){if(t=Array.from(t),e._x_virtualDirectives){let s=Object.entries(e._x_virtualDirectives).map(([a,l])=>({name:a,value:l})),o=tn(s);s=s.map(a=>o.find(l=>l.name===a.name)?{name:`x-bind:${a.name}`,value:`"${a.value}"`}:a),t=t.concat(s)}let n={};return t.map(an((s,o)=>n[s]=o)).filter(cn).map(Ls(n,i)).sort(Ps).map(s=>Rs(e,s))}function tn(e){return Array.from(e).map(an()).filter(t=>!cn(t))}var Zt=!1,Fe=new Map,nn=Symbol();function ks(e){Zt=!0;let t=Symbol();nn=t,Fe.set(t,[]);let i=()=>{for(;Fe.get(t).length;)Fe.get(t).shift()();Fe.delete(t)},n=()=>{Zt=!1,i()};e(i),n()}function rn(e){let t=[],i=a=>t.push(a),[n,r]=gs(e);return t.push(r),[{Alpine:je,effect:n,cleanup:i,evaluateLater:R.bind(R,e),evaluate:he.bind(he,e)},()=>t.forEach(a=>a())]}function Rs(e,t){let i=()=>{},n=nt[t.type]||i,[r,s]=rn(e);Wi(e,t.original,s);let o=()=>{e._x_ignore||e._x_ignoreSelf||(n.inline&&n.inline(e,t,r),n=n.bind(n,e,t,r),Zt?Fe.get(nn).push(n):n())};return o.runCleanups=s,o}var sn=(e,t)=>({name:i,value:n})=>(i.startsWith(e)&&(i=i.replace(e,t)),{name:i,value:n}),on=e=>e;function an(e=()=>{}){return({name:t,value:i})=>{let{name:n,value:r}=ln.reduce((s,o)=>o(s),{name:t,value:i});return n!==t&&e(n,t),{name:n,value:r}}}var ln=[];function Gt(e){ln.push(e)}function cn({name:e}){return un().test(e)}var un=()=>new RegExp(`^${Yt}([^:^.]+)\\b`);function Ls(e,t){return({name:i,value:n})=>{let r=i.match(un()),s=i.match(/:([a-zA-Z0-9\-_:]+)/),o=i.match(/\.[^.\]]+(?=[^\]]*$)/g)||[],a=t||e[i]||i;return{type:r?r[1]:null,value:s?s[1]:null,modifiers:o.map(l=>l.replace(".","")),expression:n,original:a}}}var Xt="DEFAULT",pe=["ignore","ref","data","id","anchor","bind","init","for","model","modelable","transition","show","if",Xt,"teleport"];function Ps(e,t){let i=pe.indexOf(e.type)===-1?Xt:e.type,n=pe.indexOf(t.type)===-1?Xt:t.type;return pe.indexOf(i)-pe.indexOf(n)}function Ue(e,t,i={}){e.dispatchEvent(new CustomEvent(t,{detail:i,bubbles:!0,composed:!0,cancelable:!0}))}function me(e,t){if(typeof ShadowRoot=="function"&&e instanceof ShadowRoot){Array.from(e.children).forEach(r=>me(r,t));return}let i=!1;if(t(e,()=>i=!0),i)return;let n=e.firstElementChild;for(;n;)me(n,t),n=n.nextElementSibling}function z(e,...t){console.warn(`Alpine Warning: ${e}`,...t)}var dn=!1;function Ds(){dn&&z("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."),dn=!0,document.body||z("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"),Ue(document,"alpine:init"),Ue(document,"alpine:initializing"),Vt(),vs(t=>G(t,me)),Ut(t=>Oe(t)),Vi((t,i)=>{Jt(t,i).forEach(n=>n())});let e=t=>!rt(t.parentElement,!0);Array.from(document.querySelectorAll(pn().join(","))).filter(e).forEach(t=>{G(t)}),Ue(document,"alpine:initialized"),setTimeout(()=>{Us()})}var Qt=[],fn=[];function hn(){return Qt.map(e=>e())}function pn(){return Qt.concat(fn).map(e=>e())}function mn(e){Qt.push(e)}function gn(e){fn.push(e)}function rt(e,t=!1){return Ae(e,i=>{if((t?pn():hn()).some(r=>i.matches(r)))return!0})}function Ae(e,t){if(e){if(t(e))return e;if(e._x_teleportBack&&(e=e._x_teleportBack),!!e.parentElement)return Ae(e.parentElement,t)}}function Ms(e){return hn().some(t=>e.matches(t))}var vn=[];function zs(e){vn.push(e)}var Fs=1;function G(e,t=me,i=()=>{}){Ae(e,n=>n._x_ignore)||ks(()=>{t(e,(n,r)=>{n._x_marker||(i(n,r),vn.forEach(s=>s(n,r)),Jt(n,n.attributes).forEach(s=>s()),n._x_ignore||(n._x_marker=Fs++),n._x_ignore&&r())})})}function Oe(e,t=me){t(e,i=>{bs(i),qi(i),delete i._x_marker})}function Us(){[["ui","dialog",["[x-dialog], [x-popover]"]],["anchor","anchor",["[x-anchor]"]],["sort","sort",["[x-sort]"]]].forEach(([t,i,n])=>{Ns(i)||n.some(r=>{if(document.querySelector(r))return z(`found "${r}", but missing ${t} plugin`),!0})})}var ei=[],ti=!1;function ii(e=()=>{}){return queueMicrotask(()=>{ti||setTimeout(()=>{ni()})}),new Promise(t=>{ei.push(()=>{e(),t()})})}function ni(){for(ti=!1;ei.length;)ei.shift()()}function Bs(){ti=!0}function ri(e,t){return Array.isArray(t)?bn(e,t.join(" ")):typeof t=="object"&&t!==null?js(e,t):typeof t=="function"?ri(e,t()):bn(e,t)}function bn(e,t){let i=r=>r.split(" ").filter(s=>!e.classList.contains(s)).filter(Boolean),n=r=>(e.classList.add(...r),()=>{e.classList.remove(...r)});return t=t===!0?t="":t||"",n(i(t))}function js(e,t){let i=a=>a.split(" ").filter(Boolean),n=Object.entries(t).flatMap(([a,l])=>l?i(a):!1).filter(Boolean),r=Object.entries(t).flatMap(([a,l])=>l?!1:i(a)).filter(Boolean),s=[],o=[];return r.forEach(a=>{e.classList.contains(a)&&(e.classList.remove(a),o.push(a))}),n.forEach(a=>{e.classList.contains(a)||(e.classList.add(a),s.push(a))}),()=>{o.forEach(a=>e.classList.add(a)),s.forEach(a=>e.classList.remove(a))}}function st(e,t){return typeof t=="object"&&t!==null?Vs(e,t):Ws(e,t)}function Vs(e,t){let i={};return Object.entries(t).forEach(([n,r])=>{i[n]=e.style[n],n.startsWith("--")||(n=qs(n)),e.style.setProperty(n,r)}),setTimeout(()=>{e.style.length===0&&e.removeAttribute("style")}),()=>{st(e,i)}}function Ws(e,t){let i=e.getAttribute("style",t);return e.setAttribute("style",t),()=>{e.setAttribute("style",i||"")}}function qs(e){return e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function si(e,t=()=>{}){let i=!1;return function(){i?t.apply(this,arguments):(i=!0,e.apply(this,arguments))}}N("transition",(e,{value:t,modifiers:i,expression:n},{evaluate:r})=>{typeof n=="function"&&(n=r(n)),n!==!1&&(!n||typeof n=="boolean"?Ks(e,i,t):Hs(e,n,t))});function Hs(e,t,i){yn(e,ri,""),{enter:r=>{e._x_transition.enter.during=r},"enter-start":r=>{e._x_transition.enter.start=r},"enter-end":r=>{e._x_transition.enter.end=r},leave:r=>{e._x_transition.leave.during=r},"leave-start":r=>{e._x_transition.leave.start=r},"leave-end":r=>{e._x_transition.leave.end=r}}[i](t)}function Ks(e,t,i){yn(e,st);let n=!t.includes("in")&&!t.includes("out")&&!i,r=n||t.includes("in")||["enter"].includes(i),s=n||t.includes("out")||["leave"].includes(i);t.includes("in")&&!n&&(t=t.filter((b,h)=>h<t.indexOf("out"))),t.includes("out")&&!n&&(t=t.filter((b,h)=>h>t.indexOf("out")));let o=!t.includes("opacity")&&!t.includes("scale"),a=o||t.includes("opacity"),l=o||t.includes("scale"),c=a?0:1,u=l?Be(t,"scale",95)/100:1,d=Be(t,"delay",0)/1e3,f=Be(t,"origin","center"),y="opacity, transform",m=Be(t,"duration",150)/1e3,v=Be(t,"duration",75)/1e3,p="cubic-bezier(0.4, 0.0, 0.2, 1)";r&&(e._x_transition.enter.during={transformOrigin:f,transitionDelay:`${d}s`,transitionProperty:y,transitionDuration:`${m}s`,transitionTimingFunction:p},e._x_transition.enter.start={opacity:c,transform:`scale(${u})`},e._x_transition.enter.end={opacity:1,transform:"scale(1)"}),s&&(e._x_transition.leave.during={transformOrigin:f,transitionDelay:`${d}s`,transitionProperty:y,transitionDuration:`${v}s`,transitionTimingFunction:p},e._x_transition.leave.start={opacity:1,transform:"scale(1)"},e._x_transition.leave.end={opacity:c,transform:`scale(${u})`})}function yn(e,t,i={}){e._x_transition||(e._x_transition={enter:{during:i,start:i,end:i},leave:{during:i,start:i,end:i},in(n=()=>{},r=()=>{}){oi(e,t,{during:this.enter.during,start:this.enter.start,end:this.enter.end},n,r)},out(n=()=>{},r=()=>{}){oi(e,t,{during:this.leave.during,start:this.leave.start,end:this.leave.end},n,r)}})}window.Element.prototype._x_toggleAndCascadeWithTransitions=function(e,t,i,n){const r=document.visibilityState==="visible"?requestAnimationFrame:setTimeout;let s=()=>r(i);if(t){e._x_transition&&(e._x_transition.enter||e._x_transition.leave)?e._x_transition.enter&&(Object.entries(e._x_transition.enter.during).length||Object.entries(e._x_transition.enter.start).length||Object.entries(e._x_transition.enter.end).length)?e._x_transition.in(i):s():e._x_transition?e._x_transition.in(i):s();return}e._x_hidePromise=e._x_transition?new Promise((o,a)=>{e._x_transition.out(()=>{},()=>o(n)),e._x_transitioning&&e._x_transitioning.beforeCancel(()=>a({isFromCancelledTransition:!0}))}):Promise.resolve(n),queueMicrotask(()=>{let o=wn(e);o?(o._x_hideChildren||(o._x_hideChildren=[]),o._x_hideChildren.push(e)):r(()=>{let a=l=>{let c=Promise.all([l._x_hidePromise,...(l._x_hideChildren||[]).map(a)]).then(([u])=>u?.());return delete l._x_hidePromise,delete l._x_hideChildren,c};a(e).catch(l=>{if(!l.isFromCancelledTransition)throw l})})})};function wn(e){let t=e.parentNode;if(t)return t._x_hidePromise?t:wn(t)}function oi(e,t,{during:i,start:n,end:r}={},s=()=>{},o=()=>{}){if(e._x_transitioning&&e._x_transitioning.cancel(),Object.keys(i).length===0&&Object.keys(n).length===0&&Object.keys(r).length===0){s(),o();return}let a,l,c;Ys(e,{start(){a=t(e,n)},during(){l=t(e,i)},before:s,end(){a(),c=t(e,r)},after:o,cleanup(){l(),c()}})}function Ys(e,t){let i,n,r,s=si(()=>{$(()=>{i=!0,n||t.before(),r||(t.end(),ni()),t.after(),e.isConnected&&t.cleanup(),delete e._x_transitioning})});e._x_transitioning={beforeCancels:[],beforeCancel(o){this.beforeCancels.push(o)},cancel:si(function(){for(;this.beforeCancels.length;)this.beforeCancels.shift()();s()}),finish:s},$(()=>{t.start(),t.during()}),Bs(),requestAnimationFrame(()=>{if(i)return;let o=Number(getComputedStyle(e).transitionDuration.replace(/,.*/,"").replace("s",""))*1e3,a=Number(getComputedStyle(e).transitionDelay.replace(/,.*/,"").replace("s",""))*1e3;o===0&&(o=Number(getComputedStyle(e).animationDuration.replace("s",""))*1e3),$(()=>{t.before()}),n=!0,requestAnimationFrame(()=>{i||($(()=>{t.end()}),ni(),setTimeout(e._x_transitioning.finish,o+a),r=!0)})})}function Be(e,t,i){if(e.indexOf(t)===-1)return i;const n=e[e.indexOf(t)+1];if(!n||t==="scale"&&isNaN(n))return i;if(t==="duration"||t==="delay"){let r=n.match(/([0-9]+)ms/);if(r)return r[1]}return t==="origin"&&["top","right","left","center","bottom"].includes(e[e.indexOf(t)+2])?[n,e[e.indexOf(t)+2]].join(" "):n}var ee=!1;function te(e,t=()=>{}){return(...i)=>ee?t(...i):e(...i)}function Js(e){return(...t)=>ee&&e(...t)}var _n=[];function ot(e){_n.push(e)}function Zs(e,t){_n.forEach(i=>i(e,t)),ee=!0,xn(()=>{G(t,(i,n)=>{n(i,()=>{})})}),ee=!1}var ai=!1;function Gs(e,t){t._x_dataStack||(t._x_dataStack=e._x_dataStack),ee=!0,ai=!0,xn(()=>{Xs(t)}),ee=!1,ai=!1}function Xs(e){let t=!1;G(e,(n,r)=>{me(n,(s,o)=>{if(t&&Ms(s))return o();t=!0,r(s,o)})})}function xn(e){let t=de;zi((i,n)=>{let r=t(i);return Ce(r),()=>{}}),e(),zi(t)}function En(e,t,i,n=[]){switch(e._x_bindings||(e._x_bindings=Ie({})),e._x_bindings[t]=i,t=n.includes("camel")?oo(t):t,t){case"value":Qs(e,i);break;case"style":to(e,i);break;case"class":eo(e,i);break;case"selected":case"checked":io(e,t,i);break;default:In(e,t,i);break}}function Qs(e,t){if(An(e))e.attributes.value===void 0&&(e.value=t),window.fromModel&&(typeof t=="boolean"?e.checked=at(e.value)===t:e.checked=Cn(e.value,t));else if(li(e))Number.isInteger(t)?e.value=t:!Array.isArray(t)&&typeof t!="boolean"&&![null,void 0].includes(t)?e.value=String(t):Array.isArray(t)?e.checked=t.some(i=>Cn(i,e.value)):e.checked=!!t;else if(e.tagName==="SELECT")so(e,t);else{if(e.value===t)return;e.value=t===void 0?"":t}}function eo(e,t){e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedClasses=ri(e,t)}function to(e,t){e._x_undoAddedStyles&&e._x_undoAddedStyles(),e._x_undoAddedStyles=st(e,t)}function io(e,t,i){In(e,t,i),ro(e,t,i)}function In(e,t,i){[null,void 0,!1].includes(i)&&lo(t)?e.removeAttribute(t):(Tn(t)&&(i=t),no(e,t,i))}function no(e,t,i){e.getAttribute(t)!=i&&e.setAttribute(t,i)}function ro(e,t,i){e[t]!==i&&(e[t]=i)}function so(e,t){const i=[].concat(t).map(n=>n+"");Array.from(e.options).forEach(n=>{n.selected=i.includes(n.value)})}function oo(e){return e.toLowerCase().replace(/-(\w)/g,(t,i)=>i.toUpperCase())}function Cn(e,t){return e==t}function at(e){return[1,"1","true","on","yes",!0].includes(e)?!0:[0,"0","false","off","no",!1].includes(e)?!1:e?!!e:null}var ao=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootclonable","shadowrootdelegatesfocus","shadowrootserializable"]);function Tn(e){return ao.has(e)}function lo(e){return!["aria-pressed","aria-checked","aria-expanded","aria-selected"].includes(e)}function co(e,t,i){return e._x_bindings&&e._x_bindings[t]!==void 0?e._x_bindings[t]:Sn(e,t,i)}function uo(e,t,i,n=!0){if(e._x_bindings&&e._x_bindings[t]!==void 0)return e._x_bindings[t];if(e._x_inlineBindings&&e._x_inlineBindings[t]!==void 0){let r=e._x_inlineBindings[t];return r.extract=n,Xi(()=>he(e,r.expression))}return Sn(e,t,i)}function Sn(e,t,i){let n=e.getAttribute(t);return n===null?typeof i=="function"?i():i:n===""?!0:Tn(t)?!![t,"true"].includes(n):n}function li(e){return e.type==="checkbox"||e.localName==="ui-checkbox"||e.localName==="ui-switch"}function An(e){return e.type==="radio"||e.localName==="ui-radio"}function On(e,t){let i;return function(){const n=this,r=arguments,s=function(){i=null,e.apply(n,r)};clearTimeout(i),i=setTimeout(s,t)}}function $n(e,t){let i;return function(){let n=this,r=arguments;i||(e.apply(n,r),i=!0,setTimeout(()=>i=!1,t))}}function Nn({get:e,set:t},{get:i,set:n}){let r=!0,s,o=de(()=>{let a=e(),l=i();if(r)n(ci(a)),r=!1;else{let c=JSON.stringify(a),u=JSON.stringify(l);c!==s?n(ci(a)):c!==u&&t(ci(l))}s=JSON.stringify(e()),JSON.stringify(i())});return()=>{Ce(o)}}function ci(e){return typeof e=="object"?JSON.parse(JSON.stringify(e)):e}function fo(e){(Array.isArray(e)?e:[e]).forEach(i=>i(je))}var ge={},kn=!1;function ho(e,t){if(kn||(ge=Ie(ge),kn=!0),t===void 0)return ge[e];ge[e]=t,Yi(ge[e]),typeof t=="object"&&t!==null&&t.hasOwnProperty("init")&&typeof t.init=="function"&&ge[e].init()}function po(){return ge}var Rn={};function mo(e,t){let i=typeof t!="function"?()=>t:t;return e instanceof Element?Ln(e,i()):(Rn[e]=i,()=>{})}function go(e){return Object.entries(Rn).forEach(([t,i])=>{Object.defineProperty(e,t,{get(){return(...n)=>i(...n)}})}),e}function Ln(e,t,i){let n=[];for(;n.length;)n.pop()();let r=Object.entries(t).map(([o,a])=>({name:o,value:a})),s=tn(r);return r=r.map(o=>s.find(a=>a.name===o.name)?{name:`x-bind:${o.name}`,value:`"${o.value}"`}:o),Jt(e,r,i).map(o=>{n.push(o.runCleanups),o()}),()=>{for(;n.length;)n.pop()()}}var Pn={};function vo(e,t){Pn[e]=t}function bo(e,t){return Object.entries(Pn).forEach(([i,n])=>{Object.defineProperty(e,i,{get(){return(...r)=>n.bind(t)(...r)},enumerable:!1})}),e}var yo={get reactive(){return Ie},get release(){return Ce},get effect(){return de},get raw(){return Mi},version:"3.15.0",flushAndStopDeferringMutations:_s,dontAutoEvaluateFunctions:Xi,disableEffectScheduling:ps,startObservingMutations:Vt,stopObservingMutations:Hi,setReactivityEngine:ms,onAttributeRemoved:Wi,onAttributesAdded:Vi,closestDataStack:fe,skipDuringClone:te,onlyDuringClone:Js,addRootSelector:mn,addInitSelector:gn,interceptClone:ot,addScopeToNode:De,deferMutations:ws,mapAttributes:Gt,evaluateLater:R,interceptInit:zs,setEvaluator:Ts,mergeProxies:Te,extractProp:uo,findClosest:Ae,onElRemoved:Ut,closestRoot:rt,destroyTree:Oe,interceptor:Ji,transition:oi,setStyles:st,mutateDom:$,directive:N,entangle:Nn,throttle:$n,debounce:On,evaluate:he,initTree:G,nextTick:ii,prefixed:Se,prefix:$s,plugin:fo,magic:B,store:ho,start:Ds,clone:Gs,cloneNode:Zs,bound:co,$data:Ki,watch:Fi,walk:me,data:vo,bind:mo},je=yo,k=class{constructor(e,t,i,n){this.type=e,this.value=t,this.start=i,this.end=n}},wo=class{constructor(e){this.input=e,this.position=0,this.tokens=[]}tokenize(){for(;this.position<this.input.length&&(this.skipWhitespace(),!(this.position>=this.input.length));){const e=this.input[this.position];this.isDigit(e)?this.readNumber():this.isAlpha(e)||e==="_"||e==="$"?this.readIdentifierOrKeyword():e==='"'||e==="'"?this.readString():e==="/"&&this.peek()==="/"?this.skipLineComment():this.readOperatorOrPunctuation()}return this.tokens.push(new k("EOF",null,this.position,this.position)),this.tokens}skipWhitespace(){for(;this.position<this.input.length&&/\s/.test(this.input[this.position]);)this.position++}skipLineComment(){for(;this.position<this.input.length&&this.input[this.position]!==`
`;)this.position++}isDigit(e){return/[0-9]/.test(e)}isAlpha(e){return/[a-zA-Z]/.test(e)}isAlphaNumeric(e){return/[a-zA-Z0-9_$]/.test(e)}peek(e=1){return this.input[this.position+e]||""}readNumber(){const e=this.position;let t=!1;for(;this.position<this.input.length;){const n=this.input[this.position];if(this.isDigit(n))this.position++;else if(n==="."&&!t)t=!0,this.position++;else break}const i=this.input.slice(e,this.position);this.tokens.push(new k("NUMBER",parseFloat(i),e,this.position))}readIdentifierOrKeyword(){const e=this.position;for(;this.position<this.input.length&&this.isAlphaNumeric(this.input[this.position]);)this.position++;const t=this.input.slice(e,this.position);["true","false","null","undefined","new","typeof","void","delete","in","instanceof"].includes(t)?t==="true"||t==="false"?this.tokens.push(new k("BOOLEAN",t==="true",e,this.position)):t==="null"?this.tokens.push(new k("NULL",null,e,this.position)):t==="undefined"?this.tokens.push(new k("UNDEFINED",void 0,e,this.position)):this.tokens.push(new k("KEYWORD",t,e,this.position)):this.tokens.push(new k("IDENTIFIER",t,e,this.position))}readString(){const e=this.position,t=this.input[this.position];this.position++;let i="",n=!1;for(;this.position<this.input.length;){const r=this.input[this.position];if(n){switch(r){case"n":i+=`
`;break;case"t":i+="	";break;case"r":i+="\r";break;case"\\":i+="\\";break;case t:i+=t;break;default:i+=r}n=!1}else if(r==="\\")n=!0;else if(r===t){this.position++,this.tokens.push(new k("STRING",i,e,this.position));return}else i+=r;this.position++}throw new Error(`Unterminated string starting at position ${e}`)}readOperatorOrPunctuation(){const e=this.position,t=this.input[this.position],i=this.peek(),n=this.peek(2);if(t==="="&&i==="="&&n==="=")this.position+=3,this.tokens.push(new k("OPERATOR","===",e,this.position));else if(t==="!"&&i==="="&&n==="=")this.position+=3,this.tokens.push(new k("OPERATOR","!==",e,this.position));else if(t==="="&&i==="=")this.position+=2,this.tokens.push(new k("OPERATOR","==",e,this.position));else if(t==="!"&&i==="=")this.position+=2,this.tokens.push(new k("OPERATOR","!=",e,this.position));else if(t==="<"&&i==="=")this.position+=2,this.tokens.push(new k("OPERATOR","<=",e,this.position));else if(t===">"&&i==="=")this.position+=2,this.tokens.push(new k("OPERATOR",">=",e,this.position));else if(t==="&"&&i==="&")this.position+=2,this.tokens.push(new k("OPERATOR","&&",e,this.position));else if(t==="|"&&i==="|")this.position+=2,this.tokens.push(new k("OPERATOR","||",e,this.position));else if(t==="+"&&i==="+")this.position+=2,this.tokens.push(new k("OPERATOR","++",e,this.position));else if(t==="-"&&i==="-")this.position+=2,this.tokens.push(new k("OPERATOR","--",e,this.position));else{this.position++;const r="()[]{},.;:?".includes(t)?"PUNCTUATION":"OPERATOR";this.tokens.push(new k(r,t,e,this.position))}}},_o=class{constructor(e){this.tokens=e,this.position=0}parse(){if(this.isAtEnd())throw new Error("Empty expression");const e=this.parseExpression();if(this.match("PUNCTUATION",";"),!this.isAtEnd())throw new Error(`Unexpected token: ${this.current().value}`);return e}parseExpression(){return this.parseAssignment()}parseAssignment(){const e=this.parseTernary();if(this.match("OPERATOR","=")){const t=this.parseAssignment();if(e.type==="Identifier"||e.type==="MemberExpression")return{type:"AssignmentExpression",left:e,operator:"=",right:t};throw new Error("Invalid assignment target")}return e}parseTernary(){const e=this.parseLogicalOr();if(this.match("PUNCTUATION","?")){const t=this.parseExpression();this.consume("PUNCTUATION",":");const i=this.parseExpression();return{type:"ConditionalExpression",test:e,consequent:t,alternate:i}}return e}parseLogicalOr(){let e=this.parseLogicalAnd();for(;this.match("OPERATOR","||");){const t=this.previous().value,i=this.parseLogicalAnd();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseLogicalAnd(){let e=this.parseEquality();for(;this.match("OPERATOR","&&");){const t=this.previous().value,i=this.parseEquality();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseEquality(){let e=this.parseRelational();for(;this.match("OPERATOR","==","!=","===","!==");){const t=this.previous().value,i=this.parseRelational();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseRelational(){let e=this.parseAdditive();for(;this.match("OPERATOR","<",">","<=",">=");){const t=this.previous().value,i=this.parseAdditive();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseAdditive(){let e=this.parseMultiplicative();for(;this.match("OPERATOR","+","-");){const t=this.previous().value,i=this.parseMultiplicative();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseMultiplicative(){let e=this.parseUnary();for(;this.match("OPERATOR","*","/","%");){const t=this.previous().value,i=this.parseUnary();e={type:"BinaryExpression",operator:t,left:e,right:i}}return e}parseUnary(){if(this.match("OPERATOR","++","--")){const e=this.previous().value,t=this.parseUnary();return{type:"UpdateExpression",operator:e,argument:t,prefix:!0}}if(this.match("OPERATOR","!","-","+")){const e=this.previous().value,t=this.parseUnary();return{type:"UnaryExpression",operator:e,argument:t,prefix:!0}}return this.parsePostfix()}parsePostfix(){let e=this.parseMember();return this.match("OPERATOR","++","--")?{type:"UpdateExpression",operator:this.previous().value,argument:e,prefix:!1}:e}parseMember(){let e=this.parsePrimary();for(;;)if(this.match("PUNCTUATION",".")){const t=this.consume("IDENTIFIER");e={type:"MemberExpression",object:e,property:{type:"Identifier",name:t.value},computed:!1}}else if(this.match("PUNCTUATION","[")){const t=this.parseExpression();this.consume("PUNCTUATION","]"),e={type:"MemberExpression",object:e,property:t,computed:!0}}else if(this.match("PUNCTUATION","(")){const t=this.parseArguments();e={type:"CallExpression",callee:e,arguments:t}}else break;return e}parseArguments(){const e=[];if(!this.check("PUNCTUATION",")"))do e.push(this.parseExpression());while(this.match("PUNCTUATION",","));return this.consume("PUNCTUATION",")"),e}parsePrimary(){if(this.match("NUMBER"))return{type:"Literal",value:this.previous().value};if(this.match("STRING"))return{type:"Literal",value:this.previous().value};if(this.match("BOOLEAN"))return{type:"Literal",value:this.previous().value};if(this.match("NULL"))return{type:"Literal",value:null};if(this.match("UNDEFINED"))return{type:"Literal",value:void 0};if(this.match("IDENTIFIER"))return{type:"Identifier",name:this.previous().value};if(this.match("PUNCTUATION","(")){const e=this.parseExpression();return this.consume("PUNCTUATION",")"),e}if(this.match("PUNCTUATION","["))return this.parseArrayLiteral();if(this.match("PUNCTUATION","{"))return this.parseObjectLiteral();throw new Error(`Unexpected token: ${this.current().type} "${this.current().value}"`)}parseArrayLiteral(){const e=[];for(;!this.check("PUNCTUATION","]")&&!this.isAtEnd()&&(e.push(this.parseExpression()),this.match("PUNCTUATION",","));)if(this.check("PUNCTUATION","]"))break;return this.consume("PUNCTUATION","]"),{type:"ArrayExpression",elements:e}}parseObjectLiteral(){const e=[];for(;!this.check("PUNCTUATION","}")&&!this.isAtEnd();){let t,i=!1;if(this.match("STRING"))t={type:"Literal",value:this.previous().value};else if(this.match("IDENTIFIER"))t={type:"Identifier",name:this.previous().value};else if(this.match("PUNCTUATION","["))t=this.parseExpression(),i=!0,this.consume("PUNCTUATION","]");else throw new Error("Expected property key");this.consume("PUNCTUATION",":");const n=this.parseExpression();if(e.push({type:"Property",key:t,value:n,computed:i,shorthand:!1}),this.match("PUNCTUATION",",")){if(this.check("PUNCTUATION","}"))break}else break}return this.consume("PUNCTUATION","}"),{type:"ObjectExpression",properties:e}}match(...e){for(let t=0;t<e.length;t++){const i=e[t];if(t===0&&e.length>1){const n=i;for(let r=1;r<e.length;r++)if(this.check(n,e[r]))return this.advance(),!0;return!1}else if(e.length===1)return this.checkType(i)?(this.advance(),!0):!1}return!1}check(e,t){return this.isAtEnd()?!1:t!==void 0?this.current().type===e&&this.current().value===t:this.current().type===e}checkType(e){return this.isAtEnd()?!1:this.current().type===e}advance(){return this.isAtEnd()||this.position++,this.previous()}isAtEnd(){return this.current().type==="EOF"}current(){return this.tokens[this.position]}previous(){return this.tokens[this.position-1]}consume(e,t){if(t!==void 0){if(this.check(e,t))return this.advance();throw new Error(`Expected ${e} "${t}" but got ${this.current().type} "${this.current().value}"`)}if(this.check(e))return this.advance();throw new Error(`Expected ${e} but got ${this.current().type} "${this.current().value}"`)}},xo=class{evaluate({node:e,scope:t={},context:i=null,allowGlobal:n=!1,forceBindingRootScopeToFunctions:r=!0}){switch(e.type){case"Literal":return e.value;case"Identifier":if(e.name in t){const m=t[e.name];return typeof m=="function"?m.bind(t):m}if(n&&typeof globalThis[e.name]<"u"){const m=globalThis[e.name];return typeof m=="function"?m.bind(globalThis):m}throw new Error(`Undefined variable: ${e.name}`);case"MemberExpression":const s=this.evaluate({node:e.object,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});if(s==null)throw new Error("Cannot read property of null or undefined");let o;if(e.computed){const m=this.evaluate({node:e.property,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});o=s[m]}else o=s[e.property.name];return typeof o=="function"?r?o.bind(t):o.bind(s):o;case"CallExpression":const a=e.arguments.map(m=>this.evaluate({node:m,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}));if(e.callee.type==="MemberExpression"){const m=this.evaluate({node:e.callee.object,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});let v;if(e.callee.computed){const p=this.evaluate({node:e.callee.property,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});v=m[p]}else v=m[e.callee.property.name];if(typeof v!="function")throw new Error("Value is not a function");return v.apply(m,a)}else if(e.callee.type==="Identifier"){const m=e.callee.name;let v;if(m in t)v=t[m];else if(n&&typeof globalThis[m]<"u")v=globalThis[m];else throw new Error(`Undefined variable: ${m}`);if(typeof v!="function")throw new Error("Value is not a function");const p=i!==null?i:t;return v.apply(p,a)}else{const m=this.evaluate({node:e.callee,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});if(typeof m!="function")throw new Error("Value is not a function");return m.apply(i,a)}case"UnaryExpression":const l=this.evaluate({node:e.argument,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});switch(e.operator){case"!":return!l;case"-":return-l;case"+":return+l;default:throw new Error(`Unknown unary operator: ${e.operator}`)}case"UpdateExpression":if(e.argument.type==="Identifier"){const m=e.argument.name;if(!(m in t))throw new Error(`Undefined variable: ${m}`);const v=t[m];return e.operator==="++"?t[m]=v+1:e.operator==="--"&&(t[m]=v-1),e.prefix?t[m]:v}else if(e.argument.type==="MemberExpression"){const m=this.evaluate({node:e.argument.object,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}),v=e.argument.computed?this.evaluate({node:e.argument.property,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}):e.argument.property.name,p=m[v];return e.operator==="++"?m[v]=p+1:e.operator==="--"&&(m[v]=p-1),e.prefix?m[v]:p}throw new Error("Invalid update expression target");case"BinaryExpression":const c=this.evaluate({node:e.left,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}),u=this.evaluate({node:e.right,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});switch(e.operator){case"+":return c+u;case"-":return c-u;case"*":return c*u;case"/":return c/u;case"%":return c%u;case"==":return c==u;case"!=":return c!=u;case"===":return c===u;case"!==":return c!==u;case"<":return c<u;case">":return c>u;case"<=":return c<=u;case">=":return c>=u;case"&&":return c&&u;case"||":return c||u;default:throw new Error(`Unknown binary operator: ${e.operator}`)}case"ConditionalExpression":return this.evaluate({node:e.test,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r})?this.evaluate({node:e.consequent,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}):this.evaluate({node:e.alternate,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});case"AssignmentExpression":const f=this.evaluate({node:e.right,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});if(e.left.type==="Identifier")return t[e.left.name]=f,f;if(e.left.type==="MemberExpression"){const m=this.evaluate({node:e.left.object,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});if(e.left.computed){const v=this.evaluate({node:e.left.property,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});m[v]=f}else m[e.left.property.name]=f;return f}throw new Error("Invalid assignment target");case"ArrayExpression":return e.elements.map(m=>this.evaluate({node:m,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}));case"ObjectExpression":const y={};for(const m of e.properties){const v=m.computed?this.evaluate({node:m.key,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}):m.key.type==="Identifier"?m.key.name:this.evaluate({node:m.key,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r}),p=this.evaluate({node:m.value,scope:t,context:i,allowGlobal:n,forceBindingRootScopeToFunctions:r});y[v]=p}return y;default:throw new Error(`Unknown node type: ${e.type}`)}}};function Eo(e){try{const i=new wo(e).tokenize(),r=new _o(i).parse(),s=new xo;return function(o={}){const{scope:a={},context:l=null,allowGlobal:c=!1,forceBindingRootScopeToFunctions:u=!1}=o;return s.evaluate({node:r,scope:a,context:l,allowGlobal:c,forceBindingRootScopeToFunctions:u})}}catch(t){throw new Error(`CSP Parser Error: ${t.message}`)}}function Io(e,t){let i=Co(e);if(typeof t=="function")return en(i,t);let n=To(e,t,i);return Gi.bind(null,e,t,n)}function Co(e){let t={};return tt(t,e),[t,...fe(e)]}function To(e,t,i){return(n=()=>{},{scope:r={},params:s=[]}={})=>{let o=Te([r,...i]),l=Eo(t)({scope:o,allowGlobal:!0,forceBindingRootScopeToFunctions:!0});if(ze&&typeof l=="function"){let c=l.apply(l,s);c instanceof Promise?c.then(u=>n(u)):n(c)}else typeof l=="object"&&l instanceof Promise?l.then(c=>n(c)):n(l)}}function So(e,t){const i=Object.create(null),n=e.split(",");for(let r=0;r<n.length;r++)i[n[r]]=!0;return r=>!!i[r]}var Ao=Object.freeze({}),Oo=Object.prototype.hasOwnProperty,lt=(e,t)=>Oo.call(e,t),ve=Array.isArray,Ve=e=>Dn(e)==="[object Map]",$o=e=>typeof e=="string",ui=e=>typeof e=="symbol",ct=e=>e!==null&&typeof e=="object",No=Object.prototype.toString,Dn=e=>No.call(e),Mn=e=>Dn(e).slice(8,-1),di=e=>$o(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,ko=e=>{const t=Object.create(null);return i=>t[i]||(t[i]=e(i))},Ro=ko(e=>e.charAt(0).toUpperCase()+e.slice(1)),zn=(e,t)=>e!==t&&(e===e||t===t),fi=new WeakMap,We=[],H,be=Symbol("iterate"),hi=Symbol("Map key iterate");function Lo(e){return e&&e._isEffect===!0}function Po(e,t=Ao){Lo(e)&&(e=e.raw);const i=zo(e,t);return t.lazy||i(),i}function Do(e){e.active&&(Fn(e),e.options.onStop&&e.options.onStop(),e.active=!1)}var Mo=0;function zo(e,t){const i=function(){if(!i.active)return e();if(!We.includes(i)){Fn(i);try{return Uo(),We.push(i),H=i,e()}finally{We.pop(),Un(),H=We[We.length-1]}}};return i.id=Mo++,i.allowRecurse=!!t.allowRecurse,i._isEffect=!0,i.active=!0,i.raw=e,i.deps=[],i.options=t,i}function Fn(e){const{deps:t}=e;if(t.length){for(let i=0;i<t.length;i++)t[i].delete(e);t.length=0}}var $e=!0,pi=[];function Fo(){pi.push($e),$e=!1}function Uo(){pi.push($e),$e=!0}function Un(){const e=pi.pop();$e=e===void 0?!0:e}function j(e,t,i){if(!$e||H===void 0)return;let n=fi.get(e);n||fi.set(e,n=new Map);let r=n.get(i);r||n.set(i,r=new Set),r.has(H)||(r.add(H),H.deps.push(r),H.options.onTrack&&H.options.onTrack({effect:H,target:e,type:t,key:i}))}function ie(e,t,i,n,r,s){const o=fi.get(e);if(!o)return;const a=new Set,l=u=>{u&&u.forEach(d=>{(d!==H||d.allowRecurse)&&a.add(d)})};if(t==="clear")o.forEach(l);else if(i==="length"&&ve(e))o.forEach((u,d)=>{(d==="length"||d>=n)&&l(u)});else switch(i!==void 0&&l(o.get(i)),t){case"add":ve(e)?di(i)&&l(o.get("length")):(l(o.get(be)),Ve(e)&&l(o.get(hi)));break;case"delete":ve(e)||(l(o.get(be)),Ve(e)&&l(o.get(hi)));break;case"set":Ve(e)&&l(o.get(be));break}const c=u=>{u.options.onTrigger&&u.options.onTrigger({effect:u,target:e,key:i,type:t,newValue:n,oldValue:r,oldTarget:s}),u.options.scheduler?u.options.scheduler(u):u()};a.forEach(c)}var Bo=So("__proto__,__v_isRef,__isVue"),Bn=new Set(Object.getOwnPropertyNames(Symbol).map(e=>Symbol[e]).filter(ui)),jo=Vn(),Vo=Vn(!0),jn=Wo();function Wo(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...i){const n=O(this);for(let s=0,o=this.length;s<o;s++)j(n,"get",s+"");const r=n[t](...i);return r===-1||r===!1?n[t](...i.map(O)):r}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...i){Fo();const n=O(this)[t].apply(this,i);return Un(),n}}),e}function Vn(e=!1,t=!1){return function(n,r,s){if(r==="__v_isReactive")return!e;if(r==="__v_isReadonly")return e;if(r==="__v_raw"&&s===(e?t?ra:Gn:t?na:Zn).get(n))return n;const o=ve(n);if(!e&&o&&lt(jn,r))return Reflect.get(jn,r,s);const a=Reflect.get(n,r,s);return(ui(r)?Bn.has(r):Bo(r))||(e||j(n,"get",r),t)?a:yi(a)?!o||!di(r)?a.value:a:ct(a)?e?Xn(a):bi(a):a}}var qo=Ho();function Ho(e=!1){return function(i,n,r,s){let o=i[n];if(!e&&(r=O(r),o=O(o),!ve(i)&&yi(o)&&!yi(r)))return o.value=r,!0;const a=ve(i)&&di(n)?Number(n)<i.length:lt(i,n),l=Reflect.set(i,n,r,s);return i===O(s)&&(a?zn(r,o)&&ie(i,"set",n,r,o):ie(i,"add",n,r)),l}}function Ko(e,t){const i=lt(e,t),n=e[t],r=Reflect.deleteProperty(e,t);return r&&i&&ie(e,"delete",t,void 0,n),r}function Yo(e,t){const i=Reflect.has(e,t);return(!ui(t)||!Bn.has(t))&&j(e,"has",t),i}function Jo(e){return j(e,"iterate",ve(e)?"length":be),Reflect.ownKeys(e)}var Zo={get:jo,set:qo,deleteProperty:Ko,has:Yo,ownKeys:Jo},Go={get:Vo,set(e,t){return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e),!0},deleteProperty(e,t){return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e),!0}},mi=e=>ct(e)?bi(e):e,gi=e=>ct(e)?Xn(e):e,vi=e=>e,ut=e=>Reflect.getPrototypeOf(e);function dt(e,t,i=!1,n=!1){e=e.__v_raw;const r=O(e),s=O(t);t!==s&&!i&&j(r,"get",t),!i&&j(r,"get",s);const{has:o}=ut(r),a=n?vi:i?gi:mi;if(o.call(r,t))return a(e.get(t));if(o.call(r,s))return a(e.get(s));e!==r&&e.get(t)}function ft(e,t=!1){const i=this.__v_raw,n=O(i),r=O(e);return e!==r&&!t&&j(n,"has",e),!t&&j(n,"has",r),e===r?i.has(e):i.has(e)||i.has(r)}function ht(e,t=!1){return e=e.__v_raw,!t&&j(O(e),"iterate",be),Reflect.get(e,"size",e)}function Wn(e){e=O(e);const t=O(this);return ut(t).has.call(t,e)||(t.add(e),ie(t,"add",e,e)),this}function qn(e,t){t=O(t);const i=O(this),{has:n,get:r}=ut(i);let s=n.call(i,e);s?Jn(i,n,e):(e=O(e),s=n.call(i,e));const o=r.call(i,e);return i.set(e,t),s?zn(t,o)&&ie(i,"set",e,t,o):ie(i,"add",e,t),this}function Hn(e){const t=O(this),{has:i,get:n}=ut(t);let r=i.call(t,e);r?Jn(t,i,e):(e=O(e),r=i.call(t,e));const s=n?n.call(t,e):void 0,o=t.delete(e);return r&&ie(t,"delete",e,void 0,s),o}function Kn(){const e=O(this),t=e.size!==0,i=Ve(e)?new Map(e):new Set(e),n=e.clear();return t&&ie(e,"clear",void 0,void 0,i),n}function pt(e,t){return function(n,r){const s=this,o=s.__v_raw,a=O(o),l=t?vi:e?gi:mi;return!e&&j(a,"iterate",be),o.forEach((c,u)=>n.call(r,l(c),l(u),s))}}function mt(e,t,i){return function(...n){const r=this.__v_raw,s=O(r),o=Ve(s),a=e==="entries"||e===Symbol.iterator&&o,l=e==="keys"&&o,c=r[e](...n),u=i?vi:t?gi:mi;return!t&&j(s,"iterate",l?hi:be),{next(){const{value:d,done:f}=c.next();return f?{value:d,done:f}:{value:a?[u(d[0]),u(d[1])]:u(d),done:f}},[Symbol.iterator](){return this}}}}function ne(e){return function(...t){{const i=t[0]?`on key "${t[0]}" `:"";console.warn(`${Ro(e)} operation ${i}failed: target is readonly.`,O(this))}return e==="delete"?!1:this}}function Xo(){const e={get(s){return dt(this,s)},get size(){return ht(this)},has:ft,add:Wn,set:qn,delete:Hn,clear:Kn,forEach:pt(!1,!1)},t={get(s){return dt(this,s,!1,!0)},get size(){return ht(this)},has:ft,add:Wn,set:qn,delete:Hn,clear:Kn,forEach:pt(!1,!0)},i={get(s){return dt(this,s,!0)},get size(){return ht(this,!0)},has(s){return ft.call(this,s,!0)},add:ne("add"),set:ne("set"),delete:ne("delete"),clear:ne("clear"),forEach:pt(!0,!1)},n={get(s){return dt(this,s,!0,!0)},get size(){return ht(this,!0)},has(s){return ft.call(this,s,!0)},add:ne("add"),set:ne("set"),delete:ne("delete"),clear:ne("clear"),forEach:pt(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{e[s]=mt(s,!1,!1),i[s]=mt(s,!0,!1),t[s]=mt(s,!1,!0),n[s]=mt(s,!0,!0)}),[e,i,t,n]}var[Qo,ea,qc,Hc]=Xo();function Yn(e,t){const i=e?ea:Qo;return(n,r,s)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?n:Reflect.get(lt(i,r)&&r in n?i:n,r,s)}var ta={get:Yn(!1)},ia={get:Yn(!0)};function Jn(e,t,i){const n=O(i);if(n!==i&&t.call(e,n)){const r=Mn(e);console.warn(`Reactive ${r} contains both the raw and reactive versions of the same object${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}var Zn=new WeakMap,na=new WeakMap,Gn=new WeakMap,ra=new WeakMap;function sa(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function oa(e){return e.__v_skip||!Object.isExtensible(e)?0:sa(Mn(e))}function bi(e){return e&&e.__v_isReadonly?e:Qn(e,!1,Zo,ta,Zn)}function Xn(e){return Qn(e,!0,Go,ia,Gn)}function Qn(e,t,i,n,r){if(!ct(e))return console.warn(`value cannot be made reactive: ${String(e)}`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=r.get(e);if(s)return s;const o=oa(e);if(o===0)return e;const a=new Proxy(e,o===2?n:i);return r.set(e,a),a}function O(e){return e&&O(e.__v_raw)||e}function yi(e){return!!(e&&e.__v_isRef===!0)}B("nextTick",()=>ii),B("dispatch",e=>Ue.bind(Ue,e)),B("watch",(e,{evaluateLater:t,cleanup:i})=>(n,r)=>{let s=t(n),a=Fi(()=>{let l;return s(c=>l=c),l},r);i(a)}),B("store",po),B("data",e=>Ki(e)),B("root",e=>rt(e)),B("refs",e=>(e._x_refs_proxy||(e._x_refs_proxy=Te(aa(e))),e._x_refs_proxy));function aa(e){let t=[];return Ae(e,i=>{i._x_refs&&t.push(i._x_refs)}),t}var wi={};function er(e){return wi[e]||(wi[e]=0),++wi[e]}function la(e,t){return Ae(e,i=>{if(i._x_ids&&i._x_ids[t])return!0})}function ca(e,t){e._x_ids||(e._x_ids={}),e._x_ids[t]||(e._x_ids[t]=er(t))}B("id",(e,{cleanup:t})=>(i,n=null)=>{let r=`${i}${n?`-${n}`:""}`;return ua(e,r,t,()=>{let s=la(e,i),o=s?s._x_ids[i]:er(i);return n?`${i}-${o}-${n}`:`${i}-${o}`})}),ot((e,t)=>{e._x_id&&(t._x_id=e._x_id)});function ua(e,t,i,n){if(e._x_id||(e._x_id={}),e._x_id[t])return e._x_id[t];let r=n();return e._x_id[t]=r,i(()=>{delete e._x_id[t]}),r}B("el",e=>e),tr("Focus","focus","focus"),tr("Persist","persist","persist");function tr(e,t,i){B(t,n=>z(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${i}`,n))}N("modelable",(e,{expression:t},{effect:i,evaluateLater:n,cleanup:r})=>{let s=n(t),o=()=>{let u;return s(d=>u=d),u},a=n(`${t} = __placeholder`),l=u=>a(()=>{},{scope:{__placeholder:u}}),c=o();l(c),queueMicrotask(()=>{if(!e._x_model)return;e._x_removeModelListeners.default();let u=e._x_model.get,d=e._x_model.set,f=Nn({get(){return u()},set(y){d(y)}},{get(){return o()},set(y){l(y)}});r(f)})}),N("teleport",(e,{modifiers:t,expression:i},{cleanup:n})=>{e.tagName.toLowerCase()!=="template"&&z("x-teleport can only be used on a <template> tag",e);let r=ir(i),s=e.content.cloneNode(!0).firstElementChild;e._x_teleport=s,s._x_teleportBack=e,e.setAttribute("data-teleport-template",!0),s.setAttribute("data-teleport-target",!0),e._x_forwardEvents&&e._x_forwardEvents.forEach(a=>{s.addEventListener(a,l=>{l.stopPropagation(),e.dispatchEvent(new l.constructor(l.type,l))})}),De(s,{},e);let o=(a,l,c)=>{c.includes("prepend")?l.parentNode.insertBefore(a,l):c.includes("append")?l.parentNode.insertBefore(a,l.nextSibling):l.appendChild(a)};$(()=>{o(s,r,t),te(()=>{G(s)})()}),e._x_teleportPutBack=()=>{let a=ir(i);$(()=>{o(e._x_teleport,a,t)})},n(()=>$(()=>{s.remove(),Oe(s)}))});var da=document.createElement("div");function ir(e){let t=te(()=>document.querySelector(e),()=>da)();return t||z(`Cannot find x-teleport element for selector: "${e}"`),t}var nr=()=>{};nr.inline=(e,{modifiers:t},{cleanup:i})=>{t.includes("self")?e._x_ignoreSelf=!0:e._x_ignore=!0,i(()=>{t.includes("self")?delete e._x_ignoreSelf:delete e._x_ignore})},N("ignore",nr),N("effect",te((e,{expression:t},{effect:i})=>{i(R(e,t))}));function _i(e,t,i,n){let r=e,s=l=>n(l),o={},a=(l,c)=>u=>c(l,u);if(i.includes("dot")&&(t=fa(t)),i.includes("camel")&&(t=ha(t)),i.includes("passive")&&(o.passive=!0),i.includes("capture")&&(o.capture=!0),i.includes("window")&&(r=window),i.includes("document")&&(r=document),i.includes("debounce")){let l=i[i.indexOf("debounce")+1]||"invalid-wait",c=gt(l.split("ms")[0])?Number(l.split("ms")[0]):250;s=On(s,c)}if(i.includes("throttle")){let l=i[i.indexOf("throttle")+1]||"invalid-wait",c=gt(l.split("ms")[0])?Number(l.split("ms")[0]):250;s=$n(s,c)}return i.includes("prevent")&&(s=a(s,(l,c)=>{c.preventDefault(),l(c)})),i.includes("stop")&&(s=a(s,(l,c)=>{c.stopPropagation(),l(c)})),i.includes("once")&&(s=a(s,(l,c)=>{l(c),r.removeEventListener(t,s,o)})),(i.includes("away")||i.includes("outside"))&&(r=document,s=a(s,(l,c)=>{e.contains(c.target)||c.target.isConnected!==!1&&(e.offsetWidth<1&&e.offsetHeight<1||e._x_isShown!==!1&&l(c))})),i.includes("self")&&(s=a(s,(l,c)=>{c.target===e&&l(c)})),(ma(t)||rr(t))&&(s=a(s,(l,c)=>{ga(c,i)||l(c)})),r.addEventListener(t,s,o),()=>{r.removeEventListener(t,s,o)}}function fa(e){return e.replace(/-/g,".")}function ha(e){return e.toLowerCase().replace(/-(\w)/g,(t,i)=>i.toUpperCase())}function gt(e){return!Array.isArray(e)&&!isNaN(e)}function pa(e){return[" ","_"].includes(e)?e:e.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[_\s]/,"-").toLowerCase()}function ma(e){return["keydown","keyup"].includes(e)}function rr(e){return["contextmenu","click","mouse"].some(t=>e.includes(t))}function ga(e,t){let i=t.filter(s=>!["window","document","prevent","stop","once","capture","self","away","outside","passive","preserve-scroll"].includes(s));if(i.includes("debounce")){let s=i.indexOf("debounce");i.splice(s,gt((i[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(i.includes("throttle")){let s=i.indexOf("throttle");i.splice(s,gt((i[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(i.length===0||i.length===1&&sr(e.key).includes(i[0]))return!1;const r=["ctrl","shift","alt","meta","cmd","super"].filter(s=>i.includes(s));return i=i.filter(s=>!r.includes(s)),!(r.length>0&&r.filter(o=>((o==="cmd"||o==="super")&&(o="meta"),e[`${o}Key`])).length===r.length&&(rr(e.type)||sr(e.key).includes(i[0])))}function sr(e){if(!e)return[];e=pa(e);let t={ctrl:"control",slash:"/",space:" ",spacebar:" ",cmd:"meta",esc:"escape",up:"arrow-up",down:"arrow-down",left:"arrow-left",right:"arrow-right",period:".",comma:",",equal:"=",minus:"-",underscore:"_"};return t[e]=e,Object.keys(t).map(i=>{if(t[i]===e)return i}).filter(i=>i)}N("model",(e,{modifiers:t,expression:i},{effect:n,cleanup:r})=>{let s=e;t.includes("parent")&&(s=e.parentNode);let o=R(s,i),a;typeof i=="string"?a=R(s,`${i} = __placeholder`):typeof i=="function"&&typeof i()=="string"?a=R(s,`${i()} = __placeholder`):a=()=>{};let l=()=>{let f;return o(y=>f=y),or(f)?f.get():f},c=f=>{let y;o(m=>y=m),or(y)?y.set(f):a(()=>{},{scope:{__placeholder:f}})};typeof i=="string"&&e.type==="radio"&&$(()=>{e.hasAttribute("name")||e.setAttribute("name",i)});let u=e.tagName.toLowerCase()==="select"||["checkbox","radio"].includes(e.type)||t.includes("lazy")?"change":"input",d=ee?()=>{}:_i(e,u,t,f=>{c(xi(e,t,f,l()))});if(t.includes("fill")&&([void 0,null,""].includes(l())||li(e)&&Array.isArray(l())||e.tagName.toLowerCase()==="select"&&e.multiple)&&c(xi(e,t,{target:e},l())),e._x_removeModelListeners||(e._x_removeModelListeners={}),e._x_removeModelListeners.default=d,r(()=>e._x_removeModelListeners.default()),e.form){let f=_i(e.form,"reset",[],y=>{ii(()=>e._x_model&&e._x_model.set(xi(e,t,{target:e},l())))});r(()=>f())}e._x_model={get(){return l()},set(f){c(f)}},e._x_forceModelUpdate=f=>{f===void 0&&typeof i=="string"&&i.match(/\./)&&(f=""),window.fromModel=!0,$(()=>En(e,"value",f)),delete window.fromModel},n(()=>{let f=l();t.includes("unintrusive")&&document.activeElement.isSameNode(e)||e._x_forceModelUpdate(f)})});function xi(e,t,i,n){return $(()=>{if(i instanceof CustomEvent&&i.detail!==void 0)return i.detail!==null&&i.detail!==void 0?i.detail:i.target.value;if(li(e))if(Array.isArray(n)){let r=null;return t.includes("number")?r=Ei(i.target.value):t.includes("boolean")?r=at(i.target.value):r=i.target.value,i.target.checked?n.includes(r)?n:n.concat([r]):n.filter(s=>!va(s,r))}else return i.target.checked;else{if(e.tagName.toLowerCase()==="select"&&e.multiple)return t.includes("number")?Array.from(i.target.selectedOptions).map(r=>{let s=r.value||r.text;return Ei(s)}):t.includes("boolean")?Array.from(i.target.selectedOptions).map(r=>{let s=r.value||r.text;return at(s)}):Array.from(i.target.selectedOptions).map(r=>r.value||r.text);{let r;return An(e)?i.target.checked?r=i.target.value:r=n:r=i.target.value,t.includes("number")?Ei(r):t.includes("boolean")?at(r):t.includes("trim")?r.trim():r}}})}function Ei(e){let t=e?parseFloat(e):null;return ba(t)?t:e}function va(e,t){return e==t}function ba(e){return!Array.isArray(e)&&!isNaN(e)}function or(e){return e!==null&&typeof e=="object"&&typeof e.get=="function"&&typeof e.set=="function"}N("cloak",e=>queueMicrotask(()=>$(()=>e.removeAttribute(Se("cloak"))))),gn(()=>`[${Se("init")}]`),N("init",te((e,{expression:t},{evaluate:i})=>typeof t=="string"?!!t.trim()&&i(t,{},!1):i(t,{},!1))),N("text",(e,{expression:t},{effect:i,evaluateLater:n})=>{let r=n(t);i(()=>{r(s=>{$(()=>{e.textContent=s})})})}),N("html",(e,{expression:t},{effect:i,evaluateLater:n})=>{let r=n(t);i(()=>{r(s=>{$(()=>{e.innerHTML=s,e._x_ignoreSelf=!0,G(e),delete e._x_ignoreSelf})})})}),Gt(sn(":",on(Se("bind:"))));var ar=(e,{value:t,modifiers:i,expression:n,original:r},{effect:s,cleanup:o})=>{if(!t){let l={};go(l),R(e,n)(u=>{Ln(e,u,r)},{scope:l});return}if(t==="key")return ya(e,n);if(e._x_inlineBindings&&e._x_inlineBindings[t]&&e._x_inlineBindings[t].extract)return;let a=R(e,n);s(()=>a(l=>{l===void 0&&typeof n=="string"&&n.match(/\./)&&(l=""),$(()=>En(e,t,l,i))})),o(()=>{e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedStyles&&e._x_undoAddedStyles()})};ar.inline=(e,{value:t,modifiers:i,expression:n})=>{t&&(e._x_inlineBindings||(e._x_inlineBindings={}),e._x_inlineBindings[t]={expression:n,extract:!1})},N("bind",ar);function ya(e,t){e._x_keyExpression=t}mn(()=>`[${Se("data")}]`),N("data",(e,{expression:t},{cleanup:i})=>{if(wa(e))return;t=t===""?"{}":t;let n={};tt(n,e);let r={};bo(r,n);let s=he(e,t,{scope:r});(s===void 0||s===!0)&&(s={}),tt(s,e);let o=Ie(s);Yi(o);let a=De(e,o);o.init&&he(e,o.init),i(()=>{o.destroy&&he(e,o.destroy),a()})}),ot((e,t)=>{e._x_dataStack&&(t._x_dataStack=e._x_dataStack,t.setAttribute("data-has-alpine-state",!0))});function wa(e){return ee?ai?!0:e.hasAttribute("data-has-alpine-state"):!1}N("show",(e,{modifiers:t,expression:i},{effect:n})=>{let r=R(e,i);e._x_doHide||(e._x_doHide=()=>{$(()=>{e.style.setProperty("display","none",t.includes("important")?"important":void 0)})}),e._x_doShow||(e._x_doShow=()=>{$(()=>{e.style.length===1&&e.style.display==="none"?e.removeAttribute("style"):e.style.removeProperty("display")})});let s=()=>{e._x_doHide(),e._x_isShown=!1},o=()=>{e._x_doShow(),e._x_isShown=!0},a=()=>setTimeout(o),l=si(d=>d?o():s(),d=>{typeof e._x_toggleAndCascadeWithTransitions=="function"?e._x_toggleAndCascadeWithTransitions(e,d,o,s):d?a():s()}),c,u=!0;n(()=>r(d=>{!u&&d===c||(t.includes("immediate")&&(d?a():s()),l(d),c=d,u=!1)}))}),N("for",(e,{expression:t},{effect:i,cleanup:n})=>{let r=xa(t),s=R(e,r.items),o=R(e,e._x_keyExpression||"index");e._x_prevKeys=[],e._x_lookup={},i(()=>_a(e,r,s,o)),n(()=>{Object.values(e._x_lookup).forEach(a=>$(()=>{Oe(a),a.remove()})),delete e._x_prevKeys,delete e._x_lookup})});function _a(e,t,i,n){let r=o=>typeof o=="object"&&!Array.isArray(o),s=e;i(o=>{Ea(o)&&o>=0&&(o=Array.from(Array(o).keys(),p=>p+1)),o===void 0&&(o=[]);let a=e._x_lookup,l=e._x_prevKeys,c=[],u=[];if(r(o))o=Object.entries(o).map(([p,b])=>{let h=lr(t,b,p,o);n(_=>{u.includes(_)&&z("Duplicate key on x-for",e),u.push(_)},{scope:{index:p,...h}}),c.push(h)});else for(let p=0;p<o.length;p++){let b=lr(t,o[p],p,o);n(h=>{u.includes(h)&&z("Duplicate key on x-for",e),u.push(h)},{scope:{index:p,...b}}),c.push(b)}let d=[],f=[],y=[],m=[];for(let p=0;p<l.length;p++){let b=l[p];u.indexOf(b)===-1&&y.push(b)}l=l.filter(p=>!y.includes(p));let v="template";for(let p=0;p<u.length;p++){let b=u[p],h=l.indexOf(b);if(h===-1)l.splice(p,0,b),d.push([v,p]);else if(h!==p){let _=l.splice(p,1)[0],E=l.splice(h-1,1)[0];l.splice(p,0,E),l.splice(h,0,_),f.push([_,E])}else m.push(b);v=b}for(let p=0;p<y.length;p++){let b=y[p];b in a&&($(()=>{Oe(a[b]),a[b].remove()}),delete a[b])}for(let p=0;p<f.length;p++){let[b,h]=f[p],_=a[b],E=a[h],x=document.createElement("div");$(()=>{E||z('x-for ":key" is undefined or invalid',s,h,a),E.after(x),_.after(E),E._x_currentIfEl&&E.after(E._x_currentIfEl),x.before(_),_._x_currentIfEl&&_.after(_._x_currentIfEl),x.remove()}),E._x_refreshXForScope(c[u.indexOf(h)])}for(let p=0;p<d.length;p++){let[b,h]=d[p],_=b==="template"?s:a[b];_._x_currentIfEl&&(_=_._x_currentIfEl);let E=c[h],x=u[h],g=document.importNode(s.content,!0).firstElementChild,w=Ie(E);De(g,w,s),g._x_refreshXForScope=I=>{Object.entries(I).forEach(([C,T])=>{w[C]=T})},$(()=>{_.after(g),te(()=>G(g))()}),typeof x=="object"&&z("x-for key cannot be an object, it must be a string or an integer",s),a[x]=g}for(let p=0;p<m.length;p++)a[m[p]]._x_refreshXForScope(c[u.indexOf(m[p])]);s._x_prevKeys=u})}function xa(e){let t=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,i=/^\s*\(|\)\s*$/g,n=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,r=e.match(n);if(!r)return;let s={};s.items=r[2].trim();let o=r[1].replace(i,"").trim(),a=o.match(t);return a?(s.item=o.replace(t,"").trim(),s.index=a[1].trim(),a[2]&&(s.collection=a[2].trim())):s.item=o,s}function lr(e,t,i,n){let r={};return/^\[.*\]$/.test(e.item)&&Array.isArray(t)?e.item.replace("[","").replace("]","").split(",").map(o=>o.trim()).forEach((o,a)=>{r[o]=t[a]}):/^\{.*\}$/.test(e.item)&&!Array.isArray(t)&&typeof t=="object"?e.item.replace("{","").replace("}","").split(",").map(o=>o.trim()).forEach(o=>{r[o]=t[o]}):r[e.item]=t,e.index&&(r[e.index]=i),e.collection&&(r[e.collection]=n),r}function Ea(e){return!Array.isArray(e)&&!isNaN(e)}function cr(){}cr.inline=(e,{expression:t},{cleanup:i})=>{let n=rt(e);n._x_refs||(n._x_refs={}),n._x_refs[t]=e,i(()=>delete n._x_refs[t])},N("ref",cr),N("if",(e,{expression:t},{effect:i,cleanup:n})=>{e.tagName.toLowerCase()!=="template"&&z("x-if can only be used on a <template> tag",e);let r=R(e,t),s=()=>{if(e._x_currentIfEl)return e._x_currentIfEl;let a=e.content.cloneNode(!0).firstElementChild;return De(a,{},e),$(()=>{e.after(a),te(()=>G(a))()}),e._x_currentIfEl=a,e._x_undoIf=()=>{$(()=>{Oe(a),a.remove()}),delete e._x_currentIfEl},a},o=()=>{e._x_undoIf&&(e._x_undoIf(),delete e._x_undoIf)};i(()=>r(a=>{a?s():o()})),n(()=>e._x_undoIf&&e._x_undoIf())}),N("id",(e,{expression:t},{evaluate:i})=>{i(t).forEach(r=>ca(e,r))}),ot((e,t)=>{e._x_ids&&(t._x_ids=e._x_ids)}),Gt(sn("@",on(Se("on:")))),N("on",te((e,{value:t,modifiers:i,expression:n},{cleanup:r})=>{let s=n?R(e,n):()=>{};e.tagName.toLowerCase()==="template"&&(e._x_forwardEvents||(e._x_forwardEvents=[]),e._x_forwardEvents.includes(t)||e._x_forwardEvents.push(t));let o=_i(e,t,i,a=>{s(()=>{},{scope:{$event:a},params:[a]})});r(()=>o())})),vt("Collapse","collapse","collapse"),vt("Intersect","intersect","intersect"),vt("Focus","trap","focus"),vt("Mask","mask","mask");function vt(e,t,i){N(t,n=>z(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${i}`,n))}je.setEvaluator(Io),je.setReactivityEngine({reactive:bi,effect:Po,release:Do,raw:O});var Ia=je,ur=Ia;function Ca(e){e.directive("collapse",t),t.inline=(i,{modifiers:n})=>{n.includes("min")&&(i._x_doShow=()=>{},i._x_doHide=()=>{})};function t(i,{modifiers:n}){let r=dr(n,"duration",250)/1e3,s=dr(n,"min",0),o=!n.includes("min");i._x_isShown||(i.style.height=`${s}px`),!i._x_isShown&&o&&(i.hidden=!0),i._x_isShown||(i.style.overflow="hidden");let a=(c,u)=>{let d=e.setStyles(c,u);return u.height?()=>{}:d},l={transitionProperty:"height",transitionDuration:`${r}s`,transitionTimingFunction:"cubic-bezier(0.4, 0.0, 0.2, 1)"};i._x_transition={in(c=()=>{},u=()=>{}){o&&(i.hidden=!1),o&&(i.style.display=null);let d=i.getBoundingClientRect().height;i.style.height="auto";let f=i.getBoundingClientRect().height;d===f&&(d=s),e.transition(i,e.setStyles,{during:l,start:{height:d+"px"},end:{height:f+"px"}},()=>i._x_isShown=!0,()=>{Math.abs(i.getBoundingClientRect().height-f)<1&&(i.style.overflow=null)})},out(c=()=>{},u=()=>{}){let d=i.getBoundingClientRect().height;e.transition(i,a,{during:l,start:{height:d+"px"},end:{height:s+"px"}},()=>i.style.overflow="hidden",()=>{i._x_isShown=!1,i.style.height==`${s}px`&&o&&(i.style.display="none",i.hidden=!0)})}}}}function dr(e,t,i){if(e.indexOf(t)===-1)return i;const n=e[e.indexOf(t)+1];if(!n)return i;if(t==="duration"){let r=n.match(/([0-9]+)ms/);if(r)return r[1]}if(t==="min"){let r=n.match(/([0-9]+)px/);if(r)return r[1]}return n}var Ta=Ca;function Sa(e){e.directive("intersect",e.skipDuringClone((t,{value:i,expression:n,modifiers:r},{evaluateLater:s,cleanup:o})=>{let a=s(n),l={rootMargin:$a(r),threshold:Aa(r)},c=new IntersectionObserver(u=>{u.forEach(d=>{d.isIntersecting!==(i==="leave")&&(a(),r.includes("once")&&c.disconnect())})},l);c.observe(t),o(()=>{c.disconnect()})}))}function Aa(e){if(e.includes("full"))return .99;if(e.includes("half"))return .5;if(!e.includes("threshold"))return 0;let t=e[e.indexOf("threshold")+1];return t==="100"?1:t==="0"?0:+`.${t}`}function Oa(e){let t=e.match(/^(-?[0-9]+)(px|%)?$/);return t?t[1]+(t[2]||"px"):void 0}function $a(e){const t="margin",i="0px 0px 0px 0px",n=e.indexOf(t);if(n===-1)return i;let r=[];for(let s=1;s<5;s++)r.push(Oa(e[n+s]||""));return r=r.filter(s=>s!==void 0),r.length?r.join(" ").trim():i}var Na=Sa,fr=["input","select","textarea","a[href]","button","[tabindex]:not(slot)","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])',"details>summary:first-of-type","details"],bt=fr.join(","),hr=typeof Element>"u",ye=hr?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,Ii=!hr&&Element.prototype.getRootNode?function(e){return e.getRootNode()}:function(e){return e.ownerDocument},pr=function(t,i,n){var r=Array.prototype.slice.apply(t.querySelectorAll(bt));return i&&ye.call(t,bt)&&r.unshift(t),r=r.filter(n),r},mr=function e(t,i,n){for(var r=[],s=Array.from(t);s.length;){var o=s.shift();if(o.tagName==="SLOT"){var a=o.assignedElements(),l=a.length?a:o.children,c=e(l,!0,n);n.flatten?r.push.apply(r,c):r.push({scope:o,candidates:c})}else{var u=ye.call(o,bt);u&&n.filter(o)&&(i||!t.includes(o))&&r.push(o);var d=o.shadowRoot||typeof n.getShadowRoot=="function"&&n.getShadowRoot(o),f=!n.shadowRootFilter||n.shadowRootFilter(o);if(d&&f){var y=e(d===!0?o.children:d.children,!0,n);n.flatten?r.push.apply(r,y):r.push({scope:o,candidates:y})}else s.unshift.apply(s,o.children)}}return r},gr=function(t,i){return t.tabIndex<0&&(i||/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName)||t.isContentEditable)&&isNaN(parseInt(t.getAttribute("tabindex"),10))?0:t.tabIndex},ka=function(t,i){return t.tabIndex===i.tabIndex?t.documentOrder-i.documentOrder:t.tabIndex-i.tabIndex},vr=function(t){return t.tagName==="INPUT"},Ra=function(t){return vr(t)&&t.type==="hidden"},La=function(t){var i=t.tagName==="DETAILS"&&Array.prototype.slice.apply(t.children).some(function(n){return n.tagName==="SUMMARY"});return i},Pa=function(t,i){for(var n=0;n<t.length;n++)if(t[n].checked&&t[n].form===i)return t[n]},Da=function(t){if(!t.name)return!0;var i=t.form||Ii(t),n=function(a){return i.querySelectorAll('input[type="radio"][name="'+a+'"]')},r;if(typeof window<"u"&&typeof window.CSS<"u"&&typeof window.CSS.escape=="function")r=n(window.CSS.escape(t.name));else try{r=n(t.name)}catch(o){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",o.message),!1}var s=Pa(r,t.form);return!s||s===t},Ma=function(t){return vr(t)&&t.type==="radio"},za=function(t){return Ma(t)&&!Da(t)},br=function(t){var i=t.getBoundingClientRect(),n=i.width,r=i.height;return n===0&&r===0},Fa=function(t,i){var n=i.displayCheck,r=i.getShadowRoot;if(getComputedStyle(t).visibility==="hidden")return!0;var s=ye.call(t,"details>summary:first-of-type"),o=s?t.parentElement:t;if(ye.call(o,"details:not([open]) *"))return!0;var a=Ii(t).host,l=a?.ownerDocument.contains(a)||t.ownerDocument.contains(t);if(!n||n==="full"){if(typeof r=="function"){for(var c=t;t;){var u=t.parentElement,d=Ii(t);if(u&&!u.shadowRoot&&r(u)===!0)return br(t);t.assignedSlot?t=t.assignedSlot:!u&&d!==t.ownerDocument?t=d.host:t=u}t=c}if(l)return!t.getClientRects().length}else if(n==="non-zero-area")return br(t);return!1},Ua=function(t){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))for(var i=t.parentElement;i;){if(i.tagName==="FIELDSET"&&i.disabled){for(var n=0;n<i.children.length;n++){var r=i.children.item(n);if(r.tagName==="LEGEND")return ye.call(i,"fieldset[disabled] *")?!0:!r.contains(t)}return!0}i=i.parentElement}return!1},yt=function(t,i){return!(i.disabled||Ra(i)||Fa(i,t)||La(i)||Ua(i))},Ci=function(t,i){return!(za(i)||gr(i)<0||!yt(t,i))},Ba=function(t){var i=parseInt(t.getAttribute("tabindex"),10);return!!(isNaN(i)||i>=0)},ja=function e(t){var i=[],n=[];return t.forEach(function(r,s){var o=!!r.scope,a=o?r.scope:r,l=gr(a,o),c=o?e(r.candidates):a;l===0?o?i.push.apply(i,c):i.push(a):n.push({documentOrder:s,tabIndex:l,item:r,isScope:o,content:c})}),n.sort(ka).reduce(function(r,s){return s.isScope?r.push.apply(r,s.content):r.push(s.content),r},[]).concat(i)},Va=function(t,i){i=i||{};var n;return i.getShadowRoot?n=mr([t],i.includeContainer,{filter:Ci.bind(null,i),flatten:!1,getShadowRoot:i.getShadowRoot,shadowRootFilter:Ba}):n=pr(t,i.includeContainer,Ci.bind(null,i)),ja(n)},yr=function(t,i){i=i||{};var n;return i.getShadowRoot?n=mr([t],i.includeContainer,{filter:yt.bind(null,i),flatten:!0,getShadowRoot:i.getShadowRoot}):n=pr(t,i.includeContainer,yt.bind(null,i)),n},wt=function(t,i){if(i=i||{},!t)throw new Error("No node provided");return ye.call(t,bt)===!1?!1:Ci(i,t)},Wa=fr.concat("iframe").join(","),_t=function(t,i){if(i=i||{},!t)throw new Error("No node provided");return ye.call(t,Wa)===!1?!1:yt(i,t)};function wr(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),i.push.apply(i,n)}return i}function _r(e){for(var t=1;t<arguments.length;t++){var i=arguments[t]!=null?arguments[t]:{};t%2?wr(Object(i),!0).forEach(function(n){qa(e,n,i[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):wr(Object(i)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))})}return e}function qa(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var xr=function(){var e=[];return{activateTrap:function(i){if(e.length>0){var n=e[e.length-1];n!==i&&n.pause()}var r=e.indexOf(i);r===-1||e.splice(r,1),e.push(i)},deactivateTrap:function(i){var n=e.indexOf(i);n!==-1&&e.splice(n,1),e.length>0&&e[e.length-1].unpause()}}}(),Ha=function(t){return t.tagName&&t.tagName.toLowerCase()==="input"&&typeof t.select=="function"},Ka=function(t){return t.key==="Escape"||t.key==="Esc"||t.keyCode===27},Ya=function(t){return t.key==="Tab"||t.keyCode===9},Er=function(t){return setTimeout(t,0)},Ir=function(t,i){var n=-1;return t.every(function(r,s){return i(r)?(n=s,!1):!0}),n},qe=function(t){for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];return typeof t=="function"?t.apply(void 0,n):t},xt=function(t){return t.target.shadowRoot&&typeof t.composedPath=="function"?t.composedPath()[0]:t.target},Ja=function(t,i){var n=i?.document||document,r=_r({returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0},i),s={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0},o,a=function(g,w,I){return g&&g[w]!==void 0?g[w]:r[I||w]},l=function(g){return s.containerGroups.findIndex(function(w){var I=w.container,C=w.tabbableNodes;return I.contains(g)||C.find(function(T){return T===g})})},c=function(g){var w=r[g];if(typeof w=="function"){for(var I=arguments.length,C=new Array(I>1?I-1:0),T=1;T<I;T++)C[T-1]=arguments[T];w=w.apply(void 0,C)}if(w===!0&&(w=void 0),!w){if(w===void 0||w===!1)return w;throw new Error("`".concat(g,"` was specified but was not a node, or did not return a node"))}var S=w;if(typeof w=="string"&&(S=n.querySelector(w),!S))throw new Error("`".concat(g,"` as selector refers to no known node"));return S},u=function(){var g=c("initialFocus");if(g===!1)return!1;if(g===void 0)if(l(n.activeElement)>=0)g=n.activeElement;else{var w=s.tabbableGroups[0],I=w&&w.firstTabbableNode;g=I||c("fallbackFocus")}if(!g)throw new Error("Your focus-trap needs to have at least one focusable element");return g},d=function(){if(s.containerGroups=s.containers.map(function(g){var w=Va(g,r.tabbableOptions),I=yr(g,r.tabbableOptions);return{container:g,tabbableNodes:w,focusableNodes:I,firstTabbableNode:w.length>0?w[0]:null,lastTabbableNode:w.length>0?w[w.length-1]:null,nextTabbableNode:function(T){var S=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,P=I.findIndex(function(D){return D===T});if(!(P<0))return S?I.slice(P+1).find(function(D){return wt(D,r.tabbableOptions)}):I.slice(0,P).reverse().find(function(D){return wt(D,r.tabbableOptions)})}}}),s.tabbableGroups=s.containerGroups.filter(function(g){return g.tabbableNodes.length>0}),s.tabbableGroups.length<=0&&!c("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")},f=function x(g){if(g!==!1&&g!==n.activeElement){if(!g||!g.focus){x(u());return}g.focus({preventScroll:!!r.preventScroll}),s.mostRecentlyFocusedNode=g,Ha(g)&&g.select()}},y=function(g){var w=c("setReturnFocus",g);return w||(w===!1?!1:g)},m=function(g){var w=xt(g);if(!(l(w)>=0)){if(qe(r.clickOutsideDeactivates,g)){o.deactivate({returnFocus:r.returnFocusOnDeactivate&&!_t(w,r.tabbableOptions)});return}qe(r.allowOutsideClick,g)||g.preventDefault()}},v=function(g){var w=xt(g),I=l(w)>=0;I||w instanceof Document?I&&(s.mostRecentlyFocusedNode=w):(g.stopImmediatePropagation(),f(s.mostRecentlyFocusedNode||u()))},p=function(g){var w=xt(g);d();var I=null;if(s.tabbableGroups.length>0){var C=l(w),T=C>=0?s.containerGroups[C]:void 0;if(C<0)g.shiftKey?I=s.tabbableGroups[s.tabbableGroups.length-1].lastTabbableNode:I=s.tabbableGroups[0].firstTabbableNode;else if(g.shiftKey){var S=Ir(s.tabbableGroups,function(q){var U=q.firstTabbableNode;return w===U});if(S<0&&(T.container===w||_t(w,r.tabbableOptions)&&!wt(w,r.tabbableOptions)&&!T.nextTabbableNode(w,!1))&&(S=C),S>=0){var P=S===0?s.tabbableGroups.length-1:S-1,D=s.tabbableGroups[P];I=D.lastTabbableNode}}else{var J=Ir(s.tabbableGroups,function(q){var U=q.lastTabbableNode;return w===U});if(J<0&&(T.container===w||_t(w,r.tabbableOptions)&&!wt(w,r.tabbableOptions)&&!T.nextTabbableNode(w))&&(J=C),J>=0){var F=J===s.tabbableGroups.length-1?0:J+1,Ee=s.tabbableGroups[F];I=Ee.firstTabbableNode}}}else I=c("fallbackFocus");I&&(g.preventDefault(),f(I))},b=function(g){if(Ka(g)&&qe(r.escapeDeactivates,g)!==!1){g.preventDefault(),o.deactivate();return}if(Ya(g)){p(g);return}},h=function(g){var w=xt(g);l(w)>=0||qe(r.clickOutsideDeactivates,g)||qe(r.allowOutsideClick,g)||(g.preventDefault(),g.stopImmediatePropagation())},_=function(){if(s.active)return xr.activateTrap(o),s.delayInitialFocusTimer=r.delayInitialFocus?Er(function(){f(u())}):f(u()),n.addEventListener("focusin",v,!0),n.addEventListener("mousedown",m,{capture:!0,passive:!1}),n.addEventListener("touchstart",m,{capture:!0,passive:!1}),n.addEventListener("click",h,{capture:!0,passive:!1}),n.addEventListener("keydown",b,{capture:!0,passive:!1}),o},E=function(){if(s.active)return n.removeEventListener("focusin",v,!0),n.removeEventListener("mousedown",m,!0),n.removeEventListener("touchstart",m,!0),n.removeEventListener("click",h,!0),n.removeEventListener("keydown",b,!0),o};return o={get active(){return s.active},get paused(){return s.paused},activate:function(g){if(s.active)return this;var w=a(g,"onActivate"),I=a(g,"onPostActivate"),C=a(g,"checkCanFocusTrap");C||d(),s.active=!0,s.paused=!1,s.nodeFocusedBeforeActivation=n.activeElement,w&&w();var T=function(){C&&d(),_(),I&&I()};return C?(C(s.containers.concat()).then(T,T),this):(T(),this)},deactivate:function(g){if(!s.active)return this;var w=_r({onDeactivate:r.onDeactivate,onPostDeactivate:r.onPostDeactivate,checkCanReturnFocus:r.checkCanReturnFocus},g);clearTimeout(s.delayInitialFocusTimer),s.delayInitialFocusTimer=void 0,E(),s.active=!1,s.paused=!1,xr.deactivateTrap(o);var I=a(w,"onDeactivate"),C=a(w,"onPostDeactivate"),T=a(w,"checkCanReturnFocus"),S=a(w,"returnFocus","returnFocusOnDeactivate");I&&I();var P=function(){Er(function(){S&&f(y(s.nodeFocusedBeforeActivation)),C&&C()})};return S&&T?(T(y(s.nodeFocusedBeforeActivation)).then(P,P),this):(P(),this)},pause:function(){return s.paused||!s.active?this:(s.paused=!0,E(),this)},unpause:function(){return!s.paused||!s.active?this:(s.paused=!1,d(),_(),this)},updateContainerElements:function(g){var w=[].concat(g).filter(Boolean);return s.containers=w.map(function(I){return typeof I=="string"?n.querySelector(I):I}),s.active&&d(),this}},o.updateContainerElements(t),o};function Za(e){let t,i;window.addEventListener("focusin",()=>{t=i,i=document.activeElement}),e.magic("focus",n=>{let r=n;return{__noscroll:!1,__wrapAround:!1,within(s){return r=s,this},withoutScrolling(){return this.__noscroll=!0,this},noscroll(){return this.__noscroll=!0,this},withWrapAround(){return this.__wrapAround=!0,this},wrap(){return this.withWrapAround()},focusable(s){return _t(s)},previouslyFocused(){return t},lastFocused(){return t},focused(){return i},focusables(){return Array.isArray(r)?r:yr(r,{displayCheck:"none"})},all(){return this.focusables()},isFirst(s){let o=this.all();return o[0]&&o[0].isSameNode(s)},isLast(s){let o=this.all();return o.length&&o.slice(-1)[0].isSameNode(s)},getFirst(){return this.all()[0]},getLast(){return this.all().slice(-1)[0]},getNext(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===s.length-1?s[0]:s[s.indexOf(o)+1]},getPrevious(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===0?s.slice(-1)[0]:s[s.indexOf(o)-1]},first(){this.focus(this.getFirst())},last(){this.focus(this.getLast())},next(){this.focus(this.getNext())},previous(){this.focus(this.getPrevious())},prev(){return this.previous()},focus(s){s&&setTimeout(()=>{s.hasAttribute("tabindex")||s.setAttribute("tabindex","0"),s.focus({preventScroll:this.__noscroll})})}}}),e.directive("trap",e.skipDuringClone((n,{expression:r,modifiers:s},{effect:o,evaluateLater:a,cleanup:l})=>{let c=a(r),u=!1,d={escapeDeactivates:!1,allowOutsideClick:!0,fallbackFocus:()=>n},f=()=>{};if(s.includes("noautofocus"))d.initialFocus=!1;else{let p=n.querySelector("[autofocus]");p&&(d.initialFocus=p)}s.includes("inert")&&(d.onPostActivate=()=>{e.nextTick(()=>{f=Cr(n)})});let y=Ja(n,d),m=()=>{};const v=()=>{f(),f=()=>{},m(),m=()=>{},y.deactivate({returnFocus:!s.includes("noreturn")})};o(()=>c(p=>{u!==p&&(p&&!u&&(s.includes("noscroll")&&(m=Ga()),setTimeout(()=>{y.activate()},15)),!p&&u&&v(),u=!!p)})),l(v)},(n,{expression:r,modifiers:s},{evaluate:o})=>{s.includes("inert")&&o(r)&&Cr(n)}))}function Cr(e){let t=[];return Tr(e,i=>{let n=i.hasAttribute("aria-hidden");i.setAttribute("aria-hidden","true"),t.push(()=>n||i.removeAttribute("aria-hidden"))}),()=>{for(;t.length;)t.pop()()}}function Tr(e,t){e.isSameNode(document.body)||!e.parentNode||Array.from(e.parentNode.children).forEach(i=>{i.isSameNode(e)?Tr(e.parentNode,t):t(i)})}function Ga(){let e=document.documentElement.style.overflow,t=document.documentElement.style.paddingRight,i=window.innerWidth-document.documentElement.clientWidth;return document.documentElement.style.overflow="hidden",document.documentElement.style.paddingRight=`${i}px`,()=>{document.documentElement.style.overflow=e,document.documentElement.style.paddingRight=t}}var Xa=Za;/*! Bundled license information:
  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)
  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  */function Qa(){return!0}function el({component:e,argument:t}){return new Promise(i=>{if(t)window.addEventListener(t,()=>i(),{once:!0});else{const n=r=>{r.detail.id===e.id&&(window.removeEventListener("async-alpine:load",n),i())};window.addEventListener("async-alpine:load",n)}})}function tl(){return new Promise(e=>{"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)})}function il({argument:e}){return new Promise(t=>{if(!e)return console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'"),t();const i=window.matchMedia(`(${e})`);i.matches?t():i.addEventListener("change",t,{once:!0})})}function nl({component:e,argument:t}){return new Promise(i=>{const n=t||"0px 0px 0px 0px",r=new IntersectionObserver(s=>{s[0].isIntersecting&&(r.disconnect(),i())},{rootMargin:n});r.observe(e.el)})}var Sr={eager:Qa,event:el,idle:tl,media:il,visible:nl};async function rl(e){const t=sl(e.strategy);await Ti(e,t)}async function Ti(e,t){if(t.type==="expression"){if(t.operator==="&&")return Promise.all(t.parameters.map(i=>Ti(e,i)));if(t.operator==="||")return Promise.any(t.parameters.map(i=>Ti(e,i)))}return Sr[t.method]?Sr[t.method]({component:e,argument:t.argument}):!1}function sl(e){const t=ol(e);let i=Ar(t);return i.type==="method"?{type:"expression",operator:"&&",parameters:[i]}:i}function ol(e){const t=/\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g,i=[];let n;for(;(n=t.exec(e))!==null;){const[r,s,o,a]=n;if(s!==void 0)i.push({type:"parenthesis",value:s});else if(o!==void 0)i.push({type:"operator",value:o==="|"?"&&":o});else{const l={type:"method",method:a.trim()};a.includes("(")&&(l.method=a.substring(0,a.indexOf("(")).trim(),l.argument=a.substring(a.indexOf("(")+1,a.indexOf(")"))),a.method==="immediate"&&(a.method="eager"),i.push(l)}}return i}function Ar(e){let t=Or(e);for(;e.length>0&&(e[0].value==="&&"||e[0].value==="|"||e[0].value==="||");){const i=e.shift().value,n=Or(e);t.type==="expression"&&t.operator===i?t.parameters.push(n):t={type:"expression",operator:i,parameters:[t,n]}}return t}function Or(e){if(e[0].value==="("){e.shift();const t=Ar(e);return e[0].value===")"&&e.shift(),t}else return e.shift()}function al(e){const t="load",i=e.prefixed("load-src"),n=e.prefixed("ignore");let r={defaultStrategy:"eager",keepRelativeURLs:!1},s=!1,o={},a=0;function l(){return a++}e.asyncOptions=h=>{r={...r,...h}},e.asyncData=(h,_=!1)=>{o[h]={loaded:!1,download:_}},e.asyncUrl=(h,_)=>{!h||!_||o[h]||(o[h]={loaded:!1,download:()=>import(b(_))})},e.asyncAlias=h=>{s=h};const c=h=>{e.skipDuringClone(()=>{h._x_async||(h._x_async="init",h._x_ignore=!0,h.setAttribute(n,""))})()},u=async h=>{e.skipDuringClone(async()=>{if(h._x_async!=="init")return;h._x_async="await";const{name:_,strategy:E}=d(h);await rl({name:_,strategy:E,el:h,id:h.id||l()}),h.isConnected&&(await f(_),h.isConnected&&(m(h),h._x_async="loaded"))})()};u.inline=c,e.directive(t,u).before("ignore");function d(h){const _=p(h.getAttribute(e.prefixed("data"))),E=h.getAttribute(e.prefixed(t))||r.defaultStrategy,x=h.getAttribute(i);return x&&e.asyncUrl(_,x),{name:_,strategy:E}}async function f(h){if(h.startsWith("_x_async_")||(v(h),!o[h]||o[h].loaded))return;const _=await y(h);e.data(h,_),o[h].loaded=!0}async function y(h){if(!o[h])return;const _=await o[h].download(h);return typeof _=="function"?_:_[h]||_.default||Object.values(_)[0]||!1}function m(h){e.destroyTree(h),h._x_ignore=!1,h.removeAttribute(n),!h.closest(`[${n}]`)&&e.initTree(h)}function v(h){if(!(!s||o[h])){if(typeof s=="function"){e.asyncData(h,s);return}e.asyncUrl(h,s.replaceAll("[name]",h))}}function p(h){return(h||"").trim().split(/[({]/g)[0]||`_x_async_${l()}`}function b(h){return r.keepRelativeURLs||new RegExp("^(?:[a-z+]+:)?//","i").test(h)?h:new URL(h,document.baseURI).href}}function ll(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function cl(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function ul(e,t,i){return t&&cl(e.prototype,t),e}var dl=Object.defineProperty,X=function(e,t){return dl(e,"name",{value:t,configurable:!0})},fl=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`,hl=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`,pl=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,ml=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,gl=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`,vl=X(function(e){return new DOMParser().parseFromString(e,"text/html").body.childNodes[0]},"stringToHTML"),He=X(function(e){var t=new DOMParser().parseFromString(e,"application/xml");return document.importNode(t.documentElement,!0).outerHTML},"getSvgNode"),A={CONTAINER:"sn-notifications-container",NOTIFY:"sn-notify",NOTIFY_CONTENT:"sn-notify-content",NOTIFY_ICON:"sn-notify-icon",NOTIFY_CLOSE:"sn-notify-close",NOTIFY_TITLE:"sn-notify-title",NOTIFY_TEXT:"sn-notify-text",IS_X_CENTER:"sn-is-x-center",IS_Y_CENTER:"sn-is-y-center",IS_CENTER:"sn-is-center",IS_LEFT:"sn-is-left",IS_RIGHT:"sn-is-right",IS_TOP:"sn-is-top",IS_BOTTOM:"sn-is-bottom",NOTIFY_OUTLINE:"sn-notify-outline",NOTIFY_FILLED:"sn-notify-filled",NOTIFY_ERROR:"sn-notify-error",NOTIFY_WARNING:"sn-notify-warning",NOTIFY_SUCCESS:"sn-notify-success",NOTIFY_INFO:"sn-notify-info",NOTIFY_FADE:"sn-notify-fade",NOTIFY_FADE_IN:"sn-notify-fade-in",NOTIFY_SLIDE:"sn-notify-slide",NOTIFY_SLIDE_IN:"sn-notify-slide-in",NOTIFY_AUTOCLOSE:"sn-notify-autoclose"},re={ERROR:"error",WARNING:"warning",SUCCESS:"success",INFO:"info"},$r={OUTLINE:"outline",FILLED:"filled"},Si={FADE:"fade",SLIDE:"slide"},Ke={CLOSE:He(fl),SUCCESS:He(ml),ERROR:He(hl),WARNING:He(gl),INFO:He(pl)},Nr=X(function(e){e.wrapper.classList.add(A.NOTIFY_FADE),setTimeout(function(){e.wrapper.classList.add(A.NOTIFY_FADE_IN)},100)},"fadeIn"),kr=X(function(e){e.wrapper.classList.remove(A.NOTIFY_FADE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"fadeOut"),bl=X(function(e){e.wrapper.classList.add(A.NOTIFY_SLIDE),setTimeout(function(){e.wrapper.classList.add(A.NOTIFY_SLIDE_IN)},100)},"slideIn"),yl=X(function(e){e.wrapper.classList.remove(A.NOTIFY_SLIDE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"slideOut"),Rr=function(){function e(t){var i=this;ll(this,e),this.notifyOut=X(function(q){q(i)},"notifyOut");var n=t.notificationsGap,r=n===void 0?20:n,s=t.notificationsPadding,o=s===void 0?20:s,a=t.status,l=a===void 0?"success":a,c=t.effect,u=c===void 0?Si.FADE:c,d=t.type,f=d===void 0?"outline":d,y=t.title,m=t.text,v=t.showIcon,p=v===void 0?!0:v,b=t.customIcon,h=b===void 0?"":b,_=t.customClass,E=_===void 0?"":_,x=t.speed,g=x===void 0?500:x,w=t.showCloseButton,I=w===void 0?!0:w,C=t.autoclose,T=C===void 0?!0:C,S=t.autotimeout,P=S===void 0?3e3:S,D=t.position,J=D===void 0?"right top":D,F=t.customWrapper,Ee=F===void 0?"":F;if(this.customWrapper=Ee,this.status=l,this.title=y,this.text=m,this.showIcon=p,this.customIcon=h,this.customClass=E,this.speed=g,this.effect=u,this.showCloseButton=I,this.autoclose=T,this.autotimeout=P,this.notificationsGap=r,this.notificationsPadding=o,this.type=f,this.position=J,!this.checkRequirements()){console.error("You must specify 'title' or 'text' at least.");return}this.setContainer(),this.setWrapper(),this.setPosition(),this.showIcon&&this.setIcon(),this.showCloseButton&&this.setCloseButton(),this.setContent(),this.container.prepend(this.wrapper),this.setEffect(),this.notifyIn(this.selectedNotifyInEffect),this.autoclose&&this.autoClose(),this.setObserver()}return ul(e,[{key:"checkRequirements",value:function(){return!!(this.title||this.text)}},{key:"setContainer",value:function(){var i=document.querySelector(".".concat(A.CONTAINER));i?this.container=i:(this.container=document.createElement("div"),this.container.classList.add(A.CONTAINER),document.body.appendChild(this.container)),this.notificationsPadding&&this.container.style.setProperty("--sn-notifications-padding","".concat(this.notificationsPadding,"px")),this.notificationsGap&&this.container.style.setProperty("--sn-notifications-gap","".concat(this.notificationsGap,"px"))}},{key:"setPosition",value:function(){this.container.classList[this.position==="center"?"add":"remove"](A.IS_CENTER),this.container.classList[this.position.includes("left")?"add":"remove"](A.IS_LEFT),this.container.classList[this.position.includes("right")?"add":"remove"](A.IS_RIGHT),this.container.classList[this.position.includes("top")?"add":"remove"](A.IS_TOP),this.container.classList[this.position.includes("bottom")?"add":"remove"](A.IS_BOTTOM),this.container.classList[this.position.includes("x-center")?"add":"remove"](A.IS_X_CENTER),this.container.classList[this.position.includes("y-center")?"add":"remove"](A.IS_Y_CENTER)}},{key:"setCloseButton",value:function(){var i=this,n=document.createElement("div");n.classList.add(A.NOTIFY_CLOSE),n.innerHTML=Ke.CLOSE,this.wrapper.appendChild(n),n.addEventListener("click",function(){i.close()})}},{key:"setWrapper",value:function(){var i=this;switch(this.customWrapper?this.wrapper=vl(this.customWrapper):this.wrapper=document.createElement("div"),this.wrapper.style.setProperty("--sn-notify-transition-duration","".concat(this.speed,"ms")),this.wrapper.classList.add(A.NOTIFY),this.type){case $r.OUTLINE:this.wrapper.classList.add(A.NOTIFY_OUTLINE);break;case $r.FILLED:this.wrapper.classList.add(A.NOTIFY_FILLED);break;default:this.wrapper.classList.add(A.NOTIFY_OUTLINE)}switch(this.status){case re.SUCCESS:this.wrapper.classList.add(A.NOTIFY_SUCCESS);break;case re.ERROR:this.wrapper.classList.add(A.NOTIFY_ERROR);break;case re.WARNING:this.wrapper.classList.add(A.NOTIFY_WARNING);break;case re.INFO:this.wrapper.classList.add(A.NOTIFY_INFO);break}this.autoclose&&(this.wrapper.classList.add(A.NOTIFY_AUTOCLOSE),this.wrapper.style.setProperty("--sn-notify-autoclose-timeout","".concat(this.autotimeout+this.speed,"ms"))),this.customClass&&this.customClass.split(" ").forEach(function(n){i.wrapper.classList.add(n)})}},{key:"setContent",value:function(){var i=document.createElement("div");i.classList.add(A.NOTIFY_CONTENT);var n,r;this.title&&(n=document.createElement("div"),n.classList.add(A.NOTIFY_TITLE),n.textContent=this.title.trim(),this.showCloseButton||(n.style.paddingRight="0")),this.text&&(r=document.createElement("div"),r.classList.add(A.NOTIFY_TEXT),r.innerHTML=this.text.trim(),this.title||(r.style.marginTop="0")),this.wrapper.appendChild(i),this.title&&i.appendChild(n),this.text&&i.appendChild(r)}},{key:"setIcon",value:function(){var i=X(function(r){switch(r){case re.SUCCESS:return Ke.SUCCESS;case re.ERROR:return Ke.ERROR;case re.WARNING:return Ke.WARNING;case re.INFO:return Ke.INFO}},"computedIcon"),n=document.createElement("div");n.classList.add(A.NOTIFY_ICON),n.innerHTML=this.customIcon||i(this.status),(this.status||this.customIcon)&&this.wrapper.appendChild(n)}},{key:"setObserver",value:function(){var i=this,n=new IntersectionObserver(function(r){if(r[0].intersectionRatio<=0)i.close();else return},{threshold:0});setTimeout(function(){n.observe(i.wrapper)},this.speed)}},{key:"notifyIn",value:function(t){t(this)}},{key:"autoClose",value:function(){var i=this;setTimeout(function(){i.close()},this.autotimeout+this.speed)}},{key:"close",value:function(){this.notifyOut(this.selectedNotifyOutEffect)}},{key:"setEffect",value:function(){switch(this.effect){case Si.FADE:this.selectedNotifyInEffect=Nr,this.selectedNotifyOutEffect=kr;break;case Si.SLIDE:this.selectedNotifyInEffect=bl,this.selectedNotifyOutEffect=yl;break;default:this.selectedNotifyInEffect=Nr,this.selectedNotifyOutEffect=kr}}}]),e}();X(Rr,"Notify");var Lr=Rr;globalThis.Notify=Lr;const Pr=["success","error","warning","info"],Dr=["right top","top right","right bottom","bottom right","left top","top left","left bottom","bottom left","center top","x-center top","center bottom","x-center bottom","left center","left y-center","y-center left","right center","right y-center","y-center right","top center","top x-center","bottom center","bottom x-center","center"],Mr={status:"info",title:"Notification",text:"",effect:"fade",speed:300,autoclose:!0,autotimeout:4e3,position:"right top"};function Ye(e={}){const t={...Mr,...e};Pr.includes(t.status)||(console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`),t.status="info"),Dr.includes(t.position)||(console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`),t.position="right top"),new Lr(t)}const wl={custom:Ye,success(e,t="Success",i={}){Ye({status:"success",title:t,text:e,...i})},error(e,t="Error",i={}){Ye({status:"error",title:t,text:e,...i})},warning(e,t="Warning",i={}){Ye({status:"warning",title:t,text:e,...i})},info(e,t="Info",i={}){Ye({status:"info",title:t,text:e,...i})},setDefaults(e={}){Object.assign(Mr,e)},get allowedStatuses(){return[...Pr]},get allowedPositions(){return[...Dr]}},Ai=function(){},Je={},Et={},Ze={};function _l(e,t){e=Array.isArray(e)?e:[e];const i=[];let n=e.length,r=n,s,o,a,l;for(s=function(c,u){u.length&&i.push(c),r--,r||t(i)};n--;){if(o=e[n],a=Et[o],a){s(o,a);continue}l=Ze[o]=Ze[o]||[],l.push(s)}}function zr(e,t){if(!e)return;const i=Ze[e];if(Et[e]=t,!!i)for(;i.length;)i[0](e,t),i.splice(0,1)}function Oi(e,t){typeof e=="function"&&(e={success:e}),t.length?(e.error||Ai)(t):(e.success||Ai)(e)}function xl(e,t,i,n,r,s,o,a){let l=e.type[0];if(a)try{i.sheet.cssText.length||(l="e")}catch(c){c.code!==18&&(l="e")}if(l==="e"){if(s+=1,s<o)return Fr(t,n,r,s)}else if(i.rel==="preload"&&i.as==="style"){i.rel="stylesheet";return}n(t,l,e.defaultPrevented)}function Fr(e,t,i,n){const r=document,s=i.async,o=(i.numRetries||0)+1,a=i.before||Ai,l=e.replace(/[\?|#].*$/,""),c=e.replace(/^(css|img|module|nomodule)!/,"");let u,d,f;if(n=n||0,/(^css!|\.css$)/.test(l))f=r.createElement("link"),f.rel="stylesheet",f.href=c,u="hideFocus"in f,u&&f.relList&&(u=0,f.rel="preload",f.as="style"),i.inlineStyleNonce&&f.setAttribute("nonce",i.inlineStyleNonce);else if(/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l))f=r.createElement("img"),f.src=c;else if(f=r.createElement("script"),f.src=c,f.async=s===void 0?!0:s,i.inlineScriptNonce&&f.setAttribute("nonce",i.inlineScriptNonce),d="noModule"in f,/^module!/.test(l)){if(!d)return t(e,"l");f.type="module"}else if(/^nomodule!/.test(l)&&d)return t(e,"l");const y=function(m){xl(m,e,f,t,i,n,o,u)};f.addEventListener("load",y,{once:!0}),f.addEventListener("error",y,{once:!0}),a(e,f)!==!1&&r.head.appendChild(f)}function El(e,t,i){e=Array.isArray(e)?e:[e];let n=e.length,r=[];function s(o,a,l){if(a==="e"&&r.push(o),a==="b")if(l)r.push(o);else return;n--,n||t(r)}for(let o=0;o<e.length;o++)Fr(e[o],s,i)}function se(e,t,i){let n,r;if(t&&typeof t=="string"&&t.trim&&(n=t.trim()),r=(n?i:t)||{},n){if(n in Je)throw"LoadJS";Je[n]=!0}function s(o,a){El(e,function(l){Oi(r,l),o&&Oi({success:o,error:a},l),zr(n,l)},r)}if(r.returnPromise)return new Promise(s);s()}se.ready=function(t,i){return _l(t,function(n){Oi(i,n)}),se},se.done=function(t){zr(t,[])},se.reset=function(){Object.keys(Je).forEach(t=>delete Je[t]),Object.keys(Et).forEach(t=>delete Et[t]),Object.keys(Ze).forEach(t=>delete Ze[t])},se.isDefined=function(t){return t in Je};function Il(e){if(typeof Alpine>"u"||typeof Alpine.$data!="function"){console.error("Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data.");return}if(e instanceof Element){const t=Cl(e)||e;let i=Alpine.$data(t);if(i===void 0){const n=t.closest?.("[x-data]");n&&(i=Alpine.$data(n))}return i===void 0&&jr("element",t),i}if(typeof e=="string"){const t=e.trim();if(!t){console.warn("Rizzy.$data: Invalid componentId provided (empty string).");return}const i=`[data-alpine-root="${Br(t)}"]`;let n=null;const r=document.getElementById(t);if(r&&(n=r.matches(i)?r:r.querySelector(i)),n||(n=Ur(t)),!n){console.warn(`Rizzy.$data: Could not locate an Alpine root using ${i} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${t}"' is present.`);return}const s=Alpine.$data(n);return s===void 0&&jr(`data-alpine-root="${t}"`,n),s}console.warn("Rizzy.$data: Expected a non-empty string id or an Element.")}function Cl(e){if(!(e instanceof Element))return null;const t=e.tagName?.toLowerCase?.()==="rz-proxy",i=e.getAttribute?.("data-for");if(t||i){const n=i||"";if(!n)return e;const r=Ur(n);return r||(console.warn(`Rizzy.$data: Proxy element could not resolve Alpine root for id "${n}". Ensure the teleported root rendered with data-alpine-root="${n}".`),null)}return e}function Ur(e){const t=`[data-alpine-root="${Br(e)}"]`,i=document.querySelectorAll(t);for(const n of i)if(n.hasAttribute("x-data"))return n;return i.length>0?i[0]:document.getElementById(e)||null}function Br(e){try{if(window.CSS&&typeof window.CSS.escape=="function")return window.CSS.escape(e)}catch{}return String(e).replace(/"/g,'\\"')}function jr(e,t){const i=`${t.tagName?.toLowerCase?.()||"node"}${t.id?"#"+t.id:""}${t.classList?.length?"."+Array.from(t.classList).join("."):""}`;console.warn(`Rizzy.$data: Located target via ${e} (${i}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`)}function Tl(e){e.data("rzAccordion",()=>({selected:"",allowMultiple:!1,init(){this.allowMultiple=this.$el.dataset.multiple==="true"},destroy(){}}))}function Sl(e){e.data("accordionItem",()=>({open:!1,sectionId:"",expandedClass:"",init(){this.open=this.$el.dataset.isOpen==="true",this.sectionId=this.$el.dataset.sectionId,this.expandedClass=this.$el.dataset.expandedClass;const t=this;typeof this.selected<"u"&&typeof this.allowMultiple<"u"?this.$watch("selected",(i,n)=>{i!==t.sectionId&&!t.allowMultiple&&(t.open=!1)}):console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.")},destroy(){},toggle(){this.selected=this.sectionId,this.open=!this.open},getExpandedCss(){return this.open?this.expandedClass:""},getAriaExpanded(){return this.open?"true":"false"}}))}function Al(e){e.data("rzAlert",()=>({parentElement:null,showAlert:!0,init(){const t=this.$el.dataset.alpineRoot||this.$el.closest("[data-alpine-root]");this.parentElement=document.getElementById(t)},dismiss(){this.showAlert=!1;const t=this;setTimeout(()=>{t.parentElement.style.display="none"},205)}}))}function Ol(e){e.data("rzAspectRatio",()=>({init(){const t=parseFloat(this.$el.dataset.ratio);if(!isNaN(t)&&t>0){const i=100/t+"%";this.$el.style.paddingBottom=i}else this.$el.style.paddingBottom="100%"}}))}function $l(e){e.data("rzBrowser",()=>({screenSize:"",setDesktopScreenSize(){this.screenSize=""},setTabletScreenSize(){this.screenSize="max-w-2xl"},setPhoneScreenSize(){this.screenSize="max-w-sm"},getBrowserBorderCss(){return[this.screenSize,this.screenSize===""?"border-none":"border-x"]},getDesktopScreenCss(){return[this.screenSize===""?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getTabletScreenCss(){return[this.screenSize==="max-w-2xl"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getPhoneScreenCss(){return[this.screenSize==="max-w-sm"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]}}))}function Nl(e,t){e.data("rzCalendar",()=>({calendar:null,initialized:!1,init(){const i=JSON.parse(this.$el.dataset.assets||"[]"),n=this.$el.dataset.configId,r=this.$el.dataset.nonce;if(i.length===0){console.warn("RzCalendar: No assets configured.");return}t(i,{success:()=>{this.initCalendar(n)},error:s=>console.error("RzCalendar: Failed to load assets",s)},r)},initCalendar(i){const n=document.getElementById(i);if(!n){console.error(`RzCalendar: Config element #${i} not found.`);return}let r={};try{r=JSON.parse(n.textContent)}catch(a){console.error("RzCalendar: Failed to parse config JSON",a);return}const s={clickDay:(a,l)=>this.dispatchCalendarEvent("clickDay",{event:a,dates:l.selectedDates}),clickWeekNumber:(a,l,c,u)=>this.dispatchCalendarEvent("clickWeekNumber",{event:a,number:l,days:c,year:u}),clickMonth:(a,l)=>this.dispatchCalendarEvent("clickMonth",{event:a,month:l}),clickYear:(a,l)=>this.dispatchCalendarEvent("clickYear",{event:a,year:l}),clickArrow:(a,l,c)=>this.dispatchCalendarEvent("clickArrow",{event:a,year:l,month:c}),changeTime:(a,l,c,u,d)=>this.dispatchCalendarEvent("changeTime",{event:a,time:l,hours:c,minutes:u,keeping:d}),changeView:a=>this.dispatchCalendarEvent("changeView",{view:a}),getDays:(a,l,c,u,d)=>{}},o={...r.options,styles:r.styles,actions:s};window.VanillaCalendarPro?(this.calendar=new VanillaCalendarPro.Calendar(this.$refs.calendarEl,o),this.calendar.init(),this.initialized=!0,this.dispatchCalendarEvent("init",{instance:this.calendar})):console.error("RzCalendar: VanillaCalendar global not found.")},dispatchCalendarEvent(i,n){this.$dispatch(`rz:calendar:${i}`,n)},destroy(){this.calendar&&(this.calendar.destroy(),this.dispatchCalendarEvent("destroy",{}))}}))}function kl(e,t){function i(n){if(!n)return{};const r=document.getElementById(n);if(!r)return console.warn(`[rzCarousel] JSON script element #${n} not found.`),{};try{return JSON.parse(r.textContent||"{}")}catch(s){return console.error(`[rzCarousel] Failed to parse JSON from #${n}:`,s),{}}}e.data("rzCarousel",()=>({emblaApi:null,canScrollPrev:!1,canScrollNext:!1,selectedIndex:0,scrollSnaps:[],init(){const n=(()=>{try{return JSON.parse(this.$el.dataset.assets||"[]")}catch(c){return console.error("[rzCarousel] Bad assets JSON:",c),[]}})(),r=this.$el.dataset.nonce||"",s=i(this.$el.dataset.config),o=s.Options||{},a=s.Plugins||[],l=this;n.length>0&&typeof t=="function"?t(n,{success(){window.EmblaCarousel?l.initializeEmbla(o,a):console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.")},error(c){console.error("[rzCarousel] Failed to load EmblaCarousel assets.",c)}},r):window.EmblaCarousel?this.initializeEmbla(o,a):console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.")},initializeEmbla(n,r){const s=this.$el.querySelector('[x-ref="viewport"]');if(!s){console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');return}const o=this.instantiatePlugins(r);this.emblaApi=window.EmblaCarousel(s,n,o),this.emblaApi.on("select",this.onSelect.bind(this)),this.emblaApi.on("reInit",this.onSelect.bind(this)),this.onSelect()},instantiatePlugins(n){return!Array.isArray(n)||n.length===0?[]:n.map(r=>{const s=window[r.Name];if(typeof s!="function")return console.error(`[rzCarousel] Plugin constructor '${r.Name}' not found on window object.`),null;try{return s(r.Options||{})}catch(o){return console.error(`[rzCarousel] Error instantiating plugin '${r.Name}':`,o),null}}).filter(Boolean)},destroy(){this.emblaApi&&this.emblaApi.destroy()},onSelect(){this.emblaApi&&(this.selectedIndex=this.emblaApi.selectedScrollSnap(),this.canScrollPrev=this.emblaApi.canScrollPrev(),this.canScrollNext=this.emblaApi.canScrollNext(),this.scrollSnaps=this.emblaApi.scrollSnapList())},cannotScrollPrev(){return!this.canScrollPrev},cannotScrollNext(){return!this.canScrollNext},scrollPrev(){this.emblaApi?.scrollPrev()},scrollNext(){this.emblaApi?.scrollNext()},scrollTo(n){this.emblaApi?.scrollTo(n)}}))}function Rl(e,t){e.data("rzCodeViewer",()=>({expand:!1,border:!0,copied:!1,copyTitle:"Copy",copiedTitle:"Copied!",init(){const i=JSON.parse(this.$el.dataset.assets),n=this.$el.dataset.codeid,r=this.$el.dataset.nonce;this.copyTitle=this.$el.dataset.copyTitle||this.copyTitle,this.copiedTitle=this.$el.dataset.copiedTitle||this.copiedTitle,t(i,{success:function(){const s=document.getElementById(n);window.hljs&&s&&window.hljs.highlightElement(s)},error:function(){console.error("Failed to load Highlight.js")}},r)},notCopied(){return!this.copied},disableCopied(){this.copied=!1},toggleExpand(){this.expand=!this.expand},copyHTML(){navigator.clipboard.writeText(this.$refs.codeBlock.textContent),this.copied=!this.copied},getCopiedTitle(){return this.copied?this.copiedTitle:this.copyTitle},getCopiedCss(){return[this.copied?"focus-visible:outline-success":"focus-visible:outline-foreground"]},getExpandCss(){return[this.expand?"":"max-h-60"]},getExpandButtonCss(){return this.expand?"rotate-180":"rotate-0"}}))}function Ll(e){e.data("rzCollapsible",()=>({isOpen:!1,init(){this.isOpen=this.$el.dataset.defaultOpen==="true"},toggle(){this.isOpen=!this.isOpen},state(){return this.isOpen?"open":"closed"}}))}function Pl(e,t){e.data("rzCombobox",()=>({tomSelect:null,init(){const i=JSON.parse(this.$el.dataset.assets||"[]"),n=this.$el.dataset.nonce;i.length>0&&typeof t=="function"?t(i,{success:()=>this.initTomSelect(),error:r=>console.error("RzCombobox: Failed to load assets.",r)},n):window.TomSelect&&this.initTomSelect()},initTomSelect(){const i=this.$refs.selectInput;if(!i)return;const n=document.getElementById(this.$el.dataset.configId),r=n?JSON.parse(n.textContent):{},s={},o=(a,l)=>{if(!a)return null;const c=document.createElement("div");let u=l.item;if(typeof u=="string")try{u=JSON.parse(u)}catch{}const d={...l,item:u};return e&&typeof e.addScopeToNode=="function"?e.addScopeToNode(c,d):c._x_dataStack=[d],c.innerHTML=a.innerHTML,c};this.$refs.optionTemplate&&(s.option=(a,l)=>o(this.$refs.optionTemplate,a)),this.$refs.itemTemplate&&(s.item=(a,l)=>o(this.$refs.itemTemplate,a)),r.dataAttr="data-item",this.tomSelect=new TomSelect(i,{...r,render:s,onInitialize:function(){this.sync()}})},destroy(){this.tomSelect&&(this.tomSelect.destroy(),this.tomSelect=null)}}))}function Dl(e,t){e.data("rzDateEdit",()=>({options:{},placeholder:"",prependText:"",init(){const i=this.$el.dataset.config,n=document.getElementById(this.$el.dataset.uid+"-input");if(i){const o=JSON.parse(i);o&&(this.options=o.options||{},this.placeholder=o.placeholder||"",this.prependText=o.prependText||"")}const r=JSON.parse(this.$el.dataset.assets),s=this.$el.dataset.nonce;t(r,{success:function(){window.flatpickr&&n&&window.flatpickr(n,this.options)},error:function(){console.error("Failed to load Flatpickr assets.")}},s)}}))}function Ml(e){e.data("rzDialog",()=>({modalOpen:!1,eventTriggerName:"",closeEventName:"rz:modal-close",closeOnEscape:!0,closeOnClickOutside:!0,modalId:"",bodyId:"",footerId:"",nonce:"",_escapeListener:null,_openListener:null,_closeEventListener:null,init(){this.modalId=this.$el.dataset.modalId||"",this.bodyId=this.$el.dataset.bodyId||"",this.footerId=this.$el.dataset.footerId||"",this.nonce=this.$el.dataset.nonce||"",this.eventTriggerName=this.$el.dataset.eventTriggerName||"",this.closeEventName=this.$el.dataset.closeEventName||this.closeEventName,this.closeOnEscape=this.$el.dataset.closeOnEscape!=="false",this.closeOnClickOutside=this.$el.dataset.closeOnClickOutside!=="false",this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized",{detail:{modalId:this.modalId,bodyId:this.bodyId,footerId:this.footerId},bubbles:!0})),this.eventTriggerName&&(this._openListener=t=>{this.openModal(t)},window.addEventListener(this.eventTriggerName,this._openListener)),this._closeEventListener=t=>{this.modalOpen&&this.closeModalInternally("event")},window.addEventListener(this.closeEventName,this._closeEventListener),this._escapeListener=t=>{this.modalOpen&&this.closeOnEscape&&t.key==="Escape"&&this.closeModalInternally("escape")},window.addEventListener("keydown",this._escapeListener),this.$watch("modalOpen",t=>{const i=document.body.offsetWidth;document.body.classList.toggle("overflow-hidden",t);const n=document.body.offsetWidth-i;document.body.style.setProperty("--page-scrollbar-width",`${n}px`),t?this.$nextTick(()=>{this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(),this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open",{detail:{modalId:this.modalId},bubbles:!0}))}):this.$nextTick(()=>{this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close",{detail:{modalId:this.modalId},bubbles:!0}))})})},notModalOpen(){return!this.modalOpen},destroy(){this._openListener&&this.eventTriggerName&&window.removeEventListener(this.eventTriggerName,this._openListener),this._closeEventListener&&window.removeEventListener(this.closeEventName,this._closeEventListener),this._escapeListener&&window.removeEventListener("keydown",this._escapeListener),document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px")},openModal(t=null){const i=new CustomEvent("rz:modal-before-open",{detail:{modalId:this.modalId,originalEvent:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(i),i.defaultPrevented||(this.modalOpen=!0)},closeModalInternally(t="unknown"){const i=new CustomEvent("rz:modal-before-close",{detail:{modalId:this.modalId,reason:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(i),i.defaultPrevented||(document.activeElement?.blur&&document.activeElement.blur(),this.modalOpen=!1,document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px"))},closeModal(){this.closeModalInternally("button")},handleClickOutside(){this.closeOnClickOutside&&this.closeModalInternally("backdrop")}}))}const $i=Math.min,Ne=Math.max,It=Math.round,K=e=>({x:e,y:e}),zl={left:"right",right:"left",bottom:"top",top:"bottom"},Fl={start:"end",end:"start"};function Vr(e,t,i){return Ne(e,$i(t,i))}function Ct(e,t){return typeof e=="function"?e(t):e}function we(e){return e.split("-")[0]}function Tt(e){return e.split("-")[1]}function Wr(e){return e==="x"?"y":"x"}function qr(e){return e==="y"?"height":"width"}function _e(e){return["top","bottom"].includes(we(e))?"y":"x"}function Hr(e){return Wr(_e(e))}function Ul(e,t,i){i===void 0&&(i=!1);const n=Tt(e),r=Hr(e),s=qr(r);let o=r==="x"?n===(i?"end":"start")?"right":"left":n==="start"?"bottom":"top";return t.reference[s]>t.floating[s]&&(o=St(o)),[o,St(o)]}function Bl(e){const t=St(e);return[Ni(e),t,Ni(t)]}function Ni(e){return e.replace(/start|end/g,t=>Fl[t])}function jl(e,t,i){const n=["left","right"],r=["right","left"],s=["top","bottom"],o=["bottom","top"];switch(e){case"top":case"bottom":return i?t?r:n:t?n:r;case"left":case"right":return t?s:o;default:return[]}}function Vl(e,t,i,n){const r=Tt(e);let s=jl(we(e),i==="start",n);return r&&(s=s.map(o=>o+"-"+r),t&&(s=s.concat(s.map(Ni)))),s}function St(e){return e.replace(/left|right|bottom|top/g,t=>zl[t])}function Wl(e){return{top:0,right:0,bottom:0,left:0,...e}}function ql(e){return typeof e!="number"?Wl(e):{top:e,right:e,bottom:e,left:e}}function At(e){const{x:t,y:i,width:n,height:r}=e;return{width:n,height:r,top:i,left:t,right:t+n,bottom:i+r,x:t,y:i}}function Kr(e,t,i){let{reference:n,floating:r}=e;const s=_e(t),o=Hr(t),a=qr(o),l=we(t),c=s==="y",u=n.x+n.width/2-r.width/2,d=n.y+n.height/2-r.height/2,f=n[a]/2-r[a]/2;let y;switch(l){case"top":y={x:u,y:n.y-r.height};break;case"bottom":y={x:u,y:n.y+n.height};break;case"right":y={x:n.x+n.width,y:d};break;case"left":y={x:n.x-r.width,y:d};break;default:y={x:n.x,y:n.y}}switch(Tt(t)){case"start":y[o]-=f*(i&&c?-1:1);break;case"end":y[o]+=f*(i&&c?-1:1);break}return y}const Hl=async(e,t,i)=>{const{placement:n="bottom",strategy:r="absolute",middleware:s=[],platform:o}=i,a=s.filter(Boolean),l=await(o.isRTL==null?void 0:o.isRTL(t));let c=await o.getElementRects({reference:e,floating:t,strategy:r}),{x:u,y:d}=Kr(c,n,l),f=n,y={},m=0;for(let v=0;v<a.length;v++){const{name:p,fn:b}=a[v],{x:h,y:_,data:E,reset:x}=await b({x:u,y:d,initialPlacement:n,placement:f,strategy:r,middlewareData:y,rects:c,platform:o,elements:{reference:e,floating:t}});u=h??u,d=_??d,y={...y,[p]:{...y[p],...E}},x&&m<=50&&(m++,typeof x=="object"&&(x.placement&&(f=x.placement),x.rects&&(c=x.rects===!0?await o.getElementRects({reference:e,floating:t,strategy:r}):x.rects),{x:u,y:d}=Kr(c,f,l)),v=-1)}return{x:u,y:d,placement:f,strategy:r,middlewareData:y}};async function Yr(e,t){var i;t===void 0&&(t={});const{x:n,y:r,platform:s,rects:o,elements:a,strategy:l}=e,{boundary:c="clippingAncestors",rootBoundary:u="viewport",elementContext:d="floating",altBoundary:f=!1,padding:y=0}=Ct(t,e),m=ql(y),p=a[f?d==="floating"?"reference":"floating":d],b=At(await s.getClippingRect({element:(i=await(s.isElement==null?void 0:s.isElement(p)))==null||i?p:p.contextElement||await(s.getDocumentElement==null?void 0:s.getDocumentElement(a.floating)),boundary:c,rootBoundary:u,strategy:l})),h=d==="floating"?{x:n,y:r,width:o.floating.width,height:o.floating.height}:o.reference,_=await(s.getOffsetParent==null?void 0:s.getOffsetParent(a.floating)),E=await(s.isElement==null?void 0:s.isElement(_))?await(s.getScale==null?void 0:s.getScale(_))||{x:1,y:1}:{x:1,y:1},x=At(s.convertOffsetParentRelativeRectToViewportRelativeRect?await s.convertOffsetParentRelativeRectToViewportRelativeRect({elements:a,rect:h,offsetParent:_,strategy:l}):h);return{top:(b.top-x.top+m.top)/E.y,bottom:(x.bottom-b.bottom+m.bottom)/E.y,left:(b.left-x.left+m.left)/E.x,right:(x.right-b.right+m.right)/E.x}}const Kl=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(t){var i,n;const{placement:r,middlewareData:s,rects:o,initialPlacement:a,platform:l,elements:c}=t,{mainAxis:u=!0,crossAxis:d=!0,fallbackPlacements:f,fallbackStrategy:y="bestFit",fallbackAxisSideDirection:m="none",flipAlignment:v=!0,...p}=Ct(e,t);if((i=s.arrow)!=null&&i.alignmentOffset)return{};const b=we(r),h=_e(a),_=we(a)===a,E=await(l.isRTL==null?void 0:l.isRTL(c.floating)),x=f||(_||!v?[St(a)]:Bl(a)),g=m!=="none";!f&&g&&x.push(...Vl(a,v,m,E));const w=[a,...x],I=await Yr(t,p),C=[];let T=((n=s.flip)==null?void 0:n.overflows)||[];if(u&&C.push(I[b]),d){const F=Ul(r,o,E);C.push(I[F[0]],I[F[1]])}if(T=[...T,{placement:r,overflows:C}],!C.every(F=>F<=0)){var S,P;const F=(((S=s.flip)==null?void 0:S.index)||0)+1,Ee=w[F];if(Ee){var D;const U=d==="alignment"?h!==_e(Ee):!1,Z=((D=T[0])==null?void 0:D.overflows[0])>0;if(!U||Z)return{data:{index:F,overflows:T},reset:{placement:Ee}}}let q=(P=T.filter(U=>U.overflows[0]<=0).sort((U,Z)=>U.overflows[1]-Z.overflows[1])[0])==null?void 0:P.placement;if(!q)switch(y){case"bestFit":{var J;const U=(J=T.filter(Z=>{if(g){const ae=_e(Z.placement);return ae===h||ae==="y"}return!0}).map(Z=>[Z.placement,Z.overflows.filter(ae=>ae>0).reduce((ae,Wc)=>ae+Wc,0)]).sort((Z,ae)=>Z[1]-ae[1])[0])==null?void 0:J[0];U&&(q=U);break}case"initialPlacement":q=a;break}if(r!==q)return{reset:{placement:q}}}return{}}}};async function Yl(e,t){const{placement:i,platform:n,elements:r}=e,s=await(n.isRTL==null?void 0:n.isRTL(r.floating)),o=we(i),a=Tt(i),l=_e(i)==="y",c=["left","top"].includes(o)?-1:1,u=s&&l?-1:1,d=Ct(t,e);let{mainAxis:f,crossAxis:y,alignmentAxis:m}=typeof d=="number"?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:d.mainAxis||0,crossAxis:d.crossAxis||0,alignmentAxis:d.alignmentAxis};return a&&typeof m=="number"&&(y=a==="end"?m*-1:m),l?{x:y*u,y:f*c}:{x:f*c,y:y*u}}const Jl=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(t){var i,n;const{x:r,y:s,placement:o,middlewareData:a}=t,l=await Yl(t,e);return o===((i=a.offset)==null?void 0:i.placement)&&(n=a.arrow)!=null&&n.alignmentOffset?{}:{x:r+l.x,y:s+l.y,data:{...l,placement:o}}}}},Zl=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(t){const{x:i,y:n,placement:r}=t,{mainAxis:s=!0,crossAxis:o=!1,limiter:a={fn:p=>{let{x:b,y:h}=p;return{x:b,y:h}}},...l}=Ct(e,t),c={x:i,y:n},u=await Yr(t,l),d=_e(we(r)),f=Wr(d);let y=c[f],m=c[d];if(s){const p=f==="y"?"top":"left",b=f==="y"?"bottom":"right",h=y+u[p],_=y-u[b];y=Vr(h,y,_)}if(o){const p=d==="y"?"top":"left",b=d==="y"?"bottom":"right",h=m+u[p],_=m-u[b];m=Vr(h,m,_)}const v=a.fn({...t,[f]:y,[d]:m});return{...v,data:{x:v.x-i,y:v.y-n,enabled:{[f]:s,[d]:o}}}}}};function Ot(){return typeof window<"u"}function ke(e){return Jr(e)?(e.nodeName||"").toLowerCase():"#document"}function M(e){var t;return(e==null||(t=e.ownerDocument)==null?void 0:t.defaultView)||window}function Q(e){var t;return(t=(Jr(e)?e.ownerDocument:e.document)||window.document)==null?void 0:t.documentElement}function Jr(e){return Ot()?e instanceof Node||e instanceof M(e).Node:!1}function V(e){return Ot()?e instanceof Element||e instanceof M(e).Element:!1}function Y(e){return Ot()?e instanceof HTMLElement||e instanceof M(e).HTMLElement:!1}function Zr(e){return!Ot()||typeof ShadowRoot>"u"?!1:e instanceof ShadowRoot||e instanceof M(e).ShadowRoot}function Ge(e){const{overflow:t,overflowX:i,overflowY:n,display:r}=W(e);return/auto|scroll|overlay|hidden|clip/.test(t+n+i)&&!["inline","contents"].includes(r)}function Gl(e){return["table","td","th"].includes(ke(e))}function $t(e){return[":popover-open",":modal"].some(t=>{try{return e.matches(t)}catch{return!1}})}function ki(e){const t=Ri(),i=V(e)?W(e):e;return["transform","translate","scale","rotate","perspective"].some(n=>i[n]?i[n]!=="none":!1)||(i.containerType?i.containerType!=="normal":!1)||!t&&(i.backdropFilter?i.backdropFilter!=="none":!1)||!t&&(i.filter?i.filter!=="none":!1)||["transform","translate","scale","rotate","perspective","filter"].some(n=>(i.willChange||"").includes(n))||["paint","layout","strict","content"].some(n=>(i.contain||"").includes(n))}function Xl(e){let t=oe(e);for(;Y(t)&&!Re(t);){if(ki(t))return t;if($t(t))return null;t=oe(t)}return null}function Ri(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function Re(e){return["html","body","#document"].includes(ke(e))}function W(e){return M(e).getComputedStyle(e)}function Nt(e){return V(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.scrollX,scrollTop:e.scrollY}}function oe(e){if(ke(e)==="html")return e;const t=e.assignedSlot||e.parentNode||Zr(e)&&e.host||Q(e);return Zr(t)?t.host:t}function Gr(e){const t=oe(e);return Re(t)?e.ownerDocument?e.ownerDocument.body:e.body:Y(t)&&Ge(t)?t:Gr(t)}function Xr(e,t,i){var n;t===void 0&&(t=[]);const r=Gr(e),s=r===((n=e.ownerDocument)==null?void 0:n.body),o=M(r);return s?(Li(o),t.concat(o,o.visualViewport||[],Ge(r)?r:[],[])):t.concat(r,Xr(r,[]))}function Li(e){return e.parent&&Object.getPrototypeOf(e.parent)?e.frameElement:null}function Qr(e){const t=W(e);let i=parseFloat(t.width)||0,n=parseFloat(t.height)||0;const r=Y(e),s=r?e.offsetWidth:i,o=r?e.offsetHeight:n,a=It(i)!==s||It(n)!==o;return a&&(i=s,n=o),{width:i,height:n,$:a}}function es(e){return V(e)?e:e.contextElement}function Le(e){const t=es(e);if(!Y(t))return K(1);const i=t.getBoundingClientRect(),{width:n,height:r,$:s}=Qr(t);let o=(s?It(i.width):i.width)/n,a=(s?It(i.height):i.height)/r;return(!o||!Number.isFinite(o))&&(o=1),(!a||!Number.isFinite(a))&&(a=1),{x:o,y:a}}const Ql=K(0);function ts(e){const t=M(e);return!Ri()||!t.visualViewport?Ql:{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}}function ec(e,t,i){return t===void 0&&(t=!1),!i||t&&i!==M(e)?!1:t}function Xe(e,t,i,n){t===void 0&&(t=!1),i===void 0&&(i=!1);const r=e.getBoundingClientRect(),s=es(e);let o=K(1);t&&(n?V(n)&&(o=Le(n)):o=Le(e));const a=ec(s,i,n)?ts(s):K(0);let l=(r.left+a.x)/o.x,c=(r.top+a.y)/o.y,u=r.width/o.x,d=r.height/o.y;if(s){const f=M(s),y=n&&V(n)?M(n):n;let m=f,v=Li(m);for(;v&&n&&y!==m;){const p=Le(v),b=v.getBoundingClientRect(),h=W(v),_=b.left+(v.clientLeft+parseFloat(h.paddingLeft))*p.x,E=b.top+(v.clientTop+parseFloat(h.paddingTop))*p.y;l*=p.x,c*=p.y,u*=p.x,d*=p.y,l+=_,c+=E,m=M(v),v=Li(m)}}return At({width:u,height:d,x:l,y:c})}function Pi(e,t){const i=Nt(e).scrollLeft;return t?t.left+i:Xe(Q(e)).left+i}function is(e,t,i){i===void 0&&(i=!1);const n=e.getBoundingClientRect(),r=n.left+t.scrollLeft-(i?0:Pi(e,n)),s=n.top+t.scrollTop;return{x:r,y:s}}function tc(e){let{elements:t,rect:i,offsetParent:n,strategy:r}=e;const s=r==="fixed",o=Q(n),a=t?$t(t.floating):!1;if(n===o||a&&s)return i;let l={scrollLeft:0,scrollTop:0},c=K(1);const u=K(0),d=Y(n);if((d||!d&&!s)&&((ke(n)!=="body"||Ge(o))&&(l=Nt(n)),Y(n))){const y=Xe(n);c=Le(n),u.x=y.x+n.clientLeft,u.y=y.y+n.clientTop}const f=o&&!d&&!s?is(o,l,!0):K(0);return{width:i.width*c.x,height:i.height*c.y,x:i.x*c.x-l.scrollLeft*c.x+u.x+f.x,y:i.y*c.y-l.scrollTop*c.y+u.y+f.y}}function ic(e){return Array.from(e.getClientRects())}function nc(e){const t=Q(e),i=Nt(e),n=e.ownerDocument.body,r=Ne(t.scrollWidth,t.clientWidth,n.scrollWidth,n.clientWidth),s=Ne(t.scrollHeight,t.clientHeight,n.scrollHeight,n.clientHeight);let o=-i.scrollLeft+Pi(e);const a=-i.scrollTop;return W(n).direction==="rtl"&&(o+=Ne(t.clientWidth,n.clientWidth)-r),{width:r,height:s,x:o,y:a}}function rc(e,t){const i=M(e),n=Q(e),r=i.visualViewport;let s=n.clientWidth,o=n.clientHeight,a=0,l=0;if(r){s=r.width,o=r.height;const c=Ri();(!c||c&&t==="fixed")&&(a=r.offsetLeft,l=r.offsetTop)}return{width:s,height:o,x:a,y:l}}function sc(e,t){const i=Xe(e,!0,t==="fixed"),n=i.top+e.clientTop,r=i.left+e.clientLeft,s=Y(e)?Le(e):K(1),o=e.clientWidth*s.x,a=e.clientHeight*s.y,l=r*s.x,c=n*s.y;return{width:o,height:a,x:l,y:c}}function ns(e,t,i){let n;if(t==="viewport")n=rc(e,i);else if(t==="document")n=nc(Q(e));else if(V(t))n=sc(t,i);else{const r=ts(e);n={x:t.x-r.x,y:t.y-r.y,width:t.width,height:t.height}}return At(n)}function rs(e,t){const i=oe(e);return i===t||!V(i)||Re(i)?!1:W(i).position==="fixed"||rs(i,t)}function oc(e,t){const i=t.get(e);if(i)return i;let n=Xr(e,[]).filter(a=>V(a)&&ke(a)!=="body"),r=null;const s=W(e).position==="fixed";let o=s?oe(e):e;for(;V(o)&&!Re(o);){const a=W(o),l=ki(o);!l&&a.position==="fixed"&&(r=null),(s?!l&&!r:!l&&a.position==="static"&&!!r&&["absolute","fixed"].includes(r.position)||Ge(o)&&!l&&rs(e,o))?n=n.filter(u=>u!==o):r=a,o=oe(o)}return t.set(e,n),n}function ac(e){let{element:t,boundary:i,rootBoundary:n,strategy:r}=e;const o=[...i==="clippingAncestors"?$t(t)?[]:oc(t,this._c):[].concat(i),n],a=o[0],l=o.reduce((c,u)=>{const d=ns(t,u,r);return c.top=Ne(d.top,c.top),c.right=$i(d.right,c.right),c.bottom=$i(d.bottom,c.bottom),c.left=Ne(d.left,c.left),c},ns(t,a,r));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function lc(e){const{width:t,height:i}=Qr(e);return{width:t,height:i}}function cc(e,t,i){const n=Y(t),r=Q(t),s=i==="fixed",o=Xe(e,!0,s,t);let a={scrollLeft:0,scrollTop:0};const l=K(0);function c(){l.x=Pi(r)}if(n||!n&&!s)if((ke(t)!=="body"||Ge(r))&&(a=Nt(t)),n){const y=Xe(t,!0,s,t);l.x=y.x+t.clientLeft,l.y=y.y+t.clientTop}else r&&c();s&&!n&&r&&c();const u=r&&!n&&!s?is(r,a):K(0),d=o.left+a.scrollLeft-l.x-u.x,f=o.top+a.scrollTop-l.y-u.y;return{x:d,y:f,width:o.width,height:o.height}}function Di(e){return W(e).position==="static"}function ss(e,t){if(!Y(e)||W(e).position==="fixed")return null;if(t)return t(e);let i=e.offsetParent;return Q(e)===i&&(i=i.ownerDocument.body),i}function os(e,t){const i=M(e);if($t(e))return i;if(!Y(e)){let r=oe(e);for(;r&&!Re(r);){if(V(r)&&!Di(r))return r;r=oe(r)}return i}let n=ss(e,t);for(;n&&Gl(n)&&Di(n);)n=ss(n,t);return n&&Re(n)&&Di(n)&&!ki(n)?i:n||Xl(e)||i}const uc=async function(e){const t=this.getOffsetParent||os,i=this.getDimensions,n=await i(e.floating);return{reference:cc(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,width:n.width,height:n.height}}};function dc(e){return W(e).direction==="rtl"}const fc={convertOffsetParentRelativeRectToViewportRelativeRect:tc,getDocumentElement:Q,getClippingRect:ac,getOffsetParent:os,getElementRects:uc,getClientRects:ic,getDimensions:lc,getScale:Le,isElement:V,isRTL:dc},kt=Jl,Rt=Zl,Lt=Kl,Pt=(e,t,i)=>{const n=new Map,r={platform:fc,...i},s={...r.platform,_c:n};return Hl(e,t,{...r,platform:s})};function hc(e){e.data("rzDropdownMenu",()=>({open:!1,isModal:!0,ariaExpanded:"false",trapActive:!1,focusedIndex:null,menuItems:[],parentEl:null,triggerEl:null,contentEl:null,anchor:"bottom",pixelOffset:3,isSubmenuActive:!1,navThrottle:100,_lastNavAt:0,selfId:null,init(){this.$el.id||(this.$el.id=crypto.randomUUID()),this.selfId=this.$el.id,this.parentEl=this.$el,this.triggerEl=this.$refs.trigger,this.anchor=this.$el.dataset.anchor||"bottom",this.pixelOffset=parseInt(this.$el.dataset.offset)||6,this.isModal=this.$el.dataset.modal!=="false",this.$watch("open",t=>{t?(this._lastNavAt=0,this.$nextTick(()=>{this.contentEl=document.getElementById(`${this.selfId}-content`),this.contentEl&&(this.updatePosition(),this.menuItems=Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled],[aria-disabled="true"])')))}),this.ariaExpanded="true",this.triggerEl.dataset.state="open",this.trapActive=this.isModal):(this.focusedIndex=null,this.closeAllSubmenus(),this.ariaExpanded="false",delete this.triggerEl.dataset.state,this.trapActive=!1,this.contentEl=null)})},updatePosition(){!this.triggerEl||!this.contentEl||(this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width",`${this.triggerEl.offsetWidth}px`),Pt(this.triggerEl,this.contentEl,{placement:this.anchor,middleware:[kt(this.pixelOffset),Lt(),Rt({padding:8})]}).then(({x:t,y:i})=>{Object.assign(this.contentEl.style,{left:`${t}px`,top:`${i}px`})}))},toggle(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}else this.open=!0,this.focusedIndex=-1},handleOutsideClick(){if(!this.open)return;this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())},handleTriggerKeydown(t){["Enter"," ","ArrowDown","ArrowUp"].includes(t.key)&&(t.preventDefault(),this.open=!0,this.$nextTick(()=>{t.key==="ArrowUp"?this.focusLastItem():this.focusFirstItem()}))},focusNextItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex>=this.menuItems.length-1?0:this.focusedIndex+1,this.focusCurrentItem()))},focusPreviousItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex<=0?this.menuItems.length-1:this.focusedIndex-1,this.focusCurrentItem()))},focusFirstItem(){this.menuItems.length&&(this.focusedIndex=0,this.focusCurrentItem())},focusLastItem(){this.menuItems.length&&(this.focusedIndex=this.menuItems.length-1,this.focusCurrentItem())},focusCurrentItem(){this.focusedIndex!==null&&this.menuItems[this.focusedIndex]&&this.$nextTick(()=>this.menuItems[this.focusedIndex].focus())},focusSelectedItem(t){if(!t||t.getAttribute("aria-disabled")==="true"||t.hasAttribute("disabled"))return;const i=this.menuItems.indexOf(t);i!==-1&&(this.focusedIndex=i,t.focus())},handleItemClick(t){const i=t.currentTarget;if(i.getAttribute("aria-disabled")==="true"||i.hasAttribute("disabled"))return;if(i.getAttribute("aria-haspopup")==="menu"){e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();return}this.open=!1;let n=this;this.$nextTick(()=>n.triggerEl?.focus())},handleItemMouseEnter(t){const i=t.currentTarget;this.focusSelectedItem(i),i.getAttribute("aria-haspopup")!=="menu"&&this.closeAllSubmenus()},handleWindowEscape(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}},handleContentTabKey(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}},handleTriggerMouseover(){let t=this;this.$nextTick(()=>t.$el.firstElementChild?.focus())},closeAllSubmenus(){this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]').forEach(i=>{e.$data(i)?.closeSubmenu()}),this.isSubmenuActive=!1}})),e.data("rzDropdownSubmenu",()=>({open:!1,ariaExpanded:"false",parentDropdown:null,triggerEl:null,contentEl:null,menuItems:[],focusedIndex:null,anchor:"right-start",pixelOffset:0,navThrottle:100,_lastNavAt:0,selfId:null,siblingContainer:null,closeTimeout:null,closeDelay:150,init(){this.$el.id||(this.$el.id=crypto.randomUUID()),this.selfId=this.$el.id;const t=this.$el.dataset.parentId;if(t){const i=document.getElementById(t);i&&(this.parentDropdown=e.$data(i))}if(!this.parentDropdown){console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");return}this.triggerEl=this.$refs.subTrigger,this.siblingContainer=this.$el.parentElement,this.anchor=this.$el.dataset.subAnchor||this.anchor,this.pixelOffset=parseInt(this.$el.dataset.subOffset)||this.pixelOffset,this.$watch("open",i=>{i?(this._lastNavAt=0,this.parentDropdown.isSubmenuActive=!0,this.$nextTick(()=>{this.contentEl=document.getElementById(`${this.selfId}-subcontent`),this.contentEl&&(this.updatePosition(this.contentEl),this.menuItems=Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])')))}),this.ariaExpanded="true",this.triggerEl.dataset.state="open"):(this.focusedIndex=null,this.ariaExpanded="false",delete this.triggerEl.dataset.state,this.$nextTick(()=>{this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]')||(this.parentDropdown.isSubmenuActive=!1)}),this.contentEl=null)})},updatePosition(t){!this.triggerEl||!t||Pt(this.triggerEl,t,{placement:this.anchor,middleware:[kt(this.pixelOffset),Lt(),Rt({padding:8})]}).then(({x:i,y:n})=>{Object.assign(t.style,{left:`${i}px`,top:`${n}px`})})},handleTriggerMouseEnter(){clearTimeout(this.closeTimeout),this.triggerEl.focus(),this.openSubmenu()},handleTriggerMouseLeave(){this.closeTimeout=setTimeout(()=>this.closeSubmenu(),this.closeDelay)},handleContentMouseEnter(){clearTimeout(this.closeTimeout)},handleContentMouseLeave(){const t=this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');t&&Array.from(t).some(n=>e.$data(n)?.open)||(this.closeTimeout=setTimeout(()=>this.closeSubmenu(),this.closeDelay))},openSubmenu(t=!1){this.open||(this.closeSiblingSubmenus(),this.open=!0,t&&this.$nextTick(()=>requestAnimationFrame(()=>this.focusFirstItem())))},closeSubmenu(){this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]')?.forEach(i=>{e.$data(i)?.closeSubmenu()}),this.open=!1},closeSiblingSubmenus(){if(!this.siblingContainer)return;Array.from(this.siblingContainer.children).filter(i=>i.hasAttribute("x-data")&&i.getAttribute("x-data").startsWith("rzDropdownSubmenu")&&i.id!==this.selfId).forEach(i=>{e.$data(i)?.closeSubmenu()})},toggleSubmenu(){this.open?this.closeSubmenu():this.openSubmenu()},openSubmenuAndFocusFirst(){this.openSubmenu(!0)},handleTriggerKeydown(t){["ArrowRight","Enter"," "].includes(t.key)&&(t.preventDefault(),this.openSubmenuAndFocusFirst())},focusNextItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex>=this.menuItems.length-1?0:this.focusedIndex+1,this.focusCurrentItem()))},focusPreviousItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex<=0?this.menuItems.length-1:this.focusedIndex-1,this.focusCurrentItem()))},focusFirstItem(){this.menuItems.length&&(this.focusedIndex=0,this.focusCurrentItem())},focusLastItem(){this.menuItems.length&&(this.focusedIndex=this.menuItems.length-1,this.focusCurrentItem())},focusCurrentItem(){this.focusedIndex!==null&&this.menuItems[this.focusedIndex]&&this.menuItems[this.focusedIndex].focus()},handleItemClick(t){const i=t.currentTarget;if(!(i.getAttribute("aria-disabled")==="true"||i.hasAttribute("disabled"))){if(i.getAttribute("aria-haspopup")==="menu"){e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();return}this.parentDropdown.open=!1,this.$nextTick(()=>this.parentDropdown.triggerEl?.focus())}},handleItemMouseEnter(t){const i=t.currentTarget;if(i.getAttribute("aria-disabled")==="true"||i.hasAttribute("disabled"))return;const n=this.menuItems.indexOf(i);n!==-1&&(this.focusedIndex=n,i.focus()),i.getAttribute("aria-haspopup")==="menu"?e.$data(i.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu():this.closeSiblingSubmenus()},handleSubmenuEscape(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))},handleSubmenuArrowLeft(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))}}))}function pc(e){e.data("rzDarkModeToggle",()=>({get mode(){return this.$store.theme.mode},get prefersDark(){return this.$store.theme.prefersDark},get effectiveDark(){return this.$store.theme.effectiveDark},get isDark(){return this.$store.theme.isDark},get isLight(){return this.$store.theme.isLight},setLight(){this.$store.theme.setLight()},setDark(){this.$store.theme.setDark()},setAuto(){this.$store.theme.setAuto()},toggle(){this.$store.theme.toggle()}}))}function mc(e){e.data("rzEmbeddedPreview",()=>({iframe:null,onDarkModeToggle:null,init(){try{this.iframe=this.$refs.iframe;const t=this.debounce(()=>{this.resizeIframe(this.iframe)},50);this.resizeIframe(this.iframe),new ResizeObserver(r=>{for(let s of r)t()}).observe(this.iframe);const n=this.iframe;this.onDarkModeToggle=r=>{n.contentWindow.postMessage(r.detail,"*")},window.addEventListener("darkModeToggle",this.onDarkModeToggle)}catch{console.error("Cannot access iframe content")}},resizeIframe(t){if(t)try{const i=t.contentDocument||t.contentWindow?.document;if(i){const n=i.body;if(!n)setInterval(()=>{this.resizeIframe(t)},150);else{const r=n.scrollHeight+15;t.style.height=r+"px"}}}catch(i){console.error("Error resizing iframe:",i)}},debounce(t,i=300){let n;return(...r)=>{clearTimeout(n),n=setTimeout(()=>{t.apply(this,r)},i)}},destroy(){window.removeEventListener("darkModeToggle",this.onDarkModeToggle)}}))}function gc(e){e.data("rzEmpty",()=>{})}function vc(e){e.data("rzHeading",()=>({observer:null,headingId:"",init(){this.headingId=this.$el.dataset.alpineRoot;const t=this;if(typeof this.setCurrentHeading=="function"){const i=(r,s)=>{r.forEach(o=>{o.isIntersecting&&t.setCurrentHeading(t.headingId)})},n={threshold:.5};this.observer=new IntersectionObserver(i,n),this.observer.observe(this.$el)}else console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.")},destroy(){this.observer!=null&&this.observer.disconnect()}}))}function bc(e){e.data("rzIndicator",()=>({visible:!1,init(){const t=this.$el.dataset.color;t?this.$el.style.backgroundColor=t:this.$el.style.backgroundColor="var(--color-success)",this.$el.dataset.visible==="true"&&(this.visible=!0)},notVisible(){return!this.visible},setVisible(t){this.visible=t}}))}function yc(e){e.data("rzInputGroupAddon",()=>({handleClick(t){if(t.target.closest("button"))return;const i=this.$el.parentElement;i&&i.querySelector("input, textarea")?.focus()}}))}function wc(e,t){e.data("rzMarkdown",()=>({init(){const i=JSON.parse(this.$el.dataset.assets),n=this.$el.dataset.nonce;t(i,{success:function(){window.hljs.highlightAll()},error:function(){console.error("Failed to load Highlight.js")}},n)}}))}function _c(e,t){e.data("rzNavigationMenu",()=>({activeItemId:null,open:!1,closeTimeout:null,prevIndex:null,list:null,isClosing:!1,_triggerIndex(i){return this.list?Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]')).findIndex(r=>r.getAttribute("x-ref")===`trigger_${i}`):-1},_contentEl(i){return document.getElementById(`${i}-content`)},init(){this.$el.querySelectorAll("[data-popover]").forEach(n=>{n.style.display="none"}),this.$nextTick(()=>{this.list=this.$refs.list})},toggleActive(i){const n=i.currentTarget.getAttribute("x-ref").replace("trigger_","");this.activeItemId===n&&this.open?this.closeMenu():this.openMenu(n)},handleTriggerEnter(i){const n=i.currentTarget.getAttribute("x-ref").replace("trigger_","");this.cancelClose(),this.activeItemId!==n&&!this.isClosing&&requestAnimationFrame(()=>this.openMenu(n))},handleItemEnter(i){const n=i.currentTarget;if(!n)return;this.cancelClose();const r=n.querySelector('[x-ref^="trigger_"]');if(r){const s=r.getAttribute("x-ref").replace("trigger_","");this.activeItemId!==s&&!this.isClosing&&requestAnimationFrame(()=>this.openMenu(s))}else this.open&&!this.isClosing&&this.closeMenu()},handleContentEnter(){this.cancelClose()},scheduleClose(){this.isClosing||this.closeTimeout||(this.closeTimeout=setTimeout(()=>this.closeMenu(),150))},cancelClose(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null),this.isClosing=!1},openMenu(i){this.cancelClose(),this.isClosing=!1;const n=this._triggerIndex(i),r=n>(this.prevIndex??n)?"end":"start",s=this.prevIndex===null;if(this.open&&this.activeItemId&&this.activeItemId!==i){const l=this.$refs[`trigger_${this.activeItemId}`];l&&delete l.dataset.state;const c=this._contentEl(this.activeItemId);if(c){const u=r==="end"?"start":"end";c.setAttribute("data-motion",`to-${u}`),setTimeout(()=>{c.style.display="none"},150)}}this.activeItemId=i,this.open=!0,this.prevIndex=n;const o=this.$refs[`trigger_${i}`],a=this._contentEl(i);!o||!a||(Pt(o,a,{placement:"bottom-start",middleware:[kt(6),Lt(),Rt({padding:8})]}).then(({x:l,y:c})=>{Object.assign(a.style,{left:`${l}px`,top:`${c}px`})}),a.style.display="block",s?a.setAttribute("data-motion","fade-in"):a.setAttribute("data-motion",`from-${r}`),this.$nextTick(()=>{o.setAttribute("aria-expanded","true"),o.dataset.state="open"}))},closeMenu(){if(!this.open||this.isClosing)return;this.isClosing=!0,this.cancelClose();const i=this.activeItemId;if(!i){this.isClosing=!1;return}const n=this.$refs[`trigger_${i}`];n&&(n.setAttribute("aria-expanded","false"),delete n.dataset.state);const r=this._contentEl(i);r&&(r.setAttribute("data-motion","fade-out"),setTimeout(()=>{r.style.display="none"},150)),this.open=!1,this.activeItemId=null,this.prevIndex=null,setTimeout(()=>{this.isClosing=!1},150)}}))}function xc(e){e.data("rzPopover",()=>({open:!1,ariaExpanded:"false",triggerEl:null,contentEl:null,init(){this.triggerEl=this.$refs.trigger,this.contentEl=this.$refs.content,this.$watch("open",t=>{this.ariaExpanded=t.toString(),t&&this.$nextTick(()=>this.updatePosition())})},updatePosition(){if(!this.triggerEl||!this.contentEl)return;const t=this.$el.dataset.anchor||"bottom",i=parseInt(this.$el.dataset.offset)||0,n=parseInt(this.$el.dataset.crossAxisOffset)||0,r=parseInt(this.$el.dataset.alignmentAxisOffset)||null,s=this.$el.dataset.strategy||"absolute",o=this.$el.dataset.enableFlip!=="false",a=this.$el.dataset.enableShift!=="false",l=parseInt(this.$el.dataset.shiftPadding)||8;let c=[];c.push(kt({mainAxis:i,crossAxis:n,alignmentAxis:r})),o&&c.push(Lt()),a&&c.push(Rt({padding:l})),Pt(this.triggerEl,this.contentEl,{placement:t,strategy:s,middleware:c}).then(({x:u,y:d})=>{Object.assign(this.contentEl.style,{left:`${u}px`,top:`${d}px`})})},toggle(){this.open=!this.open},handleOutsideClick(){this.open&&(this.open=!1)},handleWindowEscape(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))}}))}function Ec(e){e.data("rzPrependInput",()=>({prependContainer:null,textInput:null,init(){this.prependContainer=this.$refs.prependContainer,this.textInput=this.$refs.textInput;let t=this;setTimeout(()=>{t.updatePadding()},50),window.addEventListener("resize",this.updatePadding)},destroy(){window.removeEventListener("resize",this.updatePadding)},updatePadding(){const t=this.prependContainer,i=this.textInput;if(!t||!i){i&&i.classList.remove("text-transparent");return}const r=t.offsetWidth+10;i.style.paddingLeft=r+"px",i.classList.remove("text-transparent")}}))}function Ic(e){e.data("rzProgress",()=>({currentVal:0,minVal:0,maxVal:100,percentage:0,label:"",init(){const t=this.$el;this.currentVal=parseInt(t.getAttribute("data-current-val"))||0,this.minVal=parseInt(t.getAttribute("data-min-val"))||0,this.maxVal=parseInt(t.getAttribute("data-max-val"))||100,this.label=t.getAttribute("data-label"),this.calculatePercentage(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuemin",this.minVal),t.setAttribute("aria-valuemax",this.maxVal),t.setAttribute("aria-valuetext",`${this.percentage}%`),this.updateProgressBar(),new ResizeObserver(n=>{this.updateProgressBar()}).observe(t),this.$watch("currentVal",()=>{this.calculatePercentage(),this.updateProgressBar(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuetext",`${this.percentage}%`)})},calculatePercentage(){this.maxVal===this.minVal?this.percentage=0:this.percentage=Math.min(Math.max((this.currentVal-this.minVal)/(this.maxVal-this.minVal)*100,0),100)},buildLabel(){var t=this.label||"{percent}%";return this.calculatePercentage(),t.replace("{percent}",this.percentage)},buildInsideLabelPosition(){const t=this.$refs.progressBar,i=this.$refs.progressBarLabel,n=this.$refs.innerLabel;i&&t&&n&&(n.innerText=this.buildLabel(),i.clientWidth>t.clientWidth?i.style.left=t.clientWidth+10+"px":i.style.left=t.clientWidth/2-i.clientWidth/2+"px")},getLabelCss(){const t=this.$refs.progressBarLabel,i=this.$refs.progressBar;return t&&i&&t.clientWidth>i.clientWidth?"text-foreground dark:text-foreground":""},updateProgressBar(){const t=this.$refs.progressBar;t&&(t.style.width=`${this.percentage}%`,this.buildInsideLabelPosition())},setProgress(t){this.currentVal=t},increment(t=1){this.currentVal=Math.min(this.currentVal+t,this.maxVal)},decrement(t=1){this.currentVal=Math.max(this.currentVal-t,this.minVal)}}))}function Cc(e){e.data("rzQuickReferenceContainer",()=>({headings:[],currentHeadingId:"",init(){this.headings=JSON.parse(this.$el.dataset.headings||"[]"),this.currentHeadingId=this.$el.dataset.currentheadingid||""},handleHeadingClick(){const t=this.$el.dataset.headingid;window.requestAnimationFrame(()=>{this.currentHeadingId=t})},setCurrentHeading(t){this.headings.includes(t)&&(this.currentHeadingId=t)},getSelectedCss(){const t=this.$el.dataset.headingid;return{"font-bold":this.currentHeadingId===t}},getSelectedAriaCurrent(){const t=this.$el.dataset.headingid;return this.currentHeadingId===t?"true":null}}))}function Tc(e){e.data("rzSheet",()=>({open:!1,init(){this.open=this.$el.dataset.defaultOpen==="true"},toggle(){this.open=!this.open},close(){this.open=!1},show(){this.open=!0},state(){return this.open?"open":"closed"}}))}function Sc(e){e.data("rzTabs",()=>({selectedTab:"",_triggers:[],_observer:null,init(){const t=this.$el.dataset.defaultValue;this._observer=new MutationObserver(()=>this.refreshTriggers()),this._observer.observe(this.$el,{childList:!0,subtree:!0}),this.refreshTriggers(),t&&this._triggers.some(i=>i.dataset.value===t)?this.selectedTab=t:this._triggers.length>0&&(this.selectedTab=this._triggers[0].dataset.value)},destroy(){this._observer&&this._observer.disconnect()},refreshTriggers(){this._triggers=Array.from(this.$el.querySelectorAll('[role="tab"]'))},onTriggerClick(t){const i=t.currentTarget?.dataset?.value;!i||t.currentTarget.getAttribute("aria-disabled")==="true"||(this.selectedTab=i,this.$dispatch("rz:tabs-change",{value:this.selectedTab}))},isSelected(t){return this.selectedTab===t},bindTrigger(){this.selectedTab;const t=this.$el.dataset.value,i=this.isSelected(t),n=this.$el.getAttribute("aria-disabled")==="true";return{"aria-selected":String(i),tabindex:i?"0":"-1","data-state":i?"active":"inactive",...n&&{disabled:!0}}},_attrDisabled(){return this.$el.getAttribute("aria-disabled")==="true"?"true":null},_attrAriaSelected(){return String(this.$el.dataset.value===this.selectedTab)},_attrHidden(){return this.$el.dataset.value===this.selectedTab?null:"true"},_attrAriaHidden(){return String(this.selectedTab!==this.$el.dataset.value)},_attrDataState(){return this.selectedTab===this.$el.dataset.value?"active":"inactive"},_attrTabIndex(){return this.selectedTab===this.$el.dataset.value?"0":"-1"},onListKeydown(t){if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End"].includes(t.key)){t.preventDefault();const i=this._triggers.filter(l=>l.getAttribute("aria-disabled")!=="true");if(i.length===0)return;const n=i.findIndex(l=>l.dataset.value===this.selectedTab);if(n===-1)return;const r=t.currentTarget?.getAttribute("aria-orientation")==="vertical",s=r?"ArrowUp":"ArrowLeft",o=r?"ArrowDown":"ArrowRight";let a=n;switch(t.key){case s:a=n-1<0?i.length-1:n-1;break;case o:a=(n+1)%i.length;break;case"Home":a=0;break;case"End":a=i.length-1;break}if(a>=0&&a<i.length){const l=i[a];this.selectedTab=l.dataset.value,this.$nextTick(()=>l.focus())}}}}))}function Ac(e){e.data("rzSidebar",()=>({open:!1,openMobile:!1,isMobile:!1,collapsible:"offcanvas",shortcut:"b",cookieName:"sidebar_state",mobileBreakpoint:768,init(){this.collapsible=this.$el.dataset.collapsible||"offcanvas",this.shortcut=this.$el.dataset.shortcut||"b",this.cookieName=this.$el.dataset.cookieName||"sidebar_state",this.mobileBreakpoint=parseInt(this.$el.dataset.mobileBreakpoint)||768;const t=this.cookieName?document.cookie.split("; ").find(n=>n.startsWith(`${this.cookieName}=`))?.split("=")[1]:null,i=this.$el.dataset.defaultOpen==="true";this.open=t!==null?t==="true":i,this.checkIfMobile(),window.addEventListener("keydown",n=>{(n.ctrlKey||n.metaKey)&&n.key.toLowerCase()===this.shortcut.toLowerCase()&&(n.preventDefault(),this.toggle())}),this.$watch("open",n=>{this.cookieName&&(document.cookie=`${this.cookieName}=${n}; path=/; max-age=31536000`)})},checkIfMobile(){this.isMobile=window.innerWidth<this.mobileBreakpoint},toggle(){this.isMobile?this.openMobile=!this.openMobile:this.open=!this.open},close(){this.isMobile&&(this.openMobile=!1)},isMobileOpen(){return this.openMobile},desktopState(){return this.open?"expanded":"collapsed"},mobileState(){return this.openMobile?"open":"closed"},getCollapsibleAttribute(){return this.desktopState()==="collapsed"?this.collapsible:""}}))}function Oc(e){e.data("rzCommand",()=>({search:"",selectedValue:null,selectedIndex:-1,items:[],filteredItems:[],groupTemplates:new Map,activeDescendantId:null,isOpen:!1,isEmpty:!0,firstRender:!0,isLoading:!1,error:null,loop:!1,shouldFilter:!0,itemsUrl:null,fetchTrigger:"immediate",serverFiltering:!1,dataItemTemplateId:null,_dataFetched:!1,_debounceTimer:null,showLoading(){return this.isLoading},hasError(){return this.error!==null},notHasError(){return this.error==null},shouldShowEmpty(){return this.isEmpty&&this.search&&!this.isLoading&&!this.error},shouldShowEmptyOrError(){return this.isEmpty&&this.search&&!this.isLoading||this.error!==null},init(){this.loop=this.$el.dataset.loop==="true",this.shouldFilter=this.$el.dataset.shouldFilter!=="false",this.selectedValue=this.$el.dataset.selectedValue||null,this.itemsUrl=this.$el.dataset.itemsUrl||null,this.fetchTrigger=this.$el.dataset.fetchTrigger||"immediate",this.serverFiltering=this.$el.dataset.serverFiltering==="true",this.dataItemTemplateId=this.$el.dataset.templateId||null;const t=this.$el.dataset.itemsId;let i=[];if(t){const n=document.getElementById(t);if(n)try{i=JSON.parse(n.textContent||"[]")}catch(r){console.error(`RzCommand: Failed to parse JSON from script tag #${t}`,r)}}i.length>0&&!this.dataItemTemplateId&&console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them."),i.forEach(n=>{n.id=n.id||`static-item-${crypto.randomUUID()}`,n.isDataItem=!0,this.registerItem(n)}),this.itemsUrl&&this.fetchTrigger==="immediate"&&this.fetchItems(),this.$watch("search",n=>{this.firstRender=!1,this.serverFiltering?(clearTimeout(this._debounceTimer),this._debounceTimer=setTimeout(()=>{this.fetchItems(n)},300)):this.filterAndSortItems()}),this.$watch("selectedIndex",(n,r)=>{if(r>-1){const s=this.filteredItems[r];if(s){const o=this.$el.querySelector(`[data-command-item-id="${s.id}"]`);o&&(o.removeAttribute("data-selected"),o.setAttribute("aria-selected","false"))}}if(n>-1&&this.filteredItems[n]){const s=this.filteredItems[n];this.activeDescendantId=s.id;const o=this.$el.querySelector(`[data-command-item-id="${s.id}"]`);o&&(o.setAttribute("data-selected","true"),o.setAttribute("aria-selected","true"),o.scrollIntoView({block:"nearest"}));const a=s.value;this.selectedValue!==a&&(this.selectedValue=a,this.$dispatch("rz:command:select",{value:a}))}else this.activeDescendantId=null,this.selectedValue=null}),this.$watch("selectedValue",n=>{const r=this.filteredItems.findIndex(s=>s.value===n);this.selectedIndex!==r&&(this.selectedIndex=r)}),this.$watch("filteredItems",n=>{this.isOpen=n.length>0||this.isLoading,this.isEmpty=n.length===0,this.firstRender||window.dispatchEvent(new CustomEvent("rz:command:list-changed",{detail:{items:this.filteredItems,groups:this.groupTemplates,commandId:this.$el.id}}))})},async fetchItems(t=""){if(this.itemsUrl){if(!this.dataItemTemplateId){console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data."),this.error="Configuration error: No data template found.";return}this.isLoading=!0,this.error=null;try{const i=new URL(this.itemsUrl,window.location.origin);this.serverFiltering&&t&&i.searchParams.append("q",t);const n=await fetch(i);if(!n.ok)throw new Error(`Network response was not ok: ${n.statusText}`);const r=await n.json();this.serverFiltering&&(this.items=this.items.filter(s=>!s.isDataItem)),r.forEach(s=>{s.id=s.id||`data-item-${crypto.randomUUID()}`,s.isDataItem=!0,this.registerItem(s)}),this._dataFetched=!0}catch(i){this.error=i.message||"Failed to fetch command items.",console.error("RzCommand:",this.error)}finally{this.isLoading=!1,this.filterAndSortItems()}}},handleInteraction(){this.itemsUrl&&this.fetchTrigger==="on-open"&&!this._dataFetched&&this.fetchItems()},registerItem(t){this.items.some(i=>i.id===t.id)||(t._order=this.items.length,this.items.push(t),this.selectedIndex===-1&&(this.selectedIndex=0),this.serverFiltering||this.filterAndSortItems())},unregisterItem(t){this.items=this.items.filter(i=>i.id!==t),this.filterAndSortItems()},registerGroupTemplate(t,i){this.groupTemplates.has(t)||this.groupTemplates.set(t,i)},filterAndSortItems(){if(this.serverFiltering&&this._dataFetched){this.filteredItems=this.items,this.selectedIndex=this.filteredItems.length>0?0:-1;return}let t;if(!this.shouldFilter||!this.search?t=this.items.map(i=>({...i,score:1})):t=this.items.map(i=>({...i,score:i.forceMount?0:this.commandScore(i.name,this.search,i.keywords)})).filter(i=>i.score>0||i.forceMount).sort((i,n)=>i.forceMount&&!n.forceMount?1:!i.forceMount&&n.forceMount?-1:n.score!==i.score?n.score-i.score:(i._order||0)-(n._order||0)),this.filteredItems=t,this.selectedValue){const i=this.filteredItems.findIndex(n=>n.value===this.selectedValue);this.selectedIndex=i>-1?i:this.filteredItems.length>0?0:-1}else this.selectedIndex=this.filteredItems.length>0?0:-1},handleItemClick(t){const i=t.target.closest("[data-command-item-id]");if(!i)return;const n=i.dataset.commandItemId,r=this.filteredItems.findIndex(s=>s.id===n);if(r>-1){const s=this.filteredItems[r];s&&!s.disabled&&(this.selectedIndex=r,this.$dispatch("rz:command:execute",{value:s.value}))}},handleItemHover(t){const i=t.target.closest("[data-command-item-id]");if(!i)return;const n=i.dataset.commandItemId,r=this.filteredItems.findIndex(s=>s.id===n);if(r>-1){const s=this.filteredItems[r];s&&!s.disabled&&this.selectedIndex!==r&&(this.selectedIndex=r)}},handleKeydown(t){switch(t.key){case"ArrowDown":t.preventDefault(),this.selectNext();break;case"ArrowUp":t.preventDefault(),this.selectPrev();break;case"Home":t.preventDefault(),this.selectFirst();break;case"End":t.preventDefault(),this.selectLast();break;case"Enter":t.preventDefault();const i=this.filteredItems[this.selectedIndex];i&&!i.disabled&&this.$dispatch("rz:command:execute",{value:i.value});break}},selectNext(){if(this.filteredItems.length===0)return;let t=this.selectedIndex,i=0;do{if(t=t+1>=this.filteredItems.length?this.loop?0:this.filteredItems.length-1:t+1,i++,!this.filteredItems[t]?.disabled){this.selectedIndex=t;return}if(!this.loop&&t===this.filteredItems.length-1)return}while(i<=this.filteredItems.length)},selectPrev(){if(this.filteredItems.length===0)return;let t=this.selectedIndex,i=0;do{if(t=t-1<0?this.loop?this.filteredItems.length-1:0:t-1,i++,!this.filteredItems[t]?.disabled){this.selectedIndex=t;return}if(!this.loop&&t===0)return}while(i<=this.filteredItems.length)},selectFirst(){if(this.filteredItems.length>0){const t=this.filteredItems.findIndex(i=>!i.disabled);t>-1&&(this.selectedIndex=t)}},selectLast(){if(this.filteredItems.length>0){const t=this.filteredItems.map(i=>i.disabled).lastIndexOf(!1);t>-1&&(this.selectedIndex=t)}},commandScore(t,i,n=[]){const d=/[\\/_+.#"@[\(\{&]/,f=/[\s-]/,y=`${t} ${n?n.join(" "):""}`;function m(p){return p.toLowerCase().replace(/[\s-]/g," ")}function v(p,b,h,_,E,x,g){if(x===b.length)return E===p.length?1:.99;const w=`${E},${x}`;if(g[w]!==void 0)return g[w];const I=_.charAt(x);let C=h.indexOf(I,E),T=0;for(;C>=0;){let S=v(p,b,h,_,C+1,x+1,g);S>T&&(C===E?S*=1:d.test(p.charAt(C-1))?S*=.8:f.test(p.charAt(C-1))?S*=.9:(S*=.17,E>0&&(S*=Math.pow(.999,C-E))),p.charAt(C)!==b.charAt(x)&&(S*=.9999)),S>T&&(T=S),C=h.indexOf(I,C+1)}return g[w]=T,T}return v(y,i,m(y),m(i),0,0,{})}}))}function $c(e){e.data("rzCommandItem",()=>({parent:null,itemData:{},init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandItem must be a child of RzCommand.");return}this.parent=e.$data(t),this.itemData={id:this.$el.id,value:this.$el.dataset.value||this.$el.textContent.trim(),name:this.$el.dataset.name||this.$el.dataset.value||this.$el.textContent.trim(),keywords:JSON.parse(this.$el.dataset.keywords||"[]"),group:this.$el.dataset.group||null,templateId:this.$el.id+"-template",disabled:this.$el.dataset.disabled==="true",forceMount:this.$el.dataset.forceMount==="true"},this.parent.registerItem(this.itemData)},destroy(){this.parent&&this.parent.unregisterItem(this.itemData.id)}}))}function Nc(e){e.data("rzCommandList",()=>({parent:null,dataItemTemplate:null,init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandList must be a child of RzCommand.");return}this.parent=e.$data(t),this.parent.dataItemTemplateId&&(this.dataItemTemplate=document.getElementById(this.parent.dataItemTemplateId))},renderList(t){if(t.detail.commandId!==this.parent.$el.id)return;const i=t.detail.items||[],n=t.detail.groups||new Map,r=this.$el;r.querySelectorAll("[data-dynamic-item]").forEach(o=>o.remove());const s=new Map([["__ungrouped__",[]]]);i.forEach(o=>{const a=o.group||"__ungrouped__";s.has(a)||s.set(a,[]),s.get(a).push(o)}),s.forEach((o,a)=>{if(o.length===0)return;const l=document.createElement("div");if(l.setAttribute("role","group"),l.setAttribute("data-dynamic-item","true"),l.setAttribute("data-slot","command-group"),a!=="__ungrouped__"){const c=n.get(a);if(c){const u=document.getElementById(c);if(u&&u.content){const d=u.content.cloneNode(!0),f=d.firstElementChild;f&&(l.setAttribute("aria-labelledby",f.id),l.appendChild(d))}}}o.forEach(c=>{const u=this.parent.filteredItems.indexOf(c);let d;if(c.isDataItem){if(!this.dataItemTemplate)return;d=this.dataItemTemplate.content.cloneNode(!0).firstElementChild,e.addScopeToNode(d,{item:c})}else{const f=document.getElementById(c.templateId);f&&f.content&&(d=f.content.cloneNode(!0).querySelector(`[data-command-item-id="${c.id}"]`))}d&&(d.setAttribute("data-command-item-id",c.id),d.setAttribute("data-value",c.value),c.keywords&&d.setAttribute("data-keywords",JSON.stringify(c.keywords)),c.group&&d.setAttribute("data-group",c.group),c.disabled&&d.setAttribute("data-disabled","true"),c.forceMount&&d.setAttribute("data-force-mount","true"),d.setAttribute("role","option"),d.setAttribute("aria-selected",this.parent.selectedIndex===u),c.disabled&&d.setAttribute("aria-disabled","true"),this.parent.selectedIndex===u&&d.setAttribute("data-selected","true"),l.appendChild(d),e.initTree(d))}),r.appendChild(l)})}}))}function kc(e){e.data("rzCommandGroup",()=>({parent:null,heading:"",templateId:"",init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandGroup must be a child of RzCommand.");return}this.parent=e.$data(t),this.heading=this.$el.dataset.heading,this.templateId=this.$el.dataset.templateId,this.heading&&this.templateId&&this.parent.registerGroupTemplate(this.heading,this.templateId)}}))}async function Rc(e){e=[...e].sort();const t=e.join("|"),n=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}function xe(e,t,i){let n,r;typeof t=="function"?n={success:t}:t&&typeof t=="object"?n=t:typeof t=="string"&&(r=t),!r&&typeof i=="string"&&(r=i);const s=Array.isArray(e)?e:[e];return Rc(s).then(o=>(se.isDefined(o)||se(s,o,{async:!1,inlineScriptNonce:r,inlineStyleNonce:r}),new Promise((a,l)=>{se.ready(o,{success:()=>{try{n&&typeof n.success=="function"&&n.success()}catch(c){console.error("[rizzyRequire] success callback threw:",c)}a({bundleId:o})},error:c=>{try{n&&typeof n.error=="function"&&n.error(c)}catch(u){console.error("[rizzyRequire] error callback threw:",u)}l(new Error(`[rizzyRequire] Failed to load bundle ${o} (missing: ${Array.isArray(c)?c.join(", "):String(c)})`))}})})))}function Lc(e){Tl(e),Sl(e),Al(e),Ol(e),$l(e),Nl(e,xe),kl(e,xe),Rl(e,xe),Ll(e),Pl(e,xe),Dl(e,xe),Ml(e),hc(e),pc(e),mc(e),gc(e),vc(e),bc(e),yc(e),wc(e,xe),_c(e),xc(e),Ec(e),Ic(e),Cc(e),Tc(e),Sc(e),Ac(e),Oc(e),$c(e),Nc(e),kc(e)}function Pc(e){if(!(e instanceof Element))return console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el)."),{};const t=e.dataset.propsId;if(!t)return{};const i=document.getElementById(t);if(!i)return console.warn(`[Rizzy.props] Could not find the props script tag with ID '${t}'.`),{};try{return JSON.parse(i.textContent||"{}")}catch(n){return console.error(`[Rizzy.props] Failed to parse JSON from script tag #${t}.`,n),{}}}const Dt=new Map,Mt=new Map;let as=!1;function Dc(e){return Mt.has(e)||Mt.set(e,import(e).catch(t=>{throw Mt.delete(e),t})),Mt.get(e)}function ls(e,t){const i=globalThis.Alpine;return i&&typeof i.asyncData=="function"?(i.asyncData(e,()=>Dc(t).catch(n=>(console.error(`[RizzyUI] Failed to load Alpine module '${e}' from '${t}'.`,n),()=>({_error:!0,_errorMessage:`Module '${e}' failed to load.`})))),!0):(console.error(`[RizzyUI] Could not register async component '${e}'. AsyncAlpine not available.`),!1)}function Mc(e,t){if(!e||!t){console.error("[RizzyUI] registerAsyncComponent requires both name and path.");return}const i=Dt.get(e);i&&i.path!==t&&console.warn(`[RizzyUI] Re-registering '${e}' with a different path.
  Previous: ${i.path}
  New:      ${t}`);const n=globalThis.Alpine;if(n&&n.version){const r=!i||i.path!==t;if(!(i&&i.loaderSet&&!r)){const o=ls(e,t);Dt.set(e,{path:t,loaderSet:o})}return}Dt.set(e,{path:t,loaderSet:!1}),as||(as=!0,document.addEventListener("alpine:init",()=>{for(const[r,s]of Dt)if(!s.loaderSet){const o=ls(r,s.path);s.loaderSet=o}},{once:!0}))}function zc(e){e.directive("mobile",(t,{modifiers:i,expression:n},{cleanup:r})=>{const s=i.find(b=>b.startsWith("bp-")),o=s?parseInt(s.slice(3),10):768,a=!!(n&&n.length>0);if(typeof window>"u"||!window.matchMedia){t.dataset.mobile="false",t.dataset.screen="desktop";return}const l=()=>window.innerWidth<o,c=b=>{t.dataset.mobile=b?"true":"false",t.dataset.screen=b?"mobile":"desktop"},u=()=>typeof e.$data=="function"?e.$data(t):t.__x?t.__x.$data:null,d=b=>{if(!a)return;const h=u();h&&(h[n]=b)},f=b=>{t.dispatchEvent(new CustomEvent("screen:change",{bubbles:!0,detail:{isMobile:b,width:window.innerWidth,breakpoint:o}}))},y=window.matchMedia(`(max-width: ${o-1}px)`),m=()=>{const b=l();c(b),d(b),f(b)};m();const v=()=>m(),p=()=>m();y.addEventListener("change",v),window.addEventListener("resize",p,{passive:!0}),r(()=>{y.removeEventListener("change",v),window.removeEventListener("resize",p)})})}function Fc(e){const t=(i,{expression:n,modifiers:r},{cleanup:s,effect:o})=>{if(!n||typeof n!="string")return;const a=(v,p,b)=>{const _=p.replace(/\[(\d+)\]/g,".$1").split("."),E=_.pop();let x=v;for(const g of _)(x[g]==null||typeof x[g]!="object")&&(x[g]=isFinite(+g)?[]:{}),x=x[g];x[E]=b},l=e.closestDataStack(i)||[],c=l[0]||null,u=l[1]||null;if(!c||!u)return;const d=n.split(",").map(v=>v.trim()).filter(Boolean).map(v=>{const p=v.split("->").map(b=>b.trim());return p.length!==2?(console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ',v),null):{parentPath:p[0],childPath:p[1]}}).filter(Boolean),f=r.includes("init-child")||r.includes("child")||r.includes("childWins"),y=d.map(()=>({fromParent:!1,fromChild:!1,skipChildOnce:f})),m=[];d.forEach((v,p)=>{const b=y[p];if(f){const E=e.evaluate(i,v.childPath,{scope:c});b.fromChild=!0,a(u,v.parentPath,E),queueMicrotask(()=>{b.fromChild=!1})}else{const E=e.evaluate(i,v.parentPath,{scope:u});b.fromParent=!0,a(c,v.childPath,E),queueMicrotask(()=>{b.fromParent=!1})}const h=o(()=>{const E=e.evaluate(i,v.parentPath,{scope:u});b.fromChild||(b.fromParent=!0,a(c,v.childPath,E),queueMicrotask(()=>{b.fromParent=!1}))}),_=o(()=>{const E=e.evaluate(i,v.childPath,{scope:c});if(!b.fromParent){if(b.skipChildOnce){b.skipChildOnce=!1;return}b.fromChild=!0,a(u,v.parentPath,E),queueMicrotask(()=>{b.fromChild=!1})}});m.push(h,_)}),s(()=>{for(const v of m)try{v&&v()}catch{}})};e.directive("syncprop",t)}class Uc{constructor(){this.storageKey="darkMode",this.eventName="rz:theme-change",this.darkClass="dark",this._mode="auto",this._mq=null,this._initialized=!1,this._onMqChange=null,this._onStorage=null,this._lastSnapshot={mode:null,effectiveDark:null,prefersDark:null}}init(){if(this._initialized||typeof window>"u")return;this._initialized=!0,this._mq=typeof window.matchMedia=="function"?window.matchMedia("(prefers-color-scheme: dark)"):null;const t=this._safeReadStorage(this.storageKey);this._mode=this._normalizeMode(t??"auto"),this._sync(),this._onMqChange=()=>{this._sync()},this._mq&&(typeof this._mq.addEventListener=="function"?this._mq.addEventListener("change",this._onMqChange):typeof this._mq.addListener=="function"&&this._mq.addListener(this._onMqChange)),this._onStorage=i=>{if(i.key!==this.storageKey)return;const n=this._normalizeMode(i.newValue??"auto");n!==this._mode&&(this._mode=n,this._sync())},window.addEventListener("storage",this._onStorage)}destroy(){this._initialized&&(this._initialized=!1,this._mq&&this._onMqChange&&(typeof this._mq.removeEventListener=="function"?this._mq.removeEventListener("change",this._onMqChange):typeof this._mq.removeListener=="function"&&this._mq.removeListener(this._onMqChange)),typeof window<"u"&&this._onStorage&&window.removeEventListener("storage",this._onStorage),this._onMqChange=null,this._onStorage=null,this._mq=null,this._lastSnapshot={mode:null,effectiveDark:null,prefersDark:null})}get mode(){return this._mode}get prefersDark(){return!!this._mq?.matches}get effectiveDark(){return this._mode==="dark"||this._mode==="auto"&&this.prefersDark}isDark(){return this.effectiveDark}isLight(){return!this.effectiveDark}setLight(){this._setMode("light")}setDark(){this._setMode("dark")}setAuto(){this._setMode("auto")}toggle(){const t=this.effectiveDark;this._setMode(t?"light":"dark")}_setMode(t){this._mode=this._normalizeMode(t),this._persist(),this._sync()}_normalizeMode(t){return t==="light"||t==="dark"||t==="auto"?t:"auto"}_safeReadStorage(t){try{return window?.localStorage?.getItem(t)}catch{return null}}_persist(){try{window?.localStorage?.setItem(this.storageKey,this._mode)}catch{}}_sync(){const t=this.effectiveDark,i=this._mode,n=this.prefersDark,r=typeof document<"u"?document.documentElement:null,s=r?r.classList.contains(this.darkClass)===t&&r.style.colorScheme===(t?"dark":"light"):!0;this._lastSnapshot.mode===i&&this._lastSnapshot.effectiveDark===t&&this._lastSnapshot.prefersDark===n&&s||(this._lastSnapshot={mode:i,effectiveDark:t,prefersDark:n},r&&(r.classList.toggle(this.darkClass,t),r.style.colorScheme=t?"dark":"light"),typeof window<"u"&&window.dispatchEvent(new CustomEvent(this.eventName,{detail:{mode:i,darkMode:t,prefersDark:n,source:"RizzyUI"}})))}}const L=new Uc;function Bc(e){L.init(),e.store("theme",{_mode:L.mode,_prefersDark:L.prefersDark,_effectiveDark:L.effectiveDark,_onThemeChange:null,init(){this._onThemeChange||(this._onThemeChange=()=>this._refresh(),window.addEventListener(L.eventName,this._onThemeChange)),this._refresh()},_refresh(){this._mode=L.mode,this._prefersDark=L.prefersDark,this._effectiveDark=L.effectiveDark},get mode(){return this._mode},get effectiveDark(){return this._effectiveDark},get prefersDark(){return this._prefersDark},get isDark(){return this._effectiveDark},get isLight(){return!this._effectiveDark},setLight(){L.setLight()},setDark(){L.setDark()},setAuto(){L.setAuto()},toggle(){L.toggle()}})}let Qe=null;function jc(e){return Qe||(e.plugin(Ta),e.plugin(Na),e.plugin(Xa),e.plugin(al),typeof document<"u"&&document.addEventListener("alpine:init",()=>{Bc(e)}),Lc(e),zc(e),Fc(e),Qe={Alpine:e,require:xe,toast:wl,$data:Il,props:Pc,registerAsyncComponent:Mc,theme:L},typeof window<"u"&&(L.init(),window.Alpine=e,window.Rizzy={...window.Rizzy||{},...Qe},document.dispatchEvent(new CustomEvent("rz:init",{detail:{Rizzy:window.Rizzy}}))),Qe)}const Vc=jc(ur);return ur.start(),Vc});
</file>

<file path="wwwroot/js/rizzyui.es.js">
var flushPending = false;
var flushing = false;
var queue = [];
var lastFlushedIndex = -1;
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  let index = queue.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex)
    queue.splice(index, 1);
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i2 = 0; i2 < queue.length; i2++) {
    queue[i2]();
    lastFlushedIndex = i2;
  }
  queue.length = 0;
  lastFlushedIndex = -1;
  flushing = false;
}
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  } });
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup2 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i2) => i2());
      };
    }
    el._x_effects.add(effectReference);
    cleanup2 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup2();
  }];
}
function watch(getter, callback) {
  let firstTime = true;
  let oldValue;
  let effectReference = effect(() => {
    let value = getter();
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  });
  return () => release(effectReference);
}
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds.push(callback);
  }
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i2) => i2());
      delete el._x_attributeCleanups[name];
    }
  });
}
function cleanupElement(el) {
  el._x_effects?.forEach(dequeueJob);
  while (el._x_cleanups?.length)
    el._x_cleanups.pop()();
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var queuedMutations = [];
function flushObserver() {
  let records = observer.takeRecords();
  queuedMutations.push(() => records.length > 0 && onMutate(records));
  let queueLengthWhenTriggered = queuedMutations.length;
  queueMicrotask(() => {
    if (queuedMutations.length === queueLengthWhenTriggered) {
      while (queuedMutations.length > 0)
        queuedMutations.shift()();
    }
  });
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = /* @__PURE__ */ new Set();
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < mutations.length; i2++) {
    if (mutations[i2].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i2].type === "childList") {
      mutations[i2].removedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (!node._x_marker)
          return;
        removedNodes.add(node);
      });
      mutations[i2].addedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (removedNodes.has(node)) {
          removedNodes.delete(node);
          return;
        }
        if (node._x_marker)
          return;
        addedNodes.push(node);
      });
    }
    if (mutations[i2].type === "attributes") {
      let el = mutations[i2].target;
      let name = mutations[i2].attributeName;
      let oldValue = mutations[i2].oldValue;
      let add2 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add2();
      } else if (el.hasAttribute(name)) {
        remove();
        add2();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i2) => i2(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.some((i2) => i2.contains(node)))
      continue;
    onElRemoveds.forEach((i2) => i2(node));
  }
  for (let node of addedNodes) {
    if (!node.isConnected)
      continue;
    onElAddeds.forEach((i2) => i2(node));
  }
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data2, referenceNode) {
  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
  };
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  return new Proxy({ objects }, mergeProxyTrap);
}
var mergeProxyTrap = {
  ownKeys({ objects }) {
    return Array.from(
      new Set(objects.flatMap((i2) => Object.keys(i2)))
    );
  },
  has({ objects }, name) {
    if (name == Symbol.unscopables)
      return false;
    return objects.some(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
    );
  },
  get({ objects }, name, thisProxy) {
    if (name == "toJSON")
      return collapseProxies;
    return Reflect.get(
      objects.find(
        (obj) => Reflect.has(obj, name)
      ) || {},
      name,
      thisProxy
    );
  },
  set({ objects }, name, value, thisProxy) {
    const target = objects.find(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name)
    ) || objects[objects.length - 1];
    const descriptor = Object.getOwnPropertyDescriptor(target, name);
    if (descriptor?.set && descriptor?.get)
      return descriptor.set.call(thisProxy, value) || true;
    return Reflect.set(target, name, value);
  }
};
function collapseProxies() {
  let keys = Reflect.ownKeys(this);
  return keys.reduce((acc, key) => {
    acc[key] = Reflect.get(this, key);
    return acc;
  }, {});
}
function initInterceptors(data2) {
  let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      if (typeof value === "object" && value !== null && value.__v_skip)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data2, path, key);
      } else {
        if (isObject2(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data2);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data2, path, key) {
      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data2, path, key) => {
        let innerValue = initialValue.initialize(data2, path, key);
        obj.initialValue = innerValue;
        return initialize(data2, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  let memoizedUtilities = getUtilities(el);
  Object.entries(magics).forEach(([name, callback]) => {
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, memoizedUtilities);
      },
      enumerable: false
    });
  });
  return obj;
}
function getUtilities(el) {
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  let utils = { interceptor, ...utilities };
  onElRemoved(el, cleanup2);
  return utils;
}
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e2) {
    handleError(e2, el, expression);
  }
}
function handleError(error2, el, expression = void 0) {
  error2 = Object.assign(
    error2 ?? { message: "No error message given." },
    { el, expression }
  );
  console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error2;
  }, 0);
}
var shouldAutoEvaluateFunctions = true;
function dontAutoEvaluateFunctions(callback) {
  let cache = shouldAutoEvaluateFunctions;
  shouldAutoEvaluateFunctions = false;
  let result = callback();
  shouldAutoEvaluateFunctions = cache;
  return result;
}
function evaluate$1(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [], context } = {}) => {
    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      let func2 = new AsyncFunction(
        ["__self", "scope"],
        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
      );
      Object.defineProperty(func2, "name", {
        value: `[Alpine] ${expression}`
      });
      return func2;
    } catch (error2) {
      handleError(error2, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [], context } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope2, ...dataStack]);
    if (typeof func === "function") {
      let promise = func.call(context, func, completeScope).catch((error2) => handleError(error2, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope2, params, el) {
  if (shouldAutoEvaluateFunctions && typeof value === "function") {
    let result = value.apply(scope2, params);
    if (result instanceof Promise) {
      result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i2) => receiver(i2));
  } else {
    receiver(value);
  }
}
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
  return {
    before(directive2) {
      if (!directiveHandlers[directive2]) {
        console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
        return;
      }
      const pos = directiveOrder.indexOf(directive2);
      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directiveExists(name) {
  return Object.keys(directiveHandlers).includes(name);
}
function directives(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives2.map((directive2) => {
    return getDirectiveHandler(el, directive2);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = /* @__PURE__ */ new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities(el) {
  let cleanups = [];
  let cleanup2 = (callback) => cleanups.push(callback);
  let [effect3, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect3,
    cleanup: cleanup2,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate$1.bind(evaluate$1, el)
  };
  let doCleanup = () => cleanups.forEach((i2) => i2());
  return [utilities, doCleanup];
}
function getDirectiveHandler(el, directive2) {
  let noop = () => {
  };
  let handler4 = directiveHandlers[directive2.type] || noop;
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  onAttributeRemoved(el, directive2.original, cleanup2);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler4.inline && handler4.inline(el, directive2, utilities);
    handler4 = handler4.bind(handler4, el, directive2, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
  };
  fullHandler.runCleanups = cleanup2;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into = (i2) => i2;
function toTransformedAttributes(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
      return transform(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({ name }) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i2) => i2.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport"
];
function byPriority(a2, b) {
  let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      // Allows events to pass the shadow DOM barrier.
      composed: true,
      cancelable: true
    })
  );
}
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback);
    node = node.nextElementSibling;
  }
}
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started = false;
function start() {
  if (started)
    warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started = true;
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
  setTimeout(() => {
    warnAboutMissingPlugins();
  });
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
var initInterceptors2 = [];
function interceptInit(callback) {
  initInterceptors2.push(callback);
}
var markerDispenser = 1;
function initTree(el, walker = walk, intercept = () => {
}) {
  if (findClosest(el, (i2) => i2._x_ignore))
    return;
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      if (el2._x_marker)
        return;
      intercept(el2, skip);
      initInterceptors2.forEach((i2) => i2(el2, skip));
      directives(el2, el2.attributes).forEach((handle) => handle());
      if (!el2._x_ignore)
        el2._x_marker = markerDispenser++;
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root, walker = walk) {
  walker(root, (el) => {
    cleanupElement(el);
    cleanupAttributes(el);
    delete el._x_marker;
  });
}
function warnAboutMissingPlugins() {
  let pluginDirectives = [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ];
  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
    if (directiveExists(directive2))
      return;
    selectors.some((selector) => {
      if (document.querySelector(selector)) {
        warn(`found "${selector}", but missing ${plugin2} plugin`);
        return true;
      }
    });
  });
}
var tickStack = [];
var isHolding = false;
function nextTick(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
  return new Promise((res) => {
    tickStack.push(() => {
      callback();
      res();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i2) => {
    if (el.classList.contains(i2)) {
      el.classList.remove(i2);
      removed.push(i2);
    }
  });
  forAdd.forEach((i2) => {
    if (!el.classList.contains(i2)) {
      el.classList.add(i2);
      added.push(i2);
    }
  });
  return () => {
    removed.forEach((i2) => el.classList.add(i2));
    added.forEach((i2) => el.classList.remove(i2));
  };
}
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "function")
    expression = evaluate2(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    "enter": (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    "leave": (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
  let delay3 = modifierValue$1(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue$1(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick2(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
    el._x_transition.out(() => {
    }, () => resolve(hide));
    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick2(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i2]) => i2?.());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e2) => {
          if (!e2.isFromCancelledTransition)
            throw e2;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start2);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay3 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay3);
      reachedEnd = true;
    });
  });
}
function modifierValue$1(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function onlyDuringClone(callback) {
  return (...args) => isCloning && callback(...args);
}
var interceptors = [];
function interceptClone(callback) {
  interceptors.push(callback);
}
function cloneNode(from, to) {
  interceptors.forEach((i2) => i2(from, to));
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    initTree(to, (el, callback) => {
      callback(el, () => {
      });
    });
  });
  isCloning = false;
}
var isCloningLegacy = false;
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  isCloningLegacy = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
  isCloningLegacy = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache);
}
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty(el, name, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (isRadio$1(el)) {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      if (typeof value === "boolean") {
        el.checked = safeParseBoolean(el.value) === value;
      } else {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    }
  } else if (isCheckbox(el)) {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value === void 0 ? "" : value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttributeAndProperty(el, name, value) {
  bindAttribute(el, name, value);
  setPropertyIfChanged(el, name, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function safeParseBoolean(rawValue) {
  if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
    return true;
  }
  if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
    return false;
  }
  return rawValue ? Boolean(rawValue) : null;
}
var booleanAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function isBooleanAttr(attrName) {
  return booleanAttributes.has(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding(el, name, fallback);
}
function extractProp(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions(() => {
      return evaluate$1(el, binding.expression);
    });
  }
  return getAttributeBinding(el, name, fallback);
}
function getAttributeBinding(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function isCheckbox(el) {
  return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
}
function isRadio$1(el) {
  return el.type === "radio" || el.localName === "ui-radio";
}
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this, args = arguments;
    const later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash;
  let reference = effect(() => {
    let outer = outerGet();
    let inner = innerGet();
    if (firstRun) {
      innerSet(cloneIfObject(outer));
      firstRun = false;
    } else {
      let outerHashLatest = JSON.stringify(outer);
      let innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        innerSet(cloneIfObject(outer));
      } else if (outerHashLatest !== innerHashLatest) {
        outerSet(cloneIfObject(inner));
      } else ;
    }
    outerHash = JSON.stringify(outerGet());
    JSON.stringify(innerGet());
  });
  return () => {
    release(reference);
  };
}
function cloneIfObject(value) {
  return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
}
function plugin(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i2) => i2(alpine_default));
}
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  initInterceptors(stores[name]);
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
}
function getStores() {
  return stores;
}
var binds = {};
function bind2(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    return applyBindingsObject(name, getBindings());
  } else {
    binds[name] = getBindings;
  }
  return () => {
  };
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives(el, attributes, original).map((handle) => {
    cleanupRunners.push(handle.runCleanups);
    handle();
  });
  return () => {
    while (cleanupRunners.length)
      cleanupRunners.pop()();
  };
}
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine$1 = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.15.0",
  flushAndStopDeferringMutations,
  dontAutoEvaluateFunctions,
  disableEffectScheduling,
  startObservingMutations,
  stopObservingMutations,
  setReactivityEngine,
  onAttributeRemoved,
  onAttributesAdded,
  closestDataStack,
  skipDuringClone,
  onlyDuringClone,
  addRootSelector,
  addInitSelector,
  interceptClone,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  interceptInit,
  setEvaluator,
  mergeProxies,
  extractProp,
  findClosest,
  onElRemoved,
  closestRoot,
  destroyTree,
  interceptor,
  // INTERNAL: not public API and is subject to change without major release.
  transition,
  // INTERNAL
  setStyles,
  // INTERNAL
  mutateDom,
  directive,
  entangle,
  throttle,
  debounce,
  evaluate: evaluate$1,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  // INTERNAL
  cloneNode,
  // INTERNAL
  bound: getBinding,
  $data: scope,
  watch,
  walk,
  data,
  bind: bind2
};
var alpine_default = Alpine$1;
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return (val) => !!map[val];
}
var EMPTY_OBJ = Object.freeze({});
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap = /* @__PURE__ */ new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol("iterate");
var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function isEffect(fn) {
  return fn && fn._isEffect === true;
}
function effect2(fn, options = EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }
  const effect3 = createReactiveEffect(fn, options);
  if (!options.lazy) {
    effect3();
  }
  return effect3;
}
function stop(effect3) {
  if (effect3.active) {
    cleanup(effect3);
    if (effect3.options.onStop) {
      effect3.options.onStop();
    }
    effect3.active = false;
  }
}
var uid = 0;
function createReactiveEffect(fn, options) {
  const effect3 = function reactiveEffect() {
    if (!effect3.active) {
      return fn();
    }
    if (!effectStack.includes(effect3)) {
      cleanup(effect3);
      try {
        enableTracking();
        effectStack.push(effect3);
        activeEffect = effect3;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };
  effect3.id = uid++;
  effect3.allowRecurse = !!options.allowRecurse;
  effect3._isEffect = true;
  effect3.active = true;
  effect3.raw = fn;
  effect3.deps = [];
  effect3.options = options;
  return effect3;
}
function cleanup(effect3) {
  const { deps } = effect3;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect3);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!shouldTrack || activeEffect === void 0) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add2 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect3) => {
        if (effect3 !== activeEffect || effect3.allowRecurse) {
          effects.add(effect3);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add2);
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add2(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add2(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          add2(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          add2(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const run = (effect3) => {
    if (effect3.options.onTrigger) {
      effect3.options.onTrigger({
        effect: effect3,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect3.options.scheduler) {
      effect3.options.scheduler(effect3);
    } else {
      effect3();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
var get2 = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject(res)) {
      return isReadonly ? readonly(res) : reactive2(res);
    }
    return res;
  };
}
var set2 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get2,
  set: set2,
  deleteProperty,
  has,
  ownKeys: ownKeys$1
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => isObject(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done: done2 } = innerIterator.next();
        return done2 ? { value, done: done2 } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done2
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (target && target[
    "__v_isReadonly"
    /* IS_READONLY */
  ]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* RAW */
  ] && !(isReadonly && target[
    "__v_isReactive"
    /* IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  return observed && toRaw(observed[
    "__v_raw"
    /* RAW */
  ]) || observed;
}
function isRef(r2) {
  return Boolean(r2 && r2.__v_isRef === true);
}
magic("nextTick", () => nextTick);
magic("dispatch", (el) => dispatch.bind(dispatch, el));
magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
  let evaluate2 = evaluateLater2(key);
  let getter = () => {
    let value;
    evaluate2((i2) => value = i2);
    return value;
  };
  let unwatch = watch(getter, callback);
  cleanup2(unwatch);
});
magic("store", getStores);
magic("data", (el) => scope(el));
magic("root", (el) => closestRoot(el));
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  findClosest(el, (i2) => {
    if (i2._x_refs)
      refObjects.push(i2._x_refs);
  });
  return refObjects;
}
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}
magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
  let cacheKey = `${name}${key ? `-${key}` : ""}`;
  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
});
interceptClone((from, to) => {
  if (from._x_id) {
    to._x_id = from._x_id;
  }
});
function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
  if (!el._x_id)
    el._x_id = {};
  if (el._x_id[cacheKey])
    return el._x_id[cacheKey];
  let output = callback();
  el._x_id[cacheKey] = output;
  cleanup2(() => {
    delete el._x_id[cacheKey];
  });
  return output;
}
magic("el", (el) => el);
warnMissingPluginMagic("Focus", "focus", "focus");
warnMissingPluginMagic("Persist", "persist", "persist");
function warnMissingPluginMagic(name, magicName, slug) {
  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
  let func = evaluateLater2(expression);
  let innerGet = () => {
    let result;
    func((i2) => result = i2);
    return result;
  };
  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { "__placeholder": val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle(
      {
        get() {
          return outerGet();
        },
        set(value) {
          outerSet(value);
        }
      },
      {
        get() {
          return innerGet();
        },
        set(value) {
          innerSet(value);
        }
      }
    );
    cleanup2(releaseEntanglement);
  });
});
directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = getTarget(expression);
  let clone2 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone2;
  clone2._x_teleportBack = el;
  el.setAttribute("data-teleport-template", true);
  clone2.setAttribute("data-teleport-target", true);
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone2.addEventListener(eventName, (e2) => {
        e2.stopPropagation();
        el.dispatchEvent(new e2.constructor(e2.type, e2));
      });
    });
  }
  addScopeToNode(clone2, {}, el);
  let placeInDom = (clone3, target2, modifiers2) => {
    if (modifiers2.includes("prepend")) {
      target2.parentNode.insertBefore(clone3, target2);
    } else if (modifiers2.includes("append")) {
      target2.parentNode.insertBefore(clone3, target2.nextSibling);
    } else {
      target2.appendChild(clone3);
    }
  };
  mutateDom(() => {
    placeInDom(clone2, target, modifiers);
    skipDuringClone(() => {
      initTree(clone2);
    })();
  });
  el._x_teleportPutBack = () => {
    let target2 = getTarget(expression);
    mutateDom(() => {
      placeInDom(el._x_teleport, target2, modifiers);
    });
  };
  cleanup2(
    () => mutateDom(() => {
      clone2.remove();
      destroyTree(clone2);
    })
  );
});
var teleportContainerDuringClone = document.createElement("div");
function getTarget(expression) {
  let target = skipDuringClone(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone;
  })();
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  return target;
}
var handler = () => {
};
handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup2(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);
directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
  effect3(evaluateLater(el, expression));
}));
function on(el, event2, modifiers, callback) {
  let listenerTarget = el;
  let handler4 = (e2) => callback(e2);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
  if (modifiers.includes("dot"))
    event2 = dotSyntax(event2);
  if (modifiers.includes("camel"))
    event2 = camelCase2(event2);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = debounce(handler4, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = throttle(handler4, wait);
  }
  if (modifiers.includes("prevent"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.preventDefault();
      next(e2);
    });
  if (modifiers.includes("stop"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.stopPropagation();
      next(e2);
    });
  if (modifiers.includes("once")) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      next(e2);
      listenerTarget.removeEventListener(event2, handler4, options);
    });
  }
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (el.contains(e2.target))
        return;
      if (e2.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e2);
    });
  }
  if (modifiers.includes("self"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.target === el && next(e2);
    });
  if (isKeyEvent(event2) || isClickEvent(event2)) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
        return;
      }
      next(e2);
    });
  }
  listenerTarget.addEventListener(event2, handler4, options);
  return () => {
    listenerTarget.removeEventListener(event2, handler4, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  if ([" ", "_"].includes(
    subject
  ))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event2) {
  return ["keydown", "keyup"].includes(event2);
}
function isClickEvent(event2) {
  return ["contextmenu", "click", "mouse"].some((i2) => event2.includes(i2));
}
function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
  let keyModifiers = modifiers.filter((i2) => {
    return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(i2);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e2[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (isClickEvent(e2.type))
        return false;
      if (keyToModifiers(e2.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    "ctrl": "control",
    "slash": "/",
    "space": " ",
    "spacebar": " ",
    "cmd": "meta",
    "esc": "escape",
    "up": "arrow-up",
    "down": "arrow-down",
    "left": "arrow-left",
    "right": "arrow-right",
    "period": ".",
    "comma": ",",
    "equal": "=",
    "minus": "-",
    "underscore": "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { "__placeholder": value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  let event2 = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning ? () => {
  } : on(el, event2, modifiers, (e2) => {
    setValue(getInputValue(el, modifiers, e2, getValue()));
  });
  if (modifiers.includes("fill")) {
    if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
      setValue(
        getInputValue(el, modifiers, { target: el }, getValue())
      );
    }
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup2(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on(el.form, "reset", [], (e2) => {
      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
    });
    cleanup2(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom(() => bind(el, "value", value));
    delete window.fromModel;
  };
  effect3(() => {
    let value = getValue();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue(el, modifiers, event2, currentValue) {
  return mutateDom(() => {
    if (event2 instanceof CustomEvent && event2.detail !== void 0)
      return event2.detail !== null && event2.detail !== void 0 ? event2.detail : event2.target.value;
    else if (isCheckbox(el)) {
      if (Array.isArray(currentValue)) {
        let newValue = null;
        if (modifiers.includes("number")) {
          newValue = safeParseNumber(event2.target.value);
        } else if (modifiers.includes("boolean")) {
          newValue = safeParseBoolean(event2.target.value);
        } else {
          newValue = event2.target.value;
        }
        return event2.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
      } else {
        return event2.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      if (modifiers.includes("number")) {
        return Array.from(event2.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        });
      } else if (modifiers.includes("boolean")) {
        return Array.from(event2.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseBoolean(rawValue);
        });
      }
      return Array.from(event2.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let newValue;
      if (isRadio$1(el)) {
        if (event2.target.checked) {
          newValue = event2.target.value;
        } else {
          newValue = currentValue;
        }
      } else {
        newValue = event2.target.value;
      }
      if (modifiers.includes("number")) {
        return safeParseNumber(newValue);
      } else if (modifiers.includes("boolean")) {
        return safeParseBoolean(newValue);
      } else if (modifiers.includes("trim")) {
        return newValue.trim();
      } else {
        return newValue;
      }
    }
  });
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate2(expression, {}, false);
  }
  return evaluate2(expression, {}, false);
}));
directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});
directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes(startingWith(":", into(prefix("bind:"))));
var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    getBindings((bindings) => {
      applyBindingsObject(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate2 = evaluateLater(el, expression);
  effect3(() => evaluate2((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom(() => bind(el, value, result, modifiers));
  }));
  cleanup2(() => {
    el._x_undoAddedClasses && el._x_undoAddedClasses();
    el._x_undoAddedStyles && el._x_undoAddedStyles();
  });
};
handler2.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive("bind", handler2);
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector(() => `[${prefix("data")}]`);
directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
  if (shouldSkipRegisteringDataDuringClone(el))
    return;
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data2 = evaluate$1(el, expression, { scope: dataProviderContext });
  if (data2 === void 0 || data2 === true)
    data2 = {};
  injectMagics(data2, el);
  let reactiveData = reactive(data2);
  initInterceptors(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate$1(el, reactiveData["init"]);
  cleanup2(() => {
    reactiveData["destroy"] && evaluate$1(el, reactiveData["destroy"]);
    undo();
  });
});
interceptClone((from, to) => {
  if (from._x_dataStack) {
    to._x_dataStack = from._x_dataStack;
    to.setAttribute("data-has-alpine-state", true);
  }
});
function shouldSkipRegisteringDataDuringClone(el) {
  if (!isCloning)
    return false;
  if (isCloningLegacy)
    return true;
  return el.hasAttribute("data-has-alpine-state");
}
directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
  let evaluate2 = evaluateLater(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once(
    (value) => value ? show() : hide(),
    (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    }
  );
  let oldValue;
  let firstTime = true;
  effect3(() => evaluate2((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(
    el,
    // the x-bind:key expression is stored for our use instead of evaluated.
    el._x_keyExpression || "index"
  );
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup2(() => {
    Object.values(el._x_lookup).forEach((el2) => mutateDom(
      () => {
        destroyTree(el2);
        el2.remove();
      }
    ));
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i2) => i2 + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject2(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => {
          if (keys.includes(value2))
            warn("Duplicate key on x-for", el);
          keys.push(value2);
        }, { scope: { index: key, ...scope2 } });
        scopes.push(scope2);
      });
    } else {
      for (let i2 = 0; i2 < items.length; i2++) {
        let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
        evaluateKey((value) => {
          if (keys.includes(value))
            warn("Duplicate key on x-for", el);
          keys.push(value);
        }, { scope: { index: i2, ...scope2 } });
        scopes.push(scope2);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i2 = 0; i2 < prevKeys.length; i2++) {
      let key = prevKeys[i2];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i2 = 0; i2 < keys.length; i2++) {
      let key = keys[i2];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i2, 0, key);
        adds.push([lastKey, i2]);
      } else if (prevIndex !== i2) {
        let keyInSpot = prevKeys.splice(i2, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i2, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i2 = 0; i2 < removes.length; i2++) {
      let key = removes[i2];
      if (!(key in lookup))
        continue;
      mutateDom(() => {
        destroyTree(lookup[key]);
        lookup[key].remove();
      });
      delete lookup[key];
    }
    for (let i2 = 0; i2 < moves.length; i2++) {
      let [keyInSpot, keyForSpot] = moves[i2];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        if (!elForSpot)
          warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i2 = 0; i2 < adds.length; i2++) {
      let [lastKey2, index] = adds[i2];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope2 = scopes[index];
      let key = keys[index];
      let clone2 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive(scope2);
      addScopeToNode(clone2, reactiveScope, templateEl);
      clone2._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom(() => {
        lastEl.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone2;
    }
    for (let i2 = 0; i2 < sames.length; i2++) {
      lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res = {};
  res.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res.item = item.replace(forIteratorRE, "").trim();
    res.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.collection = iteratorMatch[2].trim();
    }
  } else {
    res.item = item;
  }
  return res;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
    names.forEach((name, i2) => {
      scopeVariables[name] = item[i2];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler3() {
}
handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup2(() => delete root._x_refs[expression]);
};
directive("ref", handler3);
directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-if can only be used on a <template> tag", el);
  let evaluate2 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone2 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      el.after(clone2);
      skipDuringClone(() => initTree(clone2))();
    });
    el._x_currentIfEl = clone2;
    el._x_undoIf = () => {
      mutateDom(() => {
        destroyTree(clone2);
        clone2.remove();
      });
      delete el._x_currentIfEl;
    };
    return clone2;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect3(() => evaluate2((value) => {
    value ? show() : hide();
  }));
  cleanup2(() => el._x_undoIf && el._x_undoIf());
});
directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
  let names = evaluate2(expression);
  names.forEach((name) => setIdRoot(el, name));
});
interceptClone((from, to) => {
  if (from._x_ids) {
    to._x_ids = from._x_ids;
  }
});
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
  let evaluate2 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e2) => {
    evaluate2(() => {
    }, { scope: { "$event": e2 }, params: [e2] });
  });
  cleanup2(() => removeListener());
}));
warnMissingPluginDirective("Collapse", "collapse", "collapse");
warnMissingPluginDirective("Intersect", "intersect", "intersect");
warnMissingPluginDirective("Focus", "trap", "focus");
warnMissingPluginDirective("Mask", "mask", "mask");
function warnMissingPluginDirective(name, directiveName, slug) {
  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default.setEvaluator(normalEvaluator);
alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
var src_default$3 = alpine_default;
var module_default$3 = src_default$3;
function src_default$2(Alpine2) {
  Alpine2.directive("collapse", collapse);
  collapse.inline = (el, { modifiers }) => {
    if (!modifiers.includes("min"))
      return;
    el._x_doShow = () => {
    };
    el._x_doHide = () => {
    };
  };
  function collapse(el, { modifiers }) {
    let duration = modifierValue(modifiers, "duration", 250) / 1e3;
    let floor = modifierValue(modifiers, "min", 0);
    let fullyHide = !modifiers.includes("min");
    if (!el._x_isShown)
      el.style.height = `${floor}px`;
    if (!el._x_isShown && fullyHide)
      el.hidden = true;
    if (!el._x_isShown)
      el.style.overflow = "hidden";
    let setFunction = (el2, styles) => {
      let revertFunction = Alpine2.setStyles(el2, styles);
      return styles.height ? () => {
      } : revertFunction;
    };
    let transitionStyles = {
      transitionProperty: "height",
      transitionDuration: `${duration}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    el._x_transition = {
      in(before = () => {
      }, after = () => {
      }) {
        if (fullyHide)
          el.hidden = false;
        if (fullyHide)
          el.style.display = null;
        let current = el.getBoundingClientRect().height;
        el.style.height = "auto";
        let full = el.getBoundingClientRect().height;
        if (current === full) {
          current = floor;
        }
        Alpine2.transition(el, Alpine2.setStyles, {
          during: transitionStyles,
          start: { height: current + "px" },
          end: { height: full + "px" }
        }, () => el._x_isShown = true, () => {
          if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
            el.style.overflow = null;
          }
        });
      },
      out(before = () => {
      }, after = () => {
      }) {
        let full = el.getBoundingClientRect().height;
        Alpine2.transition(el, setFunction, {
          during: transitionStyles,
          start: { height: full + "px" },
          end: { height: floor + "px" }
        }, () => el.style.overflow = "hidden", () => {
          el._x_isShown = false;
          if (el.style.height == `${floor}px` && fullyHide) {
            el.style.display = "none";
            el.hidden = true;
          }
        });
      }
    };
  }
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "min") {
    let match = rawValue.match(/([0-9]+)px/);
    if (match)
      return match[1];
  }
  return rawValue;
}
var module_default$2 = src_default$2;
function src_default$1(Alpine2) {
  Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater2(expression);
    let options = {
      rootMargin: getRootMargin(modifiers),
      threshold: getThreshold(modifiers)
    };
    let observer2 = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting === (value === "leave"))
          return;
        evaluate2();
        modifiers.includes("once") && observer2.disconnect();
      });
    }, options);
    observer2.observe(el);
    cleanup2(() => {
      observer2.disconnect();
    });
  }));
}
function getThreshold(modifiers) {
  if (modifiers.includes("full"))
    return 0.99;
  if (modifiers.includes("half"))
    return 0.5;
  if (!modifiers.includes("threshold"))
    return 0;
  let threshold = modifiers[modifiers.indexOf("threshold") + 1];
  if (threshold === "100")
    return 1;
  if (threshold === "0")
    return 0;
  return Number(`.${threshold}`);
}
function getLengthValue(rawValue) {
  let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
  return match ? match[1] + (match[2] || "px") : void 0;
}
function getRootMargin(modifiers) {
  const key = "margin";
  const fallback = "0px 0px 0px 0px";
  const index = modifiers.indexOf(key);
  if (index === -1)
    return fallback;
  let values = [];
  for (let i2 = 1; i2 < 5; i2++) {
    values.push(getLengthValue(modifiers[index + i2] || ""));
  }
  values = values.filter((v2) => v2 !== void 0);
  return values.length ? values.join(" ").trim() : fallback;
}
var module_default$1 = src_default$1;
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
  return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = /* @__PURE__ */ function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return e2.key === "Tab" || e2.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i2) {
    if (fn(value)) {
      idx = i2;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event2) {
  return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n2) {
            return n2 === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
            return isTabbable(n2, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e2) {
    var target = getActualTarget(e2);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e2.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e2) {
    var target = getActualTarget(e2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e2.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e2.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e2.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e2) {
    if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
      e2.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e2)) {
      checkTab(e2);
      return;
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
function src_default(Alpine2) {
  let lastFocused;
  let currentFocused;
  window.addEventListener("focusin", () => {
    lastFocused = currentFocused;
    currentFocused = document.activeElement;
  });
  Alpine2.magic("focus", (el) => {
    let within = el;
    return {
      __noscroll: false,
      __wrapAround: false,
      within(el2) {
        within = el2;
        return this;
      },
      withoutScrolling() {
        this.__noscroll = true;
        return this;
      },
      noscroll() {
        this.__noscroll = true;
        return this;
      },
      withWrapAround() {
        this.__wrapAround = true;
        return this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(el2) {
        return isFocusable(el2);
      },
      previouslyFocused() {
        return lastFocused;
      },
      lastFocused() {
        return lastFocused;
      },
      focused() {
        return currentFocused;
      },
      focusables() {
        if (Array.isArray(within))
          return within;
        return focusable(within, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(el2) {
        let els = this.all();
        return els[0] && els[0].isSameNode(el2);
      },
      isLast(el2) {
        let els = this.all();
        return els.length && els.slice(-1)[0].isSameNode(el2);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
          return list[0];
        }
        return list[list.indexOf(current) + 1];
      },
      getPrevious() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === 0) {
          return list.slice(-1)[0];
        }
        return list[list.indexOf(current) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(el2) {
        if (!el2)
          return;
        setTimeout(() => {
          if (!el2.hasAttribute("tabindex"))
            el2.setAttribute("tabindex", "0");
          el2.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  });
  Alpine2.directive("trap", Alpine2.skipDuringClone(
    (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluator = evaluateLater2(expression);
      let oldValue = false;
      let options = {
        escapeDeactivates: false,
        allowOutsideClick: true,
        fallbackFocus: () => el
      };
      let undoInert = () => {
      };
      if (modifiers.includes("noautofocus")) {
        options.initialFocus = false;
      } else {
        let autofocusEl = el.querySelector("[autofocus]");
        if (autofocusEl)
          options.initialFocus = autofocusEl;
      }
      if (modifiers.includes("inert")) {
        options.onPostActivate = () => {
          Alpine2.nextTick(() => {
            undoInert = setInert(el);
          });
        };
      }
      let trap = createFocusTrap(el, options);
      let undoDisableScrolling = () => {
      };
      const releaseFocus = () => {
        undoInert();
        undoInert = () => {
        };
        undoDisableScrolling();
        undoDisableScrolling = () => {
        };
        trap.deactivate({
          returnFocus: !modifiers.includes("noreturn")
        });
      };
      effect3(() => evaluator((value) => {
        if (oldValue === value)
          return;
        if (value && !oldValue) {
          if (modifiers.includes("noscroll"))
            undoDisableScrolling = disableScrolling();
          setTimeout(() => {
            trap.activate();
          }, 15);
        }
        if (!value && oldValue) {
          releaseFocus();
        }
        oldValue = !!value;
      }));
      cleanup2(releaseFocus);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
      if (modifiers.includes("inert") && evaluate2(expression))
        setInert(el);
    }
  ));
}
function setInert(el) {
  let undos = [];
  crawlSiblingsUp(el, (sibling) => {
    let cache = sibling.hasAttribute("aria-hidden");
    sibling.setAttribute("aria-hidden", "true");
    undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
  });
  return () => {
    while (undos.length)
      undos.pop()();
  };
}
function crawlSiblingsUp(el, callback) {
  if (el.isSameNode(document.body) || !el.parentNode)
    return;
  Array.from(el.parentNode.children).forEach((sibling) => {
    if (sibling.isSameNode(el)) {
      crawlSiblingsUp(el.parentNode, callback);
    } else {
      callback(sibling);
    }
  });
}
function disableScrolling() {
  let overflow = document.documentElement.style.overflow;
  let paddingRight = document.documentElement.style.paddingRight;
  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.overflow = "hidden";
  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
  return () => {
    document.documentElement.style.overflow = overflow;
    document.documentElement.style.paddingRight = paddingRight;
  };
}
var module_default = src_default;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function eager() {
  return true;
}
function event({ component, argument }) {
  return new Promise((resolve) => {
    if (argument) {
      window.addEventListener(
        argument,
        () => resolve(),
        { once: true }
      );
    } else {
      const cb = (e2) => {
        if (e2.detail.id !== component.id) return;
        window.removeEventListener("async-alpine:load", cb);
        resolve();
      };
      window.addEventListener("async-alpine:load", cb);
    }
  });
}
function idle() {
  return new Promise((resolve) => {
    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(resolve);
    } else {
      setTimeout(resolve, 200);
    }
  });
}
function media({ argument }) {
  return new Promise((resolve) => {
    if (!argument) {
      console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'");
      return resolve();
    }
    const mediaQuery = window.matchMedia(`(${argument})`);
    if (mediaQuery.matches) {
      resolve();
    } else {
      mediaQuery.addEventListener("change", resolve, { once: true });
    }
  });
}
function visible({ component, argument }) {
  return new Promise((resolve) => {
    const rootMargin = argument || "0px 0px 0px 0px";
    const observer2 = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        observer2.disconnect();
        resolve();
      }
    }, { rootMargin });
    observer2.observe(component.el);
  });
}
var strategies_default = {
  eager,
  event,
  idle,
  media,
  visible
};
async function awaitRequirements(component) {
  const requirements = parseRequirements(component.strategy);
  await generateRequirements(component, requirements);
}
async function generateRequirements(component, requirements) {
  if (requirements.type === "expression") {
    if (requirements.operator === "&&") {
      return Promise.all(
        requirements.parameters.map((param) => generateRequirements(component, param))
      );
    }
    if (requirements.operator === "||") {
      return Promise.any(
        requirements.parameters.map((param) => generateRequirements(component, param))
      );
    }
  }
  if (!strategies_default[requirements.method]) return false;
  return strategies_default[requirements.method]({
    component,
    argument: requirements.argument
  });
}
function parseRequirements(expression) {
  const tokens = tokenize(expression);
  let ast = parseExpression(tokens);
  if (ast.type === "method") {
    return {
      type: "expression",
      operator: "&&",
      parameters: [ast]
    };
  }
  return ast;
}
function tokenize(expression) {
  const regex = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g;
  const tokens = [];
  let match;
  while ((match = regex.exec(expression)) !== null) {
    const [_, parenthesis, operator, token] = match;
    if (parenthesis !== void 0) {
      tokens.push({ type: "parenthesis", value: parenthesis });
    } else if (operator !== void 0) {
      tokens.push({
        type: "operator",
        // we do the below to make operators backwards-compatible with previous
        // versions of Async Alpine, where '|' is equivalent to &&
        value: operator === "|" ? "&&" : operator
      });
    } else {
      const tokenObj = {
        type: "method",
        method: token.trim()
      };
      if (token.includes("(")) {
        tokenObj.method = token.substring(0, token.indexOf("(")).trim();
        tokenObj.argument = token.substring(
          token.indexOf("(") + 1,
          token.indexOf(")")
        );
      }
      if (token.method === "immediate") {
        token.method = "eager";
      }
      tokens.push(tokenObj);
    }
  }
  return tokens;
}
function parseExpression(tokens) {
  let ast = parseTerm(tokens);
  while (tokens.length > 0 && (tokens[0].value === "&&" || tokens[0].value === "|" || tokens[0].value === "||")) {
    const operator = tokens.shift().value;
    const right = parseTerm(tokens);
    if (ast.type === "expression" && ast.operator === operator) {
      ast.parameters.push(right);
    } else {
      ast = {
        type: "expression",
        operator,
        parameters: [ast, right]
      };
    }
  }
  return ast;
}
function parseTerm(tokens) {
  if (tokens[0].value === "(") {
    tokens.shift();
    const ast = parseExpression(tokens);
    if (tokens[0].value === ")") {
      tokens.shift();
    }
    return ast;
  } else {
    return tokens.shift();
  }
}
function async_alpine_default(Alpine2) {
  const directive2 = "load";
  const srcAttr = Alpine2.prefixed("load-src");
  const ignoreAttr = Alpine2.prefixed("ignore");
  let options = {
    defaultStrategy: "eager",
    keepRelativeURLs: false
  };
  let alias = false;
  let data2 = {};
  let realIndex = 0;
  function index() {
    return realIndex++;
  }
  Alpine2.asyncOptions = (opts) => {
    options = {
      ...options,
      ...opts
    };
  };
  Alpine2.asyncData = (name, download2 = false) => {
    data2[name] = {
      loaded: false,
      download: download2
    };
  };
  Alpine2.asyncUrl = (name, url) => {
    if (!name || !url || data2[name]) return;
    data2[name] = {
      loaded: false,
      download: () => import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        parseUrl(url)
      )
    };
  };
  Alpine2.asyncAlias = (path) => {
    alias = path;
  };
  const syncHandler = (el) => {
    Alpine2.skipDuringClone(() => {
      if (el._x_async) return;
      el._x_async = "init";
      el._x_ignore = true;
      el.setAttribute(ignoreAttr, "");
    })();
  };
  const handler4 = async (el) => {
    Alpine2.skipDuringClone(async () => {
      if (el._x_async !== "init") return;
      el._x_async = "await";
      const { name, strategy } = elementPrep(el);
      await awaitRequirements({
        name,
        strategy,
        el,
        id: el.id || index()
      });
      if (!el.isConnected) return;
      await download(name);
      if (!el.isConnected) return;
      activate(el);
      el._x_async = "loaded";
    })();
  };
  handler4.inline = syncHandler;
  Alpine2.directive(directive2, handler4).before("ignore");
  function elementPrep(el) {
    const name = parseName(el.getAttribute(Alpine2.prefixed("data")));
    const strategy = el.getAttribute(Alpine2.prefixed(directive2)) || options.defaultStrategy;
    const urlAttributeValue = el.getAttribute(srcAttr);
    if (urlAttributeValue) {
      Alpine2.asyncUrl(name, urlAttributeValue);
    }
    return {
      name,
      strategy
    };
  }
  async function download(name) {
    if (name.startsWith("_x_async_")) return;
    handleAlias(name);
    if (!data2[name] || data2[name].loaded) return;
    const module = await getModule(name);
    Alpine2.data(name, module);
    data2[name].loaded = true;
  }
  async function getModule(name) {
    if (!data2[name]) return;
    const module = await data2[name].download(name);
    if (typeof module === "function") return module;
    let whichExport = module[name] || module.default || Object.values(module)[0] || false;
    return whichExport;
  }
  function activate(el) {
    Alpine2.destroyTree(el);
    el._x_ignore = false;
    el.removeAttribute(ignoreAttr);
    if (el.closest(`[${ignoreAttr}]`)) return;
    Alpine2.initTree(el);
  }
  function handleAlias(name) {
    if (!alias || data2[name]) return;
    if (typeof alias === "function") {
      Alpine2.asyncData(name, alias);
      return;
    }
    Alpine2.asyncUrl(name, alias.replaceAll("[name]", name));
  }
  function parseName(attribute) {
    const parsedName = (attribute || "").trim().split(/[({]/g)[0];
    const ourName = parsedName || `_x_async_${index()}`;
    return ourName;
  }
  function parseUrl(url) {
    if (options.keepRelativeURLs) return url;
    const absoluteReg = new RegExp("^(?:[a-z+]+:)?//", "i");
    if (!absoluteReg.test(url)) {
      return new URL(url, document.baseURI).href;
    }
    return url;
  }
}
function t(t2, e2) {
  if (!(t2 instanceof e2)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function e(t2, e2) {
  for (var s2 = 0; s2 < e2.length; s2++) {
    var i2 = e2[s2];
    i2.enumerable = i2.enumerable || false;
    i2.configurable = true;
    if ("value" in i2) i2.writable = true;
    Object.defineProperty(t2, i2.key, i2);
  }
}
function s(t2, s2, i2) {
  if (s2) e(t2.prototype, s2);
  return t2;
}
var i = Object.defineProperty;
var n = function(t2, e2) {
  return i(t2, "name", { value: e2, configurable: true });
};
var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var h = n(function(t2) {
  return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
}, "stringToHTML"), d = n(function(t2) {
  var e2 = new DOMParser().parseFromString(t2, "application/xml");
  return document.importNode(e2.documentElement, true).outerHTML;
}, "getSvgNode");
var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
var N = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), O = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "fadeOut"), T = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), E = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "slideOut");
var m = function() {
  function e2(s2) {
    var i2 = this;
    t(this, e2);
    this.notifyOut = n(function(t2) {
      t2(i2);
    }, "notifyOut");
    var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
    if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  s(e2, [{ key: "checkRequirements", value: function t2() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function t2() {
    var t3 = document.querySelector(".".concat(u.CONTAINER));
    t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function t2() {
    this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function t2() {
    var t3 = this;
    var e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
      t3.close();
    });
  } }, { key: "setWrapper", value: function t2() {
    var t3 = this;
    switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
      case p.OUTLINE:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
        break;
      case p.FILLED:
        this.wrapper.classList.add(u.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case f.SUCCESS:
        this.wrapper.classList.add(u.NOTIFY_SUCCESS);
        break;
      case f.ERROR:
        this.wrapper.classList.add(u.NOTIFY_ERROR);
        break;
      case f.WARNING:
        this.wrapper.classList.add(u.NOTIFY_WARNING);
        break;
      case f.INFO:
        this.wrapper.classList.add(u.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
      t3.wrapper.classList.add(e3);
    });
  } }, { key: "setContent", value: function t2() {
    var t3 = document.createElement("div");
    t3.classList.add(u.NOTIFY_CONTENT);
    var e3, s2;
    this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
  } }, { key: "setIcon", value: function t2() {
    var t3 = n(function(t4) {
      switch (t4) {
        case f.SUCCESS:
          return v.SUCCESS;
        case f.ERROR:
          return v.ERROR;
        case f.WARNING:
          return v.WARNING;
        case f.INFO:
          return v.INFO;
      }
    }, "computedIcon"), e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
  } }, { key: "setObserver", value: function t2() {
    var t3 = this;
    var e3 = new IntersectionObserver(function(e4) {
      if (e4[0].intersectionRatio <= 0) t3.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      e3.observe(t3.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function t2(t2) {
    t2(this);
  } }, { key: "autoClose", value: function t2() {
    var t3 = this;
    setTimeout(function() {
      t3.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function t2() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function t2() {
    switch (this.effect) {
      case I.FADE:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
        break;
      case I.SLIDE:
        this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
        break;
      default:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
    }
  } }]);
  return e2;
}();
n(m, "Notify");
var w = m;
globalThis.Notify = w;
const allowedStatuses = ["success", "error", "warning", "info"];
const allowedPositions = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
];
const defaultConfig = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: true,
  autotimeout: 4e3,
  position: "right top"
};
function renderToast(options = {}) {
  const config = {
    ...defaultConfig,
    ...options
  };
  if (!allowedStatuses.includes(config.status)) {
    console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
    config.status = "info";
  }
  if (!allowedPositions.includes(config.position)) {
    console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
    config.position = "right top";
  }
  new w(config);
}
const Toast = {
  custom: renderToast,
  success(text, title = "Success", options = {}) {
    renderToast({
      status: "success",
      title,
      text,
      ...options
    });
  },
  error(text, title = "Error", options = {}) {
    renderToast({
      status: "error",
      title,
      text,
      ...options
    });
  },
  warning(text, title = "Warning", options = {}) {
    renderToast({
      status: "warning",
      title,
      text,
      ...options
    });
  },
  info(text, title = "Info", options = {}) {
    renderToast({
      status: "info",
      title,
      text,
      ...options
    });
  },
  setDefaults(newDefaults = {}) {
    Object.assign(defaultConfig, newDefaults);
  },
  get allowedStatuses() {
    return [...allowedStatuses];
  },
  get allowedPositions() {
    return [...allowedPositions];
  }
};
const devnull = function() {
}, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
function subscribe(bundleIds, callbackFn) {
  bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
  const depsNotFound = [];
  let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
  fn = function(bundleId2, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId2);
    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };
  while (i2--) {
    bundleId = bundleIds[i2];
    r2 = bundleResultCache[bundleId];
    if (r2) {
      fn(bundleId, r2);
      continue;
    }
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}
function publish(bundleId, pathsNotFound) {
  if (!bundleId) return;
  const q = bundleCallbackQueue[bundleId];
  bundleResultCache[bundleId] = pathsNotFound;
  if (!q) return;
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}
function executeCallbacks(args, depsNotFound) {
  if (typeof args === "function") args = { success: args };
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}
function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
  let result = ev.type[0];
  if (isLegacyIECss) {
    try {
      if (!e2.sheet.cssText.length) result = "e";
    } catch (x) {
      if (x.code !== 18) result = "e";
    }
  }
  if (result === "e") {
    numTries += 1;
    if (numTries < maxTries) {
      return loadFile(path, callbackFn, args, numTries);
    }
  } else if (e2.rel === "preload" && e2.as === "style") {
    e2.rel = "stylesheet";
    return;
  }
  callbackFn(path, result, ev.defaultPrevented);
}
function loadFile(path, callbackFn, args, numTries) {
  const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
  let isLegacyIECss, hasModuleSupport, e2;
  numTries = numTries || 0;
  if (/(^css!|\.css$)/.test(pathname)) {
    e2 = doc.createElement("link");
    e2.rel = "stylesheet";
    e2.href = pathStripped;
    isLegacyIECss = "hideFocus" in e2;
    if (isLegacyIECss && e2.relList) {
      isLegacyIECss = 0;
      e2.rel = "preload";
      e2.as = "style";
    }
    if (args.inlineStyleNonce) {
      e2.setAttribute("nonce", args.inlineStyleNonce);
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    e2 = doc.createElement("img");
    e2.src = pathStripped;
  } else {
    e2 = doc.createElement("script");
    e2.src = pathStripped;
    e2.async = async === void 0 ? true : async;
    if (args.inlineScriptNonce) {
      e2.setAttribute("nonce", args.inlineScriptNonce);
    }
    hasModuleSupport = "noModule" in e2;
    if (/^module!/.test(pathname)) {
      if (!hasModuleSupport) return callbackFn(path, "l");
      e2.type = "module";
    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
      return callbackFn(path, "l");
    }
  }
  const onEvent = function(ev) {
    handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
  };
  e2.addEventListener("load", onEvent, { once: true });
  e2.addEventListener("error", onEvent, { once: true });
  if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
}
function loadFiles(paths, callbackFn, args) {
  paths = Array.isArray(paths) ? paths : [paths];
  let numWaiting = paths.length, pathsNotFound = [];
  function fn(path, result, defaultPrevented) {
    if (result === "e") pathsNotFound.push(path);
    if (result === "b") {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }
    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  }
  for (let i2 = 0; i2 < paths.length; i2++) {
    loadFile(paths[i2], fn, args);
  }
}
function loadjs(paths, arg1, arg2) {
  let bundleId, args;
  if (arg1 && typeof arg1 === "string" && arg1.trim) {
    bundleId = arg1.trim();
  }
  args = (bundleId ? arg2 : arg1) || {};
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }
  function loadFn(resolve, reject) {
    loadFiles(paths, function(pathsNotFound) {
      executeCallbacks(args, pathsNotFound);
      if (resolve) {
        executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
      }
      publish(bundleId, pathsNotFound);
    }, args);
  }
  if (args.returnPromise) {
    return new Promise(loadFn);
  } else {
    loadFn();
  }
}
loadjs.ready = function ready(deps, args) {
  subscribe(deps, function(depsNotFound) {
    executeCallbacks(args, depsNotFound);
  });
  return loadjs;
};
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};
loadjs.reset = function reset() {
  Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
  Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
  Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
};
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};
function $data(idOrElement) {
  if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
    console.error(
      "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
    );
    return void 0;
  }
  if (idOrElement instanceof Element) {
    const target = resolveProxy(idOrElement) || idOrElement;
    let alpineData = Alpine.$data(target);
    if (alpineData === void 0) {
      const nearest = target.closest?.("[x-data]");
      if (nearest) {
        alpineData = Alpine.$data(nearest);
      }
    }
    if (alpineData === void 0) {
      warnDataUndefined("element", target);
    }
    return alpineData;
  }
  if (typeof idOrElement === "string") {
    const componentId = idOrElement.trim();
    if (!componentId) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return void 0;
    }
    const selector = `[data-alpine-root="${cssEscapeSafe(componentId)}"]`;
    let root = null;
    const wrapper = document.getElementById(componentId);
    if (wrapper) {
      root = wrapper.matches(selector) ? wrapper : wrapper.querySelector(selector);
    }
    if (!root) {
      root = findAlpineRootById(componentId);
    }
    if (!root) {
      console.warn(
        `Rizzy.$data: Could not locate an Alpine root using ${selector} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${componentId}"' is present.`
      );
      return void 0;
    }
    const alpineData = Alpine.$data(root);
    if (alpineData === void 0) {
      warnDataUndefined(`data-alpine-root="${componentId}"`, root);
    }
    return alpineData;
  }
  console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
  return void 0;
}
function resolveProxy(el) {
  if (!(el instanceof Element)) return null;
  const isProxyTag = el.tagName?.toLowerCase?.() === "rz-proxy";
  const proxyFor = el.getAttribute?.("data-for");
  if (isProxyTag || proxyFor) {
    const id = proxyFor || "";
    if (!id) return el;
    const root = findAlpineRootById(id);
    if (!root) {
      console.warn(
        `Rizzy.$data: Proxy element could not resolve Alpine root for id "${id}". Ensure the teleported root rendered with data-alpine-root="${id}".`
      );
      return null;
    }
    return root;
  }
  return el;
}
function findAlpineRootById(id) {
  const sel = `[data-alpine-root="${cssEscapeSafe(id)}"]`;
  const candidates = document.querySelectorAll(sel);
  for (const n2 of candidates) {
    if (n2.hasAttribute("x-data")) return n2;
  }
  if (candidates.length > 0) return candidates[0];
  return document.getElementById(id) || null;
}
function cssEscapeSafe(s2) {
  try {
    if (window.CSS && typeof window.CSS.escape === "function") {
      return window.CSS.escape(s2);
    }
  } catch (_) {
  }
  return String(s2).replace(/"/g, '\\"');
}
function warnDataUndefined(origin, target) {
  const desc = `${target.tagName?.toLowerCase?.() || "node"}${target.id ? "#" + target.id : ""}${target.classList?.length ? "." + Array.from(target.classList).join(".") : ""}`;
  console.warn(
    `Rizzy.$data: Located target via ${origin} (${desc}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
  );
}
function registerRzAccordion(Alpine2) {
  Alpine2.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: false,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function registerAccordionItem(Alpine2) {
  Alpine2.data("accordionItem", () => ({
    open: false,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true";
      this.sectionId = this.$el.dataset.sectionId;
      this.expandedClass = this.$el.dataset.expandedClass;
      const self = this;
      if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
        this.$watch("selected", (value, oldValue) => {
          if (value !== self.sectionId && !self.allowMultiple) {
            self.open = false;
          }
        });
      } else {
        console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
      }
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId;
      this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function registerRzAlert(Alpine2) {
  Alpine2.data("rzAlert", () => {
    return {
      parentElement: null,
      showAlert: true,
      init() {
        const alpineRoot = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
        this.parentElement = document.getElementById(alpineRoot);
      },
      dismiss() {
        this.showAlert = false;
        const self = this;
        setTimeout(() => {
          self.parentElement.style.display = "none";
        }, 205);
      }
    };
  });
}
function registerRzAspectRatio(Alpine2) {
  Alpine2.data("rzAspectRatio", () => ({
    init() {
      const ratio = parseFloat(this.$el.dataset.ratio);
      if (!isNaN(ratio) && ratio > 0) {
        const paddingBottom = 100 / ratio + "%";
        this.$el.style.paddingBottom = paddingBottom;
      } else {
        this.$el.style.paddingBottom = "100%";
      }
    }
  }));
}
function registerRzBrowser(Alpine2) {
  Alpine2.data("rzBrowser", () => {
    return {
      screenSize: "",
      setDesktopScreenSize() {
        this.screenSize = "";
      },
      setTabletScreenSize() {
        this.screenSize = "max-w-2xl";
      },
      setPhoneScreenSize() {
        this.screenSize = "max-w-sm";
      },
      // Get CSS classes for browser border based on screen size
      getBrowserBorderCss() {
        return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
      },
      // Get CSS classes for desktop screen button styling
      getDesktopScreenCss() {
        return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for tablet screen button styling
      getTabletScreenCss() {
        return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for phone screen button styling
      getPhoneScreenCss() {
        return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      }
    };
  });
}
function registerRzCalendar(Alpine2, require2) {
  Alpine2.data("rzCalendar", () => ({
    calendar: null,
    initialized: false,
    init() {
      const assets = JSON.parse(this.$el.dataset.assets || "[]");
      const configId = this.$el.dataset.configId;
      const nonce = this.$el.dataset.nonce;
      if (assets.length === 0) {
        console.warn("RzCalendar: No assets configured.");
        return;
      }
      require2(assets, {
        success: () => {
          this.initCalendar(configId);
        },
        error: (e2) => console.error("RzCalendar: Failed to load assets", e2)
      }, nonce);
    },
    initCalendar(configId) {
      const configElement = document.getElementById(configId);
      if (!configElement) {
        console.error(`RzCalendar: Config element #${configId} not found.`);
        return;
      }
      let rawConfig = {};
      try {
        rawConfig = JSON.parse(configElement.textContent);
      } catch (e2) {
        console.error("RzCalendar: Failed to parse config JSON", e2);
        return;
      }
      const actionHandlers = {
        clickDay: (e2, self) => this.dispatchCalendarEvent("clickDay", { event: e2, dates: self.selectedDates }),
        clickWeekNumber: (e2, number, days, year) => this.dispatchCalendarEvent("clickWeekNumber", { event: e2, number, days, year }),
        clickMonth: (e2, month) => this.dispatchCalendarEvent("clickMonth", { event: e2, month }),
        clickYear: (e2, year) => this.dispatchCalendarEvent("clickYear", { event: e2, year }),
        clickArrow: (e2, year, month) => this.dispatchCalendarEvent("clickArrow", { event: e2, year, month }),
        changeTime: (e2, time, hours, minutes, keeping) => this.dispatchCalendarEvent("changeTime", { event: e2, time, hours, minutes, keeping }),
        changeView: (view) => this.dispatchCalendarEvent("changeView", { view }),
        getDays: (day, date, HTMLElement2, HTMLButtonElement, self) => {
        }
      };
      const options = {
        ...rawConfig.options,
        styles: rawConfig.styles,
        // Correct property name for VCP
        actions: actionHandlers
      };
      if (window.VanillaCalendarPro) {
        this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, options);
        this.calendar.init();
        this.initialized = true;
        this.dispatchCalendarEvent("init", { instance: this.calendar });
      } else {
        console.error("RzCalendar: VanillaCalendar global not found.");
      }
    },
    dispatchCalendarEvent(eventName, detail) {
      this.$dispatch(`rz:calendar:${eventName}`, detail);
    },
    destroy() {
      if (this.calendar) {
        this.calendar.destroy();
        this.dispatchCalendarEvent("destroy", {});
      }
    }
  }));
}
function registerRzCarousel(Alpine2, require2) {
  function parseJsonFromScriptId(id) {
    if (!id) return {};
    const el = document.getElementById(id);
    if (!el) {
      console.warn(`[rzCarousel] JSON script element #${id} not found.`);
      return {};
    }
    try {
      return JSON.parse(el.textContent || "{}");
    } catch (e2) {
      console.error(`[rzCarousel] Failed to parse JSON from #${id}:`, e2);
      return {};
    }
  }
  Alpine2.data("rzCarousel", () => ({
    emblaApi: null,
    canScrollPrev: false,
    canScrollNext: false,
    selectedIndex: 0,
    scrollSnaps: [],
    init() {
      const assetsToLoad = (() => {
        try {
          return JSON.parse(this.$el.dataset.assets || "[]");
        } catch (e2) {
          console.error("[rzCarousel] Bad assets JSON:", e2);
          return [];
        }
      })();
      const nonce = this.$el.dataset.nonce || "";
      const config = parseJsonFromScriptId(this.$el.dataset.config);
      const options = config.Options || {};
      const pluginsConfig = config.Plugins || [];
      const self = this;
      if (assetsToLoad.length > 0 && typeof require2 === "function") {
        require2(
          assetsToLoad,
          {
            success() {
              if (window.EmblaCarousel) {
                self.initializeEmbla(options, pluginsConfig);
              } else {
                console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
              }
            },
            error(err) {
              console.error("[rzCarousel] Failed to load EmblaCarousel assets.", err);
            }
          },
          nonce
        );
      } else {
        if (window.EmblaCarousel) {
          this.initializeEmbla(options, pluginsConfig);
        } else {
          console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
        }
      }
    },
    initializeEmbla(options, pluginsConfig) {
      const viewport = this.$el.querySelector('[x-ref="viewport"]');
      if (!viewport) {
        console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
        return;
      }
      const instantiatedPlugins = this.instantiatePlugins(pluginsConfig);
      this.emblaApi = window.EmblaCarousel(viewport, options, instantiatedPlugins);
      this.emblaApi.on("select", this.onSelect.bind(this));
      this.emblaApi.on("reInit", this.onSelect.bind(this));
      this.onSelect();
    },
    instantiatePlugins(pluginsConfig) {
      if (!Array.isArray(pluginsConfig) || pluginsConfig.length === 0) {
        return [];
      }
      return pluginsConfig.map((pluginInfo) => {
        const constructor = window[pluginInfo.Name];
        if (typeof constructor !== "function") {
          console.error(`[rzCarousel] Plugin constructor '${pluginInfo.Name}' not found on window object.`);
          return null;
        }
        try {
          return constructor(pluginInfo.Options || {});
        } catch (e2) {
          console.error(`[rzCarousel] Error instantiating plugin '${pluginInfo.Name}':`, e2);
          return null;
        }
      }).filter(Boolean);
    },
    destroy() {
      if (this.emblaApi) this.emblaApi.destroy();
    },
    onSelect() {
      if (!this.emblaApi) return;
      this.selectedIndex = this.emblaApi.selectedScrollSnap();
      this.canScrollPrev = this.emblaApi.canScrollPrev();
      this.canScrollNext = this.emblaApi.canScrollNext();
      this.scrollSnaps = this.emblaApi.scrollSnapList();
    },
    cannotScrollPrev() {
      return !this.canScrollPrev;
    },
    cannotScrollNext() {
      return !this.canScrollNext;
    },
    scrollPrev() {
      this.emblaApi?.scrollPrev();
    },
    scrollNext() {
      this.emblaApi?.scrollNext();
    },
    scrollTo(index) {
      this.emblaApi?.scrollTo(index);
    }
  }));
}
function registerRzCodeViewer(Alpine2, require2) {
  Alpine2.data("rzCodeViewer", () => {
    return {
      expand: false,
      border: true,
      copied: false,
      copyTitle: "Copy",
      // Default title
      copiedTitle: "Copied!",
      // Default title
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const codeId = this.$el.dataset.codeid;
        const nonce = this.$el.dataset.nonce;
        this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
        this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
        require2(assets, {
          success: function() {
            const codeBlock = document.getElementById(codeId);
            if (window.hljs && codeBlock) {
              window.hljs.highlightElement(codeBlock);
            }
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      },
      // Function to check if code is NOT copied (for x-show)
      notCopied() {
        return !this.copied;
      },
      // Function to reset the copied state (e.g., on blur)
      disableCopied() {
        this.copied = false;
      },
      // Function to toggle the expand state
      toggleExpand() {
        this.expand = !this.expand;
      },
      // Function to copy code to clipboard
      copyHTML() {
        navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
        this.copied = !this.copied;
      },
      // Get the title for the copy button (copy/copied)
      getCopiedTitle() {
        return this.copied ? this.copiedTitle : this.copyTitle;
      },
      // Get CSS classes for the copy button based on copied state
      getCopiedCss() {
        return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
      },
      // Get CSS classes for the code container based on expand state
      getExpandCss() {
        return [this.expand ? "" : "max-h-60"];
      },
      // Get CSS classes for the expand button icon based on expand state
      getExpandButtonCss() {
        return this.expand ? "rotate-180" : "rotate-0";
      }
    };
  });
}
function registerRzCollapsible(Alpine2) {
  Alpine2.data("rzCollapsible", () => ({
    isOpen: false,
    init() {
      this.isOpen = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.isOpen = !this.isOpen;
    },
    state() {
      return this.isOpen ? "open" : "closed";
    }
  }));
}
function registerRzCombobox(Alpine2, require2) {
  Alpine2.data("rzCombobox", () => ({
    tomSelect: null,
    init() {
      const assets = JSON.parse(this.$el.dataset.assets || "[]");
      const nonce = this.$el.dataset.nonce;
      if (assets.length > 0 && typeof require2 === "function") {
        require2(assets, {
          success: () => this.initTomSelect(),
          error: (err) => console.error("RzCombobox: Failed to load assets.", err)
        }, nonce);
      } else if (window.TomSelect) {
        this.initTomSelect();
      }
    },
    initTomSelect() {
      const selectEl = this.$refs.selectInput;
      if (!selectEl) return;
      const configEl = document.getElementById(this.$el.dataset.configId);
      const config = configEl ? JSON.parse(configEl.textContent) : {};
      const render = {};
      const createAlpineRow = (templateRef, data2) => {
        if (!templateRef) return null;
        const div = document.createElement("div");
        let parsedItem = data2.item;
        if (typeof parsedItem === "string") {
          try {
            parsedItem = JSON.parse(parsedItem);
          } catch (e2) {
          }
        }
        const scope2 = {
          ...data2,
          item: parsedItem
        };
        if (Alpine2 && typeof Alpine2.addScopeToNode === "function") {
          Alpine2.addScopeToNode(div, scope2);
        } else {
          div._x_dataStack = [scope2];
        }
        div.innerHTML = templateRef.innerHTML;
        return div;
      };
      if (this.$refs.optionTemplate) {
        render.option = (data2, escape) => createAlpineRow(this.$refs.optionTemplate, data2);
      }
      if (this.$refs.itemTemplate) {
        render.item = (data2, escape) => createAlpineRow(this.$refs.itemTemplate, data2);
      }
      config.dataAttr = "data-item";
      this.tomSelect = new TomSelect(selectEl, {
        ...config,
        render,
        onInitialize: function() {
          this.sync();
        }
      });
    },
    destroy() {
      if (this.tomSelect) {
        this.tomSelect.destroy();
        this.tomSelect = null;
      }
    }
  }));
}
function registerRzDateEdit(Alpine2, require2) {
  Alpine2.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const cfgString = this.$el.dataset.config;
      const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
      if (cfgString) {
        const parsed = JSON.parse(cfgString);
        if (parsed) {
          this.options = parsed.options || {};
          this.placeholder = parsed.placeholder || "";
          this.prependText = parsed.prependText || "";
        }
      }
      const assets = JSON.parse(this.$el.dataset.assets);
      const nonce = this.$el.dataset.nonce;
      require2(assets, {
        success: function() {
          if (window.flatpickr && inputElem) {
            window.flatpickr(inputElem, this.options);
          }
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, nonce);
    }
  }));
}
function registerRzDialog(Alpine2) {
  Alpine2.data("rzDialog", () => ({
    modalOpen: false,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: true,
    closeOnClickOutside: true,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "";
      this.bodyId = this.$el.dataset.bodyId || "";
      this.footerId = this.$el.dataset.footerId || "";
      this.nonce = this.$el.dataset.nonce || "";
      this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
      this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
      this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
      this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
      this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: true
      }));
      if (this.eventTriggerName) {
        this._openListener = (e2) => {
          this.openModal(e2);
        };
        window.addEventListener(this.eventTriggerName, this._openListener);
      }
      this._closeEventListener = (event2) => {
        if (this.modalOpen) {
          this.closeModalInternally("event");
        }
      };
      window.addEventListener(this.closeEventName, this._closeEventListener);
      this._escapeListener = (e2) => {
        if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
          this.closeModalInternally("escape");
        }
      };
      window.addEventListener("keydown", this._escapeListener);
      this.$watch("modalOpen", (value) => {
        const currentWidth = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", value);
        const scrollBarWidth = document.body.offsetWidth - currentWidth;
        document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
        if (value) {
          this.$nextTick(() => {
            const dialogElement = this.$el.querySelector('[role="document"]');
            const focusable3 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
            focusable3?.focus();
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        } else {
          this.$nextTick(() => {
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        }
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      if (this._openListener && this.eventTriggerName) {
        window.removeEventListener(this.eventTriggerName, this._openListener);
      }
      if (this._closeEventListener) {
        window.removeEventListener(this.closeEventName, this._closeEventListener);
      }
      if (this._escapeListener) {
        window.removeEventListener("keydown", this._escapeListener);
      }
      document.body.classList.remove("overflow-hidden");
      document.body.style.setProperty("--page-scrollbar-width", `0px`);
    },
    openModal(event2 = null) {
      const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: event2 },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeOpenEvent);
      if (!beforeOpenEvent.defaultPrevented) {
        this.modalOpen = true;
      }
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(reason = "unknown") {
      const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeCloseEvent);
      if (!beforeCloseEvent.defaultPrevented) {
        document.activeElement?.blur && document.activeElement.blur();
        this.modalOpen = false;
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      }
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      if (this.closeOnClickOutside) {
        this.closeModalInternally("backdrop");
      }
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end) {
  return max(start2, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data2
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, []).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function registerRzDropdownMenu(Alpine2) {
  Alpine2.data("rzDropdownMenu", () => ({
    // --- STATE ---
    open: false,
    isModal: true,
    ariaExpanded: "false",
    trapActive: false,
    focusedIndex: null,
    menuItems: [],
    parentEl: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when menu opens
    anchor: "bottom",
    pixelOffset: 3,
    isSubmenuActive: false,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    // --- INIT ---
    init() {
      if (!this.$el.id) this.$el.id = crypto.randomUUID();
      this.selfId = this.$el.id;
      this.parentEl = this.$el;
      this.triggerEl = this.$refs.trigger;
      this.anchor = this.$el.dataset.anchor || "bottom";
      this.pixelOffset = parseInt(this.$el.dataset.offset) || 6;
      this.isModal = this.$el.dataset.modal !== "false";
      this.$watch("open", (value) => {
        if (value) {
          this._lastNavAt = 0;
          this.$nextTick(() => {
            this.contentEl = document.getElementById(`${this.selfId}-content`);
            if (!this.contentEl) return;
            this.updatePosition();
            this.menuItems = Array.from(
              this.contentEl.querySelectorAll(
                '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
              )
            );
          });
          this.ariaExpanded = "true";
          this.triggerEl.dataset.state = "open";
          this.trapActive = this.isModal;
        } else {
          this.focusedIndex = null;
          this.closeAllSubmenus();
          this.ariaExpanded = "false";
          delete this.triggerEl.dataset.state;
          this.trapActive = false;
          this.contentEl = null;
        }
      });
    },
    // --- METHODS ---
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`);
      computePosition(this.triggerEl, this.contentEl, {
        placement: this.anchor,
        middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(this.contentEl.style, { left: `${x}px`, top: `${y}px` });
      });
    },
    toggle() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      } else {
        this.open = true;
        this.focusedIndex = -1;
      }
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = false;
      let self = this;
      this.$nextTick(() => self.triggerEl?.focus());
    },
    handleTriggerKeydown(event2) {
      if (["Enter", " ", "ArrowDown", "ArrowUp"].includes(event2.key)) {
        event2.preventDefault();
        this.open = true;
        this.$nextTick(() => {
          if (event2.key === "ArrowUp") this.focusLastItem();
          else this.focusFirstItem();
        });
      }
    },
    focusNextItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
      this.focusCurrentItem();
    },
    focusPreviousItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
      this.focusCurrentItem();
    },
    focusFirstItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = 0;
      this.focusCurrentItem();
    },
    focusLastItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = this.menuItems.length - 1;
      this.focusCurrentItem();
    },
    focusCurrentItem() {
      if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
        this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
      }
    },
    focusSelectedItem(item) {
      if (!item || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      const index = this.menuItems.indexOf(item);
      if (index !== -1) {
        this.focusedIndex = index;
        item.focus();
      }
    },
    handleItemClick(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.open = false;
      let self = this;
      this.$nextTick(() => self.triggerEl?.focus());
    },
    handleItemMouseEnter(event2) {
      const item = event2.currentTarget;
      this.focusSelectedItem(item);
      if (item.getAttribute("aria-haspopup") !== "menu") {
        this.closeAllSubmenus();
      }
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      }
    },
    handleContentTabKey() {
      if (this.open) {
        this.open = false;
        let self = this;
        this.$nextTick(() => self.triggerEl?.focus());
      }
    },
    handleTriggerMouseover() {
      let self = this;
      this.$nextTick(() => self.$el.firstElementChild?.focus());
    },
    closeAllSubmenus() {
      const submenus = this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      submenus.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
      this.isSubmenuActive = false;
    }
  }));
  Alpine2.data("rzDropdownSubmenu", () => ({
    // --- STATE ---
    open: false,
    ariaExpanded: "false",
    parentDropdown: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when submenu opens
    menuItems: [],
    focusedIndex: null,
    anchor: "right-start",
    pixelOffset: 0,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    siblingContainer: null,
    closeTimeout: null,
    closeDelay: 150,
    // --- INIT ---
    init() {
      if (!this.$el.id) this.$el.id = crypto.randomUUID();
      this.selfId = this.$el.id;
      const parentId = this.$el.dataset.parentId;
      if (parentId) {
        const parentEl = document.getElementById(parentId);
        if (parentEl) {
          this.parentDropdown = Alpine2.$data(parentEl);
        }
      }
      if (!this.parentDropdown) {
        console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
        return;
      }
      this.triggerEl = this.$refs.subTrigger;
      this.siblingContainer = this.$el.parentElement;
      this.anchor = this.$el.dataset.subAnchor || this.anchor;
      this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset;
      this.$watch("open", (value) => {
        if (value) {
          this._lastNavAt = 0;
          this.parentDropdown.isSubmenuActive = true;
          this.$nextTick(() => {
            this.contentEl = document.getElementById(`${this.selfId}-subcontent`);
            if (!this.contentEl) return;
            this.updatePosition(this.contentEl);
            this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])'));
          });
          this.ariaExpanded = "true";
          this.triggerEl.dataset.state = "open";
        } else {
          this.focusedIndex = null;
          this.ariaExpanded = "false";
          delete this.triggerEl.dataset.state;
          this.$nextTick(() => {
            const anySubmenuIsOpen = this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]');
            if (!anySubmenuIsOpen) this.parentDropdown.isSubmenuActive = false;
          });
          this.contentEl = null;
        }
      });
    },
    // --- METHODS ---
    updatePosition(contentEl) {
      if (!this.triggerEl || !contentEl) return;
      computePosition(this.triggerEl, contentEl, {
        placement: this.anchor,
        middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(contentEl.style, { left: `${x}px`, top: `${y}px` });
      });
    },
    handleTriggerMouseEnter() {
      clearTimeout(this.closeTimeout);
      this.triggerEl.focus();
      this.openSubmenu();
    },
    handleTriggerMouseLeave() {
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    handleContentMouseEnter() {
      clearTimeout(this.closeTimeout);
    },
    handleContentMouseLeave() {
      const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      if (childSubmenus) {
        const isAnyChildOpen = Array.from(childSubmenus).some((el) => Alpine2.$data(el)?.open);
        if (isAnyChildOpen) {
          return;
        }
      }
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    openSubmenu(focusFirst = false) {
      if (this.open) return;
      this.closeSiblingSubmenus();
      this.open = true;
      if (focusFirst) {
        this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem()));
      }
    },
    closeSubmenu() {
      const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      childSubmenus?.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
      this.open = false;
    },
    closeSiblingSubmenus() {
      if (!this.siblingContainer) return;
      const siblings = Array.from(this.siblingContainer.children).filter(
        (el) => el.hasAttribute("x-data") && el.getAttribute("x-data").startsWith("rzDropdownSubmenu") && el.id !== this.selfId
      );
      siblings.forEach((el) => {
        Alpine2.$data(el)?.closeSubmenu();
      });
    },
    toggleSubmenu() {
      this.open ? this.closeSubmenu() : this.openSubmenu();
    },
    openSubmenuAndFocusFirst() {
      this.openSubmenu(true);
    },
    handleTriggerKeydown(e2) {
      if (["ArrowRight", "Enter", " "].includes(e2.key)) {
        e2.preventDefault();
        this.openSubmenuAndFocusFirst();
      }
    },
    focusNextItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
      this.focusCurrentItem();
    },
    focusPreviousItem() {
      const now = Date.now();
      if (now - this._lastNavAt < this.navThrottle) return;
      this._lastNavAt = now;
      if (!this.menuItems.length) return;
      this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
      this.focusCurrentItem();
    },
    focusFirstItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = 0;
      this.focusCurrentItem();
    },
    focusLastItem() {
      if (!this.menuItems.length) return;
      this.focusedIndex = this.menuItems.length - 1;
      this.focusCurrentItem();
    },
    focusCurrentItem() {
      if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
        this.menuItems[this.focusedIndex].focus();
      }
    },
    handleItemClick(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.parentDropdown.open = false;
      this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
    },
    handleItemMouseEnter(event2) {
      const item = event2.currentTarget;
      if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
      const index = this.menuItems.indexOf(item);
      if (index !== -1) {
        this.focusedIndex = index;
        item.focus();
      }
      if (item.getAttribute("aria-haspopup") === "menu") {
        Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu();
      } else {
        this.closeSiblingSubmenus();
      }
    },
    handleSubmenuEscape() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    },
    handleSubmenuArrowLeft() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    }
  }));
}
function registerRzDarkModeToggle(Alpine2) {
  Alpine2.data("rzDarkModeToggle", () => ({
    // Proxy all properties to the reactive store
    get mode() {
      return this.$store.theme.mode;
    },
    get prefersDark() {
      return this.$store.theme.prefersDark;
    },
    get effectiveDark() {
      return this.$store.theme.effectiveDark;
    },
    // Proxy properties from the store (isDark/isLight are getters on the store)
    get isDark() {
      return this.$store.theme.isDark;
    },
    get isLight() {
      return this.$store.theme.isLight;
    },
    // Proxy methods
    setLight() {
      this.$store.theme.setLight();
    },
    setDark() {
      this.$store.theme.setDark();
    },
    setAuto() {
      this.$store.theme.setAuto();
    },
    toggle() {
      this.$store.theme.toggle();
    }
  }));
}
function registerRzEmbeddedPreview(Alpine2) {
  Alpine2.data("rzEmbeddedPreview", () => {
    return {
      iframe: null,
      onDarkModeToggle: null,
      init() {
        try {
          this.iframe = this.$refs.iframe;
          const resize = this.debounce(() => {
            this.resizeIframe(this.iframe);
          }, 50);
          this.resizeIframe(this.iframe);
          const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
              resize();
            }
          });
          resizeObserver.observe(this.iframe);
          const iframe = this.iframe;
          this.onDarkModeToggle = (event2) => {
            iframe.contentWindow.postMessage(event2.detail, "*");
          };
          window.addEventListener("darkModeToggle", this.onDarkModeToggle);
        } catch (error2) {
          console.error("Cannot access iframe content");
        }
      },
      // Adjusts the iframe height based on its content
      resizeIframe(iframe) {
        if (iframe) {
          try {
            const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
            if (iframeDocument) {
              const iframeBody = iframeDocument.body;
              if (!iframeBody) {
                setInterval(() => {
                  this.resizeIframe(iframe);
                }, 150);
              } else {
                const newHeight = iframeBody.scrollHeight + 15;
                iframe.style.height = newHeight + "px";
              }
            }
          } catch (error2) {
            console.error("Error resizing iframe:", error2);
          }
        }
      },
      // Debounce helper to limit function calls
      debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      },
      destroy() {
        window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
      }
    };
  });
}
function registerRzEmpty(Alpine2) {
  Alpine2.data("rzEmpty", () => {
  });
}
function registerRzHeading(Alpine2) {
  Alpine2.data("rzHeading", () => {
    return {
      observer: null,
      headingId: "",
      init() {
        this.headingId = this.$el.dataset.alpineRoot;
        const self = this;
        if (typeof this.setCurrentHeading === "function") {
          const callback = (entries, observer2) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                self.setCurrentHeading(self.headingId);
              }
            });
          };
          const options = { threshold: 0.5 };
          this.observer = new IntersectionObserver(callback, options);
          this.observer.observe(this.$el);
        } else {
          console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
        }
      },
      destroy() {
        if (this.observer != null)
          this.observer.disconnect();
      }
    };
  });
}
function registerRzIndicator(Alpine2) {
  Alpine2.data("rzIndicator", () => ({
    visible: false,
    init() {
      const colorValue = this.$el.dataset.color;
      if (colorValue) {
        this.$el.style.backgroundColor = colorValue;
      } else {
        this.$el.style.backgroundColor = "var(--color-success)";
      }
      if (this.$el.dataset.visible === "true") {
        this.visible = true;
      }
    },
    notVisible() {
      return !this.visible;
    },
    setVisible(value) {
      this.visible = value;
    }
  }));
}
function registerRzInputGroupAddon(Alpine2) {
  Alpine2.data("rzInputGroupAddon", () => ({
    handleClick(event2) {
      if (event2.target.closest("button")) {
        return;
      }
      const parent = this.$el.parentElement;
      if (parent) {
        const input = parent.querySelector("input, textarea");
        input?.focus();
      }
    }
  }));
}
function registerRzMarkdown(Alpine2, require2) {
  Alpine2.data("rzMarkdown", () => {
    return {
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require2(assets, {
          success: function() {
            window.hljs.highlightAll();
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      }
    };
  });
}
function registerRzNavigationMenu(Alpine2, $data2) {
  Alpine2.data("rzNavigationMenu", () => ({
    activeItemId: null,
    open: false,
    closeTimeout: null,
    prevIndex: null,
    list: null,
    isClosing: false,
    /* ---------- helpers ---------- */
    _triggerIndex(id) {
      if (!this.list) return -1;
      const triggers = Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]'));
      return triggers.findIndex((t2) => t2.getAttribute("x-ref") === `trigger_${id}`);
    },
    _contentEl(id) {
      return document.getElementById(`${id}-content`);
    },
    /* ---------- lifecycle ---------- */
    init() {
      const contentEls = this.$el.querySelectorAll("[data-popover]");
      contentEls.forEach((el) => {
        el.style.display = "none";
      });
      this.$nextTick(() => {
        this.list = this.$refs.list;
      });
    },
    /* ---------- event handlers (from events with no params) ---------- */
    toggleActive(e2) {
      const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.activeItemId === id && this.open ? this.closeMenu() : this.openMenu(id);
    },
    handleTriggerEnter(e2) {
      const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.cancelClose();
      if (this.activeItemId !== id && !this.isClosing) {
        requestAnimationFrame(() => this.openMenu(id));
      }
    },
    handleItemEnter(e2) {
      const item = e2.currentTarget;
      if (!item) return;
      this.cancelClose();
      const trigger2 = item.querySelector('[x-ref^="trigger_"]');
      if (trigger2) {
        const id = trigger2.getAttribute("x-ref").replace("trigger_", "");
        if (this.activeItemId !== id && !this.isClosing) {
          requestAnimationFrame(() => this.openMenu(id));
        }
      } else {
        if (this.open && !this.isClosing) {
          this.closeMenu();
        }
      }
    },
    handleContentEnter() {
      this.cancelClose();
    },
    scheduleClose() {
      if (this.isClosing || this.closeTimeout) return;
      this.closeTimeout = setTimeout(() => this.closeMenu(), 150);
    },
    cancelClose() {
      if (this.closeTimeout) {
        clearTimeout(this.closeTimeout);
        this.closeTimeout = null;
      }
      this.isClosing = false;
    },
    /* ---------- open / close logic with direct DOM manipulation ---------- */
    openMenu(id) {
      this.cancelClose();
      this.isClosing = false;
      const newIdx = this._triggerIndex(id);
      const dir = newIdx > (this.prevIndex ?? newIdx) ? "end" : "start";
      const isFirstOpen = this.prevIndex === null;
      if (this.open && this.activeItemId && this.activeItemId !== id) {
        const oldTrig = this.$refs[`trigger_${this.activeItemId}`];
        if (oldTrig) delete oldTrig.dataset.state;
        const oldEl = this._contentEl(this.activeItemId);
        if (oldEl) {
          const outgoingDirection = dir === "end" ? "start" : "end";
          oldEl.setAttribute("data-motion", `to-${outgoingDirection}`);
          setTimeout(() => {
            oldEl.style.display = "none";
          }, 150);
        }
      }
      this.activeItemId = id;
      this.open = true;
      this.prevIndex = newIdx;
      const newTrig = this.$refs[`trigger_${id}`];
      const newContentEl = this._contentEl(id);
      if (!newTrig || !newContentEl) return;
      computePosition(newTrig, newContentEl, {
        placement: "bottom-start",
        middleware: [offset(6), flip(), shift({ padding: 8 })]
      }).then(({ x, y }) => {
        Object.assign(newContentEl.style, { left: `${x}px`, top: `${y}px` });
      });
      newContentEl.style.display = "block";
      if (isFirstOpen) {
        newContentEl.setAttribute("data-motion", "fade-in");
      } else {
        newContentEl.setAttribute("data-motion", `from-${dir}`);
      }
      this.$nextTick(() => {
        newTrig.setAttribute("aria-expanded", "true");
        newTrig.dataset.state = "open";
      });
    },
    closeMenu() {
      if (!this.open || this.isClosing) return;
      this.isClosing = true;
      this.cancelClose();
      const activeId = this.activeItemId;
      if (!activeId) {
        this.isClosing = false;
        return;
      }
      const trig = this.$refs[`trigger_${activeId}`];
      if (trig) {
        trig.setAttribute("aria-expanded", "false");
        delete trig.dataset.state;
      }
      const contentEl = this._contentEl(activeId);
      if (contentEl) {
        contentEl.setAttribute("data-motion", "fade-out");
        setTimeout(() => {
          contentEl.style.display = "none";
        }, 150);
      }
      this.open = false;
      this.activeItemId = null;
      this.prevIndex = null;
      setTimeout(() => {
        this.isClosing = false;
      }, 150);
    }
  }));
}
function registerRzPopover(Alpine2) {
  Alpine2.data("rzPopover", () => ({
    open: false,
    ariaExpanded: "false",
    triggerEl: null,
    contentEl: null,
    init() {
      this.triggerEl = this.$refs.trigger;
      this.contentEl = this.$refs.content;
      this.$watch("open", (value) => {
        this.ariaExpanded = value.toString();
        if (value) {
          this.$nextTick(() => this.updatePosition());
        }
      });
    },
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      const anchor = this.$el.dataset.anchor || "bottom";
      const mainOffset = parseInt(this.$el.dataset.offset) || 0;
      const crossAxisOffset = parseInt(this.$el.dataset.crossAxisOffset) || 0;
      const alignmentAxisOffset = parseInt(this.$el.dataset.alignmentAxisOffset) || null;
      const strategy = this.$el.dataset.strategy || "absolute";
      const enableFlip = this.$el.dataset.enableFlip !== "false";
      const enableShift = this.$el.dataset.enableShift !== "false";
      const shiftPadding = parseInt(this.$el.dataset.shiftPadding) || 8;
      let middleware = [];
      middleware.push(offset({
        mainAxis: mainOffset,
        crossAxis: crossAxisOffset,
        alignmentAxis: alignmentAxisOffset
      }));
      if (enableFlip) {
        middleware.push(flip());
      }
      if (enableShift) {
        middleware.push(shift({ padding: shiftPadding }));
      }
      computePosition(this.triggerEl, this.contentEl, {
        placement: anchor,
        strategy,
        middleware
      }).then(({ x, y }) => {
        Object.assign(this.contentEl.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
    },
    toggle() {
      this.open = !this.open;
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = false;
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = false;
        this.$nextTick(() => this.triggerEl?.focus());
      }
    }
  }));
}
function registerRzPrependInput(Alpine2) {
  Alpine2.data("rzPrependInput", () => {
    return {
      prependContainer: null,
      textInput: null,
      init() {
        this.prependContainer = this.$refs.prependContainer;
        this.textInput = this.$refs.textInput;
        let self = this;
        setTimeout(() => {
          self.updatePadding();
        }, 50);
        window.addEventListener("resize", this.updatePadding);
      },
      destroy() {
        window.removeEventListener("resize", this.updatePadding);
      },
      updatePadding() {
        const prependDiv = this.prependContainer;
        const inputElem = this.textInput;
        if (!prependDiv || !inputElem) {
          if (inputElem) {
            inputElem.classList.remove("text-transparent");
          }
          return;
        }
        const prependWidth = prependDiv.offsetWidth;
        const leftPadding = prependWidth + 10;
        inputElem.style.paddingLeft = leftPadding + "px";
        inputElem.classList.remove("text-transparent");
      }
    };
  });
}
function registerRzProgress(Alpine2) {
  Alpine2.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const element = this.$el;
      this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
      this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
      this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
      this.label = element.getAttribute("data-label");
      this.calculatePercentage();
      element.setAttribute("aria-valuenow", this.currentVal);
      element.setAttribute("aria-valuemin", this.minVal);
      element.setAttribute("aria-valuemax", this.maxVal);
      element.setAttribute("aria-valuetext", `${this.percentage}%`);
      this.updateProgressBar();
      const resizeObserver = new ResizeObserver((entries) => {
        this.updateProgressBar();
      });
      resizeObserver.observe(element);
      this.$watch("currentVal", () => {
        this.calculatePercentage();
        this.updateProgressBar();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      if (this.maxVal === this.minVal) {
        this.percentage = 0;
      } else {
        this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
      }
    },
    buildLabel() {
      var label = this.label || "{percent}%";
      this.calculatePercentage();
      return label.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const progressBar = this.$refs.progressBar;
      const barLabel = this.$refs.progressBarLabel;
      const innerLabel = this.$refs.innerLabel;
      if (barLabel && progressBar && innerLabel) {
        innerLabel.innerText = this.buildLabel();
        if (barLabel.clientWidth > progressBar.clientWidth) {
          barLabel.style.left = progressBar.clientWidth + 10 + "px";
        } else {
          barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
        }
      }
    },
    getLabelCss() {
      const barLabel = this.$refs.progressBarLabel;
      const progressBar = this.$refs.progressBar;
      if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
        return "text-foreground dark:text-foreground";
      }
      return "";
    },
    updateProgressBar() {
      const progressBar = this.$refs.progressBar;
      if (progressBar) {
        progressBar.style.width = `${this.percentage}%`;
        this.buildInsideLabelPosition();
      }
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(value) {
      this.currentVal = value;
    },
    increment(val = 1) {
      this.currentVal = Math.min(this.currentVal + val, this.maxVal);
    },
    decrement(val = 1) {
      this.currentVal = Math.max(this.currentVal - val, this.minVal);
    }
  }));
}
function registerRzQuickReferenceContainer(Alpine2) {
  Alpine2.data("rzQuickReferenceContainer", () => {
    return {
      headings: [],
      // Array of heading IDs
      currentHeadingId: "",
      // ID of the currently highlighted heading
      // Initializes the component with headings and the initial current heading from data attributes.
      init() {
        this.headings = JSON.parse(this.$el.dataset.headings || "[]");
        this.currentHeadingId = this.$el.dataset.currentheadingid || "";
      },
      // Handles click events on quick reference links.
      handleHeadingClick() {
        const id = this.$el.dataset.headingid;
        window.requestAnimationFrame(() => {
          this.currentHeadingId = id;
        });
      },
      // Sets the current heading ID based on intersection observer events from rzHeading.
      setCurrentHeading(id) {
        if (this.headings.includes(id)) {
          this.currentHeadingId = id;
        }
      },
      // Provides CSS classes for a link based on whether it's the current heading.
      // Returns an object suitable for :class binding.
      getSelectedCss() {
        const id = this.$el.dataset.headingid;
        return {
          "font-bold": this.currentHeadingId === id
          // Apply 'font-bold' if current
        };
      },
      // Determines the value for the aria-current attribute.
      getSelectedAriaCurrent() {
        const id = this.$el.dataset.headingid;
        return this.currentHeadingId === id ? "true" : null;
      }
    };
  });
}
function registerRzSheet(Alpine2) {
  Alpine2.data("rzSheet", () => ({
    open: false,
    init() {
      this.open = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.open = !this.open;
    },
    close() {
      this.open = false;
    },
    show() {
      this.open = true;
    },
    state() {
      return this.open ? "open" : "closed";
    }
  }));
}
function registerRzTabs(Alpine2) {
  Alpine2.data("rzTabs", () => ({
    selectedTab: "",
    _triggers: [],
    _observer: null,
    init() {
      const defaultValue = this.$el.dataset.defaultValue;
      this._observer = new MutationObserver(() => this.refreshTriggers());
      this._observer.observe(this.$el, { childList: true, subtree: true });
      this.refreshTriggers();
      if (defaultValue && this._triggers.some((t2) => t2.dataset.value === defaultValue)) {
        this.selectedTab = defaultValue;
      } else if (this._triggers.length > 0) {
        this.selectedTab = this._triggers[0].dataset.value;
      }
    },
    destroy() {
      if (this._observer) {
        this._observer.disconnect();
      }
    },
    refreshTriggers() {
      this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
    },
    onTriggerClick(e2) {
      const value = e2.currentTarget?.dataset?.value;
      if (!value || e2.currentTarget.getAttribute("aria-disabled") === "true") {
        return;
      }
      this.selectedTab = value;
      this.$dispatch("rz:tabs-change", { value: this.selectedTab });
    },
    isSelected(value) {
      return this.selectedTab === value;
    },
    bindTrigger() {
      this.selectedTab;
      const value = this.$el.dataset.value;
      const active = this.isSelected(value);
      const disabled = this.$el.getAttribute("aria-disabled") === "true";
      return {
        "aria-selected": String(active),
        "tabindex": active ? "0" : "-1",
        "data-state": active ? "active" : "inactive",
        ...disabled && { "disabled": true }
      };
    },
    _attrDisabled() {
      return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
    },
    _attrAriaSelected() {
      return String(this.$el.dataset.value === this.selectedTab);
    },
    _attrHidden() {
      return this.$el.dataset.value === this.selectedTab ? null : "true";
    },
    _attrAriaHidden() {
      return String(this.selectedTab !== this.$el.dataset.value);
    },
    _attrDataState() {
      return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
    },
    _attrTabIndex() {
      return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
    },
    onListKeydown(e2) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(e2.key)) {
        e2.preventDefault();
        const availableTriggers = this._triggers.filter((t2) => t2.getAttribute("aria-disabled") !== "true");
        if (availableTriggers.length === 0) return;
        const activeIndex = availableTriggers.findIndex((t2) => t2.dataset.value === this.selectedTab);
        if (activeIndex === -1) return;
        const isVertical = e2.currentTarget?.getAttribute("aria-orientation") === "vertical";
        const prevKey = isVertical ? "ArrowUp" : "ArrowLeft";
        const nextKey = isVertical ? "ArrowDown" : "ArrowRight";
        let newIndex = activeIndex;
        switch (e2.key) {
          case prevKey:
            newIndex = activeIndex - 1 < 0 ? availableTriggers.length - 1 : activeIndex - 1;
            break;
          case nextKey:
            newIndex = (activeIndex + 1) % availableTriggers.length;
            break;
          case "Home":
            newIndex = 0;
            break;
          case "End":
            newIndex = availableTriggers.length - 1;
            break;
        }
        if (newIndex >= 0 && newIndex < availableTriggers.length) {
          const newTrigger = availableTriggers[newIndex];
          this.selectedTab = newTrigger.dataset.value;
          this.$nextTick(() => newTrigger.focus());
        }
      }
    }
  }));
}
function registerRzSidebar(Alpine2) {
  Alpine2.data("rzSidebar", () => ({
    open: false,
    openMobile: false,
    isMobile: false,
    collapsible: "offcanvas",
    shortcut: "b",
    cookieName: "sidebar_state",
    mobileBreakpoint: 768,
    init() {
      this.collapsible = this.$el.dataset.collapsible || "offcanvas";
      this.shortcut = this.$el.dataset.shortcut || "b";
      this.cookieName = this.$el.dataset.cookieName || "sidebar_state";
      this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
      const savedState = this.cookieName ? document.cookie.split("; ").find((row) => row.startsWith(`${this.cookieName}=`))?.split("=")[1] : null;
      const defaultOpen = this.$el.dataset.defaultOpen === "true";
      this.open = savedState !== null ? savedState === "true" : defaultOpen;
      this.checkIfMobile();
      window.addEventListener("keydown", (e2) => {
        if ((e2.ctrlKey || e2.metaKey) && e2.key.toLowerCase() === this.shortcut.toLowerCase()) {
          e2.preventDefault();
          this.toggle();
        }
      });
      this.$watch("open", (value) => {
        if (this.cookieName) {
          document.cookie = `${this.cookieName}=${value}; path=/; max-age=31536000`;
        }
      });
    },
    checkIfMobile() {
      this.isMobile = window.innerWidth < this.mobileBreakpoint;
    },
    toggle() {
      if (this.isMobile) {
        this.openMobile = !this.openMobile;
      } else {
        this.open = !this.open;
      }
    },
    close() {
      if (this.isMobile) {
        this.openMobile = false;
      }
    },
    isMobileOpen() {
      return this.openMobile;
    },
    desktopState() {
      return this.open ? "expanded" : "collapsed";
    },
    mobileState() {
      return this.openMobile ? "open" : "closed";
    },
    getCollapsibleAttribute() {
      return this.desktopState() === "collapsed" ? this.collapsible : "";
    }
  }));
}
function registerRzCommand(Alpine2) {
  Alpine2.data("rzCommand", () => ({
    // --- STATE ---
    search: "",
    selectedValue: null,
    selectedIndex: -1,
    items: [],
    filteredItems: [],
    groupTemplates: /* @__PURE__ */ new Map(),
    activeDescendantId: null,
    isOpen: false,
    isEmpty: true,
    firstRender: true,
    isLoading: false,
    error: null,
    // --- CONFIG ---
    loop: false,
    shouldFilter: true,
    itemsUrl: null,
    fetchTrigger: "immediate",
    serverFiltering: false,
    dataItemTemplateId: null,
    _dataFetched: false,
    _debounceTimer: null,
    // --- COMPUTED (CSP-Compliant Methods) ---
    showLoading() {
      return this.isLoading;
    },
    hasError() {
      return this.error !== null;
    },
    notHasError() {
      return this.error == null;
    },
    shouldShowEmpty() {
      return this.isEmpty && this.search && !this.isLoading && !this.error;
    },
    shouldShowEmptyOrError() {
      return this.isEmpty && this.search && !this.isLoading || this.error !== null;
    },
    // --- LIFECYCLE ---
    init() {
      this.loop = this.$el.dataset.loop === "true";
      this.shouldFilter = this.$el.dataset.shouldFilter !== "false";
      this.selectedValue = this.$el.dataset.selectedValue || null;
      this.itemsUrl = this.$el.dataset.itemsUrl || null;
      this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate";
      this.serverFiltering = this.$el.dataset.serverFiltering === "true";
      this.dataItemTemplateId = this.$el.dataset.templateId || null;
      const itemsScriptId = this.$el.dataset.itemsId;
      let staticItems = [];
      if (itemsScriptId) {
        const itemsScript = document.getElementById(itemsScriptId);
        if (itemsScript) {
          try {
            staticItems = JSON.parse(itemsScript.textContent || "[]");
          } catch (e2) {
            console.error(`RzCommand: Failed to parse JSON from script tag #${itemsScriptId}`, e2);
          }
        }
      }
      if (staticItems.length > 0 && !this.dataItemTemplateId) {
        console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them.");
      }
      staticItems.forEach((item) => {
        item.id = item.id || `static-item-${crypto.randomUUID()}`;
        item.isDataItem = true;
        this.registerItem(item);
      });
      if (this.itemsUrl && this.fetchTrigger === "immediate") {
        this.fetchItems();
      }
      this.$watch("search", (newValue) => {
        this.firstRender = false;
        if (this.serverFiltering) {
          clearTimeout(this._debounceTimer);
          this._debounceTimer = setTimeout(() => {
            this.fetchItems(newValue);
          }, 300);
        } else {
          this.filterAndSortItems();
        }
      });
      this.$watch("selectedIndex", (newIndex, oldIndex) => {
        if (oldIndex > -1) {
          const oldItem = this.filteredItems[oldIndex];
          if (oldItem) {
            const oldEl = this.$el.querySelector(`[data-command-item-id="${oldItem.id}"]`);
            if (oldEl) {
              oldEl.removeAttribute("data-selected");
              oldEl.setAttribute("aria-selected", "false");
            }
          }
        }
        if (newIndex > -1 && this.filteredItems[newIndex]) {
          const selectedItem = this.filteredItems[newIndex];
          this.activeDescendantId = selectedItem.id;
          const el = this.$el.querySelector(`[data-command-item-id="${selectedItem.id}"]`);
          if (el) {
            el.setAttribute("data-selected", "true");
            el.setAttribute("aria-selected", "true");
            el.scrollIntoView({ block: "nearest" });
          }
          const newValue = selectedItem.value;
          if (this.selectedValue !== newValue) {
            this.selectedValue = newValue;
            this.$dispatch("rz:command:select", { value: newValue });
          }
        } else {
          this.activeDescendantId = null;
          this.selectedValue = null;
        }
      });
      this.$watch("selectedValue", (newValue) => {
        const index = this.filteredItems.findIndex((item) => item.value === newValue);
        if (this.selectedIndex !== index) {
          this.selectedIndex = index;
        }
      });
      this.$watch("filteredItems", (items) => {
        this.isOpen = items.length > 0 || this.isLoading;
        this.isEmpty = items.length === 0;
        if (!this.firstRender) {
          window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
            detail: {
              items: this.filteredItems,
              groups: this.groupTemplates,
              commandId: this.$el.id
            }
          }));
        }
      });
    },
    // --- METHODS ---
    async fetchItems(query = "") {
      if (!this.itemsUrl) return;
      if (!this.dataItemTemplateId) {
        console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data.");
        this.error = "Configuration error: No data template found.";
        return;
      }
      this.isLoading = true;
      this.error = null;
      try {
        const url = new URL(this.itemsUrl, window.location.origin);
        if (this.serverFiltering && query) {
          url.searchParams.append("q", query);
        }
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const data2 = await response.json();
        if (this.serverFiltering) {
          this.items = this.items.filter((i2) => !i2.isDataItem);
        }
        data2.forEach((item) => {
          item.id = item.id || `data-item-${crypto.randomUUID()}`;
          item.isDataItem = true;
          this.registerItem(item);
        });
        this._dataFetched = true;
      } catch (e2) {
        this.error = e2.message || "Failed to fetch command items.";
        console.error("RzCommand:", this.error);
      } finally {
        this.isLoading = false;
        this.filterAndSortItems();
      }
    },
    handleInteraction() {
      if (this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched) {
        this.fetchItems();
      }
    },
    registerItem(item) {
      if (this.items.some((i2) => i2.id === item.id)) return;
      item._order = this.items.length;
      this.items.push(item);
      if (this.selectedIndex === -1)
        this.selectedIndex = 0;
      if (!this.serverFiltering) {
        this.filterAndSortItems();
      }
    },
    unregisterItem(itemId) {
      this.items = this.items.filter((i2) => i2.id !== itemId);
      this.filterAndSortItems();
    },
    registerGroupTemplate(name, templateId) {
      if (!this.groupTemplates.has(name)) {
        this.groupTemplates.set(name, templateId);
      }
    },
    filterAndSortItems() {
      if (this.serverFiltering && this._dataFetched) {
        this.filteredItems = this.items;
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        return;
      }
      let items;
      if (!this.shouldFilter || !this.search) {
        items = this.items.map((item) => ({ ...item, score: 1 }));
      } else {
        items = this.items.map((item) => ({
          ...item,
          score: item.forceMount ? 0 : this.commandScore(item.name, this.search, item.keywords)
        })).filter((item) => item.score > 0 || item.forceMount).sort((a2, b) => {
          if (a2.forceMount && !b.forceMount) return 1;
          if (!a2.forceMount && b.forceMount) return -1;
          if (b.score !== a2.score) return b.score - a2.score;
          return (a2._order || 0) - (b._order || 0);
        });
      }
      this.filteredItems = items;
      if (this.selectedValue) {
        const newIndex = this.filteredItems.findIndex((item) => item.value === this.selectedValue);
        this.selectedIndex = newIndex > -1 ? newIndex : this.filteredItems.length > 0 ? 0 : -1;
      } else {
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
      }
    },
    // --- EVENT HANDLERS ---
    handleItemClick(event2) {
      const host = event2.target.closest("[data-command-item-id]");
      if (!host) return;
      const itemId = host.dataset.commandItemId;
      const index = this.filteredItems.findIndex((item) => item.id === itemId);
      if (index > -1) {
        const item = this.filteredItems[index];
        if (item && !item.disabled) {
          this.selectedIndex = index;
          this.$dispatch("rz:command:execute", { value: item.value });
        }
      }
    },
    handleItemHover(event2) {
      const host = event2.target.closest("[data-command-item-id]");
      if (!host) return;
      const itemId = host.dataset.commandItemId;
      const index = this.filteredItems.findIndex((item) => item.id === itemId);
      if (index > -1) {
        const item = this.filteredItems[index];
        if (item && !item.disabled) {
          if (this.selectedIndex !== index) {
            this.selectedIndex = index;
          }
        }
      }
    },
    // --- KEYBOARD NAVIGATION ---
    handleKeydown(e2) {
      switch (e2.key) {
        case "ArrowDown":
          e2.preventDefault();
          this.selectNext();
          break;
        case "ArrowUp":
          e2.preventDefault();
          this.selectPrev();
          break;
        case "Home":
          e2.preventDefault();
          this.selectFirst();
          break;
        case "End":
          e2.preventDefault();
          this.selectLast();
          break;
        case "Enter":
          e2.preventDefault();
          const item = this.filteredItems[this.selectedIndex];
          if (item && !item.disabled) {
            this.$dispatch("rz:command:execute", { value: item.value });
          }
          break;
      }
    },
    selectNext() {
      if (this.filteredItems.length === 0) return;
      let i2 = this.selectedIndex, count = 0;
      do {
        i2 = i2 + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : i2 + 1;
        count++;
        if (!this.filteredItems[i2]?.disabled) {
          this.selectedIndex = i2;
          return;
        }
        if (!this.loop && i2 === this.filteredItems.length - 1) return;
      } while (count <= this.filteredItems.length);
    },
    selectPrev() {
      if (this.filteredItems.length === 0) return;
      let i2 = this.selectedIndex, count = 0;
      do {
        i2 = i2 - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : i2 - 1;
        count++;
        if (!this.filteredItems[i2]?.disabled) {
          this.selectedIndex = i2;
          return;
        }
        if (!this.loop && i2 === 0) return;
      } while (count <= this.filteredItems.length);
    },
    selectFirst() {
      if (this.filteredItems.length > 0) {
        const firstEnabledIndex = this.filteredItems.findIndex((item) => !item.disabled);
        if (firstEnabledIndex > -1) this.selectedIndex = firstEnabledIndex;
      }
    },
    selectLast() {
      if (this.filteredItems.length > 0) {
        const lastEnabledIndex = this.filteredItems.map((item) => item.disabled).lastIndexOf(false);
        if (lastEnabledIndex > -1) this.selectedIndex = lastEnabledIndex;
      }
    },
    // --- SCORING ALGORITHM (Adapted from cmdk) ---
    commandScore(string, search, keywords = []) {
      const SCORE_CONTINUE_MATCH = 1;
      const SCORE_SPACE_WORD_JUMP = 0.9;
      const SCORE_NON_SPACE_WORD_JUMP = 0.8;
      const SCORE_CHARACTER_JUMP = 0.17;
      const PENALTY_SKIPPED = 0.999;
      const PENALTY_CASE_MISMATCH = 0.9999;
      const PENALTY_NOT_COMPLETE = 0.99;
      const IS_GAP_REGEXP = /[\\/_+.#"@[\(\{&]/;
      const IS_SPACE_REGEXP = /[\s-]/;
      const fullString = `${string} ${keywords ? keywords.join(" ") : ""}`;
      function formatInput(str) {
        return str.toLowerCase().replace(/[\s-]/g, " ");
      }
      function commandScoreInner(str, abbr, lowerStr, lowerAbbr, strIndex, abbrIndex, memo) {
        if (abbrIndex === abbr.length) {
          return strIndex === str.length ? SCORE_CONTINUE_MATCH : PENALTY_NOT_COMPLETE;
        }
        const memoKey = `${strIndex},${abbrIndex}`;
        if (memo[memoKey] !== void 0) return memo[memoKey];
        const abbrChar = lowerAbbr.charAt(abbrIndex);
        let index = lowerStr.indexOf(abbrChar, strIndex);
        let highScore = 0;
        while (index >= 0) {
          let score = commandScoreInner(str, abbr, lowerStr, lowerAbbr, index + 1, abbrIndex + 1, memo);
          if (score > highScore) {
            if (index === strIndex) {
              score *= SCORE_CONTINUE_MATCH;
            } else if (IS_GAP_REGEXP.test(str.charAt(index - 1))) {
              score *= SCORE_NON_SPACE_WORD_JUMP;
            } else if (IS_SPACE_REGEXP.test(str.charAt(index - 1))) {
              score *= SCORE_SPACE_WORD_JUMP;
            } else {
              score *= SCORE_CHARACTER_JUMP;
              if (strIndex > 0) {
                score *= Math.pow(PENALTY_SKIPPED, index - strIndex);
              }
            }
            if (str.charAt(index) !== abbr.charAt(abbrIndex)) {
              score *= PENALTY_CASE_MISMATCH;
            }
          }
          if (score > highScore) {
            highScore = score;
          }
          index = lowerStr.indexOf(abbrChar, index + 1);
        }
        memo[memoKey] = highScore;
        return highScore;
      }
      return commandScoreInner(fullString, search, formatInput(fullString), formatInput(search), 0, 0, {});
    }
  }));
}
function registerRzCommandItem(Alpine2) {
  Alpine2.data("rzCommandItem", () => ({
    parent: null,
    itemData: {},
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandItem must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      this.itemData = {
        id: this.$el.id,
        value: this.$el.dataset.value || this.$el.textContent.trim(),
        name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
        keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
        group: this.$el.dataset.group || null,
        templateId: this.$el.id + "-template",
        disabled: this.$el.dataset.disabled === "true",
        forceMount: this.$el.dataset.forceMount === "true"
      };
      this.parent.registerItem(this.itemData);
    },
    destroy() {
      if (this.parent) {
        this.parent.unregisterItem(this.itemData.id);
      }
    }
  }));
}
function registerRzCommandList(Alpine2) {
  Alpine2.data("rzCommandList", () => ({
    parent: null,
    dataItemTemplate: null,
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandList must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      if (this.parent.dataItemTemplateId) {
        this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId);
      }
    },
    renderList(event2) {
      if (event2.detail.commandId !== this.parent.$el.id) return;
      const items = event2.detail.items || [];
      const groups = event2.detail.groups || /* @__PURE__ */ new Map();
      const container = this.$el;
      container.querySelectorAll("[data-dynamic-item]").forEach((el) => el.remove());
      const groupedItems = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
      items.forEach((item) => {
        const groupName = item.group || "__ungrouped__";
        if (!groupedItems.has(groupName)) {
          groupedItems.set(groupName, []);
        }
        groupedItems.get(groupName).push(item);
      });
      groupedItems.forEach((groupItems, groupName) => {
        if (groupItems.length === 0) return;
        const groupContainer = document.createElement("div");
        groupContainer.setAttribute("role", "group");
        groupContainer.setAttribute("data-dynamic-item", "true");
        groupContainer.setAttribute("data-slot", "command-group");
        if (groupName !== "__ungrouped__") {
          const headingTemplateId = groups.get(groupName);
          if (headingTemplateId) {
            const headingTemplate = document.getElementById(headingTemplateId);
            if (headingTemplate && headingTemplate.content) {
              const headingClone = headingTemplate.content.cloneNode(true);
              const headingEl = headingClone.firstElementChild;
              if (headingEl) {
                groupContainer.setAttribute("aria-labelledby", headingEl.id);
                groupContainer.appendChild(headingClone);
              }
            }
          }
        }
        groupItems.forEach((item) => {
          const itemIndex = this.parent.filteredItems.indexOf(item);
          let itemEl;
          if (item.isDataItem) {
            if (!this.dataItemTemplate) {
              return;
            }
            const clone2 = this.dataItemTemplate.content.cloneNode(true);
            itemEl = clone2.firstElementChild;
            Alpine2.addScopeToNode(itemEl, { item });
          } else {
            const template = document.getElementById(item.templateId);
            if (template && template.content) {
              const clone2 = template.content.cloneNode(true);
              itemEl = clone2.querySelector(`[data-command-item-id="${item.id}"]`);
            }
          }
          if (itemEl) {
            itemEl.setAttribute("data-command-item-id", item.id);
            itemEl.setAttribute("data-value", item.value);
            if (item.keywords) itemEl.setAttribute("data-keywords", JSON.stringify(item.keywords));
            if (item.group) itemEl.setAttribute("data-group", item.group);
            if (item.disabled) itemEl.setAttribute("data-disabled", "true");
            if (item.forceMount) itemEl.setAttribute("data-force-mount", "true");
            itemEl.setAttribute("role", "option");
            itemEl.setAttribute("aria-selected", this.parent.selectedIndex === itemIndex);
            if (item.disabled) {
              itemEl.setAttribute("aria-disabled", "true");
            }
            if (this.parent.selectedIndex === itemIndex) {
              itemEl.setAttribute("data-selected", "true");
            }
            groupContainer.appendChild(itemEl);
            Alpine2.initTree(itemEl);
          }
        });
        container.appendChild(groupContainer);
      });
    }
  }));
}
function registerRzCommandGroup(Alpine2) {
  Alpine2.data("rzCommandGroup", () => ({
    parent: null,
    heading: "",
    templateId: "",
    init() {
      const parentEl = this.$el.closest('[x-data="rzCommand"]');
      if (!parentEl) {
        console.error("CommandGroup must be a child of RzCommand.");
        return;
      }
      this.parent = Alpine2.$data(parentEl);
      this.heading = this.$el.dataset.heading;
      this.templateId = this.$el.dataset.templateId;
      if (this.heading && this.templateId) {
        this.parent.registerGroupTemplate(this.heading, this.templateId);
      }
    }
  }));
}
async function generateBundleId(paths) {
  paths = [...paths].sort();
  const joinedPaths = paths.join("|");
  const encoder = new TextEncoder();
  const data2 = encoder.encode(joinedPaths);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function rizzyRequire(paths, callbackOrNonce, nonce) {
  let cbObj = void 0;
  let csp = void 0;
  if (typeof callbackOrNonce === "function") {
    cbObj = { success: callbackOrNonce };
  } else if (callbackOrNonce && typeof callbackOrNonce === "object") {
    cbObj = callbackOrNonce;
  } else if (typeof callbackOrNonce === "string") {
    csp = callbackOrNonce;
  }
  if (!csp && typeof nonce === "string") csp = nonce;
  const files = Array.isArray(paths) ? paths : [paths];
  return generateBundleId(files).then((bundleId) => {
    if (!loadjs.isDefined(bundleId)) {
      loadjs(files, bundleId, {
        // keep scripts ordered unless you explicitly change this later
        async: false,
        // pass CSP nonce to both script and style tags as your loader expects
        inlineScriptNonce: csp,
        inlineStyleNonce: csp
      });
    }
    return new Promise((resolve, reject) => {
      loadjs.ready(bundleId, {
        success: () => {
          try {
            if (cbObj && typeof cbObj.success === "function") cbObj.success();
          } catch (e2) {
            console.error("[rizzyRequire] success callback threw:", e2);
          }
          resolve({ bundleId });
        },
        error: (depsNotFound) => {
          try {
            if (cbObj && typeof cbObj.error === "function") {
              cbObj.error(depsNotFound);
            }
          } catch (e2) {
            console.error("[rizzyRequire] error callback threw:", e2);
          }
          reject(
            new Error(
              `[rizzyRequire] Failed to load bundle ${bundleId} (missing: ${Array.isArray(depsNotFound) ? depsNotFound.join(", ") : String(depsNotFound)})`
            )
          );
        }
      });
    });
  });
}
function registerComponents(Alpine2) {
  registerRzAccordion(Alpine2);
  registerAccordionItem(Alpine2);
  registerRzAlert(Alpine2);
  registerRzAspectRatio(Alpine2);
  registerRzBrowser(Alpine2);
  registerRzCalendar(Alpine2, rizzyRequire);
  registerRzCarousel(Alpine2, rizzyRequire);
  registerRzCodeViewer(Alpine2, rizzyRequire);
  registerRzCollapsible(Alpine2);
  registerRzCombobox(Alpine2, rizzyRequire);
  registerRzDateEdit(Alpine2, rizzyRequire);
  registerRzDialog(Alpine2);
  registerRzDropdownMenu(Alpine2);
  registerRzDarkModeToggle(Alpine2);
  registerRzEmbeddedPreview(Alpine2);
  registerRzEmpty(Alpine2);
  registerRzHeading(Alpine2);
  registerRzIndicator(Alpine2);
  registerRzInputGroupAddon(Alpine2);
  registerRzMarkdown(Alpine2, rizzyRequire);
  registerRzNavigationMenu(Alpine2);
  registerRzPopover(Alpine2);
  registerRzPrependInput(Alpine2);
  registerRzProgress(Alpine2);
  registerRzQuickReferenceContainer(Alpine2);
  registerRzSheet(Alpine2);
  registerRzTabs(Alpine2);
  registerRzSidebar(Alpine2);
  registerRzCommand(Alpine2);
  registerRzCommandItem(Alpine2);
  registerRzCommandList(Alpine2);
  registerRzCommandGroup(Alpine2);
}
function props(alpineRootElement) {
  if (!(alpineRootElement instanceof Element)) {
    console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el).");
    return {};
  }
  const propsScriptId = alpineRootElement.dataset.propsId;
  if (!propsScriptId) {
    return {};
  }
  const propsScriptEl = document.getElementById(propsScriptId);
  if (!propsScriptEl) {
    console.warn(`[Rizzy.props] Could not find the props script tag with ID '${propsScriptId}'.`);
    return {};
  }
  try {
    return JSON.parse(propsScriptEl.textContent || "{}");
  } catch (e2) {
    console.error(`[Rizzy.props] Failed to parse JSON from script tag #${propsScriptId}.`, e2);
    return {};
  }
}
const _registered = /* @__PURE__ */ new Map();
const _importCache = /* @__PURE__ */ new Map();
let _onAlpineInitAttached = false;
function onceImport(path) {
  if (!_importCache.has(path)) {
    _importCache.set(
      path,
      import(path).catch((err) => {
        _importCache.delete(path);
        throw err;
      })
    );
  }
  return _importCache.get(path);
}
function setAsyncLoader(name, path) {
  const Alpine2 = globalThis.Alpine;
  if (!(Alpine2 && typeof Alpine2.asyncData === "function")) {
    console.error(
      `[RizzyUI] Could not register async component '${name}'. AsyncAlpine not available.`
    );
    return false;
  }
  Alpine2.asyncData(
    name,
    () => onceImport(path).catch((error2) => {
      console.error(
        `[RizzyUI] Failed to load Alpine module '${name}' from '${path}'.`,
        error2
      );
      return () => ({
        _error: true,
        _errorMessage: `Module '${name}' failed to load.`
      });
    })
  );
  return true;
}
function registerAsyncComponent(name, path) {
  if (!name || !path) {
    console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
    return;
  }
  const prev = _registered.get(name);
  if (prev && prev.path !== path) {
    console.warn(
      `[RizzyUI] Re-registering '${name}' with a different path.
  Previous: ${prev.path}
  New:      ${path}`
    );
  }
  const Alpine2 = globalThis.Alpine;
  if (Alpine2 && Alpine2.version) {
    const changedPath = !prev || prev.path !== path;
    const alreadySet = prev && prev.loaderSet && !changedPath;
    if (!alreadySet) {
      const ok = setAsyncLoader(name, path);
      _registered.set(name, { path, loaderSet: ok });
    }
    return;
  }
  _registered.set(name, { path, loaderSet: false });
  if (!_onAlpineInitAttached) {
    _onAlpineInitAttached = true;
    document.addEventListener(
      "alpine:init",
      () => {
        for (const [n2, info] of _registered) {
          if (!info.loaderSet) {
            const ok = setAsyncLoader(n2, info.path);
            info.loaderSet = ok;
          }
        }
      },
      { once: true }
    );
  }
}
function registerMobileDirective(Alpine2) {
  Alpine2.directive("mobile", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    const bpMod = modifiers.find((m2) => m2.startsWith("bp-"));
    const BREAKPOINT = bpMod ? parseInt(bpMod.slice(3), 10) : 768;
    const ASSIGN_PROP = !!(expression && expression.length > 0);
    if (typeof window === "undefined" || !window.matchMedia) {
      el.dataset.mobile = "false";
      el.dataset.screen = "desktop";
      return;
    }
    const isMobileNow = () => window.innerWidth < BREAKPOINT;
    const reflect = (val) => {
      el.dataset.mobile = val ? "true" : "false";
      el.dataset.screen = val ? "mobile" : "desktop";
    };
    const getComponentData = () => {
      if (typeof Alpine2.$data === "function") return Alpine2.$data(el);
      return el.__x ? el.__x.$data : null;
    };
    const setProp = (val) => {
      if (!ASSIGN_PROP) return;
      const data2 = getComponentData();
      if (data2) data2[expression] = val;
    };
    const dispatch2 = (val) => {
      el.dispatchEvent(
        new CustomEvent("screen:change", {
          bubbles: true,
          detail: { isMobile: val, width: window.innerWidth, breakpoint: BREAKPOINT }
        })
      );
    };
    const mql = window.matchMedia(`(max-width: ${BREAKPOINT - 1}px)`);
    const update = () => {
      const val = isMobileNow();
      reflect(val);
      setProp(val);
      dispatch2(val);
    };
    update();
    const onChange = () => update();
    const onResize = () => update();
    mql.addEventListener("change", onChange);
    window.addEventListener("resize", onResize, { passive: true });
    cleanup2(() => {
      mql.removeEventListener("change", onChange);
      window.removeEventListener("resize", onResize);
    });
  });
}
function registerSyncDirective(Alpine2) {
  const handler4 = (el, { expression, modifiers }, { cleanup: cleanup2, effect: effect3 }) => {
    if (!expression || typeof expression !== "string") return;
    const setAtPath = (obj, path, value) => {
      const norm = path.replace(/\[(\d+)\]/g, ".$1");
      const keys = norm.split(".");
      const last = keys.pop();
      let cur = obj;
      for (const k of keys) {
        if (cur[k] == null || typeof cur[k] !== "object") cur[k] = isFinite(+k) ? [] : {};
        cur = cur[k];
      }
      cur[last] = value;
    };
    const stack = Alpine2.closestDataStack(el) || [];
    const childData = stack[0] || null;
    const parentData = stack[1] || null;
    if (!childData || !parentData) {
      if (import.meta?.env?.DEV) {
        console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
      }
      return;
    }
    const pairs = expression.split(",").map((s2) => s2.trim()).filter(Boolean).map((s2) => {
      const m2 = s2.split("->").map((x) => x.trim());
      if (m2.length !== 2) {
        console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', s2);
        return null;
      }
      return { parentPath: m2[0], childPath: m2[1] };
    }).filter(Boolean);
    const initChildWins = modifiers.includes("init-child") || modifiers.includes("child") || modifiers.includes("childWins");
    const guard = pairs.map(() => ({
      fromParent: false,
      fromChild: false,
      skipChildOnce: initChildWins
      // avoid redundant first child->parent write
    }));
    const stops = [];
    pairs.forEach((pair, idx) => {
      const g = guard[idx];
      if (initChildWins) {
        const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
        g.fromChild = true;
        setAtPath(parentData, pair.parentPath, childVal);
        queueMicrotask(() => {
          g.fromChild = false;
        });
      } else {
        const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
        g.fromParent = true;
        setAtPath(childData, pair.childPath, parentVal);
        queueMicrotask(() => {
          g.fromParent = false;
        });
      }
      const stop1 = effect3(() => {
        const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
        if (g.fromChild) return;
        g.fromParent = true;
        setAtPath(childData, pair.childPath, parentVal);
        queueMicrotask(() => {
          g.fromParent = false;
        });
      });
      const stop2 = effect3(() => {
        const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
        if (g.fromParent) return;
        if (g.skipChildOnce) {
          g.skipChildOnce = false;
          return;
        }
        g.fromChild = true;
        setAtPath(parentData, pair.parentPath, childVal);
        queueMicrotask(() => {
          g.fromChild = false;
        });
      });
      stops.push(stop1, stop2);
    });
    cleanup2(() => {
      for (const stop2 of stops) {
        try {
          stop2 && stop2();
        } catch {
        }
      }
    });
  };
  Alpine2.directive("syncprop", handler4);
}
class ThemeController {
  constructor() {
    this.storageKey = "darkMode";
    this.eventName = "rz:theme-change";
    this.darkClass = "dark";
    this._mode = "auto";
    this._mq = null;
    this._initialized = false;
    this._onMqChange = null;
    this._onStorage = null;
    this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  init() {
    if (this._initialized) return;
    if (typeof window === "undefined") return;
    this._initialized = true;
    this._mq = typeof window.matchMedia === "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
    const raw2 = this._safeReadStorage(this.storageKey);
    this._mode = this._normalizeMode(raw2 ?? "auto");
    this._sync();
    this._onMqChange = () => {
      this._sync();
    };
    if (this._mq) {
      if (typeof this._mq.addEventListener === "function") {
        this._mq.addEventListener("change", this._onMqChange);
      } else if (typeof this._mq.addListener === "function") {
        this._mq.addListener(this._onMqChange);
      }
    }
    this._onStorage = (e2) => {
      if (e2.key !== this.storageKey) return;
      const next = this._normalizeMode(e2.newValue ?? "auto");
      if (next !== this._mode) {
        this._mode = next;
        this._sync();
      }
    };
    window.addEventListener("storage", this._onStorage);
  }
  destroy() {
    if (!this._initialized) return;
    this._initialized = false;
    if (this._mq && this._onMqChange) {
      if (typeof this._mq.removeEventListener === "function") {
        this._mq.removeEventListener("change", this._onMqChange);
      } else if (typeof this._mq.removeListener === "function") {
        this._mq.removeListener(this._onMqChange);
      }
    }
    if (typeof window !== "undefined" && this._onStorage) {
      window.removeEventListener("storage", this._onStorage);
    }
    this._onMqChange = null;
    this._onStorage = null;
    this._mq = null;
    this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  // ----- Public State Accessors -----
  get mode() {
    return this._mode;
  }
  get prefersDark() {
    return !!this._mq?.matches;
  }
  get effectiveDark() {
    return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
  }
  // ----- Public API Surface -----
  isDark() {
    return this.effectiveDark;
  }
  isLight() {
    return !this.effectiveDark;
  }
  setLight() {
    this._setMode("light");
  }
  setDark() {
    this._setMode("dark");
  }
  setAuto() {
    this._setMode("auto");
  }
  toggle() {
    const currentlyDark = this.effectiveDark;
    this._setMode(currentlyDark ? "light" : "dark");
  }
  // ----- Internals -----
  _setMode(value) {
    this._mode = this._normalizeMode(value);
    this._persist();
    this._sync();
  }
  _normalizeMode(value) {
    return value === "light" || value === "dark" || value === "auto" ? value : "auto";
  }
  _safeReadStorage(key) {
    try {
      return window?.localStorage?.getItem(key);
    } catch (e2) {
      return null;
    }
  }
  _persist() {
    try {
      window?.localStorage?.setItem(this.storageKey, this._mode);
    } catch (e2) {
    }
  }
  _sync() {
    const effectiveDark = this.effectiveDark;
    const mode = this._mode;
    const prefersDark = this.prefersDark;
    const root = typeof document !== "undefined" ? document.documentElement : null;
    const domMatchesState = root ? root.classList.contains(this.darkClass) === effectiveDark && root.style.colorScheme === (effectiveDark ? "dark" : "light") : true;
    if (this._lastSnapshot.mode === mode && this._lastSnapshot.effectiveDark === effectiveDark && this._lastSnapshot.prefersDark === prefersDark && domMatchesState) {
      return;
    }
    this._lastSnapshot = { mode, effectiveDark, prefersDark };
    if (root) {
      root.classList.toggle(this.darkClass, effectiveDark);
      root.style.colorScheme = effectiveDark ? "dark" : "light";
    }
    if (typeof window !== "undefined") {
      window.dispatchEvent(
        new CustomEvent(this.eventName, {
          detail: {
            mode,
            darkMode: effectiveDark,
            // External API uses 'darkMode' convention
            prefersDark,
            source: "RizzyUI"
          }
        })
      );
    }
  }
}
const themeController = new ThemeController();
function registerStores(Alpine2) {
  themeController.init();
  Alpine2.store("theme", {
    // Reactive state mirrors
    // We mirror ALL derived properties to ensure Alpine reactivity works 
    // for bindings like x-show="prefersDark" or x-text="mode".
    _mode: themeController.mode,
    _prefersDark: themeController.prefersDark,
    _effectiveDark: themeController.effectiveDark,
    // Listener reference to prevent duplicate registration
    _onThemeChange: null,
    init() {
      if (!this._onThemeChange) {
        this._onThemeChange = () => this._refresh();
        window.addEventListener(themeController.eventName, this._onThemeChange);
      }
      this._refresh();
    },
    _refresh() {
      this._mode = themeController.mode;
      this._prefersDark = themeController.prefersDark;
      this._effectiveDark = themeController.effectiveDark;
    },
    // ----- Reactive Getters -----
    // These return the reactive properties from the store, ensuring Alpine
    // properly tracks dependencies.
    get mode() {
      return this._mode;
    },
    get effectiveDark() {
      return this._effectiveDark;
    },
    get prefersDark() {
      return this._prefersDark;
    },
    // Expose as getters (not methods) for consistency
    get isDark() {
      return this._effectiveDark;
    },
    get isLight() {
      return !this._effectiveDark;
    },
    // ----- Proxy Methods -----
    setLight() {
      themeController.setLight();
    },
    setDark() {
      themeController.setDark();
    },
    setAuto() {
      themeController.setAuto();
    },
    toggle() {
      themeController.toggle();
    }
  });
}
let cachedRizzyUI = null;
function bootstrapRizzyUI(Alpine2) {
  if (cachedRizzyUI) return cachedRizzyUI;
  Alpine2.plugin(module_default$2);
  Alpine2.plugin(module_default$1);
  Alpine2.plugin(module_default);
  Alpine2.plugin(async_alpine_default);
  if (typeof document !== "undefined") {
    document.addEventListener("alpine:init", () => {
      registerStores(Alpine2);
    });
  }
  registerComponents(Alpine2);
  registerMobileDirective(Alpine2);
  registerSyncDirective(Alpine2);
  cachedRizzyUI = {
    Alpine: Alpine2,
    require: rizzyRequire,
    toast: Toast,
    $data,
    props,
    registerAsyncComponent,
    theme: themeController
  };
  if (typeof window !== "undefined") {
    themeController.init();
    window.Alpine = Alpine2;
    window.Rizzy = { ...window.Rizzy || {}, ...cachedRizzyUI };
    document.dispatchEvent(new CustomEvent("rz:init", {
      detail: { Rizzy: window.Rizzy }
    }));
  }
  return cachedRizzyUI;
}
const RizzyUI = bootstrapRizzyUI(module_default$3);
module_default$3.start();
export {
  RizzyUI as default
};
//# sourceMappingURL=rizzyui.es.js.map
</file>

<file path="wwwroot/js/rizzyui.js">
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.RizzyUI = factory());
})(this, function() {
  "use strict";
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1 && index > lastFlushedIndex)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i2 = 0; i2 < queue.length; i2++) {
      queue[i2]();
      lastFlushedIndex = i2;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i2) => i2());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i2) => i2());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    el._x_effects?.forEach(dequeueJob);
    while (el._x_cleanups?.length)
      el._x_cleanups.pop()();
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mutations.length; i2++) {
      if (mutations[i2].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i2].type === "childList") {
        mutations[i2].removedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (!node._x_marker)
            return;
          removedNodes.add(node);
        });
        mutations[i2].addedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (removedNodes.has(node)) {
            removedNodes.delete(node);
            return;
          }
          if (node._x_marker)
            return;
          addedNodes.push(node);
        });
      }
      if (mutations[i2].type === "attributes") {
        let el = mutations[i2].target;
        let name = mutations[i2].attributeName;
        let oldValue = mutations[i2].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i2) => i2(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.some((i2) => i2.contains(node)))
        continue;
      onElRemoveds.forEach((i2) => i2(node));
    }
    for (let node of addedNodes) {
      if (!node.isConnected)
        continue;
      onElAddeds.forEach((i2) => i2(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i2) => Object.keys(i2)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Reflect.has(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return descriptor.set.call(thisProxy, value) || true;
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        if (typeof value === "object" && value !== null && value.__v_skip)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    let memoizedUtilities = getUtilities(el);
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, memoizedUtilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function getUtilities(el) {
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    let utils = { interceptor, ...utilities };
    onElRemoved(el, cleanup2);
    return utils;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e2) {
      handleError(e2, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate$1(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [], context } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func.call(context, func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i2) => receiver(i2));
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directiveExists(name) {
    return Object.keys(directiveHandlers).includes(name);
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate$1.bind(evaluate$1, el)
    };
    let doCleanup = () => cleanups.forEach((i2) => i2());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i2) => i2;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i2) => i2.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a2, b) {
    let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
    setTimeout(() => {
      warnAboutMissingPlugins();
    });
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors2 = [];
  function interceptInit(callback) {
    initInterceptors2.push(callback);
  }
  var markerDispenser = 1;
  function initTree(el, walker = walk, intercept = () => {
  }) {
    if (findClosest(el, (i2) => i2._x_ignore))
      return;
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        if (el2._x_marker)
          return;
        intercept(el2, skip);
        initInterceptors2.forEach((i2) => i2(el2, skip));
        directives(el2, el2.attributes).forEach((handle) => handle());
        if (!el2._x_ignore)
          el2._x_marker = markerDispenser++;
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root, walker = walk) {
    walker(root, (el) => {
      cleanupElement(el);
      cleanupAttributes(el);
      delete el._x_marker;
    });
  }
  function warnAboutMissingPlugins() {
    let pluginDirectives = [
      ["ui", "dialog", ["[x-dialog], [x-popover]"]],
      ["anchor", "anchor", ["[x-anchor]"]],
      ["sort", "sort", ["[x-sort]"]]
    ];
    pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
      if (directiveExists(directive2))
        return;
      selectors.some((selector) => {
        if (document.querySelector(selector)) {
          warn(`found "${selector}", but missing ${plugin2} plugin`);
          return true;
        }
      });
    });
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i2) => {
      if (el.classList.contains(i2)) {
        el.classList.remove(i2);
        removed.push(i2);
      }
    });
    forAdd.forEach((i2) => {
      if (!el.classList.contains(i2)) {
        el.classList.add(i2);
        added.push(i2);
      }
    });
    return () => {
      removed.forEach((i2) => el.classList.add(i2));
      added.forEach((i2) => el.classList.remove(i2));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
    let delay2 = modifierValue$1(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue$1(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i2]) => i2?.());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e2) => {
            if (!e2.isFromCancelledTransition)
              throw e2;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay2 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay2);
        reachedEnd = true;
      });
    });
  }
  function modifierValue$1(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function onlyDuringClone(callback) {
    return (...args) => isCloning && callback(...args);
  }
  var interceptors = [];
  function interceptClone(callback) {
    interceptors.push(callback);
  }
  function cloneNode(from, to) {
    interceptors.forEach((i2) => i2(from, to));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to, (el, callback) => {
        callback(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (isRadio$1(el)) {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (isCheckbox(el)) {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  var booleanAttributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected",
    "shadowrootclonable",
    "shadowrootdelegatesfocus",
    "shadowrootserializable"
  ]);
  function isBooleanAttr(attrName) {
    return booleanAttributes.has(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate$1(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function isCheckbox(el) {
    return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
  }
  function isRadio$1(el) {
    return el.type === "radio" || el.localName === "ui-radio";
  }
  function debounce(func, wait) {
    let timeout;
    return function() {
      const context = this, args = arguments;
      const later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else ;
      }
      outerHash = JSON.stringify(outerGet());
      JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }
  function plugin(callback) {
    let callbacks = Array.isArray(callback) ? callback : [callback];
    callbacks.forEach((i2) => i2(alpine_default));
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    initInterceptors(stores[name]);
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine$1 = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.15.0",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate: evaluate$1,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine$1;
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i2 = 0; i2 < list.length; i2++) {
      map[list[i2]] = true;
    }
    return (val) => !!map[val];
  }
  var EMPTY_OBJ = Object.freeze({});
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol("iterate");
  var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i2 = 0; i2 < deps.length; i2++) {
        deps[i2].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys$1(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys: ownKeys$1
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v2) => Reflect.getPrototypeOf(v2);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = isMap(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r2) {
    return Boolean(r2 && r2.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i2) => value = i2);
      return value;
    };
    let unwatch = watch(getter, callback);
    cleanup2(unwatch);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    findClosest(el, (i2) => {
      if (i2._x_refs)
        refObjects.push(i2._x_refs);
    });
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id}-${key}` : `${name}-${id}`;
    });
  });
  interceptClone((from, to) => {
    if (from._x_id) {
      to._x_id = from._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i2) => result = i2);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone2.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e2) => {
          e2.stopPropagation();
          el.dispatchEvent(new e2.constructor(e2.type, e2));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    let placeInDom = (clone3, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone3, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone3, target2.nextSibling);
      } else {
        target2.appendChild(clone3);
      }
    };
    mutateDom(() => {
      placeInDom(clone2, target, modifiers);
      skipDuringClone(() => {
        initTree(clone2);
      })();
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(
      () => mutateDom(() => {
        clone2.remove();
        destroyTree(clone2);
      })
    );
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
    effect3(evaluateLater(el, expression));
  }));
  function on(el, event2, modifiers, callback) {
    let listenerTarget = el;
    let handler4 = (e2) => callback(e2);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
    if (modifiers.includes("dot"))
      event2 = dotSyntax(event2);
    if (modifiers.includes("camel"))
      event2 = camelCase2(event2);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.preventDefault();
        next(e2);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.stopPropagation();
        next(e2);
      });
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        next(e2);
        listenerTarget.removeEventListener(event2, handler4, options);
      });
    }
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (el.contains(e2.target))
          return;
        if (e2.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e2);
      });
    }
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.target === el && next(e2);
      });
    if (isKeyEvent(event2) || isClickEvent(event2)) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
          return;
        }
        next(e2);
      });
    }
    listenerTarget.addEventListener(event2, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event2, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event2) {
    return ["keydown", "keyup"].includes(event2);
  }
  function isClickEvent(event2) {
    return ["contextmenu", "click", "mouse"].some((i2) => event2.includes(i2));
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
    let keyModifiers = modifiers.filter((i2) => {
      return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(i2);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e2[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (isClickEvent(e2.type))
          return false;
        if (keyToModifiers(e2.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "comma": ",",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    let event2 = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener = isCloning ? () => {
    } : on(el, event2, modifiers, (e2) => {
      setValue(getInputValue(el, modifiers, e2, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
        setValue(
          getInputValue(el, modifiers, { target: el }, getValue())
        );
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e2) => {
        nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect3(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event2, currentValue) {
    return mutateDom(() => {
      if (event2 instanceof CustomEvent && event2.detail !== void 0)
        return event2.detail !== null && event2.detail !== void 0 ? event2.detail : event2.target.value;
      else if (isCheckbox(el)) {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event2.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event2.target.value);
          } else {
            newValue = event2.target.value;
          }
          return event2.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event2.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event2.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event2.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event2.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let newValue;
        if (isRadio$1(el)) {
          if (event2.target.checked) {
            newValue = event2.target.value;
          } else {
            newValue = currentValue;
          }
        } else {
          newValue = event2.target.value;
        }
        if (modifiers.includes("number")) {
          return safeParseNumber(newValue);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(newValue);
        } else if (modifiers.includes("trim")) {
          return newValue.trim();
        } else {
          return newValue;
        }
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
    cleanup2(() => {
      el._x_undoAddedClasses && el._x_undoAddedClasses();
      el._x_undoAddedStyles && el._x_undoAddedStyles();
    });
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate$1(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate$1(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate$1(el, reactiveData["destroy"]);
      undo();
    });
  });
  interceptClone((from, to) => {
    if (from._x_dataStack) {
      to._x_dataStack = from._x_dataStack;
      to.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => mutateDom(
        () => {
          destroyTree(el2);
          el2.remove();
        }
      ));
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i2) => i2 + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => {
            if (keys.includes(value2))
              warn("Duplicate key on x-for", el);
            keys.push(value2);
          }, { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i2 = 0; i2 < items.length; i2++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
          evaluateKey((value) => {
            if (keys.includes(value))
              warn("Duplicate key on x-for", el);
            keys.push(value);
          }, { scope: { index: i2, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i2 = 0; i2 < prevKeys.length; i2++) {
        let key = prevKeys[i2];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i2 = 0; i2 < keys.length; i2++) {
        let key = keys[i2];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i2, 0, key);
          adds.push([lastKey, i2]);
        } else if (prevIndex !== i2) {
          let keyInSpot = prevKeys.splice(i2, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i2, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i2 = 0; i2 < removes.length; i2++) {
        let key = removes[i2];
        if (!(key in lookup))
          continue;
        mutateDom(() => {
          destroyTree(lookup[key]);
          lookup[key].remove();
        });
        delete lookup[key];
      }
      for (let i2 = 0; i2 < moves.length; i2++) {
        let [keyInSpot, keyForSpot] = moves[i2];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i2 = 0; i2 < adds.length; i2++) {
        let [lastKey2, index] = adds[i2];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone2, reactiveScope, templateEl);
        clone2._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone2);
          skipDuringClone(() => initTree(clone2))();
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i2 = 0; i2 < sames.length; i2++) {
        lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
      names.forEach((name, i2) => {
        scopeVariables[name] = item[i2];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        mutateDom(() => {
          destroyTree(clone2);
          clone2.remove();
        });
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from, to) => {
    if (from._x_ids) {
      to._x_ids = from._x_ids;
    }
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e2) => {
      evaluate2(() => {
      }, { scope: { "$event": e2 }, params: [e2] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default$3 = alpine_default;
  var module_default$3 = src_default$3;
  function src_default$2(Alpine2) {
    Alpine2.directive("collapse", collapse);
    collapse.inline = (el, { modifiers }) => {
      if (!modifiers.includes("min"))
        return;
      el._x_doShow = () => {
      };
      el._x_doHide = () => {
      };
    };
    function collapse(el, { modifiers }) {
      let duration = modifierValue(modifiers, "duration", 250) / 1e3;
      let floor = modifierValue(modifiers, "min", 0);
      let fullyHide = !modifiers.includes("min");
      if (!el._x_isShown)
        el.style.height = `${floor}px`;
      if (!el._x_isShown && fullyHide)
        el.hidden = true;
      if (!el._x_isShown)
        el.style.overflow = "hidden";
      let setFunction = (el2, styles) => {
        let revertFunction = Alpine2.setStyles(el2, styles);
        return styles.height ? () => {
        } : revertFunction;
      };
      let transitionStyles = {
        transitionProperty: "height",
        transitionDuration: `${duration}s`,
        transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
      };
      el._x_transition = {
        in(before = () => {
        }, after = () => {
        }) {
          if (fullyHide)
            el.hidden = false;
          if (fullyHide)
            el.style.display = null;
          let current = el.getBoundingClientRect().height;
          el.style.height = "auto";
          let full = el.getBoundingClientRect().height;
          if (current === full) {
            current = floor;
          }
          Alpine2.transition(el, Alpine2.setStyles, {
            during: transitionStyles,
            start: { height: current + "px" },
            end: { height: full + "px" }
          }, () => el._x_isShown = true, () => {
            if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
              el.style.overflow = null;
            }
          });
        },
        out(before = () => {
        }, after = () => {
        }) {
          let full = el.getBoundingClientRect().height;
          Alpine2.transition(el, setFunction, {
            during: transitionStyles,
            start: { height: full + "px" },
            end: { height: floor + "px" }
          }, () => el.style.overflow = "hidden", () => {
            el._x_isShown = false;
            if (el.style.height == `${floor}px` && fullyHide) {
              el.style.display = "none";
              el.hidden = true;
            }
          });
        }
      };
    }
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "min") {
      let match = rawValue.match(/([0-9]+)px/);
      if (match)
        return match[1];
    }
    return rawValue;
  }
  var module_default$2 = src_default$2;
  function src_default$1(Alpine2) {
    Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluate2 = evaluateLater2(expression);
      let options = {
        rootMargin: getRootMargin(modifiers),
        threshold: getThreshold(modifiers)
      };
      let observer2 = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting === (value === "leave"))
            return;
          evaluate2();
          modifiers.includes("once") && observer2.disconnect();
        });
      }, options);
      observer2.observe(el);
      cleanup2(() => {
        observer2.disconnect();
      });
    }));
  }
  function getThreshold(modifiers) {
    if (modifiers.includes("full"))
      return 0.99;
    if (modifiers.includes("half"))
      return 0.5;
    if (!modifiers.includes("threshold"))
      return 0;
    let threshold = modifiers[modifiers.indexOf("threshold") + 1];
    if (threshold === "100")
      return 1;
    if (threshold === "0")
      return 0;
    return Number(`.${threshold}`);
  }
  function getLengthValue(rawValue) {
    let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
    return match ? match[1] + (match[2] || "px") : void 0;
  }
  function getRootMargin(modifiers) {
    const key = "margin";
    const fallback = "0px 0px 0px 0px";
    const index = modifiers.indexOf(key);
    if (index === -1)
      return fallback;
    let values = [];
    for (let i2 = 1; i2 < 5; i2++) {
      values.push(getLengthValue(modifiers[index + i2] || ""));
    }
    values = values.filter((v2) => v2 !== void 0);
    return values.length ? values.join(" ").trim() : fallback;
  }
  var module_default$1 = src_default$1;
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
    return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r2;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === "full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (nodeIsAttached) {
        return !node.getClientRects().length;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = /* @__PURE__ */ function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e2) {
    return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e2) {
    return e2.key === "Tab" || e2.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i2) {
      if (fn(value)) {
        idx = i2;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event2) {
    return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2, config.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e2) {
      var target = getActualTarget(e2);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e2.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e2) {
      var target = getActualTarget(e2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e2.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e2.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e2.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e2) {
      if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
        e2.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e2)) {
        checkTab(e2);
        return;
      }
    };
    var checkClick = function checkClick2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };
  function src_default(Alpine2) {
    let lastFocused;
    let currentFocused;
    window.addEventListener("focusin", () => {
      lastFocused = currentFocused;
      currentFocused = document.activeElement;
    });
    Alpine2.magic("focus", (el) => {
      let within = el;
      return {
        __noscroll: false,
        __wrapAround: false,
        within(el2) {
          within = el2;
          return this;
        },
        withoutScrolling() {
          this.__noscroll = true;
          return this;
        },
        noscroll() {
          this.__noscroll = true;
          return this;
        },
        withWrapAround() {
          this.__wrapAround = true;
          return this;
        },
        wrap() {
          return this.withWrapAround();
        },
        focusable(el2) {
          return isFocusable(el2);
        },
        previouslyFocused() {
          return lastFocused;
        },
        lastFocused() {
          return lastFocused;
        },
        focused() {
          return currentFocused;
        },
        focusables() {
          if (Array.isArray(within))
            return within;
          return focusable(within, { displayCheck: "none" });
        },
        all() {
          return this.focusables();
        },
        isFirst(el2) {
          let els = this.all();
          return els[0] && els[0].isSameNode(el2);
        },
        isLast(el2) {
          let els = this.all();
          return els.length && els.slice(-1)[0].isSameNode(el2);
        },
        getFirst() {
          return this.all()[0];
        },
        getLast() {
          return this.all().slice(-1)[0];
        },
        getNext() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
            return list[0];
          }
          return list[list.indexOf(current) + 1];
        },
        getPrevious() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === 0) {
            return list.slice(-1)[0];
          }
          return list[list.indexOf(current) - 1];
        },
        first() {
          this.focus(this.getFirst());
        },
        last() {
          this.focus(this.getLast());
        },
        next() {
          this.focus(this.getNext());
        },
        previous() {
          this.focus(this.getPrevious());
        },
        prev() {
          return this.previous();
        },
        focus(el2) {
          if (!el2)
            return;
          setTimeout(() => {
            if (!el2.hasAttribute("tabindex"))
              el2.setAttribute("tabindex", "0");
            el2.focus({ preventScroll: this.__noscroll });
          });
        }
      };
    });
    Alpine2.directive("trap", Alpine2.skipDuringClone(
      (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
        let evaluator = evaluateLater2(expression);
        let oldValue = false;
        let options = {
          escapeDeactivates: false,
          allowOutsideClick: true,
          fallbackFocus: () => el
        };
        let undoInert = () => {
        };
        if (modifiers.includes("noautofocus")) {
          options.initialFocus = false;
        } else {
          let autofocusEl = el.querySelector("[autofocus]");
          if (autofocusEl)
            options.initialFocus = autofocusEl;
        }
        if (modifiers.includes("inert")) {
          options.onPostActivate = () => {
            Alpine2.nextTick(() => {
              undoInert = setInert(el);
            });
          };
        }
        let trap = createFocusTrap(el, options);
        let undoDisableScrolling = () => {
        };
        const releaseFocus = () => {
          undoInert();
          undoInert = () => {
          };
          undoDisableScrolling();
          undoDisableScrolling = () => {
          };
          trap.deactivate({
            returnFocus: !modifiers.includes("noreturn")
          });
        };
        effect3(() => evaluator((value) => {
          if (oldValue === value)
            return;
          if (value && !oldValue) {
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            setTimeout(() => {
              trap.activate();
            }, 15);
          }
          if (!value && oldValue) {
            releaseFocus();
          }
          oldValue = !!value;
        }));
        cleanup2(releaseFocus);
      },
      // When cloning, we only want to add aria-hidden attributes to the
      // DOM and not try to actually trap, as trapping can mess with the
      // live DOM and isn't just isolated to the cloned DOM.
      (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
        if (modifiers.includes("inert") && evaluate2(expression))
          setInert(el);
      }
    ));
  }
  function setInert(el) {
    let undos = [];
    crawlSiblingsUp(el, (sibling) => {
      let cache = sibling.hasAttribute("aria-hidden");
      sibling.setAttribute("aria-hidden", "true");
      undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
    });
    return () => {
      while (undos.length)
        undos.pop()();
    };
  }
  function crawlSiblingsUp(el, callback) {
    if (el.isSameNode(document.body) || !el.parentNode)
      return;
    Array.from(el.parentNode.children).forEach((sibling) => {
      if (sibling.isSameNode(el)) {
        crawlSiblingsUp(el.parentNode, callback);
      } else {
        callback(sibling);
      }
    });
  }
  function disableScrolling() {
    let overflow = document.documentElement.style.overflow;
    let paddingRight = document.documentElement.style.paddingRight;
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden";
    document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
    return () => {
      document.documentElement.style.overflow = overflow;
      document.documentElement.style.paddingRight = paddingRight;
    };
  }
  var module_default = src_default;
  /*! Bundled license information:
    tabbable/dist/index.esm.js:
      (*!
      * tabbable 5.3.3
      * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
      *)
    focus-trap/dist/focus-trap.esm.js:
      (*!
      * focus-trap 6.9.4
      * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
      *)
    */
  function eager() {
    return true;
  }
  function event({ component, argument }) {
    return new Promise((resolve) => {
      if (argument) {
        window.addEventListener(
          argument,
          () => resolve(),
          { once: true }
        );
      } else {
        const cb = (e2) => {
          if (e2.detail.id !== component.id) return;
          window.removeEventListener("async-alpine:load", cb);
          resolve();
        };
        window.addEventListener("async-alpine:load", cb);
      }
    });
  }
  function idle() {
    return new Promise((resolve) => {
      if ("requestIdleCallback" in window) {
        window.requestIdleCallback(resolve);
      } else {
        setTimeout(resolve, 200);
      }
    });
  }
  function media({ argument }) {
    return new Promise((resolve) => {
      if (!argument) {
        console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'");
        return resolve();
      }
      const mediaQuery = window.matchMedia(`(${argument})`);
      if (mediaQuery.matches) {
        resolve();
      } else {
        mediaQuery.addEventListener("change", resolve, { once: true });
      }
    });
  }
  function visible({ component, argument }) {
    return new Promise((resolve) => {
      const rootMargin = argument || "0px 0px 0px 0px";
      const observer2 = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          observer2.disconnect();
          resolve();
        }
      }, { rootMargin });
      observer2.observe(component.el);
    });
  }
  var strategies_default = {
    eager,
    event,
    idle,
    media,
    visible
  };
  async function awaitRequirements(component) {
    const requirements = parseRequirements(component.strategy);
    await generateRequirements(component, requirements);
  }
  async function generateRequirements(component, requirements) {
    if (requirements.type === "expression") {
      if (requirements.operator === "&&") {
        return Promise.all(
          requirements.parameters.map((param) => generateRequirements(component, param))
        );
      }
      if (requirements.operator === "||") {
        return Promise.any(
          requirements.parameters.map((param) => generateRequirements(component, param))
        );
      }
    }
    if (!strategies_default[requirements.method]) return false;
    return strategies_default[requirements.method]({
      component,
      argument: requirements.argument
    });
  }
  function parseRequirements(expression) {
    const tokens = tokenize(expression);
    let ast = parseExpression(tokens);
    if (ast.type === "method") {
      return {
        type: "expression",
        operator: "&&",
        parameters: [ast]
      };
    }
    return ast;
  }
  function tokenize(expression) {
    const regex = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g;
    const tokens = [];
    let match;
    while ((match = regex.exec(expression)) !== null) {
      const [_, parenthesis, operator, token] = match;
      if (parenthesis !== void 0) {
        tokens.push({ type: "parenthesis", value: parenthesis });
      } else if (operator !== void 0) {
        tokens.push({
          type: "operator",
          // we do the below to make operators backwards-compatible with previous
          // versions of Async Alpine, where '|' is equivalent to &&
          value: operator === "|" ? "&&" : operator
        });
      } else {
        const tokenObj = {
          type: "method",
          method: token.trim()
        };
        if (token.includes("(")) {
          tokenObj.method = token.substring(0, token.indexOf("(")).trim();
          tokenObj.argument = token.substring(
            token.indexOf("(") + 1,
            token.indexOf(")")
          );
        }
        if (token.method === "immediate") {
          token.method = "eager";
        }
        tokens.push(tokenObj);
      }
    }
    return tokens;
  }
  function parseExpression(tokens) {
    let ast = parseTerm(tokens);
    while (tokens.length > 0 && (tokens[0].value === "&&" || tokens[0].value === "|" || tokens[0].value === "||")) {
      const operator = tokens.shift().value;
      const right = parseTerm(tokens);
      if (ast.type === "expression" && ast.operator === operator) {
        ast.parameters.push(right);
      } else {
        ast = {
          type: "expression",
          operator,
          parameters: [ast, right]
        };
      }
    }
    return ast;
  }
  function parseTerm(tokens) {
    if (tokens[0].value === "(") {
      tokens.shift();
      const ast = parseExpression(tokens);
      if (tokens[0].value === ")") {
        tokens.shift();
      }
      return ast;
    } else {
      return tokens.shift();
    }
  }
  function async_alpine_default(Alpine2) {
    const directive2 = "load";
    const srcAttr = Alpine2.prefixed("load-src");
    const ignoreAttr = Alpine2.prefixed("ignore");
    let options = {
      defaultStrategy: "eager",
      keepRelativeURLs: false
    };
    let alias = false;
    let data2 = {};
    let realIndex = 0;
    function index() {
      return realIndex++;
    }
    Alpine2.asyncOptions = (opts) => {
      options = {
        ...options,
        ...opts
      };
    };
    Alpine2.asyncData = (name, download2 = false) => {
      data2[name] = {
        loaded: false,
        download: download2
      };
    };
    Alpine2.asyncUrl = (name, url) => {
      if (!name || !url || data2[name]) return;
      data2[name] = {
        loaded: false,
        download: () => import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          parseUrl(url)
        )
      };
    };
    Alpine2.asyncAlias = (path) => {
      alias = path;
    };
    const syncHandler = (el) => {
      Alpine2.skipDuringClone(() => {
        if (el._x_async) return;
        el._x_async = "init";
        el._x_ignore = true;
        el.setAttribute(ignoreAttr, "");
      })();
    };
    const handler4 = async (el) => {
      Alpine2.skipDuringClone(async () => {
        if (el._x_async !== "init") return;
        el._x_async = "await";
        const { name, strategy } = elementPrep(el);
        await awaitRequirements({
          name,
          strategy,
          el,
          id: el.id || index()
        });
        if (!el.isConnected) return;
        await download(name);
        if (!el.isConnected) return;
        activate(el);
        el._x_async = "loaded";
      })();
    };
    handler4.inline = syncHandler;
    Alpine2.directive(directive2, handler4).before("ignore");
    function elementPrep(el) {
      const name = parseName(el.getAttribute(Alpine2.prefixed("data")));
      const strategy = el.getAttribute(Alpine2.prefixed(directive2)) || options.defaultStrategy;
      const urlAttributeValue = el.getAttribute(srcAttr);
      if (urlAttributeValue) {
        Alpine2.asyncUrl(name, urlAttributeValue);
      }
      return {
        name,
        strategy
      };
    }
    async function download(name) {
      if (name.startsWith("_x_async_")) return;
      handleAlias(name);
      if (!data2[name] || data2[name].loaded) return;
      const module2 = await getModule(name);
      Alpine2.data(name, module2);
      data2[name].loaded = true;
    }
    async function getModule(name) {
      if (!data2[name]) return;
      const module2 = await data2[name].download(name);
      if (typeof module2 === "function") return module2;
      let whichExport = module2[name] || module2.default || Object.values(module2)[0] || false;
      return whichExport;
    }
    function activate(el) {
      Alpine2.destroyTree(el);
      el._x_ignore = false;
      el.removeAttribute(ignoreAttr);
      if (el.closest(`[${ignoreAttr}]`)) return;
      Alpine2.initTree(el);
    }
    function handleAlias(name) {
      if (!alias || data2[name]) return;
      if (typeof alias === "function") {
        Alpine2.asyncData(name, alias);
        return;
      }
      Alpine2.asyncUrl(name, alias.replaceAll("[name]", name));
    }
    function parseName(attribute) {
      const parsedName = (attribute || "").trim().split(/[({]/g)[0];
      const ourName = parsedName || `_x_async_${index()}`;
      return ourName;
    }
    function parseUrl(url) {
      if (options.keepRelativeURLs) return url;
      const absoluteReg = new RegExp("^(?:[a-z+]+:)?//", "i");
      if (!absoluteReg.test(url)) {
        return new URL(url, document.baseURI).href;
      }
      return url;
    }
  }
  function t(t2, e2) {
    if (!(t2 instanceof e2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function e(t2, e2) {
    for (var s2 = 0; s2 < e2.length; s2++) {
      var i2 = e2[s2];
      i2.enumerable = i2.enumerable || false;
      i2.configurable = true;
      if ("value" in i2) i2.writable = true;
      Object.defineProperty(t2, i2.key, i2);
    }
  }
  function s(t2, s2, i2) {
    if (s2) e(t2.prototype, s2);
    return t2;
  }
  var i = Object.defineProperty;
  var n = function(t2, e2) {
    return i(t2, "name", { value: e2, configurable: true });
  };
  var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
  var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
  var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var h = n(function(t2) {
    return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
  }, "stringToHTML"), d = n(function(t2) {
    var e2 = new DOMParser().parseFromString(t2, "application/xml");
    return document.importNode(e2.documentElement, true).outerHTML;
  }, "getSvgNode");
  var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
  var N = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
    }, 100);
  }, "fadeIn"), O = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "fadeOut"), T = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
    }, 100);
  }, "slideIn"), E = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "slideOut");
  var m = function() {
    function e2(s2) {
      var i2 = this;
      t(this, e2);
      this.notifyOut = n(function(t2) {
        t2(i2);
      }, "notifyOut");
      var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
      if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
        console.error("You must specify 'title' or 'text' at least.");
        return;
      }
      this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
    }
    s(e2, [{ key: "checkRequirements", value: function t2() {
      return !!(this.title || this.text);
    } }, { key: "setContainer", value: function t2() {
      var t3 = document.querySelector(".".concat(u.CONTAINER));
      t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
    } }, { key: "setPosition", value: function t2() {
      this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
    } }, { key: "setCloseButton", value: function t2() {
      var t3 = this;
      var e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
        t3.close();
      });
    } }, { key: "setWrapper", value: function t2() {
      var t3 = this;
      switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
        case p.OUTLINE:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
          break;
        case p.FILLED:
          this.wrapper.classList.add(u.NOTIFY_FILLED);
          break;
        default:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
      }
      switch (this.status) {
        case f.SUCCESS:
          this.wrapper.classList.add(u.NOTIFY_SUCCESS);
          break;
        case f.ERROR:
          this.wrapper.classList.add(u.NOTIFY_ERROR);
          break;
        case f.WARNING:
          this.wrapper.classList.add(u.NOTIFY_WARNING);
          break;
        case f.INFO:
          this.wrapper.classList.add(u.NOTIFY_INFO);
          break;
      }
      this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
        t3.wrapper.classList.add(e3);
      });
    } }, { key: "setContent", value: function t2() {
      var t3 = document.createElement("div");
      t3.classList.add(u.NOTIFY_CONTENT);
      var e3, s2;
      this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
    } }, { key: "setIcon", value: function t2() {
      var t3 = n(function(t4) {
        switch (t4) {
          case f.SUCCESS:
            return v.SUCCESS;
          case f.ERROR:
            return v.ERROR;
          case f.WARNING:
            return v.WARNING;
          case f.INFO:
            return v.INFO;
        }
      }, "computedIcon"), e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
    } }, { key: "setObserver", value: function t2() {
      var t3 = this;
      var e3 = new IntersectionObserver(function(e4) {
        if (e4[0].intersectionRatio <= 0) t3.close();
        else return;
      }, { threshold: 0 });
      setTimeout(function() {
        e3.observe(t3.wrapper);
      }, this.speed);
    } }, { key: "notifyIn", value: function t2(t2) {
      t2(this);
    } }, { key: "autoClose", value: function t2() {
      var t3 = this;
      setTimeout(function() {
        t3.close();
      }, this.autotimeout + this.speed);
    } }, { key: "close", value: function t2() {
      this.notifyOut(this.selectedNotifyOutEffect);
    } }, { key: "setEffect", value: function t2() {
      switch (this.effect) {
        case I.FADE:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
          break;
        case I.SLIDE:
          this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
          break;
        default:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
      }
    } }]);
    return e2;
  }();
  n(m, "Notify");
  var w = m;
  globalThis.Notify = w;
  const allowedStatuses = ["success", "error", "warning", "info"];
  const allowedPositions = [
    // Standard Corners
    "right top",
    "top right",
    "right bottom",
    "bottom right",
    "left top",
    "top left",
    "left bottom",
    "bottom left",
    // Centered Horizontally
    "center top",
    "x-center top",
    "center bottom",
    "x-center bottom",
    // Centered Vertically
    "left center",
    "left y-center",
    "y-center left",
    "right center",
    "right y-center",
    "y-center right",
    // Aliases for Centered Horizontally (already covered but good for robustness)
    "top center",
    "top x-center",
    "bottom center",
    "bottom x-center",
    // Absolute Center
    "center"
  ];
  const defaultConfig = {
    status: "info",
    title: "Notification",
    text: "",
    effect: "fade",
    speed: 300,
    autoclose: true,
    autotimeout: 4e3,
    position: "right top"
  };
  function renderToast(options = {}) {
    const config = {
      ...defaultConfig,
      ...options
    };
    if (!allowedStatuses.includes(config.status)) {
      console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
      config.status = "info";
    }
    if (!allowedPositions.includes(config.position)) {
      console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
      config.position = "right top";
    }
    new w(config);
  }
  const Toast = {
    custom: renderToast,
    success(text, title = "Success", options = {}) {
      renderToast({
        status: "success",
        title,
        text,
        ...options
      });
    },
    error(text, title = "Error", options = {}) {
      renderToast({
        status: "error",
        title,
        text,
        ...options
      });
    },
    warning(text, title = "Warning", options = {}) {
      renderToast({
        status: "warning",
        title,
        text,
        ...options
      });
    },
    info(text, title = "Info", options = {}) {
      renderToast({
        status: "info",
        title,
        text,
        ...options
      });
    },
    setDefaults(newDefaults = {}) {
      Object.assign(defaultConfig, newDefaults);
    },
    get allowedStatuses() {
      return [...allowedStatuses];
    },
    get allowedPositions() {
      return [...allowedPositions];
    }
  };
  const devnull = function() {
  }, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
  function subscribe(bundleIds, callbackFn) {
    bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
    const depsNotFound = [];
    let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
    fn = function(bundleId2, pathsNotFound) {
      if (pathsNotFound.length) depsNotFound.push(bundleId2);
      numWaiting--;
      if (!numWaiting) callbackFn(depsNotFound);
    };
    while (i2--) {
      bundleId = bundleIds[i2];
      r2 = bundleResultCache[bundleId];
      if (r2) {
        fn(bundleId, r2);
        continue;
      }
      q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
      q.push(fn);
    }
  }
  function publish(bundleId, pathsNotFound) {
    if (!bundleId) return;
    const q = bundleCallbackQueue[bundleId];
    bundleResultCache[bundleId] = pathsNotFound;
    if (!q) return;
    while (q.length) {
      q[0](bundleId, pathsNotFound);
      q.splice(0, 1);
    }
  }
  function executeCallbacks(args, depsNotFound) {
    if (typeof args === "function") args = { success: args };
    if (depsNotFound.length) (args.error || devnull)(depsNotFound);
    else (args.success || devnull)(args);
  }
  function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
    let result = ev.type[0];
    if (isLegacyIECss) {
      try {
        if (!e2.sheet.cssText.length) result = "e";
      } catch (x) {
        if (x.code !== 18) result = "e";
      }
    }
    if (result === "e") {
      numTries += 1;
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e2.rel === "preload" && e2.as === "style") {
      e2.rel = "stylesheet";
      return;
    }
    callbackFn(path, result, ev.defaultPrevented);
  }
  function loadFile(path, callbackFn, args, numTries) {
    const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
    let isLegacyIECss, hasModuleSupport, e2;
    numTries = numTries || 0;
    if (/(^css!|\.css$)/.test(pathname)) {
      e2 = doc.createElement("link");
      e2.rel = "stylesheet";
      e2.href = pathStripped;
      isLegacyIECss = "hideFocus" in e2;
      if (isLegacyIECss && e2.relList) {
        isLegacyIECss = 0;
        e2.rel = "preload";
        e2.as = "style";
      }
      if (args.inlineStyleNonce) {
        e2.setAttribute("nonce", args.inlineStyleNonce);
      }
    } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
      e2 = doc.createElement("img");
      e2.src = pathStripped;
    } else {
      e2 = doc.createElement("script");
      e2.src = pathStripped;
      e2.async = async === void 0 ? true : async;
      if (args.inlineScriptNonce) {
        e2.setAttribute("nonce", args.inlineScriptNonce);
      }
      hasModuleSupport = "noModule" in e2;
      if (/^module!/.test(pathname)) {
        if (!hasModuleSupport) return callbackFn(path, "l");
        e2.type = "module";
      } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
        return callbackFn(path, "l");
      }
    }
    const onEvent = function(ev) {
      handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
    };
    e2.addEventListener("load", onEvent, { once: true });
    e2.addEventListener("error", onEvent, { once: true });
    if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
  }
  function loadFiles(paths, callbackFn, args) {
    paths = Array.isArray(paths) ? paths : [paths];
    let numWaiting = paths.length, pathsNotFound = [];
    function fn(path, result, defaultPrevented) {
      if (result === "e") pathsNotFound.push(path);
      if (result === "b") {
        if (defaultPrevented) pathsNotFound.push(path);
        else return;
      }
      numWaiting--;
      if (!numWaiting) callbackFn(pathsNotFound);
    }
    for (let i2 = 0; i2 < paths.length; i2++) {
      loadFile(paths[i2], fn, args);
    }
  }
  function loadjs(paths, arg1, arg2) {
    let bundleId, args;
    if (arg1 && typeof arg1 === "string" && arg1.trim) {
      bundleId = arg1.trim();
    }
    args = (bundleId ? arg2 : arg1) || {};
    if (bundleId) {
      if (bundleId in bundleIdCache) {
        throw "LoadJS";
      } else {
        bundleIdCache[bundleId] = true;
      }
    }
    function loadFn(resolve, reject) {
      loadFiles(paths, function(pathsNotFound) {
        executeCallbacks(args, pathsNotFound);
        if (resolve) {
          executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
        }
        publish(bundleId, pathsNotFound);
      }, args);
    }
    if (args.returnPromise) {
      return new Promise(loadFn);
    } else {
      loadFn();
    }
  }
  loadjs.ready = function ready(deps, args) {
    subscribe(deps, function(depsNotFound) {
      executeCallbacks(args, depsNotFound);
    });
    return loadjs;
  };
  loadjs.done = function done(bundleId) {
    publish(bundleId, []);
  };
  loadjs.reset = function reset() {
    Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
    Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
    Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
  };
  loadjs.isDefined = function isDefined(bundleId) {
    return bundleId in bundleIdCache;
  };
  function $data(idOrElement) {
    if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
      console.error(
        "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
      );
      return void 0;
    }
    if (idOrElement instanceof Element) {
      const target = resolveProxy(idOrElement) || idOrElement;
      let alpineData = Alpine.$data(target);
      if (alpineData === void 0) {
        const nearest = target.closest?.("[x-data]");
        if (nearest) {
          alpineData = Alpine.$data(nearest);
        }
      }
      if (alpineData === void 0) {
        warnDataUndefined("element", target);
      }
      return alpineData;
    }
    if (typeof idOrElement === "string") {
      const componentId = idOrElement.trim();
      if (!componentId) {
        console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
        return void 0;
      }
      const selector = `[data-alpine-root="${cssEscapeSafe(componentId)}"]`;
      let root = null;
      const wrapper = document.getElementById(componentId);
      if (wrapper) {
        root = wrapper.matches(selector) ? wrapper : wrapper.querySelector(selector);
      }
      if (!root) {
        root = findAlpineRootById(componentId);
      }
      if (!root) {
        console.warn(
          `Rizzy.$data: Could not locate an Alpine root using ${selector} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${componentId}"' is present.`
        );
        return void 0;
      }
      const alpineData = Alpine.$data(root);
      if (alpineData === void 0) {
        warnDataUndefined(`data-alpine-root="${componentId}"`, root);
      }
      return alpineData;
    }
    console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
    return void 0;
  }
  function resolveProxy(el) {
    if (!(el instanceof Element)) return null;
    const isProxyTag = el.tagName?.toLowerCase?.() === "rz-proxy";
    const proxyFor = el.getAttribute?.("data-for");
    if (isProxyTag || proxyFor) {
      const id = proxyFor || "";
      if (!id) return el;
      const root = findAlpineRootById(id);
      if (!root) {
        console.warn(
          `Rizzy.$data: Proxy element could not resolve Alpine root for id "${id}". Ensure the teleported root rendered with data-alpine-root="${id}".`
        );
        return null;
      }
      return root;
    }
    return el;
  }
  function findAlpineRootById(id) {
    const sel = `[data-alpine-root="${cssEscapeSafe(id)}"]`;
    const candidates = document.querySelectorAll(sel);
    for (const n2 of candidates) {
      if (n2.hasAttribute("x-data")) return n2;
    }
    if (candidates.length > 0) return candidates[0];
    return document.getElementById(id) || null;
  }
  function cssEscapeSafe(s2) {
    try {
      if (window.CSS && typeof window.CSS.escape === "function") {
        return window.CSS.escape(s2);
      }
    } catch (_) {
    }
    return String(s2).replace(/"/g, '\\"');
  }
  function warnDataUndefined(origin, target) {
    const desc = `${target.tagName?.toLowerCase?.() || "node"}${target.id ? "#" + target.id : ""}${target.classList?.length ? "." + Array.from(target.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located target via ${origin} (${desc}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
    );
  }
  function registerRzAccordion(Alpine2) {
    Alpine2.data("rzAccordion", () => ({
      selected: "",
      // ID of the currently selected/opened section (if not allowMultiple)
      allowMultiple: false,
      // Whether multiple sections can be open
      init() {
        this.allowMultiple = this.$el.dataset.multiple === "true";
      },
      destroy() {
      }
    }));
  }
  function registerAccordionItem(Alpine2) {
    Alpine2.data("accordionItem", () => ({
      open: false,
      sectionId: "",
      expandedClass: "",
      init() {
        this.open = this.$el.dataset.isOpen === "true";
        this.sectionId = this.$el.dataset.sectionId;
        this.expandedClass = this.$el.dataset.expandedClass;
        const self2 = this;
        if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
          this.$watch("selected", (value, oldValue) => {
            if (value !== self2.sectionId && !self2.allowMultiple) {
              self2.open = false;
            }
          });
        } else {
          console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
        }
      },
      destroy() {
      },
      // Toggle the section's open state and update the parent's 'selected' state.
      toggle() {
        this.selected = this.sectionId;
        this.open = !this.open;
      },
      // Get the CSS classes for the expanded/collapsed chevron icon.
      getExpandedCss() {
        return this.open ? this.expandedClass : "";
      },
      // Get the value for aria-expanded attribute based on the 'open' state.
      getAriaExpanded() {
        return this.open ? "true" : "false";
      }
    }));
  }
  function registerRzAlert(Alpine2) {
    Alpine2.data("rzAlert", () => {
      return {
        parentElement: null,
        showAlert: true,
        init() {
          const alpineRoot = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
          this.parentElement = document.getElementById(alpineRoot);
        },
        dismiss() {
          this.showAlert = false;
          const self2 = this;
          setTimeout(() => {
            self2.parentElement.style.display = "none";
          }, 205);
        }
      };
    });
  }
  function registerRzAspectRatio(Alpine2) {
    Alpine2.data("rzAspectRatio", () => ({
      init() {
        const ratio = parseFloat(this.$el.dataset.ratio);
        if (!isNaN(ratio) && ratio > 0) {
          const paddingBottom = 100 / ratio + "%";
          this.$el.style.paddingBottom = paddingBottom;
        } else {
          this.$el.style.paddingBottom = "100%";
        }
      }
    }));
  }
  function registerRzBrowser(Alpine2) {
    Alpine2.data("rzBrowser", () => {
      return {
        screenSize: "",
        setDesktopScreenSize() {
          this.screenSize = "";
        },
        setTabletScreenSize() {
          this.screenSize = "max-w-2xl";
        },
        setPhoneScreenSize() {
          this.screenSize = "max-w-sm";
        },
        // Get CSS classes for browser border based on screen size
        getBrowserBorderCss() {
          return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
        },
        // Get CSS classes for desktop screen button styling
        getDesktopScreenCss() {
          return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for tablet screen button styling
        getTabletScreenCss() {
          return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for phone screen button styling
        getPhoneScreenCss() {
          return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        }
      };
    });
  }
  function registerRzCalendar(Alpine2, require) {
    Alpine2.data("rzCalendar", () => ({
      calendar: null,
      initialized: false,
      init() {
        const assets = JSON.parse(this.$el.dataset.assets || "[]");
        const configId = this.$el.dataset.configId;
        const nonce = this.$el.dataset.nonce;
        if (assets.length === 0) {
          console.warn("RzCalendar: No assets configured.");
          return;
        }
        require(assets, {
          success: () => {
            this.initCalendar(configId);
          },
          error: (e2) => console.error("RzCalendar: Failed to load assets", e2)
        }, nonce);
      },
      initCalendar(configId) {
        const configElement = document.getElementById(configId);
        if (!configElement) {
          console.error(`RzCalendar: Config element #${configId} not found.`);
          return;
        }
        let rawConfig = {};
        try {
          rawConfig = JSON.parse(configElement.textContent);
        } catch (e2) {
          console.error("RzCalendar: Failed to parse config JSON", e2);
          return;
        }
        const actionHandlers = {
          clickDay: (e2, self2) => this.dispatchCalendarEvent("clickDay", { event: e2, dates: self2.selectedDates }),
          clickWeekNumber: (e2, number, days, year) => this.dispatchCalendarEvent("clickWeekNumber", { event: e2, number, days, year }),
          clickMonth: (e2, month) => this.dispatchCalendarEvent("clickMonth", { event: e2, month }),
          clickYear: (e2, year) => this.dispatchCalendarEvent("clickYear", { event: e2, year }),
          clickArrow: (e2, year, month) => this.dispatchCalendarEvent("clickArrow", { event: e2, year, month }),
          changeTime: (e2, time, hours, minutes, keeping) => this.dispatchCalendarEvent("changeTime", { event: e2, time, hours, minutes, keeping }),
          changeView: (view) => this.dispatchCalendarEvent("changeView", { view }),
          getDays: (day, date, HTMLElement2, HTMLButtonElement, self2) => {
          }
        };
        const options = {
          ...rawConfig.options,
          styles: rawConfig.styles,
          // Correct property name for VCP
          actions: actionHandlers
        };
        if (window.VanillaCalendarPro) {
          this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, options);
          this.calendar.init();
          this.initialized = true;
          this.dispatchCalendarEvent("init", { instance: this.calendar });
        } else {
          console.error("RzCalendar: VanillaCalendar global not found.");
        }
      },
      dispatchCalendarEvent(eventName, detail) {
        this.$dispatch(`rz:calendar:${eventName}`, detail);
      },
      destroy() {
        if (this.calendar) {
          this.calendar.destroy();
          this.dispatchCalendarEvent("destroy", {});
        }
      }
    }));
  }
  function registerRzCarousel(Alpine2, require) {
    function parseJsonFromScriptId(id) {
      if (!id) return {};
      const el = document.getElementById(id);
      if (!el) {
        console.warn(`[rzCarousel] JSON script element #${id} not found.`);
        return {};
      }
      try {
        return JSON.parse(el.textContent || "{}");
      } catch (e2) {
        console.error(`[rzCarousel] Failed to parse JSON from #${id}:`, e2);
        return {};
      }
    }
    Alpine2.data("rzCarousel", () => ({
      emblaApi: null,
      canScrollPrev: false,
      canScrollNext: false,
      selectedIndex: 0,
      scrollSnaps: [],
      init() {
        const assetsToLoad = (() => {
          try {
            return JSON.parse(this.$el.dataset.assets || "[]");
          } catch (e2) {
            console.error("[rzCarousel] Bad assets JSON:", e2);
            return [];
          }
        })();
        const nonce = this.$el.dataset.nonce || "";
        const config = parseJsonFromScriptId(this.$el.dataset.config);
        const options = config.Options || {};
        const pluginsConfig = config.Plugins || [];
        const self2 = this;
        if (assetsToLoad.length > 0 && typeof require === "function") {
          require(
            assetsToLoad,
            {
              success() {
                if (window.EmblaCarousel) {
                  self2.initializeEmbla(options, pluginsConfig);
                } else {
                  console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
                }
              },
              error(err) {
                console.error("[rzCarousel] Failed to load EmblaCarousel assets.", err);
              }
            },
            nonce
          );
        } else {
          if (window.EmblaCarousel) {
            this.initializeEmbla(options, pluginsConfig);
          } else {
            console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
          }
        }
      },
      initializeEmbla(options, pluginsConfig) {
        const viewport = this.$el.querySelector('[x-ref="viewport"]');
        if (!viewport) {
          console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
          return;
        }
        const instantiatedPlugins = this.instantiatePlugins(pluginsConfig);
        this.emblaApi = window.EmblaCarousel(viewport, options, instantiatedPlugins);
        this.emblaApi.on("select", this.onSelect.bind(this));
        this.emblaApi.on("reInit", this.onSelect.bind(this));
        this.onSelect();
      },
      instantiatePlugins(pluginsConfig) {
        if (!Array.isArray(pluginsConfig) || pluginsConfig.length === 0) {
          return [];
        }
        return pluginsConfig.map((pluginInfo) => {
          const constructor = window[pluginInfo.Name];
          if (typeof constructor !== "function") {
            console.error(`[rzCarousel] Plugin constructor '${pluginInfo.Name}' not found on window object.`);
            return null;
          }
          try {
            return constructor(pluginInfo.Options || {});
          } catch (e2) {
            console.error(`[rzCarousel] Error instantiating plugin '${pluginInfo.Name}':`, e2);
            return null;
          }
        }).filter(Boolean);
      },
      destroy() {
        if (this.emblaApi) this.emblaApi.destroy();
      },
      onSelect() {
        if (!this.emblaApi) return;
        this.selectedIndex = this.emblaApi.selectedScrollSnap();
        this.canScrollPrev = this.emblaApi.canScrollPrev();
        this.canScrollNext = this.emblaApi.canScrollNext();
        this.scrollSnaps = this.emblaApi.scrollSnapList();
      },
      cannotScrollPrev() {
        return !this.canScrollPrev;
      },
      cannotScrollNext() {
        return !this.canScrollNext;
      },
      scrollPrev() {
        this.emblaApi?.scrollPrev();
      },
      scrollNext() {
        this.emblaApi?.scrollNext();
      },
      scrollTo(index) {
        this.emblaApi?.scrollTo(index);
      }
    }));
  }
  function registerRzCodeViewer(Alpine2, require) {
    Alpine2.data("rzCodeViewer", () => {
      return {
        expand: false,
        border: true,
        copied: false,
        copyTitle: "Copy",
        // Default title
        copiedTitle: "Copied!",
        // Default title
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const codeId = this.$el.dataset.codeid;
          const nonce = this.$el.dataset.nonce;
          this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
          this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
          require(assets, {
            success: function() {
              const codeBlock = document.getElementById(codeId);
              if (window.hljs && codeBlock) {
                window.hljs.highlightElement(codeBlock);
              }
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        },
        // Function to check if code is NOT copied (for x-show)
        notCopied() {
          return !this.copied;
        },
        // Function to reset the copied state (e.g., on blur)
        disableCopied() {
          this.copied = false;
        },
        // Function to toggle the expand state
        toggleExpand() {
          this.expand = !this.expand;
        },
        // Function to copy code to clipboard
        copyHTML() {
          navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
          this.copied = !this.copied;
        },
        // Get the title for the copy button (copy/copied)
        getCopiedTitle() {
          return this.copied ? this.copiedTitle : this.copyTitle;
        },
        // Get CSS classes for the copy button based on copied state
        getCopiedCss() {
          return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
        },
        // Get CSS classes for the code container based on expand state
        getExpandCss() {
          return [this.expand ? "" : "max-h-60"];
        },
        // Get CSS classes for the expand button icon based on expand state
        getExpandButtonCss() {
          return this.expand ? "rotate-180" : "rotate-0";
        }
      };
    });
  }
  function registerRzCollapsible(Alpine2) {
    Alpine2.data("rzCollapsible", () => ({
      isOpen: false,
      init() {
        this.isOpen = this.$el.dataset.defaultOpen === "true";
      },
      toggle() {
        this.isOpen = !this.isOpen;
      },
      state() {
        return this.isOpen ? "open" : "closed";
      }
    }));
  }
  function registerRzCombobox(Alpine2, require) {
    Alpine2.data("rzCombobox", () => ({
      tomSelect: null,
      init() {
        const assets = JSON.parse(this.$el.dataset.assets || "[]");
        const nonce = this.$el.dataset.nonce;
        if (assets.length > 0 && typeof require === "function") {
          require(assets, {
            success: () => this.initTomSelect(),
            error: (err) => console.error("RzCombobox: Failed to load assets.", err)
          }, nonce);
        } else if (window.TomSelect) {
          this.initTomSelect();
        }
      },
      initTomSelect() {
        const selectEl = this.$refs.selectInput;
        if (!selectEl) return;
        const configEl = document.getElementById(this.$el.dataset.configId);
        const config = configEl ? JSON.parse(configEl.textContent) : {};
        const render = {};
        const createAlpineRow = (templateRef, data2) => {
          if (!templateRef) return null;
          const div = document.createElement("div");
          let parsedItem = data2.item;
          if (typeof parsedItem === "string") {
            try {
              parsedItem = JSON.parse(parsedItem);
            } catch (e2) {
            }
          }
          const scope2 = {
            ...data2,
            item: parsedItem
          };
          if (Alpine2 && typeof Alpine2.addScopeToNode === "function") {
            Alpine2.addScopeToNode(div, scope2);
          } else {
            div._x_dataStack = [scope2];
          }
          div.innerHTML = templateRef.innerHTML;
          return div;
        };
        if (this.$refs.optionTemplate) {
          render.option = (data2, escape) => createAlpineRow(this.$refs.optionTemplate, data2);
        }
        if (this.$refs.itemTemplate) {
          render.item = (data2, escape) => createAlpineRow(this.$refs.itemTemplate, data2);
        }
        config.dataAttr = "data-item";
        this.tomSelect = new TomSelect(selectEl, {
          ...config,
          render,
          onInitialize: function() {
            this.sync();
          }
        });
      },
      destroy() {
        if (this.tomSelect) {
          this.tomSelect.destroy();
          this.tomSelect = null;
        }
      }
    }));
  }
  function registerRzDateEdit(Alpine2, require) {
    Alpine2.data("rzDateEdit", () => ({
      options: {},
      placeholder: "",
      prependText: "",
      init() {
        const cfgString = this.$el.dataset.config;
        const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
        if (cfgString) {
          const parsed = JSON.parse(cfgString);
          if (parsed) {
            this.options = parsed.options || {};
            this.placeholder = parsed.placeholder || "";
            this.prependText = parsed.prependText || "";
          }
        }
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require(assets, {
          success: function() {
            if (window.flatpickr && inputElem) {
              window.flatpickr(inputElem, this.options);
            }
          },
          error: function() {
            console.error("Failed to load Flatpickr assets.");
          }
        }, nonce);
      }
    }));
  }
  function registerRzDialog(Alpine2) {
    Alpine2.data("rzDialog", () => ({
      modalOpen: false,
      // Main state variable
      eventTriggerName: "",
      closeEventName: "rz:modal-close",
      // Default value, corresponds to Constants.Events.ModalClose
      closeOnEscape: true,
      closeOnClickOutside: true,
      modalId: "",
      bodyId: "",
      footerId: "",
      nonce: "",
      _escapeListener: null,
      _openListener: null,
      _closeEventListener: null,
      init() {
        this.modalId = this.$el.dataset.modalId || "";
        this.bodyId = this.$el.dataset.bodyId || "";
        this.footerId = this.$el.dataset.footerId || "";
        this.nonce = this.$el.dataset.nonce || "";
        this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
        this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
        this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
        this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
        this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
          detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
          bubbles: true
        }));
        if (this.eventTriggerName) {
          this._openListener = (e2) => {
            this.openModal(e2);
          };
          window.addEventListener(this.eventTriggerName, this._openListener);
        }
        this._closeEventListener = (event2) => {
          if (this.modalOpen) {
            this.closeModalInternally("event");
          }
        };
        window.addEventListener(this.closeEventName, this._closeEventListener);
        this._escapeListener = (e2) => {
          if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
            this.closeModalInternally("escape");
          }
        };
        window.addEventListener("keydown", this._escapeListener);
        this.$watch("modalOpen", (value) => {
          const currentWidth = document.body.offsetWidth;
          document.body.classList.toggle("overflow-hidden", value);
          const scrollBarWidth = document.body.offsetWidth - currentWidth;
          document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
          if (value) {
            this.$nextTick(() => {
              const dialogElement = this.$el.querySelector('[role="document"]');
              const focusable2 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
              focusable2?.focus();
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          } else {
            this.$nextTick(() => {
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          }
        });
      },
      notModalOpen() {
        return !this.modalOpen;
      },
      destroy() {
        if (this._openListener && this.eventTriggerName) {
          window.removeEventListener(this.eventTriggerName, this._openListener);
        }
        if (this._closeEventListener) {
          window.removeEventListener(this.closeEventName, this._closeEventListener);
        }
        if (this._escapeListener) {
          window.removeEventListener("keydown", this._escapeListener);
        }
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      },
      openModal(event2 = null) {
        const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
          detail: { modalId: this.modalId, originalEvent: event2 },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeOpenEvent);
        if (!beforeOpenEvent.defaultPrevented) {
          this.modalOpen = true;
        }
      },
      // Internal close function called by button, escape, backdrop, event
      closeModalInternally(reason = "unknown") {
        const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
          detail: { modalId: this.modalId, reason },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeCloseEvent);
        if (!beforeCloseEvent.defaultPrevented) {
          document.activeElement?.blur && document.activeElement.blur();
          this.modalOpen = false;
          document.body.classList.remove("overflow-hidden");
          document.body.style.setProperty("--page-scrollbar-width", `0px`);
        }
      },
      // Called only by the explicit close button in the template
      closeModal() {
        this.closeModalInternally("button");
      },
      // Method called by x-on:click.outside on the dialog element
      handleClickOutside() {
        if (this.closeOnClickOutside) {
          this.closeModalInternally("backdrop");
        }
      }
    }));
  }
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start2, value, end) {
    return max(start2, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data: data2,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data2
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const flip$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            var _overflowsData$;
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
            if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b) => a2.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d2.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b) => a2[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x,
          y,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element.matches(selector);
      } catch (e2) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    let width = parseFloat(css.width) || 0;
    let height = parseFloat(css.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x = (clientRect.left + visualOffsets.x) / scale.x;
    let y = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x,
      y
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      width,
      height,
      x,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, []).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$1(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data2) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data2.floating);
    return {
      reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$1(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  const offset = offset$1;
  const shift = shift$1;
  const flip = flip$1;
  const computePosition = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  function registerRzDropdownMenu(Alpine2) {
    Alpine2.data("rzDropdownMenu", () => ({
      // --- STATE ---
      open: false,
      isModal: true,
      ariaExpanded: "false",
      trapActive: false,
      focusedIndex: null,
      menuItems: [],
      parentEl: null,
      triggerEl: null,
      contentEl: null,
      // Will be populated when menu opens
      anchor: "bottom",
      pixelOffset: 3,
      isSubmenuActive: false,
      navThrottle: 100,
      _lastNavAt: 0,
      selfId: null,
      // --- INIT ---
      init() {
        if (!this.$el.id) this.$el.id = crypto.randomUUID();
        this.selfId = this.$el.id;
        this.parentEl = this.$el;
        this.triggerEl = this.$refs.trigger;
        this.anchor = this.$el.dataset.anchor || "bottom";
        this.pixelOffset = parseInt(this.$el.dataset.offset) || 6;
        this.isModal = this.$el.dataset.modal !== "false";
        this.$watch("open", (value) => {
          if (value) {
            this._lastNavAt = 0;
            this.$nextTick(() => {
              this.contentEl = document.getElementById(`${this.selfId}-content`);
              if (!this.contentEl) return;
              this.updatePosition();
              this.menuItems = Array.from(
                this.contentEl.querySelectorAll(
                  '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
                )
              );
            });
            this.ariaExpanded = "true";
            this.triggerEl.dataset.state = "open";
            this.trapActive = this.isModal;
          } else {
            this.focusedIndex = null;
            this.closeAllSubmenus();
            this.ariaExpanded = "false";
            delete this.triggerEl.dataset.state;
            this.trapActive = false;
            this.contentEl = null;
          }
        });
      },
      // --- METHODS ---
      updatePosition() {
        if (!this.triggerEl || !this.contentEl) return;
        this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`);
        computePosition(this.triggerEl, this.contentEl, {
          placement: this.anchor,
          middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(this.contentEl.style, { left: `${x}px`, top: `${y}px` });
        });
      },
      toggle() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        } else {
          this.open = true;
          this.focusedIndex = -1;
        }
      },
      handleOutsideClick() {
        if (!this.open) return;
        this.open = false;
        let self2 = this;
        this.$nextTick(() => self2.triggerEl?.focus());
      },
      handleTriggerKeydown(event2) {
        if (["Enter", " ", "ArrowDown", "ArrowUp"].includes(event2.key)) {
          event2.preventDefault();
          this.open = true;
          this.$nextTick(() => {
            if (event2.key === "ArrowUp") this.focusLastItem();
            else this.focusFirstItem();
          });
        }
      },
      focusNextItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
        this.focusCurrentItem();
      },
      focusPreviousItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
        this.focusCurrentItem();
      },
      focusFirstItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = 0;
        this.focusCurrentItem();
      },
      focusLastItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = this.menuItems.length - 1;
        this.focusCurrentItem();
      },
      focusCurrentItem() {
        if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
          this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
        }
      },
      focusSelectedItem(item) {
        if (!item || item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        const index = this.menuItems.indexOf(item);
        if (index !== -1) {
          this.focusedIndex = index;
          item.focus();
        }
      },
      handleItemClick(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.open = false;
        let self2 = this;
        this.$nextTick(() => self2.triggerEl?.focus());
      },
      handleItemMouseEnter(event2) {
        const item = event2.currentTarget;
        this.focusSelectedItem(item);
        if (item.getAttribute("aria-haspopup") !== "menu") {
          this.closeAllSubmenus();
        }
      },
      handleWindowEscape() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        }
      },
      handleContentTabKey() {
        if (this.open) {
          this.open = false;
          let self2 = this;
          this.$nextTick(() => self2.triggerEl?.focus());
        }
      },
      handleTriggerMouseover() {
        let self2 = this;
        this.$nextTick(() => self2.$el.firstElementChild?.focus());
      },
      closeAllSubmenus() {
        const submenus = this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        submenus.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
        this.isSubmenuActive = false;
      }
    }));
    Alpine2.data("rzDropdownSubmenu", () => ({
      // --- STATE ---
      open: false,
      ariaExpanded: "false",
      parentDropdown: null,
      triggerEl: null,
      contentEl: null,
      // Will be populated when submenu opens
      menuItems: [],
      focusedIndex: null,
      anchor: "right-start",
      pixelOffset: 0,
      navThrottle: 100,
      _lastNavAt: 0,
      selfId: null,
      siblingContainer: null,
      closeTimeout: null,
      closeDelay: 150,
      // --- INIT ---
      init() {
        if (!this.$el.id) this.$el.id = crypto.randomUUID();
        this.selfId = this.$el.id;
        const parentId = this.$el.dataset.parentId;
        if (parentId) {
          const parentEl = document.getElementById(parentId);
          if (parentEl) {
            this.parentDropdown = Alpine2.$data(parentEl);
          }
        }
        if (!this.parentDropdown) {
          console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
          return;
        }
        this.triggerEl = this.$refs.subTrigger;
        this.siblingContainer = this.$el.parentElement;
        this.anchor = this.$el.dataset.subAnchor || this.anchor;
        this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset;
        this.$watch("open", (value) => {
          if (value) {
            this._lastNavAt = 0;
            this.parentDropdown.isSubmenuActive = true;
            this.$nextTick(() => {
              this.contentEl = document.getElementById(`${this.selfId}-subcontent`);
              if (!this.contentEl) return;
              this.updatePosition(this.contentEl);
              this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])'));
            });
            this.ariaExpanded = "true";
            this.triggerEl.dataset.state = "open";
          } else {
            this.focusedIndex = null;
            this.ariaExpanded = "false";
            delete this.triggerEl.dataset.state;
            this.$nextTick(() => {
              const anySubmenuIsOpen = this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]');
              if (!anySubmenuIsOpen) this.parentDropdown.isSubmenuActive = false;
            });
            this.contentEl = null;
          }
        });
      },
      // --- METHODS ---
      updatePosition(contentEl) {
        if (!this.triggerEl || !contentEl) return;
        computePosition(this.triggerEl, contentEl, {
          placement: this.anchor,
          middleware: [offset(this.pixelOffset), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(contentEl.style, { left: `${x}px`, top: `${y}px` });
        });
      },
      handleTriggerMouseEnter() {
        clearTimeout(this.closeTimeout);
        this.triggerEl.focus();
        this.openSubmenu();
      },
      handleTriggerMouseLeave() {
        this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
      },
      handleContentMouseEnter() {
        clearTimeout(this.closeTimeout);
      },
      handleContentMouseLeave() {
        const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        if (childSubmenus) {
          const isAnyChildOpen = Array.from(childSubmenus).some((el) => Alpine2.$data(el)?.open);
          if (isAnyChildOpen) {
            return;
          }
        }
        this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
      },
      openSubmenu(focusFirst = false) {
        if (this.open) return;
        this.closeSiblingSubmenus();
        this.open = true;
        if (focusFirst) {
          this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem()));
        }
      },
      closeSubmenu() {
        const childSubmenus = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
        childSubmenus?.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
        this.open = false;
      },
      closeSiblingSubmenus() {
        if (!this.siblingContainer) return;
        const siblings = Array.from(this.siblingContainer.children).filter(
          (el) => el.hasAttribute("x-data") && el.getAttribute("x-data").startsWith("rzDropdownSubmenu") && el.id !== this.selfId
        );
        siblings.forEach((el) => {
          Alpine2.$data(el)?.closeSubmenu();
        });
      },
      toggleSubmenu() {
        this.open ? this.closeSubmenu() : this.openSubmenu();
      },
      openSubmenuAndFocusFirst() {
        this.openSubmenu(true);
      },
      handleTriggerKeydown(e2) {
        if (["ArrowRight", "Enter", " "].includes(e2.key)) {
          e2.preventDefault();
          this.openSubmenuAndFocusFirst();
        }
      },
      focusNextItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1;
        this.focusCurrentItem();
      },
      focusPreviousItem() {
        const now = Date.now();
        if (now - this._lastNavAt < this.navThrottle) return;
        this._lastNavAt = now;
        if (!this.menuItems.length) return;
        this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1;
        this.focusCurrentItem();
      },
      focusFirstItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = 0;
        this.focusCurrentItem();
      },
      focusLastItem() {
        if (!this.menuItems.length) return;
        this.focusedIndex = this.menuItems.length - 1;
        this.focusCurrentItem();
      },
      focusCurrentItem() {
        if (this.focusedIndex !== null && this.menuItems[this.focusedIndex]) {
          this.menuItems[this.focusedIndex].focus();
        }
      },
      handleItemClick(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.parentDropdown.open = false;
        this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
      },
      handleItemMouseEnter(event2) {
        const item = event2.currentTarget;
        if (item.getAttribute("aria-disabled") === "true" || item.hasAttribute("disabled")) return;
        const index = this.menuItems.indexOf(item);
        if (index !== -1) {
          this.focusedIndex = index;
          item.focus();
        }
        if (item.getAttribute("aria-haspopup") === "menu") {
          Alpine2.$data(item.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu();
        } else {
          this.closeSiblingSubmenus();
        }
      },
      handleSubmenuEscape() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      },
      handleSubmenuArrowLeft() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      }
    }));
  }
  function registerRzDarkModeToggle(Alpine2) {
    Alpine2.data("rzDarkModeToggle", () => ({
      // Proxy all properties to the reactive store
      get mode() {
        return this.$store.theme.mode;
      },
      get prefersDark() {
        return this.$store.theme.prefersDark;
      },
      get effectiveDark() {
        return this.$store.theme.effectiveDark;
      },
      // Proxy properties from the store (isDark/isLight are getters on the store)
      get isDark() {
        return this.$store.theme.isDark;
      },
      get isLight() {
        return this.$store.theme.isLight;
      },
      // Proxy methods
      setLight() {
        this.$store.theme.setLight();
      },
      setDark() {
        this.$store.theme.setDark();
      },
      setAuto() {
        this.$store.theme.setAuto();
      },
      toggle() {
        this.$store.theme.toggle();
      }
    }));
  }
  function registerRzEmbeddedPreview(Alpine2) {
    Alpine2.data("rzEmbeddedPreview", () => {
      return {
        iframe: null,
        onDarkModeToggle: null,
        init() {
          try {
            this.iframe = this.$refs.iframe;
            const resize = this.debounce(() => {
              this.resizeIframe(this.iframe);
            }, 50);
            this.resizeIframe(this.iframe);
            const resizeObserver = new ResizeObserver((entries) => {
              for (let entry of entries) {
                resize();
              }
            });
            resizeObserver.observe(this.iframe);
            const iframe = this.iframe;
            this.onDarkModeToggle = (event2) => {
              iframe.contentWindow.postMessage(event2.detail, "*");
            };
            window.addEventListener("darkModeToggle", this.onDarkModeToggle);
          } catch (error2) {
            console.error("Cannot access iframe content");
          }
        },
        // Adjusts the iframe height based on its content
        resizeIframe(iframe) {
          if (iframe) {
            try {
              const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDocument) {
                const iframeBody = iframeDocument.body;
                if (!iframeBody) {
                  setInterval(() => {
                    this.resizeIframe(iframe);
                  }, 150);
                } else {
                  const newHeight = iframeBody.scrollHeight + 15;
                  iframe.style.height = newHeight + "px";
                }
              }
            } catch (error2) {
              console.error("Error resizing iframe:", error2);
            }
          }
        },
        // Debounce helper to limit function calls
        debounce(func, timeout = 300) {
          let timer;
          return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
              func.apply(this, args);
            }, timeout);
          };
        },
        destroy() {
          window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
        }
      };
    });
  }
  function registerRzEmpty(Alpine2) {
    Alpine2.data("rzEmpty", () => {
    });
  }
  function registerRzHeading(Alpine2) {
    Alpine2.data("rzHeading", () => {
      return {
        observer: null,
        headingId: "",
        init() {
          this.headingId = this.$el.dataset.alpineRoot;
          const self2 = this;
          if (typeof this.setCurrentHeading === "function") {
            const callback = (entries, observer2) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  self2.setCurrentHeading(self2.headingId);
                }
              });
            };
            const options = { threshold: 0.5 };
            this.observer = new IntersectionObserver(callback, options);
            this.observer.observe(this.$el);
          } else {
            console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
          }
        },
        destroy() {
          if (this.observer != null)
            this.observer.disconnect();
        }
      };
    });
  }
  function registerRzIndicator(Alpine2) {
    Alpine2.data("rzIndicator", () => ({
      visible: false,
      init() {
        const colorValue = this.$el.dataset.color;
        if (colorValue) {
          this.$el.style.backgroundColor = colorValue;
        } else {
          this.$el.style.backgroundColor = "var(--color-success)";
        }
        if (this.$el.dataset.visible === "true") {
          this.visible = true;
        }
      },
      notVisible() {
        return !this.visible;
      },
      setVisible(value) {
        this.visible = value;
      }
    }));
  }
  function registerRzInputGroupAddon(Alpine2) {
    Alpine2.data("rzInputGroupAddon", () => ({
      handleClick(event2) {
        if (event2.target.closest("button")) {
          return;
        }
        const parent = this.$el.parentElement;
        if (parent) {
          const input = parent.querySelector("input, textarea");
          input?.focus();
        }
      }
    }));
  }
  function registerRzMarkdown(Alpine2, require) {
    Alpine2.data("rzMarkdown", () => {
      return {
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const nonce = this.$el.dataset.nonce;
          require(assets, {
            success: function() {
              window.hljs.highlightAll();
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        }
      };
    });
  }
  function registerRzNavigationMenu(Alpine2, $data2) {
    Alpine2.data("rzNavigationMenu", () => ({
      activeItemId: null,
      open: false,
      closeTimeout: null,
      prevIndex: null,
      list: null,
      isClosing: false,
      /* ---------- helpers ---------- */
      _triggerIndex(id) {
        if (!this.list) return -1;
        const triggers = Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]'));
        return triggers.findIndex((t2) => t2.getAttribute("x-ref") === `trigger_${id}`);
      },
      _contentEl(id) {
        return document.getElementById(`${id}-content`);
      },
      /* ---------- lifecycle ---------- */
      init() {
        const contentEls = this.$el.querySelectorAll("[data-popover]");
        contentEls.forEach((el) => {
          el.style.display = "none";
        });
        this.$nextTick(() => {
          this.list = this.$refs.list;
        });
      },
      /* ---------- event handlers (from events with no params) ---------- */
      toggleActive(e2) {
        const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
        this.activeItemId === id && this.open ? this.closeMenu() : this.openMenu(id);
      },
      handleTriggerEnter(e2) {
        const id = e2.currentTarget.getAttribute("x-ref").replace("trigger_", "");
        this.cancelClose();
        if (this.activeItemId !== id && !this.isClosing) {
          requestAnimationFrame(() => this.openMenu(id));
        }
      },
      handleItemEnter(e2) {
        const item = e2.currentTarget;
        if (!item) return;
        this.cancelClose();
        const trigger2 = item.querySelector('[x-ref^="trigger_"]');
        if (trigger2) {
          const id = trigger2.getAttribute("x-ref").replace("trigger_", "");
          if (this.activeItemId !== id && !this.isClosing) {
            requestAnimationFrame(() => this.openMenu(id));
          }
        } else {
          if (this.open && !this.isClosing) {
            this.closeMenu();
          }
        }
      },
      handleContentEnter() {
        this.cancelClose();
      },
      scheduleClose() {
        if (this.isClosing || this.closeTimeout) return;
        this.closeTimeout = setTimeout(() => this.closeMenu(), 150);
      },
      cancelClose() {
        if (this.closeTimeout) {
          clearTimeout(this.closeTimeout);
          this.closeTimeout = null;
        }
        this.isClosing = false;
      },
      /* ---------- open / close logic with direct DOM manipulation ---------- */
      openMenu(id) {
        this.cancelClose();
        this.isClosing = false;
        const newIdx = this._triggerIndex(id);
        const dir = newIdx > (this.prevIndex ?? newIdx) ? "end" : "start";
        const isFirstOpen = this.prevIndex === null;
        if (this.open && this.activeItemId && this.activeItemId !== id) {
          const oldTrig = this.$refs[`trigger_${this.activeItemId}`];
          if (oldTrig) delete oldTrig.dataset.state;
          const oldEl = this._contentEl(this.activeItemId);
          if (oldEl) {
            const outgoingDirection = dir === "end" ? "start" : "end";
            oldEl.setAttribute("data-motion", `to-${outgoingDirection}`);
            setTimeout(() => {
              oldEl.style.display = "none";
            }, 150);
          }
        }
        this.activeItemId = id;
        this.open = true;
        this.prevIndex = newIdx;
        const newTrig = this.$refs[`trigger_${id}`];
        const newContentEl = this._contentEl(id);
        if (!newTrig || !newContentEl) return;
        computePosition(newTrig, newContentEl, {
          placement: "bottom-start",
          middleware: [offset(6), flip(), shift({ padding: 8 })]
        }).then(({ x, y }) => {
          Object.assign(newContentEl.style, { left: `${x}px`, top: `${y}px` });
        });
        newContentEl.style.display = "block";
        if (isFirstOpen) {
          newContentEl.setAttribute("data-motion", "fade-in");
        } else {
          newContentEl.setAttribute("data-motion", `from-${dir}`);
        }
        this.$nextTick(() => {
          newTrig.setAttribute("aria-expanded", "true");
          newTrig.dataset.state = "open";
        });
      },
      closeMenu() {
        if (!this.open || this.isClosing) return;
        this.isClosing = true;
        this.cancelClose();
        const activeId = this.activeItemId;
        if (!activeId) {
          this.isClosing = false;
          return;
        }
        const trig = this.$refs[`trigger_${activeId}`];
        if (trig) {
          trig.setAttribute("aria-expanded", "false");
          delete trig.dataset.state;
        }
        const contentEl = this._contentEl(activeId);
        if (contentEl) {
          contentEl.setAttribute("data-motion", "fade-out");
          setTimeout(() => {
            contentEl.style.display = "none";
          }, 150);
        }
        this.open = false;
        this.activeItemId = null;
        this.prevIndex = null;
        setTimeout(() => {
          this.isClosing = false;
        }, 150);
      }
    }));
  }
  function registerRzPopover(Alpine2) {
    Alpine2.data("rzPopover", () => ({
      open: false,
      ariaExpanded: "false",
      triggerEl: null,
      contentEl: null,
      init() {
        this.triggerEl = this.$refs.trigger;
        this.contentEl = this.$refs.content;
        this.$watch("open", (value) => {
          this.ariaExpanded = value.toString();
          if (value) {
            this.$nextTick(() => this.updatePosition());
          }
        });
      },
      updatePosition() {
        if (!this.triggerEl || !this.contentEl) return;
        const anchor = this.$el.dataset.anchor || "bottom";
        const mainOffset = parseInt(this.$el.dataset.offset) || 0;
        const crossAxisOffset = parseInt(this.$el.dataset.crossAxisOffset) || 0;
        const alignmentAxisOffset = parseInt(this.$el.dataset.alignmentAxisOffset) || null;
        const strategy = this.$el.dataset.strategy || "absolute";
        const enableFlip = this.$el.dataset.enableFlip !== "false";
        const enableShift = this.$el.dataset.enableShift !== "false";
        const shiftPadding = parseInt(this.$el.dataset.shiftPadding) || 8;
        let middleware = [];
        middleware.push(offset({
          mainAxis: mainOffset,
          crossAxis: crossAxisOffset,
          alignmentAxis: alignmentAxisOffset
        }));
        if (enableFlip) {
          middleware.push(flip());
        }
        if (enableShift) {
          middleware.push(shift({ padding: shiftPadding }));
        }
        computePosition(this.triggerEl, this.contentEl, {
          placement: anchor,
          strategy,
          middleware
        }).then(({ x, y }) => {
          Object.assign(this.contentEl.style, {
            left: `${x}px`,
            top: `${y}px`
          });
        });
      },
      toggle() {
        this.open = !this.open;
      },
      handleOutsideClick() {
        if (!this.open) return;
        this.open = false;
      },
      handleWindowEscape() {
        if (this.open) {
          this.open = false;
          this.$nextTick(() => this.triggerEl?.focus());
        }
      }
    }));
  }
  function registerRzPrependInput(Alpine2) {
    Alpine2.data("rzPrependInput", () => {
      return {
        prependContainer: null,
        textInput: null,
        init() {
          this.prependContainer = this.$refs.prependContainer;
          this.textInput = this.$refs.textInput;
          let self2 = this;
          setTimeout(() => {
            self2.updatePadding();
          }, 50);
          window.addEventListener("resize", this.updatePadding);
        },
        destroy() {
          window.removeEventListener("resize", this.updatePadding);
        },
        updatePadding() {
          const prependDiv = this.prependContainer;
          const inputElem = this.textInput;
          if (!prependDiv || !inputElem) {
            if (inputElem) {
              inputElem.classList.remove("text-transparent");
            }
            return;
          }
          const prependWidth = prependDiv.offsetWidth;
          const leftPadding = prependWidth + 10;
          inputElem.style.paddingLeft = leftPadding + "px";
          inputElem.classList.remove("text-transparent");
        }
      };
    });
  }
  function registerRzProgress(Alpine2) {
    Alpine2.data("rzProgress", () => ({
      currentVal: 0,
      minVal: 0,
      maxVal: 100,
      percentage: 0,
      label: "",
      init() {
        const element = this.$el;
        this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
        this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
        this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
        this.label = element.getAttribute("data-label");
        this.calculatePercentage();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuemin", this.minVal);
        element.setAttribute("aria-valuemax", this.maxVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
        this.updateProgressBar();
        const resizeObserver = new ResizeObserver((entries) => {
          this.updateProgressBar();
        });
        resizeObserver.observe(element);
        this.$watch("currentVal", () => {
          this.calculatePercentage();
          this.updateProgressBar();
          element.setAttribute("aria-valuenow", this.currentVal);
          element.setAttribute("aria-valuetext", `${this.percentage}%`);
        });
      },
      calculatePercentage() {
        if (this.maxVal === this.minVal) {
          this.percentage = 0;
        } else {
          this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
        }
      },
      buildLabel() {
        var label = this.label || "{percent}%";
        this.calculatePercentage();
        return label.replace("{percent}", this.percentage);
      },
      buildInsideLabelPosition() {
        const progressBar = this.$refs.progressBar;
        const barLabel = this.$refs.progressBarLabel;
        const innerLabel = this.$refs.innerLabel;
        if (barLabel && progressBar && innerLabel) {
          innerLabel.innerText = this.buildLabel();
          if (barLabel.clientWidth > progressBar.clientWidth) {
            barLabel.style.left = progressBar.clientWidth + 10 + "px";
          } else {
            barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
          }
        }
      },
      getLabelCss() {
        const barLabel = this.$refs.progressBarLabel;
        const progressBar = this.$refs.progressBar;
        if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
          return "text-foreground dark:text-foreground";
        }
        return "";
      },
      updateProgressBar() {
        const progressBar = this.$refs.progressBar;
        if (progressBar) {
          progressBar.style.width = `${this.percentage}%`;
          this.buildInsideLabelPosition();
        }
      },
      // Methods to set, increment, or decrement the progress value
      setProgress(value) {
        this.currentVal = value;
      },
      increment(val = 1) {
        this.currentVal = Math.min(this.currentVal + val, this.maxVal);
      },
      decrement(val = 1) {
        this.currentVal = Math.max(this.currentVal - val, this.minVal);
      }
    }));
  }
  function registerRzQuickReferenceContainer(Alpine2) {
    Alpine2.data("rzQuickReferenceContainer", () => {
      return {
        headings: [],
        // Array of heading IDs
        currentHeadingId: "",
        // ID of the currently highlighted heading
        // Initializes the component with headings and the initial current heading from data attributes.
        init() {
          this.headings = JSON.parse(this.$el.dataset.headings || "[]");
          this.currentHeadingId = this.$el.dataset.currentheadingid || "";
        },
        // Handles click events on quick reference links.
        handleHeadingClick() {
          const id = this.$el.dataset.headingid;
          window.requestAnimationFrame(() => {
            this.currentHeadingId = id;
          });
        },
        // Sets the current heading ID based on intersection observer events from rzHeading.
        setCurrentHeading(id) {
          if (this.headings.includes(id)) {
            this.currentHeadingId = id;
          }
        },
        // Provides CSS classes for a link based on whether it's the current heading.
        // Returns an object suitable for :class binding.
        getSelectedCss() {
          const id = this.$el.dataset.headingid;
          return {
            "font-bold": this.currentHeadingId === id
            // Apply 'font-bold' if current
          };
        },
        // Determines the value for the aria-current attribute.
        getSelectedAriaCurrent() {
          const id = this.$el.dataset.headingid;
          return this.currentHeadingId === id ? "true" : null;
        }
      };
    });
  }
  function registerRzSheet(Alpine2) {
    Alpine2.data("rzSheet", () => ({
      open: false,
      init() {
        this.open = this.$el.dataset.defaultOpen === "true";
      },
      toggle() {
        this.open = !this.open;
      },
      close() {
        this.open = false;
      },
      show() {
        this.open = true;
      },
      state() {
        return this.open ? "open" : "closed";
      }
    }));
  }
  function registerRzTabs(Alpine2) {
    Alpine2.data("rzTabs", () => ({
      selectedTab: "",
      _triggers: [],
      _observer: null,
      init() {
        const defaultValue = this.$el.dataset.defaultValue;
        this._observer = new MutationObserver(() => this.refreshTriggers());
        this._observer.observe(this.$el, { childList: true, subtree: true });
        this.refreshTriggers();
        if (defaultValue && this._triggers.some((t2) => t2.dataset.value === defaultValue)) {
          this.selectedTab = defaultValue;
        } else if (this._triggers.length > 0) {
          this.selectedTab = this._triggers[0].dataset.value;
        }
      },
      destroy() {
        if (this._observer) {
          this._observer.disconnect();
        }
      },
      refreshTriggers() {
        this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
      },
      onTriggerClick(e2) {
        const value = e2.currentTarget?.dataset?.value;
        if (!value || e2.currentTarget.getAttribute("aria-disabled") === "true") {
          return;
        }
        this.selectedTab = value;
        this.$dispatch("rz:tabs-change", { value: this.selectedTab });
      },
      isSelected(value) {
        return this.selectedTab === value;
      },
      bindTrigger() {
        this.selectedTab;
        const value = this.$el.dataset.value;
        const active = this.isSelected(value);
        const disabled = this.$el.getAttribute("aria-disabled") === "true";
        return {
          "aria-selected": String(active),
          "tabindex": active ? "0" : "-1",
          "data-state": active ? "active" : "inactive",
          ...disabled && { "disabled": true }
        };
      },
      _attrDisabled() {
        return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
      },
      _attrAriaSelected() {
        return String(this.$el.dataset.value === this.selectedTab);
      },
      _attrHidden() {
        return this.$el.dataset.value === this.selectedTab ? null : "true";
      },
      _attrAriaHidden() {
        return String(this.selectedTab !== this.$el.dataset.value);
      },
      _attrDataState() {
        return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
      },
      _attrTabIndex() {
        return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
      },
      onListKeydown(e2) {
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(e2.key)) {
          e2.preventDefault();
          const availableTriggers = this._triggers.filter((t2) => t2.getAttribute("aria-disabled") !== "true");
          if (availableTriggers.length === 0) return;
          const activeIndex = availableTriggers.findIndex((t2) => t2.dataset.value === this.selectedTab);
          if (activeIndex === -1) return;
          const isVertical = e2.currentTarget?.getAttribute("aria-orientation") === "vertical";
          const prevKey = isVertical ? "ArrowUp" : "ArrowLeft";
          const nextKey = isVertical ? "ArrowDown" : "ArrowRight";
          let newIndex = activeIndex;
          switch (e2.key) {
            case prevKey:
              newIndex = activeIndex - 1 < 0 ? availableTriggers.length - 1 : activeIndex - 1;
              break;
            case nextKey:
              newIndex = (activeIndex + 1) % availableTriggers.length;
              break;
            case "Home":
              newIndex = 0;
              break;
            case "End":
              newIndex = availableTriggers.length - 1;
              break;
          }
          if (newIndex >= 0 && newIndex < availableTriggers.length) {
            const newTrigger = availableTriggers[newIndex];
            this.selectedTab = newTrigger.dataset.value;
            this.$nextTick(() => newTrigger.focus());
          }
        }
      }
    }));
  }
  function registerRzSidebar(Alpine2) {
    Alpine2.data("rzSidebar", () => ({
      open: false,
      openMobile: false,
      isMobile: false,
      collapsible: "offcanvas",
      shortcut: "b",
      cookieName: "sidebar_state",
      mobileBreakpoint: 768,
      init() {
        this.collapsible = this.$el.dataset.collapsible || "offcanvas";
        this.shortcut = this.$el.dataset.shortcut || "b";
        this.cookieName = this.$el.dataset.cookieName || "sidebar_state";
        this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
        const savedState = this.cookieName ? document.cookie.split("; ").find((row) => row.startsWith(`${this.cookieName}=`))?.split("=")[1] : null;
        const defaultOpen = this.$el.dataset.defaultOpen === "true";
        this.open = savedState !== null ? savedState === "true" : defaultOpen;
        this.checkIfMobile();
        window.addEventListener("keydown", (e2) => {
          if ((e2.ctrlKey || e2.metaKey) && e2.key.toLowerCase() === this.shortcut.toLowerCase()) {
            e2.preventDefault();
            this.toggle();
          }
        });
        this.$watch("open", (value) => {
          if (this.cookieName) {
            document.cookie = `${this.cookieName}=${value}; path=/; max-age=31536000`;
          }
        });
      },
      checkIfMobile() {
        this.isMobile = window.innerWidth < this.mobileBreakpoint;
      },
      toggle() {
        if (this.isMobile) {
          this.openMobile = !this.openMobile;
        } else {
          this.open = !this.open;
        }
      },
      close() {
        if (this.isMobile) {
          this.openMobile = false;
        }
      },
      isMobileOpen() {
        return this.openMobile;
      },
      desktopState() {
        return this.open ? "expanded" : "collapsed";
      },
      mobileState() {
        return this.openMobile ? "open" : "closed";
      },
      getCollapsibleAttribute() {
        return this.desktopState() === "collapsed" ? this.collapsible : "";
      }
    }));
  }
  function registerRzCommand(Alpine2) {
    Alpine2.data("rzCommand", () => ({
      // --- STATE ---
      search: "",
      selectedValue: null,
      selectedIndex: -1,
      items: [],
      filteredItems: [],
      groupTemplates: /* @__PURE__ */ new Map(),
      activeDescendantId: null,
      isOpen: false,
      isEmpty: true,
      firstRender: true,
      isLoading: false,
      error: null,
      // --- CONFIG ---
      loop: false,
      shouldFilter: true,
      itemsUrl: null,
      fetchTrigger: "immediate",
      serverFiltering: false,
      dataItemTemplateId: null,
      _dataFetched: false,
      _debounceTimer: null,
      // --- COMPUTED (CSP-Compliant Methods) ---
      showLoading() {
        return this.isLoading;
      },
      hasError() {
        return this.error !== null;
      },
      notHasError() {
        return this.error == null;
      },
      shouldShowEmpty() {
        return this.isEmpty && this.search && !this.isLoading && !this.error;
      },
      shouldShowEmptyOrError() {
        return this.isEmpty && this.search && !this.isLoading || this.error !== null;
      },
      // --- LIFECYCLE ---
      init() {
        this.loop = this.$el.dataset.loop === "true";
        this.shouldFilter = this.$el.dataset.shouldFilter !== "false";
        this.selectedValue = this.$el.dataset.selectedValue || null;
        this.itemsUrl = this.$el.dataset.itemsUrl || null;
        this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate";
        this.serverFiltering = this.$el.dataset.serverFiltering === "true";
        this.dataItemTemplateId = this.$el.dataset.templateId || null;
        const itemsScriptId = this.$el.dataset.itemsId;
        let staticItems = [];
        if (itemsScriptId) {
          const itemsScript = document.getElementById(itemsScriptId);
          if (itemsScript) {
            try {
              staticItems = JSON.parse(itemsScript.textContent || "[]");
            } catch (e2) {
              console.error(`RzCommand: Failed to parse JSON from script tag #${itemsScriptId}`, e2);
            }
          }
        }
        if (staticItems.length > 0 && !this.dataItemTemplateId) {
          console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them.");
        }
        staticItems.forEach((item) => {
          item.id = item.id || `static-item-${crypto.randomUUID()}`;
          item.isDataItem = true;
          this.registerItem(item);
        });
        if (this.itemsUrl && this.fetchTrigger === "immediate") {
          this.fetchItems();
        }
        this.$watch("search", (newValue) => {
          this.firstRender = false;
          if (this.serverFiltering) {
            clearTimeout(this._debounceTimer);
            this._debounceTimer = setTimeout(() => {
              this.fetchItems(newValue);
            }, 300);
          } else {
            this.filterAndSortItems();
          }
        });
        this.$watch("selectedIndex", (newIndex, oldIndex) => {
          if (oldIndex > -1) {
            const oldItem = this.filteredItems[oldIndex];
            if (oldItem) {
              const oldEl = this.$el.querySelector(`[data-command-item-id="${oldItem.id}"]`);
              if (oldEl) {
                oldEl.removeAttribute("data-selected");
                oldEl.setAttribute("aria-selected", "false");
              }
            }
          }
          if (newIndex > -1 && this.filteredItems[newIndex]) {
            const selectedItem = this.filteredItems[newIndex];
            this.activeDescendantId = selectedItem.id;
            const el = this.$el.querySelector(`[data-command-item-id="${selectedItem.id}"]`);
            if (el) {
              el.setAttribute("data-selected", "true");
              el.setAttribute("aria-selected", "true");
              el.scrollIntoView({ block: "nearest" });
            }
            const newValue = selectedItem.value;
            if (this.selectedValue !== newValue) {
              this.selectedValue = newValue;
              this.$dispatch("rz:command:select", { value: newValue });
            }
          } else {
            this.activeDescendantId = null;
            this.selectedValue = null;
          }
        });
        this.$watch("selectedValue", (newValue) => {
          const index = this.filteredItems.findIndex((item) => item.value === newValue);
          if (this.selectedIndex !== index) {
            this.selectedIndex = index;
          }
        });
        this.$watch("filteredItems", (items) => {
          this.isOpen = items.length > 0 || this.isLoading;
          this.isEmpty = items.length === 0;
          if (!this.firstRender) {
            window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
              detail: {
                items: this.filteredItems,
                groups: this.groupTemplates,
                commandId: this.$el.id
              }
            }));
          }
        });
      },
      // --- METHODS ---
      async fetchItems(query = "") {
        if (!this.itemsUrl) return;
        if (!this.dataItemTemplateId) {
          console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data.");
          this.error = "Configuration error: No data template found.";
          return;
        }
        this.isLoading = true;
        this.error = null;
        try {
          const url = new URL(this.itemsUrl, window.location.origin);
          if (this.serverFiltering && query) {
            url.searchParams.append("q", query);
          }
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
          }
          const data2 = await response.json();
          if (this.serverFiltering) {
            this.items = this.items.filter((i2) => !i2.isDataItem);
          }
          data2.forEach((item) => {
            item.id = item.id || `data-item-${crypto.randomUUID()}`;
            item.isDataItem = true;
            this.registerItem(item);
          });
          this._dataFetched = true;
        } catch (e2) {
          this.error = e2.message || "Failed to fetch command items.";
          console.error("RzCommand:", this.error);
        } finally {
          this.isLoading = false;
          this.filterAndSortItems();
        }
      },
      handleInteraction() {
        if (this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched) {
          this.fetchItems();
        }
      },
      registerItem(item) {
        if (this.items.some((i2) => i2.id === item.id)) return;
        item._order = this.items.length;
        this.items.push(item);
        if (this.selectedIndex === -1)
          this.selectedIndex = 0;
        if (!this.serverFiltering) {
          this.filterAndSortItems();
        }
      },
      unregisterItem(itemId) {
        this.items = this.items.filter((i2) => i2.id !== itemId);
        this.filterAndSortItems();
      },
      registerGroupTemplate(name, templateId) {
        if (!this.groupTemplates.has(name)) {
          this.groupTemplates.set(name, templateId);
        }
      },
      filterAndSortItems() {
        if (this.serverFiltering && this._dataFetched) {
          this.filteredItems = this.items;
          this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
          return;
        }
        let items;
        if (!this.shouldFilter || !this.search) {
          items = this.items.map((item) => ({ ...item, score: 1 }));
        } else {
          items = this.items.map((item) => ({
            ...item,
            score: item.forceMount ? 0 : this.commandScore(item.name, this.search, item.keywords)
          })).filter((item) => item.score > 0 || item.forceMount).sort((a2, b) => {
            if (a2.forceMount && !b.forceMount) return 1;
            if (!a2.forceMount && b.forceMount) return -1;
            if (b.score !== a2.score) return b.score - a2.score;
            return (a2._order || 0) - (b._order || 0);
          });
        }
        this.filteredItems = items;
        if (this.selectedValue) {
          const newIndex = this.filteredItems.findIndex((item) => item.value === this.selectedValue);
          this.selectedIndex = newIndex > -1 ? newIndex : this.filteredItems.length > 0 ? 0 : -1;
        } else {
          this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        }
      },
      // --- EVENT HANDLERS ---
      handleItemClick(event2) {
        const host = event2.target.closest("[data-command-item-id]");
        if (!host) return;
        const itemId = host.dataset.commandItemId;
        const index = this.filteredItems.findIndex((item) => item.id === itemId);
        if (index > -1) {
          const item = this.filteredItems[index];
          if (item && !item.disabled) {
            this.selectedIndex = index;
            this.$dispatch("rz:command:execute", { value: item.value });
          }
        }
      },
      handleItemHover(event2) {
        const host = event2.target.closest("[data-command-item-id]");
        if (!host) return;
        const itemId = host.dataset.commandItemId;
        const index = this.filteredItems.findIndex((item) => item.id === itemId);
        if (index > -1) {
          const item = this.filteredItems[index];
          if (item && !item.disabled) {
            if (this.selectedIndex !== index) {
              this.selectedIndex = index;
            }
          }
        }
      },
      // --- KEYBOARD NAVIGATION ---
      handleKeydown(e2) {
        switch (e2.key) {
          case "ArrowDown":
            e2.preventDefault();
            this.selectNext();
            break;
          case "ArrowUp":
            e2.preventDefault();
            this.selectPrev();
            break;
          case "Home":
            e2.preventDefault();
            this.selectFirst();
            break;
          case "End":
            e2.preventDefault();
            this.selectLast();
            break;
          case "Enter":
            e2.preventDefault();
            const item = this.filteredItems[this.selectedIndex];
            if (item && !item.disabled) {
              this.$dispatch("rz:command:execute", { value: item.value });
            }
            break;
        }
      },
      selectNext() {
        if (this.filteredItems.length === 0) return;
        let i2 = this.selectedIndex, count = 0;
        do {
          i2 = i2 + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : i2 + 1;
          count++;
          if (!this.filteredItems[i2]?.disabled) {
            this.selectedIndex = i2;
            return;
          }
          if (!this.loop && i2 === this.filteredItems.length - 1) return;
        } while (count <= this.filteredItems.length);
      },
      selectPrev() {
        if (this.filteredItems.length === 0) return;
        let i2 = this.selectedIndex, count = 0;
        do {
          i2 = i2 - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : i2 - 1;
          count++;
          if (!this.filteredItems[i2]?.disabled) {
            this.selectedIndex = i2;
            return;
          }
          if (!this.loop && i2 === 0) return;
        } while (count <= this.filteredItems.length);
      },
      selectFirst() {
        if (this.filteredItems.length > 0) {
          const firstEnabledIndex = this.filteredItems.findIndex((item) => !item.disabled);
          if (firstEnabledIndex > -1) this.selectedIndex = firstEnabledIndex;
        }
      },
      selectLast() {
        if (this.filteredItems.length > 0) {
          const lastEnabledIndex = this.filteredItems.map((item) => item.disabled).lastIndexOf(false);
          if (lastEnabledIndex > -1) this.selectedIndex = lastEnabledIndex;
        }
      },
      // --- SCORING ALGORITHM (Adapted from cmdk) ---
      commandScore(string, search, keywords = []) {
        const SCORE_CONTINUE_MATCH = 1;
        const SCORE_SPACE_WORD_JUMP = 0.9;
        const SCORE_NON_SPACE_WORD_JUMP = 0.8;
        const SCORE_CHARACTER_JUMP = 0.17;
        const PENALTY_SKIPPED = 0.999;
        const PENALTY_CASE_MISMATCH = 0.9999;
        const PENALTY_NOT_COMPLETE = 0.99;
        const IS_GAP_REGEXP = /[\\/_+.#"@[\(\{&]/;
        const IS_SPACE_REGEXP = /[\s-]/;
        const fullString = `${string} ${keywords ? keywords.join(" ") : ""}`;
        function formatInput(str) {
          return str.toLowerCase().replace(/[\s-]/g, " ");
        }
        function commandScoreInner(str, abbr, lowerStr, lowerAbbr, strIndex, abbrIndex, memo) {
          if (abbrIndex === abbr.length) {
            return strIndex === str.length ? SCORE_CONTINUE_MATCH : PENALTY_NOT_COMPLETE;
          }
          const memoKey = `${strIndex},${abbrIndex}`;
          if (memo[memoKey] !== void 0) return memo[memoKey];
          const abbrChar = lowerAbbr.charAt(abbrIndex);
          let index = lowerStr.indexOf(abbrChar, strIndex);
          let highScore = 0;
          while (index >= 0) {
            let score = commandScoreInner(str, abbr, lowerStr, lowerAbbr, index + 1, abbrIndex + 1, memo);
            if (score > highScore) {
              if (index === strIndex) {
                score *= SCORE_CONTINUE_MATCH;
              } else if (IS_GAP_REGEXP.test(str.charAt(index - 1))) {
                score *= SCORE_NON_SPACE_WORD_JUMP;
              } else if (IS_SPACE_REGEXP.test(str.charAt(index - 1))) {
                score *= SCORE_SPACE_WORD_JUMP;
              } else {
                score *= SCORE_CHARACTER_JUMP;
                if (strIndex > 0) {
                  score *= Math.pow(PENALTY_SKIPPED, index - strIndex);
                }
              }
              if (str.charAt(index) !== abbr.charAt(abbrIndex)) {
                score *= PENALTY_CASE_MISMATCH;
              }
            }
            if (score > highScore) {
              highScore = score;
            }
            index = lowerStr.indexOf(abbrChar, index + 1);
          }
          memo[memoKey] = highScore;
          return highScore;
        }
        return commandScoreInner(fullString, search, formatInput(fullString), formatInput(search), 0, 0, {});
      }
    }));
  }
  function registerRzCommandItem(Alpine2) {
    Alpine2.data("rzCommandItem", () => ({
      parent: null,
      itemData: {},
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandItem must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        this.itemData = {
          id: this.$el.id,
          value: this.$el.dataset.value || this.$el.textContent.trim(),
          name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
          keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
          group: this.$el.dataset.group || null,
          templateId: this.$el.id + "-template",
          disabled: this.$el.dataset.disabled === "true",
          forceMount: this.$el.dataset.forceMount === "true"
        };
        this.parent.registerItem(this.itemData);
      },
      destroy() {
        if (this.parent) {
          this.parent.unregisterItem(this.itemData.id);
        }
      }
    }));
  }
  function registerRzCommandList(Alpine2) {
    Alpine2.data("rzCommandList", () => ({
      parent: null,
      dataItemTemplate: null,
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandList must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        if (this.parent.dataItemTemplateId) {
          this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId);
        }
      },
      renderList(event2) {
        if (event2.detail.commandId !== this.parent.$el.id) return;
        const items = event2.detail.items || [];
        const groups = event2.detail.groups || /* @__PURE__ */ new Map();
        const container = this.$el;
        container.querySelectorAll("[data-dynamic-item]").forEach((el) => el.remove());
        const groupedItems = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
        items.forEach((item) => {
          const groupName = item.group || "__ungrouped__";
          if (!groupedItems.has(groupName)) {
            groupedItems.set(groupName, []);
          }
          groupedItems.get(groupName).push(item);
        });
        groupedItems.forEach((groupItems, groupName) => {
          if (groupItems.length === 0) return;
          const groupContainer = document.createElement("div");
          groupContainer.setAttribute("role", "group");
          groupContainer.setAttribute("data-dynamic-item", "true");
          groupContainer.setAttribute("data-slot", "command-group");
          if (groupName !== "__ungrouped__") {
            const headingTemplateId = groups.get(groupName);
            if (headingTemplateId) {
              const headingTemplate = document.getElementById(headingTemplateId);
              if (headingTemplate && headingTemplate.content) {
                const headingClone = headingTemplate.content.cloneNode(true);
                const headingEl = headingClone.firstElementChild;
                if (headingEl) {
                  groupContainer.setAttribute("aria-labelledby", headingEl.id);
                  groupContainer.appendChild(headingClone);
                }
              }
            }
          }
          groupItems.forEach((item) => {
            const itemIndex = this.parent.filteredItems.indexOf(item);
            let itemEl;
            if (item.isDataItem) {
              if (!this.dataItemTemplate) {
                return;
              }
              const clone2 = this.dataItemTemplate.content.cloneNode(true);
              itemEl = clone2.firstElementChild;
              Alpine2.addScopeToNode(itemEl, { item });
            } else {
              const template = document.getElementById(item.templateId);
              if (template && template.content) {
                const clone2 = template.content.cloneNode(true);
                itemEl = clone2.querySelector(`[data-command-item-id="${item.id}"]`);
              }
            }
            if (itemEl) {
              itemEl.setAttribute("data-command-item-id", item.id);
              itemEl.setAttribute("data-value", item.value);
              if (item.keywords) itemEl.setAttribute("data-keywords", JSON.stringify(item.keywords));
              if (item.group) itemEl.setAttribute("data-group", item.group);
              if (item.disabled) itemEl.setAttribute("data-disabled", "true");
              if (item.forceMount) itemEl.setAttribute("data-force-mount", "true");
              itemEl.setAttribute("role", "option");
              itemEl.setAttribute("aria-selected", this.parent.selectedIndex === itemIndex);
              if (item.disabled) {
                itemEl.setAttribute("aria-disabled", "true");
              }
              if (this.parent.selectedIndex === itemIndex) {
                itemEl.setAttribute("data-selected", "true");
              }
              groupContainer.appendChild(itemEl);
              Alpine2.initTree(itemEl);
            }
          });
          container.appendChild(groupContainer);
        });
      }
    }));
  }
  function registerRzCommandGroup(Alpine2) {
    Alpine2.data("rzCommandGroup", () => ({
      parent: null,
      heading: "",
      templateId: "",
      init() {
        const parentEl = this.$el.closest('[x-data="rzCommand"]');
        if (!parentEl) {
          console.error("CommandGroup must be a child of RzCommand.");
          return;
        }
        this.parent = Alpine2.$data(parentEl);
        this.heading = this.$el.dataset.heading;
        this.templateId = this.$el.dataset.templateId;
        if (this.heading && this.templateId) {
          this.parent.registerGroupTemplate(this.heading, this.templateId);
        }
      }
    }));
  }
  async function generateBundleId(paths) {
    paths = [...paths].sort();
    const joinedPaths = paths.join("|");
    const encoder = new TextEncoder();
    const data2 = encoder.encode(joinedPaths);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  function rizzyRequire(paths, callbackOrNonce, nonce) {
    let cbObj = void 0;
    let csp = void 0;
    if (typeof callbackOrNonce === "function") {
      cbObj = { success: callbackOrNonce };
    } else if (callbackOrNonce && typeof callbackOrNonce === "object") {
      cbObj = callbackOrNonce;
    } else if (typeof callbackOrNonce === "string") {
      csp = callbackOrNonce;
    }
    if (!csp && typeof nonce === "string") csp = nonce;
    const files = Array.isArray(paths) ? paths : [paths];
    return generateBundleId(files).then((bundleId) => {
      if (!loadjs.isDefined(bundleId)) {
        loadjs(files, bundleId, {
          // keep scripts ordered unless you explicitly change this later
          async: false,
          // pass CSP nonce to both script and style tags as your loader expects
          inlineScriptNonce: csp,
          inlineStyleNonce: csp
        });
      }
      return new Promise((resolve, reject) => {
        loadjs.ready(bundleId, {
          success: () => {
            try {
              if (cbObj && typeof cbObj.success === "function") cbObj.success();
            } catch (e2) {
              console.error("[rizzyRequire] success callback threw:", e2);
            }
            resolve({ bundleId });
          },
          error: (depsNotFound) => {
            try {
              if (cbObj && typeof cbObj.error === "function") {
                cbObj.error(depsNotFound);
              }
            } catch (e2) {
              console.error("[rizzyRequire] error callback threw:", e2);
            }
            reject(
              new Error(
                `[rizzyRequire] Failed to load bundle ${bundleId} (missing: ${Array.isArray(depsNotFound) ? depsNotFound.join(", ") : String(depsNotFound)})`
              )
            );
          }
        });
      });
    });
  }
  function registerComponents(Alpine2) {
    registerRzAccordion(Alpine2);
    registerAccordionItem(Alpine2);
    registerRzAlert(Alpine2);
    registerRzAspectRatio(Alpine2);
    registerRzBrowser(Alpine2);
    registerRzCalendar(Alpine2, rizzyRequire);
    registerRzCarousel(Alpine2, rizzyRequire);
    registerRzCodeViewer(Alpine2, rizzyRequire);
    registerRzCollapsible(Alpine2);
    registerRzCombobox(Alpine2, rizzyRequire);
    registerRzDateEdit(Alpine2, rizzyRequire);
    registerRzDialog(Alpine2);
    registerRzDropdownMenu(Alpine2);
    registerRzDarkModeToggle(Alpine2);
    registerRzEmbeddedPreview(Alpine2);
    registerRzEmpty(Alpine2);
    registerRzHeading(Alpine2);
    registerRzIndicator(Alpine2);
    registerRzInputGroupAddon(Alpine2);
    registerRzMarkdown(Alpine2, rizzyRequire);
    registerRzNavigationMenu(Alpine2);
    registerRzPopover(Alpine2);
    registerRzPrependInput(Alpine2);
    registerRzProgress(Alpine2);
    registerRzQuickReferenceContainer(Alpine2);
    registerRzSheet(Alpine2);
    registerRzTabs(Alpine2);
    registerRzSidebar(Alpine2);
    registerRzCommand(Alpine2);
    registerRzCommandItem(Alpine2);
    registerRzCommandList(Alpine2);
    registerRzCommandGroup(Alpine2);
  }
  function props(alpineRootElement) {
    if (!(alpineRootElement instanceof Element)) {
      console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el).");
      return {};
    }
    const propsScriptId = alpineRootElement.dataset.propsId;
    if (!propsScriptId) {
      return {};
    }
    const propsScriptEl = document.getElementById(propsScriptId);
    if (!propsScriptEl) {
      console.warn(`[Rizzy.props] Could not find the props script tag with ID '${propsScriptId}'.`);
      return {};
    }
    try {
      return JSON.parse(propsScriptEl.textContent || "{}");
    } catch (e2) {
      console.error(`[Rizzy.props] Failed to parse JSON from script tag #${propsScriptId}.`, e2);
      return {};
    }
  }
  const _registered = /* @__PURE__ */ new Map();
  const _importCache = /* @__PURE__ */ new Map();
  let _onAlpineInitAttached = false;
  function onceImport(path) {
    if (!_importCache.has(path)) {
      _importCache.set(
        path,
        import(path).catch((err) => {
          _importCache.delete(path);
          throw err;
        })
      );
    }
    return _importCache.get(path);
  }
  function setAsyncLoader(name, path) {
    const Alpine2 = globalThis.Alpine;
    if (!(Alpine2 && typeof Alpine2.asyncData === "function")) {
      console.error(
        `[RizzyUI] Could not register async component '${name}'. AsyncAlpine not available.`
      );
      return false;
    }
    Alpine2.asyncData(
      name,
      () => onceImport(path).catch((error2) => {
        console.error(
          `[RizzyUI] Failed to load Alpine module '${name}' from '${path}'.`,
          error2
        );
        return () => ({
          _error: true,
          _errorMessage: `Module '${name}' failed to load.`
        });
      })
    );
    return true;
  }
  function registerAsyncComponent(name, path) {
    if (!name || !path) {
      console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
      return;
    }
    const prev = _registered.get(name);
    if (prev && prev.path !== path) {
      console.warn(
        `[RizzyUI] Re-registering '${name}' with a different path.
  Previous: ${prev.path}
  New:      ${path}`
      );
    }
    const Alpine2 = globalThis.Alpine;
    if (Alpine2 && Alpine2.version) {
      const changedPath = !prev || prev.path !== path;
      const alreadySet = prev && prev.loaderSet && !changedPath;
      if (!alreadySet) {
        const ok = setAsyncLoader(name, path);
        _registered.set(name, { path, loaderSet: ok });
      }
      return;
    }
    _registered.set(name, { path, loaderSet: false });
    if (!_onAlpineInitAttached) {
      _onAlpineInitAttached = true;
      document.addEventListener(
        "alpine:init",
        () => {
          for (const [n2, info] of _registered) {
            if (!info.loaderSet) {
              const ok = setAsyncLoader(n2, info.path);
              info.loaderSet = ok;
            }
          }
        },
        { once: true }
      );
    }
  }
  function registerMobileDirective(Alpine2) {
    Alpine2.directive("mobile", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
      const bpMod = modifiers.find((m2) => m2.startsWith("bp-"));
      const BREAKPOINT = bpMod ? parseInt(bpMod.slice(3), 10) : 768;
      const ASSIGN_PROP = !!(expression && expression.length > 0);
      if (typeof window === "undefined" || !window.matchMedia) {
        el.dataset.mobile = "false";
        el.dataset.screen = "desktop";
        return;
      }
      const isMobileNow = () => window.innerWidth < BREAKPOINT;
      const reflect = (val) => {
        el.dataset.mobile = val ? "true" : "false";
        el.dataset.screen = val ? "mobile" : "desktop";
      };
      const getComponentData = () => {
        if (typeof Alpine2.$data === "function") return Alpine2.$data(el);
        return el.__x ? el.__x.$data : null;
      };
      const setProp = (val) => {
        if (!ASSIGN_PROP) return;
        const data2 = getComponentData();
        if (data2) data2[expression] = val;
      };
      const dispatch2 = (val) => {
        el.dispatchEvent(
          new CustomEvent("screen:change", {
            bubbles: true,
            detail: { isMobile: val, width: window.innerWidth, breakpoint: BREAKPOINT }
          })
        );
      };
      const mql = window.matchMedia(`(max-width: ${BREAKPOINT - 1}px)`);
      const update = () => {
        const val = isMobileNow();
        reflect(val);
        setProp(val);
        dispatch2(val);
      };
      update();
      const onChange = () => update();
      const onResize = () => update();
      mql.addEventListener("change", onChange);
      window.addEventListener("resize", onResize, { passive: true });
      cleanup2(() => {
        mql.removeEventListener("change", onChange);
        window.removeEventListener("resize", onResize);
      });
    });
  }
  function registerSyncDirective(Alpine2) {
    const handler4 = (el, { expression, modifiers }, { cleanup: cleanup2, effect: effect3 }) => {
      if (!expression || typeof expression !== "string") return;
      const setAtPath = (obj, path, value) => {
        const norm = path.replace(/\[(\d+)\]/g, ".$1");
        const keys = norm.split(".");
        const last = keys.pop();
        let cur = obj;
        for (const k of keys) {
          if (cur[k] == null || typeof cur[k] !== "object") cur[k] = isFinite(+k) ? [] : {};
          cur = cur[k];
        }
        cur[last] = value;
      };
      const stack = Alpine2.closestDataStack(el) || [];
      const childData = stack[0] || null;
      const parentData = stack[1] || null;
      if (!childData || !parentData) {
        if (void 0) {
          console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
        }
        return;
      }
      const pairs = expression.split(",").map((s2) => s2.trim()).filter(Boolean).map((s2) => {
        const m2 = s2.split("->").map((x) => x.trim());
        if (m2.length !== 2) {
          console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', s2);
          return null;
        }
        return { parentPath: m2[0], childPath: m2[1] };
      }).filter(Boolean);
      const initChildWins = modifiers.includes("init-child") || modifiers.includes("child") || modifiers.includes("childWins");
      const guard = pairs.map(() => ({
        fromParent: false,
        fromChild: false,
        skipChildOnce: initChildWins
        // avoid redundant first child->parent write
      }));
      const stops = [];
      pairs.forEach((pair, idx) => {
        const g = guard[idx];
        if (initChildWins) {
          const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
          g.fromChild = true;
          setAtPath(parentData, pair.parentPath, childVal);
          queueMicrotask(() => {
            g.fromChild = false;
          });
        } else {
          const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
          g.fromParent = true;
          setAtPath(childData, pair.childPath, parentVal);
          queueMicrotask(() => {
            g.fromParent = false;
          });
        }
        const stop1 = effect3(() => {
          const parentVal = Alpine2.evaluate(el, pair.parentPath, { scope: parentData });
          if (g.fromChild) return;
          g.fromParent = true;
          setAtPath(childData, pair.childPath, parentVal);
          queueMicrotask(() => {
            g.fromParent = false;
          });
        });
        const stop2 = effect3(() => {
          const childVal = Alpine2.evaluate(el, pair.childPath, { scope: childData });
          if (g.fromParent) return;
          if (g.skipChildOnce) {
            g.skipChildOnce = false;
            return;
          }
          g.fromChild = true;
          setAtPath(parentData, pair.parentPath, childVal);
          queueMicrotask(() => {
            g.fromChild = false;
          });
        });
        stops.push(stop1, stop2);
      });
      cleanup2(() => {
        for (const stop2 of stops) {
          try {
            stop2 && stop2();
          } catch {
          }
        }
      });
    };
    Alpine2.directive("syncprop", handler4);
  }
  class ThemeController {
    constructor() {
      this.storageKey = "darkMode";
      this.eventName = "rz:theme-change";
      this.darkClass = "dark";
      this._mode = "auto";
      this._mq = null;
      this._initialized = false;
      this._onMqChange = null;
      this._onStorage = null;
      this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
    }
    init() {
      if (this._initialized) return;
      if (typeof window === "undefined") return;
      this._initialized = true;
      this._mq = typeof window.matchMedia === "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
      const raw2 = this._safeReadStorage(this.storageKey);
      this._mode = this._normalizeMode(raw2 ?? "auto");
      this._sync();
      this._onMqChange = () => {
        this._sync();
      };
      if (this._mq) {
        if (typeof this._mq.addEventListener === "function") {
          this._mq.addEventListener("change", this._onMqChange);
        } else if (typeof this._mq.addListener === "function") {
          this._mq.addListener(this._onMqChange);
        }
      }
      this._onStorage = (e2) => {
        if (e2.key !== this.storageKey) return;
        const next = this._normalizeMode(e2.newValue ?? "auto");
        if (next !== this._mode) {
          this._mode = next;
          this._sync();
        }
      };
      window.addEventListener("storage", this._onStorage);
    }
    destroy() {
      if (!this._initialized) return;
      this._initialized = false;
      if (this._mq && this._onMqChange) {
        if (typeof this._mq.removeEventListener === "function") {
          this._mq.removeEventListener("change", this._onMqChange);
        } else if (typeof this._mq.removeListener === "function") {
          this._mq.removeListener(this._onMqChange);
        }
      }
      if (typeof window !== "undefined" && this._onStorage) {
        window.removeEventListener("storage", this._onStorage);
      }
      this._onMqChange = null;
      this._onStorage = null;
      this._mq = null;
      this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
    }
    // ----- Public State Accessors -----
    get mode() {
      return this._mode;
    }
    get prefersDark() {
      return !!this._mq?.matches;
    }
    get effectiveDark() {
      return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
    }
    // ----- Public API Surface -----
    isDark() {
      return this.effectiveDark;
    }
    isLight() {
      return !this.effectiveDark;
    }
    setLight() {
      this._setMode("light");
    }
    setDark() {
      this._setMode("dark");
    }
    setAuto() {
      this._setMode("auto");
    }
    toggle() {
      const currentlyDark = this.effectiveDark;
      this._setMode(currentlyDark ? "light" : "dark");
    }
    // ----- Internals -----
    _setMode(value) {
      this._mode = this._normalizeMode(value);
      this._persist();
      this._sync();
    }
    _normalizeMode(value) {
      return value === "light" || value === "dark" || value === "auto" ? value : "auto";
    }
    _safeReadStorage(key) {
      try {
        return window?.localStorage?.getItem(key);
      } catch (e2) {
        return null;
      }
    }
    _persist() {
      try {
        window?.localStorage?.setItem(this.storageKey, this._mode);
      } catch (e2) {
      }
    }
    _sync() {
      const effectiveDark = this.effectiveDark;
      const mode = this._mode;
      const prefersDark = this.prefersDark;
      const root = typeof document !== "undefined" ? document.documentElement : null;
      const domMatchesState = root ? root.classList.contains(this.darkClass) === effectiveDark && root.style.colorScheme === (effectiveDark ? "dark" : "light") : true;
      if (this._lastSnapshot.mode === mode && this._lastSnapshot.effectiveDark === effectiveDark && this._lastSnapshot.prefersDark === prefersDark && domMatchesState) {
        return;
      }
      this._lastSnapshot = { mode, effectiveDark, prefersDark };
      if (root) {
        root.classList.toggle(this.darkClass, effectiveDark);
        root.style.colorScheme = effectiveDark ? "dark" : "light";
      }
      if (typeof window !== "undefined") {
        window.dispatchEvent(
          new CustomEvent(this.eventName, {
            detail: {
              mode,
              darkMode: effectiveDark,
              // External API uses 'darkMode' convention
              prefersDark,
              source: "RizzyUI"
            }
          })
        );
      }
    }
  }
  const themeController = new ThemeController();
  function registerStores(Alpine2) {
    themeController.init();
    Alpine2.store("theme", {
      // Reactive state mirrors
      // We mirror ALL derived properties to ensure Alpine reactivity works 
      // for bindings like x-show="prefersDark" or x-text="mode".
      _mode: themeController.mode,
      _prefersDark: themeController.prefersDark,
      _effectiveDark: themeController.effectiveDark,
      // Listener reference to prevent duplicate registration
      _onThemeChange: null,
      init() {
        if (!this._onThemeChange) {
          this._onThemeChange = () => this._refresh();
          window.addEventListener(themeController.eventName, this._onThemeChange);
        }
        this._refresh();
      },
      _refresh() {
        this._mode = themeController.mode;
        this._prefersDark = themeController.prefersDark;
        this._effectiveDark = themeController.effectiveDark;
      },
      // ----- Reactive Getters -----
      // These return the reactive properties from the store, ensuring Alpine
      // properly tracks dependencies.
      get mode() {
        return this._mode;
      },
      get effectiveDark() {
        return this._effectiveDark;
      },
      get prefersDark() {
        return this._prefersDark;
      },
      // Expose as getters (not methods) for consistency
      get isDark() {
        return this._effectiveDark;
      },
      get isLight() {
        return !this._effectiveDark;
      },
      // ----- Proxy Methods -----
      setLight() {
        themeController.setLight();
      },
      setDark() {
        themeController.setDark();
      },
      setAuto() {
        themeController.setAuto();
      },
      toggle() {
        themeController.toggle();
      }
    });
  }
  let cachedRizzyUI = null;
  function bootstrapRizzyUI(Alpine2) {
    if (cachedRizzyUI) return cachedRizzyUI;
    Alpine2.plugin(module_default$2);
    Alpine2.plugin(module_default$1);
    Alpine2.plugin(module_default);
    Alpine2.plugin(async_alpine_default);
    if (typeof document !== "undefined") {
      document.addEventListener("alpine:init", () => {
        registerStores(Alpine2);
      });
    }
    registerComponents(Alpine2);
    registerMobileDirective(Alpine2);
    registerSyncDirective(Alpine2);
    cachedRizzyUI = {
      Alpine: Alpine2,
      require: rizzyRequire,
      toast: Toast,
      $data,
      props,
      registerAsyncComponent,
      theme: themeController
    };
    if (typeof window !== "undefined") {
      themeController.init();
      window.Alpine = Alpine2;
      window.Rizzy = { ...window.Rizzy || {}, ...cachedRizzyUI };
      document.dispatchEvent(new CustomEvent("rz:init", {
        detail: { Rizzy: window.Rizzy }
      }));
    }
    return cachedRizzyUI;
  }
  const RizzyUI = bootstrapRizzyUI(module_default$3);
  module_default$3.start();
  return RizzyUI;
});
//# sourceMappingURL=rizzyui.js.map
</file>

<file path="wwwroot/js/rizzyui.min.es.js">
var jt = !1, Vt = !1, de = [], Ht = -1;
function ls(e) {
  cs(e);
}
function cs(e) {
  de.includes(e) || de.push(e), ds();
}
function us(e) {
  let t = de.indexOf(e);
  t !== -1 && t > Ht && de.splice(t, 1);
}
function ds() {
  !Vt && !jt && (jt = !0, queueMicrotask(fs));
}
function fs() {
  jt = !1, Vt = !0;
  for (let e = 0; e < de.length; e++)
    de[e](), Ht = e;
  de.length = 0, Ht = -1, Vt = !1;
}
var Se, ye, Ce, bi, Wt = !0;
function hs(e) {
  Wt = !1, e(), Wt = !0;
}
function ps(e) {
  Se = e.reactive, Ce = e.release, ye = (t) => e.effect(t, { scheduler: (n) => {
    Wt ? ls(n) : n();
  } }), bi = e.raw;
}
function Pn(e) {
  ye = e;
}
function ms(e) {
  let t = () => {
  };
  return [(i) => {
    let r = ye(i);
    return e._x_effects || (e._x_effects = /* @__PURE__ */ new Set(), e._x_runEffects = () => {
      e._x_effects.forEach((s) => s());
    }), e._x_effects.add(r), t = () => {
      r !== void 0 && (e._x_effects.delete(r), Ce(r));
    }, r;
  }, () => {
    t();
  }];
}
function yi(e, t) {
  let n = !0, i, r = ye(() => {
    let s = e();
    JSON.stringify(s), n ? i = s : queueMicrotask(() => {
      t(s, i), i = s;
    }), n = !1;
  });
  return () => Ce(r);
}
var wi = [], _i = [], xi = [];
function gs(e) {
  xi.push(e);
}
function hn(e, t) {
  typeof t == "function" ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, _i.push(t));
}
function Ei(e) {
  wi.push(e);
}
function Ii(e, t, n) {
  e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(n);
}
function Si(e, t) {
  e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach(([n, i]) => {
    (t === void 0 || t.includes(n)) && (i.forEach((r) => r()), delete e._x_attributeCleanups[n]);
  });
}
function vs(e) {
  for (e._x_effects?.forEach(us); e._x_cleanups?.length; )
    e._x_cleanups.pop()();
}
var pn = new MutationObserver(bn), mn = !1;
function gn() {
  pn.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), mn = !0;
}
function Ci() {
  bs(), pn.disconnect(), mn = !1;
}
var Ne = [];
function bs() {
  let e = pn.takeRecords();
  Ne.push(() => e.length > 0 && bn(e));
  let t = Ne.length;
  queueMicrotask(() => {
    if (Ne.length === t)
      for (; Ne.length > 0; )
        Ne.shift()();
  });
}
function $(e) {
  if (!mn)
    return e();
  Ci();
  let t = e();
  return gn(), t;
}
var vn = !1, lt = [];
function ys() {
  vn = !0;
}
function ws() {
  vn = !1, bn(lt), lt = [];
}
function bn(e) {
  if (vn) {
    lt = lt.concat(e);
    return;
  }
  let t = [], n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  for (let s = 0; s < e.length; s++)
    if (!e[s].target._x_ignoreMutationObserver && (e[s].type === "childList" && (e[s].removedNodes.forEach((o) => {
      o.nodeType === 1 && o._x_marker && n.add(o);
    }), e[s].addedNodes.forEach((o) => {
      if (o.nodeType === 1) {
        if (n.has(o)) {
          n.delete(o);
          return;
        }
        o._x_marker || t.push(o);
      }
    })), e[s].type === "attributes")) {
      let o = e[s].target, a = e[s].attributeName, l = e[s].oldValue, c = () => {
        i.has(o) || i.set(o, []), i.get(o).push({ name: a, value: o.getAttribute(a) });
      }, u = () => {
        r.has(o) || r.set(o, []), r.get(o).push(a);
      };
      o.hasAttribute(a) && l === null ? c() : o.hasAttribute(a) ? (u(), c()) : u();
    }
  r.forEach((s, o) => {
    Si(o, s);
  }), i.forEach((s, o) => {
    wi.forEach((a) => a(o, s));
  });
  for (let s of n)
    t.some((o) => o.contains(s)) || _i.forEach((o) => o(s));
  for (let s of t)
    s.isConnected && xi.forEach((o) => o(s));
  t = null, n = null, i = null, r = null;
}
function Ti(e) {
  return Ye(xe(e));
}
function Ue(e, t, n) {
  return e._x_dataStack = [t, ...xe(n || e)], () => {
    e._x_dataStack = e._x_dataStack.filter((i) => i !== t);
  };
}
function xe(e) {
  return e._x_dataStack ? e._x_dataStack : typeof ShadowRoot == "function" && e instanceof ShadowRoot ? xe(e.host) : e.parentNode ? xe(e.parentNode) : [];
}
function Ye(e) {
  return new Proxy({ objects: e }, _s);
}
var _s = {
  ownKeys({ objects: e }) {
    return Array.from(
      new Set(e.flatMap((t) => Object.keys(t)))
    );
  },
  has({ objects: e }, t) {
    return t == Symbol.unscopables ? !1 : e.some(
      (n) => Object.prototype.hasOwnProperty.call(n, t) || Reflect.has(n, t)
    );
  },
  get({ objects: e }, t, n) {
    return t == "toJSON" ? xs : Reflect.get(
      e.find(
        (i) => Reflect.has(i, t)
      ) || {},
      t,
      n
    );
  },
  set({ objects: e }, t, n, i) {
    const r = e.find(
      (o) => Object.prototype.hasOwnProperty.call(o, t)
    ) || e[e.length - 1], s = Object.getOwnPropertyDescriptor(r, t);
    return s?.set && s?.get ? s.set.call(i, n) || !0 : Reflect.set(r, t, n);
  }
};
function xs() {
  return Reflect.ownKeys(this).reduce((t, n) => (t[n] = Reflect.get(this, n), t), {});
}
function Ai(e) {
  let t = (i) => typeof i == "object" && !Array.isArray(i) && i !== null, n = (i, r = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(i)).forEach(([s, { value: o, enumerable: a }]) => {
      if (a === !1 || o === void 0 || typeof o == "object" && o !== null && o.__v_skip)
        return;
      let l = r === "" ? s : `${r}.${s}`;
      typeof o == "object" && o !== null && o._x_interceptor ? i[s] = o.initialize(e, l, s) : t(o) && o !== i && !(o instanceof Element) && n(o, l);
    });
  };
  return n(e);
}
function Oi(e, t = () => {
}) {
  let n = {
    initialValue: void 0,
    _x_interceptor: !0,
    initialize(i, r, s) {
      return e(this.initialValue, () => Es(i, r), (o) => qt(i, r, o), r, s);
    }
  };
  return t(n), (i) => {
    if (typeof i == "object" && i !== null && i._x_interceptor) {
      let r = n.initialize.bind(n);
      n.initialize = (s, o, a) => {
        let l = i.initialize(s, o, a);
        return n.initialValue = l, r(s, o, a);
      };
    } else
      n.initialValue = i;
    return n;
  };
}
function Es(e, t) {
  return t.split(".").reduce((n, i) => n[i], e);
}
function qt(e, t, n) {
  if (typeof t == "string" && (t = t.split(".")), t.length === 1)
    e[t[0]] = n;
  else {
    if (t.length === 0)
      throw error;
    return e[t[0]] || (e[t[0]] = {}), qt(e[t[0]], t.slice(1), n);
  }
}
var $i = {};
function W(e, t) {
  $i[e] = t;
}
function Ut(e, t) {
  let n = Is(t);
  return Object.entries($i).forEach(([i, r]) => {
    Object.defineProperty(e, `$${i}`, {
      get() {
        return r(t, n);
      },
      enumerable: !1
    });
  }), e;
}
function Is(e) {
  let [t, n] = Mi(e), i = { interceptor: Oi, ...t };
  return hn(e, n), i;
}
function Ss(e, t, n, ...i) {
  try {
    return n(...i);
  } catch (r) {
    Ve(r, e, t);
  }
}
function Ve(e, t, n = void 0) {
  e = Object.assign(
    e ?? { message: "No error message given." },
    { el: t, expression: n }
  ), console.warn(`Alpine Expression Error: ${e.message}
${n ? 'Expression: "' + n + `"
` : ""}`, t), setTimeout(() => {
    throw e;
  }, 0);
}
var st = !0;
function Ni(e) {
  let t = st;
  st = !1;
  let n = e();
  return st = t, n;
}
function fe(e, t, n = {}) {
  let i;
  return k(e, t)((r) => i = r, n), i;
}
function k(...e) {
  return ki(...e);
}
var ki = Ri;
function Cs(e) {
  ki = e;
}
function Ri(e, t) {
  let n = {};
  Ut(n, e);
  let i = [n, ...xe(e)], r = typeof t == "function" ? Ts(i, t) : Os(i, t, e);
  return Ss.bind(null, e, t, r);
}
function Ts(e, t) {
  return (n = () => {
  }, { scope: i = {}, params: r = [], context: s } = {}) => {
    let o = t.apply(Ye([i, ...e]), r);
    ct(n, o);
  };
}
var Lt = {};
function As(e, t) {
  if (Lt[e])
    return Lt[e];
  let n = Object.getPrototypeOf(async function() {
  }).constructor, i = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e, s = (() => {
    try {
      let o = new n(
        ["__self", "scope"],
        `with (scope) { __self.result = ${i} }; __self.finished = true; return __self.result;`
      );
      return Object.defineProperty(o, "name", {
        value: `[Alpine] ${e}`
      }), o;
    } catch (o) {
      return Ve(o, t, e), Promise.resolve();
    }
  })();
  return Lt[e] = s, s;
}
function Os(e, t, n) {
  let i = As(t, n);
  return (r = () => {
  }, { scope: s = {}, params: o = [], context: a } = {}) => {
    i.result = void 0, i.finished = !1;
    let l = Ye([s, ...e]);
    if (typeof i == "function") {
      let c = i.call(a, i, l).catch((u) => Ve(u, n, t));
      i.finished ? (ct(r, i.result, l, o, n), i.result = void 0) : c.then((u) => {
        ct(r, u, l, o, n);
      }).catch((u) => Ve(u, n, t)).finally(() => i.result = void 0);
    }
  };
}
function ct(e, t, n, i, r) {
  if (st && typeof t == "function") {
    let s = t.apply(n, i);
    s instanceof Promise ? s.then((o) => ct(e, o, n, i)).catch((o) => Ve(o, r, t)) : e(s);
  } else typeof t == "object" && t instanceof Promise ? t.then((s) => e(s)) : e(t);
}
var yn = "x-";
function Te(e = "") {
  return yn + e;
}
function $s(e) {
  yn = e;
}
var ut = {};
function N(e, t) {
  return ut[e] = t, {
    before(n) {
      if (!ut[n]) {
        console.warn(String.raw`Cannot find directive \`${n}\`. \`${e}\` will use the default order of execution`);
        return;
      }
      const i = ue.indexOf(n);
      ue.splice(i >= 0 ? i : ue.indexOf("DEFAULT"), 0, e);
    }
  };
}
function Ns(e) {
  return Object.keys(ut).includes(e);
}
function wn(e, t, n) {
  if (t = Array.from(t), e._x_virtualDirectives) {
    let s = Object.entries(e._x_virtualDirectives).map(([a, l]) => ({ name: a, value: l })), o = Li(s);
    s = s.map((a) => o.find((l) => l.name === a.name) ? {
      name: `x-bind:${a.name}`,
      value: `"${a.value}"`
    } : a), t = t.concat(s);
  }
  let i = {};
  return t.map(Fi((s, o) => i[s] = o)).filter(ji).map(Ls(i, n)).sort(Ds).map((s) => Rs(e, s));
}
function Li(e) {
  return Array.from(e).map(Fi()).filter((t) => !ji(t));
}
var Yt = !1, Fe = /* @__PURE__ */ new Map(), Di = Symbol();
function ks(e) {
  Yt = !0;
  let t = Symbol();
  Di = t, Fe.set(t, []);
  let n = () => {
    for (; Fe.get(t).length; )
      Fe.get(t).shift()();
    Fe.delete(t);
  }, i = () => {
    Yt = !1, n();
  };
  e(n), i();
}
function Mi(e) {
  let t = [], n = (a) => t.push(a), [i, r] = ms(e);
  return t.push(r), [{
    Alpine: Ke,
    effect: i,
    cleanup: n,
    evaluateLater: k.bind(k, e),
    evaluate: fe.bind(fe, e)
  }, () => t.forEach((a) => a())];
}
function Rs(e, t) {
  let n = () => {
  }, i = ut[t.type] || n, [r, s] = Mi(e);
  Ii(e, t.original, s);
  let o = () => {
    e._x_ignore || e._x_ignoreSelf || (i.inline && i.inline(e, t, r), i = i.bind(i, e, t, r), Yt ? Fe.get(Di).push(i) : i());
  };
  return o.runCleanups = s, o;
}
var Pi = (e, t) => ({ name: n, value: i }) => (n.startsWith(e) && (n = n.replace(e, t)), { name: n, value: i }), zi = (e) => e;
function Fi(e = () => {
}) {
  return ({ name: t, value: n }) => {
    let { name: i, value: r } = Bi.reduce((s, o) => o(s), { name: t, value: n });
    return i !== t && e(i, t), { name: i, value: r };
  };
}
var Bi = [];
function _n(e) {
  Bi.push(e);
}
function ji({ name: e }) {
  return Vi().test(e);
}
var Vi = () => new RegExp(`^${yn}([^:^.]+)\\b`);
function Ls(e, t) {
  return ({ name: n, value: i }) => {
    let r = n.match(Vi()), s = n.match(/:([a-zA-Z0-9\-_:]+)/), o = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], a = t || e[n] || n;
    return {
      type: r ? r[1] : null,
      value: s ? s[1] : null,
      modifiers: o.map((l) => l.replace(".", "")),
      expression: i,
      original: a
    };
  };
}
var Kt = "DEFAULT", ue = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  Kt,
  "teleport"
];
function Ds(e, t) {
  let n = ue.indexOf(e.type) === -1 ? Kt : e.type, i = ue.indexOf(t.type) === -1 ? Kt : t.type;
  return ue.indexOf(n) - ue.indexOf(i);
}
function Be(e, t, n = {}) {
  e.dispatchEvent(
    new CustomEvent(t, {
      detail: n,
      bubbles: !0,
      // Allows events to pass the shadow DOM barrier.
      composed: !0,
      cancelable: !0
    })
  );
}
function ge(e, t) {
  if (typeof ShadowRoot == "function" && e instanceof ShadowRoot) {
    Array.from(e.children).forEach((r) => ge(r, t));
    return;
  }
  let n = !1;
  if (t(e, () => n = !0), n)
    return;
  let i = e.firstElementChild;
  for (; i; )
    ge(i, t), i = i.nextElementSibling;
}
function F(e, ...t) {
  console.warn(`Alpine Warning: ${e}`, ...t);
}
var zn = !1;
function Ms() {
  zn && F("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), zn = !0, document.body || F("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), Be(document, "alpine:init"), Be(document, "alpine:initializing"), gn(), gs((t) => G(t, ge)), hn((t) => Oe(t)), Ei((t, n) => {
    wn(t, n).forEach((i) => i());
  });
  let e = (t) => !xt(t.parentElement, !0);
  Array.from(document.querySelectorAll(qi().join(","))).filter(e).forEach((t) => {
    G(t);
  }), Be(document, "alpine:initialized"), setTimeout(() => {
    Bs();
  });
}
var xn = [], Hi = [];
function Wi() {
  return xn.map((e) => e());
}
function qi() {
  return xn.concat(Hi).map((e) => e());
}
function Ui(e) {
  xn.push(e);
}
function Yi(e) {
  Hi.push(e);
}
function xt(e, t = !1) {
  return Ae(e, (n) => {
    if ((t ? qi() : Wi()).some((r) => n.matches(r)))
      return !0;
  });
}
function Ae(e, t) {
  if (e) {
    if (t(e))
      return e;
    if (e._x_teleportBack && (e = e._x_teleportBack), !!e.parentElement)
      return Ae(e.parentElement, t);
  }
}
function Ps(e) {
  return Wi().some((t) => e.matches(t));
}
var Ki = [];
function zs(e) {
  Ki.push(e);
}
var Fs = 1;
function G(e, t = ge, n = () => {
}) {
  Ae(e, (i) => i._x_ignore) || ks(() => {
    t(e, (i, r) => {
      i._x_marker || (n(i, r), Ki.forEach((s) => s(i, r)), wn(i, i.attributes).forEach((s) => s()), i._x_ignore || (i._x_marker = Fs++), i._x_ignore && r());
    });
  });
}
function Oe(e, t = ge) {
  t(e, (n) => {
    vs(n), Si(n), delete n._x_marker;
  });
}
function Bs() {
  [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ].forEach(([t, n, i]) => {
    Ns(n) || i.some((r) => {
      if (document.querySelector(r))
        return F(`found "${r}", but missing ${t} plugin`), !0;
    });
  });
}
var Jt = [], En = !1;
function In(e = () => {
}) {
  return queueMicrotask(() => {
    En || setTimeout(() => {
      Gt();
    });
  }), new Promise((t) => {
    Jt.push(() => {
      e(), t();
    });
  });
}
function Gt() {
  for (En = !1; Jt.length; )
    Jt.shift()();
}
function js() {
  En = !0;
}
function Sn(e, t) {
  return Array.isArray(t) ? Fn(e, t.join(" ")) : typeof t == "object" && t !== null ? Vs(e, t) : typeof t == "function" ? Sn(e, t()) : Fn(e, t);
}
function Fn(e, t) {
  let n = (r) => r.split(" ").filter((s) => !e.classList.contains(s)).filter(Boolean), i = (r) => (e.classList.add(...r), () => {
    e.classList.remove(...r);
  });
  return t = t === !0 ? t = "" : t || "", i(n(t));
}
function Vs(e, t) {
  let n = (a) => a.split(" ").filter(Boolean), i = Object.entries(t).flatMap(([a, l]) => l ? n(a) : !1).filter(Boolean), r = Object.entries(t).flatMap(([a, l]) => l ? !1 : n(a)).filter(Boolean), s = [], o = [];
  return r.forEach((a) => {
    e.classList.contains(a) && (e.classList.remove(a), o.push(a));
  }), i.forEach((a) => {
    e.classList.contains(a) || (e.classList.add(a), s.push(a));
  }), () => {
    o.forEach((a) => e.classList.add(a)), s.forEach((a) => e.classList.remove(a));
  };
}
function Et(e, t) {
  return typeof t == "object" && t !== null ? Hs(e, t) : Ws(e, t);
}
function Hs(e, t) {
  let n = {};
  return Object.entries(t).forEach(([i, r]) => {
    n[i] = e.style[i], i.startsWith("--") || (i = qs(i)), e.style.setProperty(i, r);
  }), setTimeout(() => {
    e.style.length === 0 && e.removeAttribute("style");
  }), () => {
    Et(e, n);
  };
}
function Ws(e, t) {
  let n = e.getAttribute("style", t);
  return e.setAttribute("style", t), () => {
    e.setAttribute("style", n || "");
  };
}
function qs(e) {
  return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function Zt(e, t = () => {
}) {
  let n = !1;
  return function() {
    n ? t.apply(this, arguments) : (n = !0, e.apply(this, arguments));
  };
}
N("transition", (e, { value: t, modifiers: n, expression: i }, { evaluate: r }) => {
  typeof i == "function" && (i = r(i)), i !== !1 && (!i || typeof i == "boolean" ? Ys(e, n, t) : Us(e, i, t));
});
function Us(e, t, n) {
  Ji(e, Sn, ""), {
    enter: (r) => {
      e._x_transition.enter.during = r;
    },
    "enter-start": (r) => {
      e._x_transition.enter.start = r;
    },
    "enter-end": (r) => {
      e._x_transition.enter.end = r;
    },
    leave: (r) => {
      e._x_transition.leave.during = r;
    },
    "leave-start": (r) => {
      e._x_transition.leave.start = r;
    },
    "leave-end": (r) => {
      e._x_transition.leave.end = r;
    }
  }[n](t);
}
function Ys(e, t, n) {
  Ji(e, Et);
  let i = !t.includes("in") && !t.includes("out") && !n, r = i || t.includes("in") || ["enter"].includes(n), s = i || t.includes("out") || ["leave"].includes(n);
  t.includes("in") && !i && (t = t.filter((g, h) => h < t.indexOf("out"))), t.includes("out") && !i && (t = t.filter((g, h) => h > t.indexOf("out")));
  let o = !t.includes("opacity") && !t.includes("scale"), a = o || t.includes("opacity"), l = o || t.includes("scale"), c = a ? 0 : 1, u = l ? ke(t, "scale", 95) / 100 : 1, d = ke(t, "delay", 0) / 1e3, f = ke(t, "origin", "center"), v = "opacity, transform", x = ke(t, "duration", 150) / 1e3, w = ke(t, "duration", 75) / 1e3, p = "cubic-bezier(0.4, 0.0, 0.2, 1)";
  r && (e._x_transition.enter.during = {
    transformOrigin: f,
    transitionDelay: `${d}s`,
    transitionProperty: v,
    transitionDuration: `${x}s`,
    transitionTimingFunction: p
  }, e._x_transition.enter.start = {
    opacity: c,
    transform: `scale(${u})`
  }, e._x_transition.enter.end = {
    opacity: 1,
    transform: "scale(1)"
  }), s && (e._x_transition.leave.during = {
    transformOrigin: f,
    transitionDelay: `${d}s`,
    transitionProperty: v,
    transitionDuration: `${w}s`,
    transitionTimingFunction: p
  }, e._x_transition.leave.start = {
    opacity: 1,
    transform: "scale(1)"
  }, e._x_transition.leave.end = {
    opacity: c,
    transform: `scale(${u})`
  });
}
function Ji(e, t, n = {}) {
  e._x_transition || (e._x_transition = {
    enter: { during: n, start: n, end: n },
    leave: { during: n, start: n, end: n },
    in(i = () => {
    }, r = () => {
    }) {
      Xt(e, t, {
        during: this.enter.during,
        start: this.enter.start,
        end: this.enter.end
      }, i, r);
    },
    out(i = () => {
    }, r = () => {
    }) {
      Xt(e, t, {
        during: this.leave.during,
        start: this.leave.start,
        end: this.leave.end
      }, i, r);
    }
  });
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(e, t, n, i) {
  const r = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let s = () => r(n);
  if (t) {
    e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(n) : s() : e._x_transition ? e._x_transition.in(n) : s();
    return;
  }
  e._x_hidePromise = e._x_transition ? new Promise((o, a) => {
    e._x_transition.out(() => {
    }, () => o(i)), e._x_transitioning && e._x_transitioning.beforeCancel(() => a({ isFromCancelledTransition: !0 }));
  }) : Promise.resolve(i), queueMicrotask(() => {
    let o = Gi(e);
    o ? (o._x_hideChildren || (o._x_hideChildren = []), o._x_hideChildren.push(e)) : r(() => {
      let a = (l) => {
        let c = Promise.all([
          l._x_hidePromise,
          ...(l._x_hideChildren || []).map(a)
        ]).then(([u]) => u?.());
        return delete l._x_hidePromise, delete l._x_hideChildren, c;
      };
      a(e).catch((l) => {
        if (!l.isFromCancelledTransition)
          throw l;
      });
    });
  });
};
function Gi(e) {
  let t = e.parentNode;
  if (t)
    return t._x_hidePromise ? t : Gi(t);
}
function Xt(e, t, { during: n, start: i, end: r } = {}, s = () => {
}, o = () => {
}) {
  if (e._x_transitioning && e._x_transitioning.cancel(), Object.keys(n).length === 0 && Object.keys(i).length === 0 && Object.keys(r).length === 0) {
    s(), o();
    return;
  }
  let a, l, c;
  Ks(e, {
    start() {
      a = t(e, i);
    },
    during() {
      l = t(e, n);
    },
    before: s,
    end() {
      a(), c = t(e, r);
    },
    after: o,
    cleanup() {
      l(), c();
    }
  });
}
function Ks(e, t) {
  let n, i, r, s = Zt(() => {
    $(() => {
      n = !0, i || t.before(), r || (t.end(), Gt()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning;
    });
  });
  e._x_transitioning = {
    beforeCancels: [],
    beforeCancel(o) {
      this.beforeCancels.push(o);
    },
    cancel: Zt(function() {
      for (; this.beforeCancels.length; )
        this.beforeCancels.shift()();
      s();
    }),
    finish: s
  }, $(() => {
    t.start(), t.during();
  }), js(), requestAnimationFrame(() => {
    if (n)
      return;
    let o = Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, a = Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    o === 0 && (o = Number(getComputedStyle(e).animationDuration.replace("s", "")) * 1e3), $(() => {
      t.before();
    }), i = !0, requestAnimationFrame(() => {
      n || ($(() => {
        t.end();
      }), Gt(), setTimeout(e._x_transitioning.finish, o + a), r = !0);
    });
  });
}
function ke(e, t, n) {
  if (e.indexOf(t) === -1)
    return n;
  const i = e[e.indexOf(t) + 1];
  if (!i || t === "scale" && isNaN(i))
    return n;
  if (t === "duration" || t === "delay") {
    let r = i.match(/([0-9]+)ms/);
    if (r)
      return r[1];
  }
  return t === "origin" && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [i, e[e.indexOf(t) + 2]].join(" ") : i;
}
var ie = !1;
function oe(e, t = () => {
}) {
  return (...n) => ie ? t(...n) : e(...n);
}
function Js(e) {
  return (...t) => ie && e(...t);
}
var Zi = [];
function It(e) {
  Zi.push(e);
}
function Gs(e, t) {
  Zi.forEach((n) => n(e, t)), ie = !0, Xi(() => {
    G(t, (n, i) => {
      i(n, () => {
      });
    });
  }), ie = !1;
}
var Qt = !1;
function Zs(e, t) {
  t._x_dataStack || (t._x_dataStack = e._x_dataStack), ie = !0, Qt = !0, Xi(() => {
    Xs(t);
  }), ie = !1, Qt = !1;
}
function Xs(e) {
  let t = !1;
  G(e, (i, r) => {
    ge(i, (s, o) => {
      if (t && Ps(s))
        return o();
      t = !0, r(s, o);
    });
  });
}
function Xi(e) {
  let t = ye;
  Pn((n, i) => {
    let r = t(n);
    return Ce(r), () => {
    };
  }), e(), Pn(t);
}
function Qi(e, t, n, i = []) {
  switch (e._x_bindings || (e._x_bindings = Se({})), e._x_bindings[t] = n, t = i.includes("camel") ? oo(t) : t, t) {
    case "value":
      Qs(e, n);
      break;
    case "style":
      to(e, n);
      break;
    case "class":
      eo(e, n);
      break;
    case "selected":
    case "checked":
      no(e, t, n);
      break;
    default:
      er(e, t, n);
      break;
  }
}
function Qs(e, t) {
  if (ir(e))
    e.attributes.value === void 0 && (e.value = t), window.fromModel && (typeof t == "boolean" ? e.checked = ot(e.value) === t : e.checked = Bn(e.value, t));
  else if (Cn(e))
    Number.isInteger(t) ? e.value = t : !Array.isArray(t) && typeof t != "boolean" && ![null, void 0].includes(t) ? e.value = String(t) : Array.isArray(t) ? e.checked = t.some((n) => Bn(n, e.value)) : e.checked = !!t;
  else if (e.tagName === "SELECT")
    so(e, t);
  else {
    if (e.value === t)
      return;
    e.value = t === void 0 ? "" : t;
  }
}
function eo(e, t) {
  e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedClasses = Sn(e, t);
}
function to(e, t) {
  e._x_undoAddedStyles && e._x_undoAddedStyles(), e._x_undoAddedStyles = Et(e, t);
}
function no(e, t, n) {
  er(e, t, n), ro(e, t, n);
}
function er(e, t, n) {
  [null, void 0, !1].includes(n) && lo(t) ? e.removeAttribute(t) : (tr(t) && (n = t), io(e, t, n));
}
function io(e, t, n) {
  e.getAttribute(t) != n && e.setAttribute(t, n);
}
function ro(e, t, n) {
  e[t] !== n && (e[t] = n);
}
function so(e, t) {
  const n = [].concat(t).map((i) => i + "");
  Array.from(e.options).forEach((i) => {
    i.selected = n.includes(i.value);
  });
}
function oo(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase());
}
function Bn(e, t) {
  return e == t;
}
function ot(e) {
  return [1, "1", "true", "on", "yes", !0].includes(e) ? !0 : [0, "0", "false", "off", "no", !1].includes(e) ? !1 : e ? !!e : null;
}
var ao = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function tr(e) {
  return ao.has(e);
}
function lo(e) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e);
}
function co(e, t, n) {
  return e._x_bindings && e._x_bindings[t] !== void 0 ? e._x_bindings[t] : nr(e, t, n);
}
function uo(e, t, n, i = !0) {
  if (e._x_bindings && e._x_bindings[t] !== void 0)
    return e._x_bindings[t];
  if (e._x_inlineBindings && e._x_inlineBindings[t] !== void 0) {
    let r = e._x_inlineBindings[t];
    return r.extract = i, Ni(() => fe(e, r.expression));
  }
  return nr(e, t, n);
}
function nr(e, t, n) {
  let i = e.getAttribute(t);
  return i === null ? typeof n == "function" ? n() : n : i === "" ? !0 : tr(t) ? !![t, "true"].includes(i) : i;
}
function Cn(e) {
  return e.type === "checkbox" || e.localName === "ui-checkbox" || e.localName === "ui-switch";
}
function ir(e) {
  return e.type === "radio" || e.localName === "ui-radio";
}
function rr(e, t) {
  let n;
  return function() {
    const i = this, r = arguments, s = function() {
      n = null, e.apply(i, r);
    };
    clearTimeout(n), n = setTimeout(s, t);
  };
}
function sr(e, t) {
  let n;
  return function() {
    let i = this, r = arguments;
    n || (e.apply(i, r), n = !0, setTimeout(() => n = !1, t));
  };
}
function or({ get: e, set: t }, { get: n, set: i }) {
  let r = !0, s, o = ye(() => {
    let a = e(), l = n();
    if (r)
      i(Dt(a)), r = !1;
    else {
      let c = JSON.stringify(a), u = JSON.stringify(l);
      c !== s ? i(Dt(a)) : c !== u && t(Dt(l));
    }
    s = JSON.stringify(e()), JSON.stringify(n());
  });
  return () => {
    Ce(o);
  };
}
function Dt(e) {
  return typeof e == "object" ? JSON.parse(JSON.stringify(e)) : e;
}
function fo(e) {
  (Array.isArray(e) ? e : [e]).forEach((n) => n(Ke));
}
var le = {}, jn = !1;
function ho(e, t) {
  if (jn || (le = Se(le), jn = !0), t === void 0)
    return le[e];
  le[e] = t, Ai(le[e]), typeof t == "object" && t !== null && t.hasOwnProperty("init") && typeof t.init == "function" && le[e].init();
}
function po() {
  return le;
}
var ar = {};
function mo(e, t) {
  let n = typeof t != "function" ? () => t : t;
  return e instanceof Element ? lr(e, n()) : (ar[e] = n, () => {
  });
}
function go(e) {
  return Object.entries(ar).forEach(([t, n]) => {
    Object.defineProperty(e, t, {
      get() {
        return (...i) => n(...i);
      }
    });
  }), e;
}
function lr(e, t, n) {
  let i = [];
  for (; i.length; )
    i.pop()();
  let r = Object.entries(t).map(([o, a]) => ({ name: o, value: a })), s = Li(r);
  return r = r.map((o) => s.find((a) => a.name === o.name) ? {
    name: `x-bind:${o.name}`,
    value: `"${o.value}"`
  } : o), wn(e, r, n).map((o) => {
    i.push(o.runCleanups), o();
  }), () => {
    for (; i.length; )
      i.pop()();
  };
}
var cr = {};
function vo(e, t) {
  cr[e] = t;
}
function bo(e, t) {
  return Object.entries(cr).forEach(([n, i]) => {
    Object.defineProperty(e, n, {
      get() {
        return (...r) => i.bind(t)(...r);
      },
      enumerable: !1
    });
  }), e;
}
var yo = {
  get reactive() {
    return Se;
  },
  get release() {
    return Ce;
  },
  get effect() {
    return ye;
  },
  get raw() {
    return bi;
  },
  version: "3.15.0",
  flushAndStopDeferringMutations: ws,
  dontAutoEvaluateFunctions: Ni,
  disableEffectScheduling: hs,
  startObservingMutations: gn,
  stopObservingMutations: Ci,
  setReactivityEngine: ps,
  onAttributeRemoved: Ii,
  onAttributesAdded: Ei,
  closestDataStack: xe,
  skipDuringClone: oe,
  onlyDuringClone: Js,
  addRootSelector: Ui,
  addInitSelector: Yi,
  interceptClone: It,
  addScopeToNode: Ue,
  deferMutations: ys,
  mapAttributes: _n,
  evaluateLater: k,
  interceptInit: zs,
  setEvaluator: Cs,
  mergeProxies: Ye,
  extractProp: uo,
  findClosest: Ae,
  onElRemoved: hn,
  closestRoot: xt,
  destroyTree: Oe,
  interceptor: Oi,
  // INTERNAL: not public API and is subject to change without major release.
  transition: Xt,
  // INTERNAL
  setStyles: Et,
  // INTERNAL
  mutateDom: $,
  directive: N,
  entangle: or,
  throttle: sr,
  debounce: rr,
  evaluate: fe,
  initTree: G,
  nextTick: In,
  prefixed: Te,
  prefix: $s,
  plugin: fo,
  magic: W,
  store: ho,
  start: Ms,
  clone: Zs,
  // INTERNAL
  cloneNode: Gs,
  // INTERNAL
  bound: co,
  $data: Ti,
  watch: yi,
  walk: ge,
  data: vo,
  bind: mo
}, Ke = yo;
function wo(e, t) {
  const n = /* @__PURE__ */ Object.create(null), i = e.split(",");
  for (let r = 0; r < i.length; r++)
    n[i[r]] = !0;
  return (r) => !!n[r];
}
var _o = Object.freeze({}), xo = Object.prototype.hasOwnProperty, St = (e, t) => xo.call(e, t), he = Array.isArray, je = (e) => ur(e) === "[object Map]", Eo = (e) => typeof e == "string", Tn = (e) => typeof e == "symbol", Ct = (e) => e !== null && typeof e == "object", Io = Object.prototype.toString, ur = (e) => Io.call(e), dr = (e) => ur(e).slice(8, -1), An = (e) => Eo(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, So = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, Co = So((e) => e.charAt(0).toUpperCase() + e.slice(1)), fr = (e, t) => e !== t && (e === e || t === t), en = /* @__PURE__ */ new WeakMap(), Re = [], Y, pe = Symbol("iterate"), tn = Symbol("Map key iterate");
function To(e) {
  return e && e._isEffect === !0;
}
function Ao(e, t = _o) {
  To(e) && (e = e.raw);
  const n = No(e, t);
  return t.lazy || n(), n;
}
function Oo(e) {
  e.active && (hr(e), e.options.onStop && e.options.onStop(), e.active = !1);
}
var $o = 0;
function No(e, t) {
  const n = function() {
    if (!n.active)
      return e();
    if (!Re.includes(n)) {
      hr(n);
      try {
        return Ro(), Re.push(n), Y = n, e();
      } finally {
        Re.pop(), pr(), Y = Re[Re.length - 1];
      }
    }
  };
  return n.id = $o++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n;
}
function hr(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0;
  }
}
var Ee = !0, On = [];
function ko() {
  On.push(Ee), Ee = !1;
}
function Ro() {
  On.push(Ee), Ee = !0;
}
function pr() {
  const e = On.pop();
  Ee = e === void 0 ? !0 : e;
}
function j(e, t, n) {
  if (!Ee || Y === void 0)
    return;
  let i = en.get(e);
  i || en.set(e, i = /* @__PURE__ */ new Map());
  let r = i.get(n);
  r || i.set(n, r = /* @__PURE__ */ new Set()), r.has(Y) || (r.add(Y), Y.deps.push(r), Y.options.onTrack && Y.options.onTrack({
    effect: Y,
    target: e,
    type: t,
    key: n
  }));
}
function re(e, t, n, i, r, s) {
  const o = en.get(e);
  if (!o)
    return;
  const a = /* @__PURE__ */ new Set(), l = (u) => {
    u && u.forEach((d) => {
      (d !== Y || d.allowRecurse) && a.add(d);
    });
  };
  if (t === "clear")
    o.forEach(l);
  else if (n === "length" && he(e))
    o.forEach((u, d) => {
      (d === "length" || d >= i) && l(u);
    });
  else
    switch (n !== void 0 && l(o.get(n)), t) {
      case "add":
        he(e) ? An(n) && l(o.get("length")) : (l(o.get(pe)), je(e) && l(o.get(tn)));
        break;
      case "delete":
        he(e) || (l(o.get(pe)), je(e) && l(o.get(tn)));
        break;
      case "set":
        je(e) && l(o.get(pe));
        break;
    }
  const c = (u) => {
    u.options.onTrigger && u.options.onTrigger({
      effect: u,
      target: e,
      key: n,
      type: t,
      newValue: i,
      oldValue: r,
      oldTarget: s
    }), u.options.scheduler ? u.options.scheduler(u) : u();
  };
  a.forEach(c);
}
var Lo = /* @__PURE__ */ wo("__proto__,__v_isRef,__isVue"), mr = new Set(Object.getOwnPropertyNames(Symbol).map((e) => Symbol[e]).filter(Tn)), Do = /* @__PURE__ */ gr(), Mo = /* @__PURE__ */ gr(!0), Vn = /* @__PURE__ */ Po();
function Po() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...n) {
      const i = O(this);
      for (let s = 0, o = this.length; s < o; s++)
        j(i, "get", s + "");
      const r = i[t](...n);
      return r === -1 || r === !1 ? i[t](...n.map(O)) : r;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...n) {
      ko();
      const i = O(this)[t].apply(this, n);
      return pr(), i;
    };
  }), e;
}
function gr(e = !1, t = !1) {
  return function(i, r, s) {
    if (r === "__v_isReactive")
      return !e;
    if (r === "__v_isReadonly")
      return e;
    if (r === "__v_raw" && s === (e ? t ? Zo : wr : t ? Go : yr).get(i))
      return i;
    const o = he(i);
    if (!e && o && St(Vn, r))
      return Reflect.get(Vn, r, s);
    const a = Reflect.get(i, r, s);
    return (Tn(r) ? mr.has(r) : Lo(r)) || (e || j(i, "get", r), t) ? a : nn(a) ? !o || !An(r) ? a.value : a : Ct(a) ? e ? _r(a) : Rn(a) : a;
  };
}
var zo = /* @__PURE__ */ Fo();
function Fo(e = !1) {
  return function(n, i, r, s) {
    let o = n[i];
    if (!e && (r = O(r), o = O(o), !he(n) && nn(o) && !nn(r)))
      return o.value = r, !0;
    const a = he(n) && An(i) ? Number(i) < n.length : St(n, i), l = Reflect.set(n, i, r, s);
    return n === O(s) && (a ? fr(r, o) && re(n, "set", i, r, o) : re(n, "add", i, r)), l;
  };
}
function Bo(e, t) {
  const n = St(e, t), i = e[t], r = Reflect.deleteProperty(e, t);
  return r && n && re(e, "delete", t, void 0, i), r;
}
function jo(e, t) {
  const n = Reflect.has(e, t);
  return (!Tn(t) || !mr.has(t)) && j(e, "has", t), n;
}
function Vo(e) {
  return j(e, "iterate", he(e) ? "length" : pe), Reflect.ownKeys(e);
}
var Ho = {
  get: Do,
  set: zo,
  deleteProperty: Bo,
  has: jo,
  ownKeys: Vo
}, Wo = {
  get: Mo,
  set(e, t) {
    return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  },
  deleteProperty(e, t) {
    return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  }
}, $n = (e) => Ct(e) ? Rn(e) : e, Nn = (e) => Ct(e) ? _r(e) : e, kn = (e) => e, Tt = (e) => Reflect.getPrototypeOf(e);
function Ge(e, t, n = !1, i = !1) {
  e = e.__v_raw;
  const r = O(e), s = O(t);
  t !== s && !n && j(r, "get", t), !n && j(r, "get", s);
  const { has: o } = Tt(r), a = i ? kn : n ? Nn : $n;
  if (o.call(r, t))
    return a(e.get(t));
  if (o.call(r, s))
    return a(e.get(s));
  e !== r && e.get(t);
}
function Ze(e, t = !1) {
  const n = this.__v_raw, i = O(n), r = O(e);
  return e !== r && !t && j(i, "has", e), !t && j(i, "has", r), e === r ? n.has(e) : n.has(e) || n.has(r);
}
function Xe(e, t = !1) {
  return e = e.__v_raw, !t && j(O(e), "iterate", pe), Reflect.get(e, "size", e);
}
function Hn(e) {
  e = O(e);
  const t = O(this);
  return Tt(t).has.call(t, e) || (t.add(e), re(t, "add", e, e)), this;
}
function Wn(e, t) {
  t = O(t);
  const n = O(this), { has: i, get: r } = Tt(n);
  let s = i.call(n, e);
  s ? br(n, i, e) : (e = O(e), s = i.call(n, e));
  const o = r.call(n, e);
  return n.set(e, t), s ? fr(t, o) && re(n, "set", e, t, o) : re(n, "add", e, t), this;
}
function qn(e) {
  const t = O(this), { has: n, get: i } = Tt(t);
  let r = n.call(t, e);
  r ? br(t, n, e) : (e = O(e), r = n.call(t, e));
  const s = i ? i.call(t, e) : void 0, o = t.delete(e);
  return r && re(t, "delete", e, void 0, s), o;
}
function Un() {
  const e = O(this), t = e.size !== 0, n = je(e) ? new Map(e) : new Set(e), i = e.clear();
  return t && re(e, "clear", void 0, void 0, n), i;
}
function Qe(e, t) {
  return function(i, r) {
    const s = this, o = s.__v_raw, a = O(o), l = t ? kn : e ? Nn : $n;
    return !e && j(a, "iterate", pe), o.forEach((c, u) => i.call(r, l(c), l(u), s));
  };
}
function et(e, t, n) {
  return function(...i) {
    const r = this.__v_raw, s = O(r), o = je(s), a = e === "entries" || e === Symbol.iterator && o, l = e === "keys" && o, c = r[e](...i), u = n ? kn : t ? Nn : $n;
    return !t && j(s, "iterate", l ? tn : pe), {
      // iterator protocol
      next() {
        const { value: d, done: f } = c.next();
        return f ? { value: d, done: f } : {
          value: a ? [u(d[0]), u(d[1])] : u(d),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function ee(e) {
  return function(...t) {
    {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(`${Co(e)} operation ${n}failed: target is readonly.`, O(this));
    }
    return e === "delete" ? !1 : this;
  };
}
function qo() {
  const e = {
    get(s) {
      return Ge(this, s);
    },
    get size() {
      return Xe(this);
    },
    has: Ze,
    add: Hn,
    set: Wn,
    delete: qn,
    clear: Un,
    forEach: Qe(!1, !1)
  }, t = {
    get(s) {
      return Ge(this, s, !1, !0);
    },
    get size() {
      return Xe(this);
    },
    has: Ze,
    add: Hn,
    set: Wn,
    delete: qn,
    clear: Un,
    forEach: Qe(!1, !0)
  }, n = {
    get(s) {
      return Ge(this, s, !0);
    },
    get size() {
      return Xe(this, !0);
    },
    has(s) {
      return Ze.call(this, s, !0);
    },
    add: ee(
      "add"
      /* ADD */
    ),
    set: ee(
      "set"
      /* SET */
    ),
    delete: ee(
      "delete"
      /* DELETE */
    ),
    clear: ee(
      "clear"
      /* CLEAR */
    ),
    forEach: Qe(!0, !1)
  }, i = {
    get(s) {
      return Ge(this, s, !0, !0);
    },
    get size() {
      return Xe(this, !0);
    },
    has(s) {
      return Ze.call(this, s, !0);
    },
    add: ee(
      "add"
      /* ADD */
    ),
    set: ee(
      "set"
      /* SET */
    ),
    delete: ee(
      "delete"
      /* DELETE */
    ),
    clear: ee(
      "clear"
      /* CLEAR */
    ),
    forEach: Qe(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = et(s, !1, !1), n[s] = et(s, !0, !1), t[s] = et(s, !1, !0), i[s] = et(s, !0, !0);
  }), [
    e,
    n,
    t,
    i
  ];
}
var [Uo, Yo, Mc, Pc] = /* @__PURE__ */ qo();
function vr(e, t) {
  const n = e ? Yo : Uo;
  return (i, r, s) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? i : Reflect.get(St(n, r) && r in i ? n : i, r, s);
}
var Ko = {
  get: /* @__PURE__ */ vr(!1)
}, Jo = {
  get: /* @__PURE__ */ vr(!0)
};
function br(e, t, n) {
  const i = O(n);
  if (i !== n && t.call(e, i)) {
    const r = dr(e);
    console.warn(`Reactive ${r} contains both the raw and reactive versions of the same object${r === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var yr = /* @__PURE__ */ new WeakMap(), Go = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), Zo = /* @__PURE__ */ new WeakMap();
function Xo(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Qo(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Xo(dr(e));
}
function Rn(e) {
  return e && e.__v_isReadonly ? e : xr(e, !1, Ho, Ko, yr);
}
function _r(e) {
  return xr(e, !0, Wo, Jo, wr);
}
function xr(e, t, n, i, r) {
  if (!Ct(e))
    return console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = r.get(e);
  if (s)
    return s;
  const o = Qo(e);
  if (o === 0)
    return e;
  const a = new Proxy(e, o === 2 ? i : n);
  return r.set(e, a), a;
}
function O(e) {
  return e && O(e.__v_raw) || e;
}
function nn(e) {
  return !!(e && e.__v_isRef === !0);
}
W("nextTick", () => In);
W("dispatch", (e) => Be.bind(Be, e));
W("watch", (e, { evaluateLater: t, cleanup: n }) => (i, r) => {
  let s = t(i), a = yi(() => {
    let l;
    return s((c) => l = c), l;
  }, r);
  n(a);
});
W("store", po);
W("data", (e) => Ti(e));
W("root", (e) => xt(e));
W("refs", (e) => (e._x_refs_proxy || (e._x_refs_proxy = Ye(ea(e))), e._x_refs_proxy));
function ea(e) {
  let t = [];
  return Ae(e, (n) => {
    n._x_refs && t.push(n._x_refs);
  }), t;
}
var Mt = {};
function Er(e) {
  return Mt[e] || (Mt[e] = 0), ++Mt[e];
}
function ta(e, t) {
  return Ae(e, (n) => {
    if (n._x_ids && n._x_ids[t])
      return !0;
  });
}
function na(e, t) {
  e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = Er(t));
}
W("id", (e, { cleanup: t }) => (n, i = null) => {
  let r = `${n}${i ? `-${i}` : ""}`;
  return ia(e, r, t, () => {
    let s = ta(e, n), o = s ? s._x_ids[n] : Er(n);
    return i ? `${n}-${o}-${i}` : `${n}-${o}`;
  });
});
It((e, t) => {
  e._x_id && (t._x_id = e._x_id);
});
function ia(e, t, n, i) {
  if (e._x_id || (e._x_id = {}), e._x_id[t])
    return e._x_id[t];
  let r = i();
  return e._x_id[t] = r, n(() => {
    delete e._x_id[t];
  }), r;
}
W("el", (e) => e);
Ir("Focus", "focus", "focus");
Ir("Persist", "persist", "persist");
function Ir(e, t, n) {
  W(t, (i) => F(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, i));
}
N("modelable", (e, { expression: t }, { effect: n, evaluateLater: i, cleanup: r }) => {
  let s = i(t), o = () => {
    let u;
    return s((d) => u = d), u;
  }, a = i(`${t} = __placeholder`), l = (u) => a(() => {
  }, { scope: { __placeholder: u } }), c = o();
  l(c), queueMicrotask(() => {
    if (!e._x_model)
      return;
    e._x_removeModelListeners.default();
    let u = e._x_model.get, d = e._x_model.set, f = or(
      {
        get() {
          return u();
        },
        set(v) {
          d(v);
        }
      },
      {
        get() {
          return o();
        },
        set(v) {
          l(v);
        }
      }
    );
    r(f);
  });
});
N("teleport", (e, { modifiers: t, expression: n }, { cleanup: i }) => {
  e.tagName.toLowerCase() !== "template" && F("x-teleport can only be used on a <template> tag", e);
  let r = Yn(n), s = e.content.cloneNode(!0).firstElementChild;
  e._x_teleport = s, s._x_teleportBack = e, e.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), e._x_forwardEvents && e._x_forwardEvents.forEach((a) => {
    s.addEventListener(a, (l) => {
      l.stopPropagation(), e.dispatchEvent(new l.constructor(l.type, l));
    });
  }), Ue(s, {}, e);
  let o = (a, l, c) => {
    c.includes("prepend") ? l.parentNode.insertBefore(a, l) : c.includes("append") ? l.parentNode.insertBefore(a, l.nextSibling) : l.appendChild(a);
  };
  $(() => {
    o(s, r, t), oe(() => {
      G(s);
    })();
  }), e._x_teleportPutBack = () => {
    let a = Yn(n);
    $(() => {
      o(e._x_teleport, a, t);
    });
  }, i(
    () => $(() => {
      s.remove(), Oe(s);
    })
  );
});
var ra = document.createElement("div");
function Yn(e) {
  let t = oe(() => document.querySelector(e), () => ra)();
  return t || F(`Cannot find x-teleport element for selector: "${e}"`), t;
}
var Sr = () => {
};
Sr.inline = (e, { modifiers: t }, { cleanup: n }) => {
  t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, n(() => {
    t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore;
  });
};
N("ignore", Sr);
N("effect", oe((e, { expression: t }, { effect: n }) => {
  n(k(e, t));
}));
function rn(e, t, n, i) {
  let r = e, s = (l) => i(l), o = {}, a = (l, c) => (u) => c(l, u);
  if (n.includes("dot") && (t = sa(t)), n.includes("camel") && (t = oa(t)), n.includes("passive") && (o.passive = !0), n.includes("capture") && (o.capture = !0), n.includes("window") && (r = window), n.includes("document") && (r = document), n.includes("debounce")) {
    let l = n[n.indexOf("debounce") + 1] || "invalid-wait", c = dt(l.split("ms")[0]) ? Number(l.split("ms")[0]) : 250;
    s = rr(s, c);
  }
  if (n.includes("throttle")) {
    let l = n[n.indexOf("throttle") + 1] || "invalid-wait", c = dt(l.split("ms")[0]) ? Number(l.split("ms")[0]) : 250;
    s = sr(s, c);
  }
  return n.includes("prevent") && (s = a(s, (l, c) => {
    c.preventDefault(), l(c);
  })), n.includes("stop") && (s = a(s, (l, c) => {
    c.stopPropagation(), l(c);
  })), n.includes("once") && (s = a(s, (l, c) => {
    l(c), r.removeEventListener(t, s, o);
  })), (n.includes("away") || n.includes("outside")) && (r = document, s = a(s, (l, c) => {
    e.contains(c.target) || c.target.isConnected !== !1 && (e.offsetWidth < 1 && e.offsetHeight < 1 || e._x_isShown !== !1 && l(c));
  })), n.includes("self") && (s = a(s, (l, c) => {
    c.target === e && l(c);
  })), (la(t) || Cr(t)) && (s = a(s, (l, c) => {
    ca(c, n) || l(c);
  })), r.addEventListener(t, s, o), () => {
    r.removeEventListener(t, s, o);
  };
}
function sa(e) {
  return e.replace(/-/g, ".");
}
function oa(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase());
}
function dt(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function aa(e) {
  return [" ", "_"].includes(
    e
  ) ? e : e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function la(e) {
  return ["keydown", "keyup"].includes(e);
}
function Cr(e) {
  return ["contextmenu", "click", "mouse"].some((t) => e.includes(t));
}
function ca(e, t) {
  let n = t.filter((s) => !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive", "preserve-scroll"].includes(s));
  if (n.includes("debounce")) {
    let s = n.indexOf("debounce");
    n.splice(s, dt((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (n.includes("throttle")) {
    let s = n.indexOf("throttle");
    n.splice(s, dt((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (n.length === 0 || n.length === 1 && Kn(e.key).includes(n[0]))
    return !1;
  const r = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter((s) => n.includes(s));
  return n = n.filter((s) => !r.includes(s)), !(r.length > 0 && r.filter((o) => ((o === "cmd" || o === "super") && (o = "meta"), e[`${o}Key`])).length === r.length && (Cr(e.type) || Kn(e.key).includes(n[0])));
}
function Kn(e) {
  if (!e)
    return [];
  e = aa(e);
  let t = {
    ctrl: "control",
    slash: "/",
    space: " ",
    spacebar: " ",
    cmd: "meta",
    esc: "escape",
    up: "arrow-up",
    down: "arrow-down",
    left: "arrow-left",
    right: "arrow-right",
    period: ".",
    comma: ",",
    equal: "=",
    minus: "-",
    underscore: "_"
  };
  return t[e] = e, Object.keys(t).map((n) => {
    if (t[n] === e)
      return n;
  }).filter((n) => n);
}
N("model", (e, { modifiers: t, expression: n }, { effect: i, cleanup: r }) => {
  let s = e;
  t.includes("parent") && (s = e.parentNode);
  let o = k(s, n), a;
  typeof n == "string" ? a = k(s, `${n} = __placeholder`) : typeof n == "function" && typeof n() == "string" ? a = k(s, `${n()} = __placeholder`) : a = () => {
  };
  let l = () => {
    let f;
    return o((v) => f = v), Jn(f) ? f.get() : f;
  }, c = (f) => {
    let v;
    o((x) => v = x), Jn(v) ? v.set(f) : a(() => {
    }, {
      scope: { __placeholder: f }
    });
  };
  typeof n == "string" && e.type === "radio" && $(() => {
    e.hasAttribute("name") || e.setAttribute("name", n);
  });
  let u = e.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input", d = ie ? () => {
  } : rn(e, u, t, (f) => {
    c(Pt(e, t, f, l()));
  });
  if (t.includes("fill") && ([void 0, null, ""].includes(l()) || Cn(e) && Array.isArray(l()) || e.tagName.toLowerCase() === "select" && e.multiple) && c(
    Pt(e, t, { target: e }, l())
  ), e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = d, r(() => e._x_removeModelListeners.default()), e.form) {
    let f = rn(e.form, "reset", [], (v) => {
      In(() => e._x_model && e._x_model.set(Pt(e, t, { target: e }, l())));
    });
    r(() => f());
  }
  e._x_model = {
    get() {
      return l();
    },
    set(f) {
      c(f);
    }
  }, e._x_forceModelUpdate = (f) => {
    f === void 0 && typeof n == "string" && n.match(/\./) && (f = ""), window.fromModel = !0, $(() => Qi(e, "value", f)), delete window.fromModel;
  }, i(() => {
    let f = l();
    t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate(f);
  });
});
function Pt(e, t, n, i) {
  return $(() => {
    if (n instanceof CustomEvent && n.detail !== void 0)
      return n.detail !== null && n.detail !== void 0 ? n.detail : n.target.value;
    if (Cn(e))
      if (Array.isArray(i)) {
        let r = null;
        return t.includes("number") ? r = zt(n.target.value) : t.includes("boolean") ? r = ot(n.target.value) : r = n.target.value, n.target.checked ? i.includes(r) ? i : i.concat([r]) : i.filter((s) => !ua(s, r));
      } else
        return n.target.checked;
    else {
      if (e.tagName.toLowerCase() === "select" && e.multiple)
        return t.includes("number") ? Array.from(n.target.selectedOptions).map((r) => {
          let s = r.value || r.text;
          return zt(s);
        }) : t.includes("boolean") ? Array.from(n.target.selectedOptions).map((r) => {
          let s = r.value || r.text;
          return ot(s);
        }) : Array.from(n.target.selectedOptions).map((r) => r.value || r.text);
      {
        let r;
        return ir(e) ? n.target.checked ? r = n.target.value : r = i : r = n.target.value, t.includes("number") ? zt(r) : t.includes("boolean") ? ot(r) : t.includes("trim") ? r.trim() : r;
      }
    }
  });
}
function zt(e) {
  let t = e ? parseFloat(e) : null;
  return da(t) ? t : e;
}
function ua(e, t) {
  return e == t;
}
function da(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function Jn(e) {
  return e !== null && typeof e == "object" && typeof e.get == "function" && typeof e.set == "function";
}
N("cloak", (e) => queueMicrotask(() => $(() => e.removeAttribute(Te("cloak")))));
Yi(() => `[${Te("init")}]`);
N("init", oe((e, { expression: t }, { evaluate: n }) => typeof t == "string" ? !!t.trim() && n(t, {}, !1) : n(t, {}, !1)));
N("text", (e, { expression: t }, { effect: n, evaluateLater: i }) => {
  let r = i(t);
  n(() => {
    r((s) => {
      $(() => {
        e.textContent = s;
      });
    });
  });
});
N("html", (e, { expression: t }, { effect: n, evaluateLater: i }) => {
  let r = i(t);
  n(() => {
    r((s) => {
      $(() => {
        e.innerHTML = s, e._x_ignoreSelf = !0, G(e), delete e._x_ignoreSelf;
      });
    });
  });
});
_n(Pi(":", zi(Te("bind:"))));
var Tr = (e, { value: t, modifiers: n, expression: i, original: r }, { effect: s, cleanup: o }) => {
  if (!t) {
    let l = {};
    go(l), k(e, i)((u) => {
      lr(e, u, r);
    }, { scope: l });
    return;
  }
  if (t === "key")
    return fa(e, i);
  if (e._x_inlineBindings && e._x_inlineBindings[t] && e._x_inlineBindings[t].extract)
    return;
  let a = k(e, i);
  s(() => a((l) => {
    l === void 0 && typeof i == "string" && i.match(/\./) && (l = ""), $(() => Qi(e, t, l, n));
  })), o(() => {
    e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedStyles && e._x_undoAddedStyles();
  });
};
Tr.inline = (e, { value: t, modifiers: n, expression: i }) => {
  t && (e._x_inlineBindings || (e._x_inlineBindings = {}), e._x_inlineBindings[t] = { expression: i, extract: !1 });
};
N("bind", Tr);
function fa(e, t) {
  e._x_keyExpression = t;
}
Ui(() => `[${Te("data")}]`);
N("data", (e, { expression: t }, { cleanup: n }) => {
  if (ha(e))
    return;
  t = t === "" ? "{}" : t;
  let i = {};
  Ut(i, e);
  let r = {};
  bo(r, i);
  let s = fe(e, t, { scope: r });
  (s === void 0 || s === !0) && (s = {}), Ut(s, e);
  let o = Se(s);
  Ai(o);
  let a = Ue(e, o);
  o.init && fe(e, o.init), n(() => {
    o.destroy && fe(e, o.destroy), a();
  });
});
It((e, t) => {
  e._x_dataStack && (t._x_dataStack = e._x_dataStack, t.setAttribute("data-has-alpine-state", !0));
});
function ha(e) {
  return ie ? Qt ? !0 : e.hasAttribute("data-has-alpine-state") : !1;
}
N("show", (e, { modifiers: t, expression: n }, { effect: i }) => {
  let r = k(e, n);
  e._x_doHide || (e._x_doHide = () => {
    $(() => {
      e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0);
    });
  }), e._x_doShow || (e._x_doShow = () => {
    $(() => {
      e.style.length === 1 && e.style.display === "none" ? e.removeAttribute("style") : e.style.removeProperty("display");
    });
  });
  let s = () => {
    e._x_doHide(), e._x_isShown = !1;
  }, o = () => {
    e._x_doShow(), e._x_isShown = !0;
  }, a = () => setTimeout(o), l = Zt(
    (d) => d ? o() : s(),
    (d) => {
      typeof e._x_toggleAndCascadeWithTransitions == "function" ? e._x_toggleAndCascadeWithTransitions(e, d, o, s) : d ? a() : s();
    }
  ), c, u = !0;
  i(() => r((d) => {
    !u && d === c || (t.includes("immediate") && (d ? a() : s()), l(d), c = d, u = !1);
  }));
});
N("for", (e, { expression: t }, { effect: n, cleanup: i }) => {
  let r = ma(t), s = k(e, r.items), o = k(
    e,
    // the x-bind:key expression is stored for our use instead of evaluated.
    e._x_keyExpression || "index"
  );
  e._x_prevKeys = [], e._x_lookup = {}, n(() => pa(e, r, s, o)), i(() => {
    Object.values(e._x_lookup).forEach((a) => $(
      () => {
        Oe(a), a.remove();
      }
    )), delete e._x_prevKeys, delete e._x_lookup;
  });
});
function pa(e, t, n, i) {
  let r = (o) => typeof o == "object" && !Array.isArray(o), s = e;
  n((o) => {
    ga(o) && o >= 0 && (o = Array.from(Array(o).keys(), (p) => p + 1)), o === void 0 && (o = []);
    let a = e._x_lookup, l = e._x_prevKeys, c = [], u = [];
    if (r(o))
      o = Object.entries(o).map(([p, g]) => {
        let h = Gn(t, g, p, o);
        i((y) => {
          u.includes(y) && F("Duplicate key on x-for", e), u.push(y);
        }, { scope: { index: p, ...h } }), c.push(h);
      });
    else
      for (let p = 0; p < o.length; p++) {
        let g = Gn(t, o[p], p, o);
        i((h) => {
          u.includes(h) && F("Duplicate key on x-for", e), u.push(h);
        }, { scope: { index: p, ...g } }), c.push(g);
      }
    let d = [], f = [], v = [], x = [];
    for (let p = 0; p < l.length; p++) {
      let g = l[p];
      u.indexOf(g) === -1 && v.push(g);
    }
    l = l.filter((p) => !v.includes(p));
    let w = "template";
    for (let p = 0; p < u.length; p++) {
      let g = u[p], h = l.indexOf(g);
      if (h === -1)
        l.splice(p, 0, g), d.push([w, p]);
      else if (h !== p) {
        let y = l.splice(p, 1)[0], E = l.splice(h - 1, 1)[0];
        l.splice(p, 0, E), l.splice(h, 0, y), f.push([y, E]);
      } else
        x.push(g);
      w = g;
    }
    for (let p = 0; p < v.length; p++) {
      let g = v[p];
      g in a && ($(() => {
        Oe(a[g]), a[g].remove();
      }), delete a[g]);
    }
    for (let p = 0; p < f.length; p++) {
      let [g, h] = f[p], y = a[g], E = a[h], _ = document.createElement("div");
      $(() => {
        E || F('x-for ":key" is undefined or invalid', s, h, a), E.after(_), y.after(E), E._x_currentIfEl && E.after(E._x_currentIfEl), _.before(y), y._x_currentIfEl && y.after(y._x_currentIfEl), _.remove();
      }), E._x_refreshXForScope(c[u.indexOf(h)]);
    }
    for (let p = 0; p < d.length; p++) {
      let [g, h] = d[p], y = g === "template" ? s : a[g];
      y._x_currentIfEl && (y = y._x_currentIfEl);
      let E = c[h], _ = u[h], m = document.importNode(s.content, !0).firstElementChild, b = Se(E);
      Ue(m, b, s), m._x_refreshXForScope = (I) => {
        Object.entries(I).forEach(([S, C]) => {
          b[S] = C;
        });
      }, $(() => {
        y.after(m), oe(() => G(m))();
      }), typeof _ == "object" && F("x-for key cannot be an object, it must be a string or an integer", s), a[_] = m;
    }
    for (let p = 0; p < x.length; p++)
      a[x[p]]._x_refreshXForScope(c[u.indexOf(x[p])]);
    s._x_prevKeys = u;
  });
}
function ma(e) {
  let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = /^\s*\(|\)\s*$/g, i = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, r = e.match(i);
  if (!r)
    return;
  let s = {};
  s.items = r[2].trim();
  let o = r[1].replace(n, "").trim(), a = o.match(t);
  return a ? (s.item = o.replace(t, "").trim(), s.index = a[1].trim(), a[2] && (s.collection = a[2].trim())) : s.item = o, s;
}
function Gn(e, t, n, i) {
  let r = {};
  return /^\[.*\]$/.test(e.item) && Array.isArray(t) ? e.item.replace("[", "").replace("]", "").split(",").map((o) => o.trim()).forEach((o, a) => {
    r[o] = t[a];
  }) : /^\{.*\}$/.test(e.item) && !Array.isArray(t) && typeof t == "object" ? e.item.replace("{", "").replace("}", "").split(",").map((o) => o.trim()).forEach((o) => {
    r[o] = t[o];
  }) : r[e.item] = t, e.index && (r[e.index] = n), e.collection && (r[e.collection] = i), r;
}
function ga(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function Ar() {
}
Ar.inline = (e, { expression: t }, { cleanup: n }) => {
  let i = xt(e);
  i._x_refs || (i._x_refs = {}), i._x_refs[t] = e, n(() => delete i._x_refs[t]);
};
N("ref", Ar);
N("if", (e, { expression: t }, { effect: n, cleanup: i }) => {
  e.tagName.toLowerCase() !== "template" && F("x-if can only be used on a <template> tag", e);
  let r = k(e, t), s = () => {
    if (e._x_currentIfEl)
      return e._x_currentIfEl;
    let a = e.content.cloneNode(!0).firstElementChild;
    return Ue(a, {}, e), $(() => {
      e.after(a), oe(() => G(a))();
    }), e._x_currentIfEl = a, e._x_undoIf = () => {
      $(() => {
        Oe(a), a.remove();
      }), delete e._x_currentIfEl;
    }, a;
  }, o = () => {
    e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf);
  };
  n(() => r((a) => {
    a ? s() : o();
  })), i(() => e._x_undoIf && e._x_undoIf());
});
N("id", (e, { expression: t }, { evaluate: n }) => {
  n(t).forEach((r) => na(e, r));
});
It((e, t) => {
  e._x_ids && (t._x_ids = e._x_ids);
});
_n(Pi("@", zi(Te("on:"))));
N("on", oe((e, { value: t, modifiers: n, expression: i }, { cleanup: r }) => {
  let s = i ? k(e, i) : () => {
  };
  e.tagName.toLowerCase() === "template" && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t));
  let o = rn(e, t, n, (a) => {
    s(() => {
    }, { scope: { $event: a }, params: [a] });
  });
  r(() => o());
}));
At("Collapse", "collapse", "collapse");
At("Intersect", "intersect", "intersect");
At("Focus", "trap", "focus");
At("Mask", "mask", "mask");
function At(e, t, n) {
  N(t, (i) => F(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, i));
}
Ke.setEvaluator(Ri);
Ke.setReactivityEngine({ reactive: Rn, effect: Ao, release: Oo, raw: O });
var va = Ke, Or = va;
function ba(e) {
  e.directive("collapse", t), t.inline = (n, { modifiers: i }) => {
    i.includes("min") && (n._x_doShow = () => {
    }, n._x_doHide = () => {
    });
  };
  function t(n, { modifiers: i }) {
    let r = Zn(i, "duration", 250) / 1e3, s = Zn(i, "min", 0), o = !i.includes("min");
    n._x_isShown || (n.style.height = `${s}px`), !n._x_isShown && o && (n.hidden = !0), n._x_isShown || (n.style.overflow = "hidden");
    let a = (c, u) => {
      let d = e.setStyles(c, u);
      return u.height ? () => {
      } : d;
    }, l = {
      transitionProperty: "height",
      transitionDuration: `${r}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    n._x_transition = {
      in(c = () => {
      }, u = () => {
      }) {
        o && (n.hidden = !1), o && (n.style.display = null);
        let d = n.getBoundingClientRect().height;
        n.style.height = "auto";
        let f = n.getBoundingClientRect().height;
        d === f && (d = s), e.transition(n, e.setStyles, {
          during: l,
          start: { height: d + "px" },
          end: { height: f + "px" }
        }, () => n._x_isShown = !0, () => {
          Math.abs(n.getBoundingClientRect().height - f) < 1 && (n.style.overflow = null);
        });
      },
      out(c = () => {
      }, u = () => {
      }) {
        let d = n.getBoundingClientRect().height;
        e.transition(n, a, {
          during: l,
          start: { height: d + "px" },
          end: { height: s + "px" }
        }, () => n.style.overflow = "hidden", () => {
          n._x_isShown = !1, n.style.height == `${s}px` && o && (n.style.display = "none", n.hidden = !0);
        });
      }
    };
  }
}
function Zn(e, t, n) {
  if (e.indexOf(t) === -1)
    return n;
  const i = e[e.indexOf(t) + 1];
  if (!i)
    return n;
  if (t === "duration") {
    let r = i.match(/([0-9]+)ms/);
    if (r)
      return r[1];
  }
  if (t === "min") {
    let r = i.match(/([0-9]+)px/);
    if (r)
      return r[1];
  }
  return i;
}
var ya = ba;
function wa(e) {
  e.directive("intersect", e.skipDuringClone((t, { value: n, expression: i, modifiers: r }, { evaluateLater: s, cleanup: o }) => {
    let a = s(i), l = {
      rootMargin: Ea(r),
      threshold: _a(r)
    }, c = new IntersectionObserver((u) => {
      u.forEach((d) => {
        d.isIntersecting !== (n === "leave") && (a(), r.includes("once") && c.disconnect());
      });
    }, l);
    c.observe(t), o(() => {
      c.disconnect();
    });
  }));
}
function _a(e) {
  if (e.includes("full"))
    return 0.99;
  if (e.includes("half"))
    return 0.5;
  if (!e.includes("threshold"))
    return 0;
  let t = e[e.indexOf("threshold") + 1];
  return t === "100" ? 1 : t === "0" ? 0 : +`.${t}`;
}
function xa(e) {
  let t = e.match(/^(-?[0-9]+)(px|%)?$/);
  return t ? t[1] + (t[2] || "px") : void 0;
}
function Ea(e) {
  const t = "margin", n = "0px 0px 0px 0px", i = e.indexOf(t);
  if (i === -1)
    return n;
  let r = [];
  for (let s = 1; s < 5; s++)
    r.push(xa(e[i + s] || ""));
  return r = r.filter((s) => s !== void 0), r.length ? r.join(" ").trim() : n;
}
var Ia = wa, $r = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], ft = /* @__PURE__ */ $r.join(","), Nr = typeof Element > "u", ve = Nr ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, sn = !Nr && Element.prototype.getRootNode ? function(e) {
  return e.getRootNode();
} : function(e) {
  return e.ownerDocument;
}, kr = function(t, n, i) {
  var r = Array.prototype.slice.apply(t.querySelectorAll(ft));
  return n && ve.call(t, ft) && r.unshift(t), r = r.filter(i), r;
}, Rr = function e(t, n, i) {
  for (var r = [], s = Array.from(t); s.length; ) {
    var o = s.shift();
    if (o.tagName === "SLOT") {
      var a = o.assignedElements(), l = a.length ? a : o.children, c = e(l, !0, i);
      i.flatten ? r.push.apply(r, c) : r.push({
        scope: o,
        candidates: c
      });
    } else {
      var u = ve.call(o, ft);
      u && i.filter(o) && (n || !t.includes(o)) && r.push(o);
      var d = o.shadowRoot || // check for an undisclosed shadow
      typeof i.getShadowRoot == "function" && i.getShadowRoot(o), f = !i.shadowRootFilter || i.shadowRootFilter(o);
      if (d && f) {
        var v = e(d === !0 ? o.children : d.children, !0, i);
        i.flatten ? r.push.apply(r, v) : r.push({
          scope: o,
          candidates: v
        });
      } else
        s.unshift.apply(s, o.children);
    }
  }
  return r;
}, Lr = function(t, n) {
  return t.tabIndex < 0 && (n || /^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || t.isContentEditable) && isNaN(parseInt(t.getAttribute("tabindex"), 10)) ? 0 : t.tabIndex;
}, Sa = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, Dr = function(t) {
  return t.tagName === "INPUT";
}, Ca = function(t) {
  return Dr(t) && t.type === "hidden";
}, Ta = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(i) {
    return i.tagName === "SUMMARY";
  });
  return n;
}, Aa = function(t, n) {
  for (var i = 0; i < t.length; i++)
    if (t[i].checked && t[i].form === n)
      return t[i];
}, Oa = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || sn(t), i = function(a) {
    return n.querySelectorAll('input[type="radio"][name="' + a + '"]');
  }, r;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    r = i(window.CSS.escape(t.name));
  else
    try {
      r = i(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var s = Aa(r, t.form);
  return !s || s === t;
}, $a = function(t) {
  return Dr(t) && t.type === "radio";
}, Na = function(t) {
  return $a(t) && !Oa(t);
}, Xn = function(t) {
  var n = t.getBoundingClientRect(), i = n.width, r = n.height;
  return i === 0 && r === 0;
}, ka = function(t, n) {
  var i = n.displayCheck, r = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var s = ve.call(t, "details>summary:first-of-type"), o = s ? t.parentElement : t;
  if (ve.call(o, "details:not([open]) *"))
    return !0;
  var a = sn(t).host, l = a?.ownerDocument.contains(a) || t.ownerDocument.contains(t);
  if (!i || i === "full") {
    if (typeof r == "function") {
      for (var c = t; t; ) {
        var u = t.parentElement, d = sn(t);
        if (u && !u.shadowRoot && r(u) === !0)
          return Xn(t);
        t.assignedSlot ? t = t.assignedSlot : !u && d !== t.ownerDocument ? t = d.host : t = u;
      }
      t = c;
    }
    if (l)
      return !t.getClientRects().length;
  } else if (i === "non-zero-area")
    return Xn(t);
  return !1;
}, Ra = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var i = 0; i < n.children.length; i++) {
          var r = n.children.item(i);
          if (r.tagName === "LEGEND")
            return ve.call(n, "fieldset[disabled] *") ? !0 : !r.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, ht = function(t, n) {
  return !(n.disabled || Ca(n) || ka(n, t) || // For a details element with a summary, the summary element gets the focus
  Ta(n) || Ra(n));
}, on = function(t, n) {
  return !(Na(n) || Lr(n) < 0 || !ht(t, n));
}, La = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, Da = function e(t) {
  var n = [], i = [];
  return t.forEach(function(r, s) {
    var o = !!r.scope, a = o ? r.scope : r, l = Lr(a, o), c = o ? e(r.candidates) : a;
    l === 0 ? o ? n.push.apply(n, c) : n.push(a) : i.push({
      documentOrder: s,
      tabIndex: l,
      item: r,
      isScope: o,
      content: c
    });
  }), i.sort(Sa).reduce(function(r, s) {
    return s.isScope ? r.push.apply(r, s.content) : r.push(s.content), r;
  }, []).concat(n);
}, Ma = function(t, n) {
  n = n || {};
  var i;
  return n.getShadowRoot ? i = Rr([t], n.includeContainer, {
    filter: on.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: La
  }) : i = kr(t, n.includeContainer, on.bind(null, n)), Da(i);
}, Mr = function(t, n) {
  n = n || {};
  var i;
  return n.getShadowRoot ? i = Rr([t], n.includeContainer, {
    filter: ht.bind(null, n),
    flatten: !0,
    getShadowRoot: n.getShadowRoot
  }) : i = kr(t, n.includeContainer, ht.bind(null, n)), i;
}, tt = function(t, n) {
  if (n = n || {}, !t)
    throw new Error("No node provided");
  return ve.call(t, ft) === !1 ? !1 : on(n, t);
}, Pa = /* @__PURE__ */ $r.concat("iframe").join(","), at = function(t, n) {
  if (n = n || {}, !t)
    throw new Error("No node provided");
  return ve.call(t, Pa) === !1 ? !1 : ht(n, t);
};
function Qn(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function ei(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qn(Object(n), !0).forEach(function(i) {
      za(e, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qn(Object(n)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return e;
}
function za(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ti = /* @__PURE__ */ function() {
  var e = [];
  return {
    activateTrap: function(n) {
      if (e.length > 0) {
        var i = e[e.length - 1];
        i !== n && i.pause();
      }
      var r = e.indexOf(n);
      r === -1 || e.splice(r, 1), e.push(n);
    },
    deactivateTrap: function(n) {
      var i = e.indexOf(n);
      i !== -1 && e.splice(i, 1), e.length > 0 && e[e.length - 1].unpause();
    }
  };
}(), Fa = function(t) {
  return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function";
}, Ba = function(t) {
  return t.key === "Escape" || t.key === "Esc" || t.keyCode === 27;
}, ja = function(t) {
  return t.key === "Tab" || t.keyCode === 9;
}, ni = function(t) {
  return setTimeout(t, 0);
}, ii = function(t, n) {
  var i = -1;
  return t.every(function(r, s) {
    return n(r) ? (i = s, !1) : !0;
  }), i;
}, Le = function(t) {
  for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)
    i[r - 1] = arguments[r];
  return typeof t == "function" ? t.apply(void 0, i) : t;
}, nt = function(t) {
  return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target;
}, Va = function(t, n) {
  var i = n?.document || document, r = ei({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0
  }, n), s = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  }, o, a = function(m, b, I) {
    return m && m[b] !== void 0 ? m[b] : r[I || b];
  }, l = function(m) {
    return s.containerGroups.findIndex(function(b) {
      var I = b.container, S = b.tabbableNodes;
      return I.contains(m) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      S.find(function(C) {
        return C === m;
      });
    });
  }, c = function(m) {
    var b = r[m];
    if (typeof b == "function") {
      for (var I = arguments.length, S = new Array(I > 1 ? I - 1 : 0), C = 1; C < I; C++)
        S[C - 1] = arguments[C];
      b = b.apply(void 0, S);
    }
    if (b === !0 && (b = void 0), !b) {
      if (b === void 0 || b === !1)
        return b;
      throw new Error("`".concat(m, "` was specified but was not a node, or did not return a node"));
    }
    var T = b;
    if (typeof b == "string" && (T = i.querySelector(b), !T))
      throw new Error("`".concat(m, "` as selector refers to no known node"));
    return T;
  }, u = function() {
    var m = c("initialFocus");
    if (m === !1)
      return !1;
    if (m === void 0)
      if (l(i.activeElement) >= 0)
        m = i.activeElement;
      else {
        var b = s.tabbableGroups[0], I = b && b.firstTabbableNode;
        m = I || c("fallbackFocus");
      }
    if (!m)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return m;
  }, d = function() {
    if (s.containerGroups = s.containers.map(function(m) {
      var b = Ma(m, r.tabbableOptions), I = Mr(m, r.tabbableOptions);
      return {
        container: m,
        tabbableNodes: b,
        focusableNodes: I,
        firstTabbableNode: b.length > 0 ? b[0] : null,
        lastTabbableNode: b.length > 0 ? b[b.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(C) {
          var T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, R = I.findIndex(function(L) {
            return L === C;
          });
          if (!(R < 0))
            return T ? I.slice(R + 1).find(function(L) {
              return tt(L, r.tabbableOptions);
            }) : I.slice(0, R).reverse().find(function(L) {
              return tt(L, r.tabbableOptions);
            });
        }
      };
    }), s.tabbableGroups = s.containerGroups.filter(function(m) {
      return m.tabbableNodes.length > 0;
    }), s.tabbableGroups.length <= 0 && !c("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
  }, f = function _(m) {
    if (m !== !1 && m !== i.activeElement) {
      if (!m || !m.focus) {
        _(u());
        return;
      }
      m.focus({
        preventScroll: !!r.preventScroll
      }), s.mostRecentlyFocusedNode = m, Fa(m) && m.select();
    }
  }, v = function(m) {
    var b = c("setReturnFocus", m);
    return b || (b === !1 ? !1 : m);
  }, x = function(m) {
    var b = nt(m);
    if (!(l(b) >= 0)) {
      if (Le(r.clickOutsideDeactivates, m)) {
        o.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: r.returnFocusOnDeactivate && !at(b, r.tabbableOptions)
        });
        return;
      }
      Le(r.allowOutsideClick, m) || m.preventDefault();
    }
  }, w = function(m) {
    var b = nt(m), I = l(b) >= 0;
    I || b instanceof Document ? I && (s.mostRecentlyFocusedNode = b) : (m.stopImmediatePropagation(), f(s.mostRecentlyFocusedNode || u()));
  }, p = function(m) {
    var b = nt(m);
    d();
    var I = null;
    if (s.tabbableGroups.length > 0) {
      var S = l(b), C = S >= 0 ? s.containerGroups[S] : void 0;
      if (S < 0)
        m.shiftKey ? I = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : I = s.tabbableGroups[0].firstTabbableNode;
      else if (m.shiftKey) {
        var T = ii(s.tabbableGroups, function(B) {
          var z = B.firstTabbableNode;
          return b === z;
        });
        if (T < 0 && (C.container === b || at(b, r.tabbableOptions) && !tt(b, r.tabbableOptions) && !C.nextTabbableNode(b, !1)) && (T = S), T >= 0) {
          var R = T === 0 ? s.tabbableGroups.length - 1 : T - 1, L = s.tabbableGroups[R];
          I = L.lastTabbableNode;
        }
      } else {
        var q = ii(s.tabbableGroups, function(B) {
          var z = B.lastTabbableNode;
          return b === z;
        });
        if (q < 0 && (C.container === b || at(b, r.tabbableOptions) && !tt(b, r.tabbableOptions) && !C.nextTabbableNode(b)) && (q = S), q >= 0) {
          var P = q === s.tabbableGroups.length - 1 ? 0 : q + 1, ae = s.tabbableGroups[P];
          I = ae.firstTabbableNode;
        }
      }
    } else
      I = c("fallbackFocus");
    I && (m.preventDefault(), f(I));
  }, g = function(m) {
    if (Ba(m) && Le(r.escapeDeactivates, m) !== !1) {
      m.preventDefault(), o.deactivate();
      return;
    }
    if (ja(m)) {
      p(m);
      return;
    }
  }, h = function(m) {
    var b = nt(m);
    l(b) >= 0 || Le(r.clickOutsideDeactivates, m) || Le(r.allowOutsideClick, m) || (m.preventDefault(), m.stopImmediatePropagation());
  }, y = function() {
    if (s.active)
      return ti.activateTrap(o), s.delayInitialFocusTimer = r.delayInitialFocus ? ni(function() {
        f(u());
      }) : f(u()), i.addEventListener("focusin", w, !0), i.addEventListener("mousedown", x, {
        capture: !0,
        passive: !1
      }), i.addEventListener("touchstart", x, {
        capture: !0,
        passive: !1
      }), i.addEventListener("click", h, {
        capture: !0,
        passive: !1
      }), i.addEventListener("keydown", g, {
        capture: !0,
        passive: !1
      }), o;
  }, E = function() {
    if (s.active)
      return i.removeEventListener("focusin", w, !0), i.removeEventListener("mousedown", x, !0), i.removeEventListener("touchstart", x, !0), i.removeEventListener("click", h, !0), i.removeEventListener("keydown", g, !0), o;
  };
  return o = {
    get active() {
      return s.active;
    },
    get paused() {
      return s.paused;
    },
    activate: function(m) {
      if (s.active)
        return this;
      var b = a(m, "onActivate"), I = a(m, "onPostActivate"), S = a(m, "checkCanFocusTrap");
      S || d(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = i.activeElement, b && b();
      var C = function() {
        S && d(), y(), I && I();
      };
      return S ? (S(s.containers.concat()).then(C, C), this) : (C(), this);
    },
    deactivate: function(m) {
      if (!s.active)
        return this;
      var b = ei({
        onDeactivate: r.onDeactivate,
        onPostDeactivate: r.onPostDeactivate,
        checkCanReturnFocus: r.checkCanReturnFocus
      }, m);
      clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, E(), s.active = !1, s.paused = !1, ti.deactivateTrap(o);
      var I = a(b, "onDeactivate"), S = a(b, "onPostDeactivate"), C = a(b, "checkCanReturnFocus"), T = a(b, "returnFocus", "returnFocusOnDeactivate");
      I && I();
      var R = function() {
        ni(function() {
          T && f(v(s.nodeFocusedBeforeActivation)), S && S();
        });
      };
      return T && C ? (C(v(s.nodeFocusedBeforeActivation)).then(R, R), this) : (R(), this);
    },
    pause: function() {
      return s.paused || !s.active ? this : (s.paused = !0, E(), this);
    },
    unpause: function() {
      return !s.paused || !s.active ? this : (s.paused = !1, d(), y(), this);
    },
    updateContainerElements: function(m) {
      var b = [].concat(m).filter(Boolean);
      return s.containers = b.map(function(I) {
        return typeof I == "string" ? i.querySelector(I) : I;
      }), s.active && d(), this;
    }
  }, o.updateContainerElements(t), o;
};
function Ha(e) {
  let t, n;
  window.addEventListener("focusin", () => {
    t = n, n = document.activeElement;
  }), e.magic("focus", (i) => {
    let r = i;
    return {
      __noscroll: !1,
      __wrapAround: !1,
      within(s) {
        return r = s, this;
      },
      withoutScrolling() {
        return this.__noscroll = !0, this;
      },
      noscroll() {
        return this.__noscroll = !0, this;
      },
      withWrapAround() {
        return this.__wrapAround = !0, this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(s) {
        return at(s);
      },
      previouslyFocused() {
        return t;
      },
      lastFocused() {
        return t;
      },
      focused() {
        return n;
      },
      focusables() {
        return Array.isArray(r) ? r : Mr(r, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(s) {
        let o = this.all();
        return o[0] && o[0].isSameNode(s);
      },
      isLast(s) {
        let o = this.all();
        return o.length && o.slice(-1)[0].isSameNode(s);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let s = this.all(), o = document.activeElement;
        if (s.indexOf(o) !== -1)
          return this.__wrapAround && s.indexOf(o) === s.length - 1 ? s[0] : s[s.indexOf(o) + 1];
      },
      getPrevious() {
        let s = this.all(), o = document.activeElement;
        if (s.indexOf(o) !== -1)
          return this.__wrapAround && s.indexOf(o) === 0 ? s.slice(-1)[0] : s[s.indexOf(o) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(s) {
        s && setTimeout(() => {
          s.hasAttribute("tabindex") || s.setAttribute("tabindex", "0"), s.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  }), e.directive("trap", e.skipDuringClone(
    (i, { expression: r, modifiers: s }, { effect: o, evaluateLater: a, cleanup: l }) => {
      let c = a(r), u = !1, d = {
        escapeDeactivates: !1,
        allowOutsideClick: !0,
        fallbackFocus: () => i
      }, f = () => {
      };
      if (s.includes("noautofocus"))
        d.initialFocus = !1;
      else {
        let p = i.querySelector("[autofocus]");
        p && (d.initialFocus = p);
      }
      s.includes("inert") && (d.onPostActivate = () => {
        e.nextTick(() => {
          f = ri(i);
        });
      });
      let v = Va(i, d), x = () => {
      };
      const w = () => {
        f(), f = () => {
        }, x(), x = () => {
        }, v.deactivate({
          returnFocus: !s.includes("noreturn")
        });
      };
      o(() => c((p) => {
        u !== p && (p && !u && (s.includes("noscroll") && (x = Wa()), setTimeout(() => {
          v.activate();
        }, 15)), !p && u && w(), u = !!p);
      })), l(w);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (i, { expression: r, modifiers: s }, { evaluate: o }) => {
      s.includes("inert") && o(r) && ri(i);
    }
  ));
}
function ri(e) {
  let t = [];
  return Pr(e, (n) => {
    let i = n.hasAttribute("aria-hidden");
    n.setAttribute("aria-hidden", "true"), t.push(() => i || n.removeAttribute("aria-hidden"));
  }), () => {
    for (; t.length; )
      t.pop()();
  };
}
function Pr(e, t) {
  e.isSameNode(document.body) || !e.parentNode || Array.from(e.parentNode.children).forEach((n) => {
    n.isSameNode(e) ? Pr(e.parentNode, t) : t(n);
  });
}
function Wa() {
  let e = document.documentElement.style.overflow, t = document.documentElement.style.paddingRight, n = window.innerWidth - document.documentElement.clientWidth;
  return document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${n}px`, () => {
    document.documentElement.style.overflow = e, document.documentElement.style.paddingRight = t;
  };
}
var qa = Ha;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function Ua() {
  return !0;
}
function Ya({ component: e, argument: t }) {
  return new Promise((n) => {
    if (t)
      window.addEventListener(
        t,
        () => n(),
        { once: !0 }
      );
    else {
      const i = (r) => {
        r.detail.id === e.id && (window.removeEventListener("async-alpine:load", i), n());
      };
      window.addEventListener("async-alpine:load", i);
    }
  });
}
function Ka() {
  return new Promise((e) => {
    "requestIdleCallback" in window ? window.requestIdleCallback(e) : setTimeout(e, 200);
  });
}
function Ja({ argument: e }) {
  return new Promise((t) => {
    if (!e)
      return console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'"), t();
    const n = window.matchMedia(`(${e})`);
    n.matches ? t() : n.addEventListener("change", t, { once: !0 });
  });
}
function Ga({ component: e, argument: t }) {
  return new Promise((n) => {
    const i = t || "0px 0px 0px 0px", r = new IntersectionObserver((s) => {
      s[0].isIntersecting && (r.disconnect(), n());
    }, { rootMargin: i });
    r.observe(e.el);
  });
}
var si = {
  eager: Ua,
  event: Ya,
  idle: Ka,
  media: Ja,
  visible: Ga
};
async function Za(e) {
  const t = Xa(e.strategy);
  await an(e, t);
}
async function an(e, t) {
  if (t.type === "expression") {
    if (t.operator === "&&")
      return Promise.all(
        t.parameters.map((n) => an(e, n))
      );
    if (t.operator === "||")
      return Promise.any(
        t.parameters.map((n) => an(e, n))
      );
  }
  return si[t.method] ? si[t.method]({
    component: e,
    argument: t.argument
  }) : !1;
}
function Xa(e) {
  const t = Qa(e);
  let n = zr(t);
  return n.type === "method" ? {
    type: "expression",
    operator: "&&",
    parameters: [n]
  } : n;
}
function Qa(e) {
  const t = /\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g, n = [];
  let i;
  for (; (i = t.exec(e)) !== null; ) {
    const [r, s, o, a] = i;
    if (s !== void 0)
      n.push({ type: "parenthesis", value: s });
    else if (o !== void 0)
      n.push({
        type: "operator",
        // we do the below to make operators backwards-compatible with previous
        // versions of Async Alpine, where '|' is equivalent to &&
        value: o === "|" ? "&&" : o
      });
    else {
      const l = {
        type: "method",
        method: a.trim()
      };
      a.includes("(") && (l.method = a.substring(0, a.indexOf("(")).trim(), l.argument = a.substring(
        a.indexOf("(") + 1,
        a.indexOf(")")
      )), a.method === "immediate" && (a.method = "eager"), n.push(l);
    }
  }
  return n;
}
function zr(e) {
  let t = oi(e);
  for (; e.length > 0 && (e[0].value === "&&" || e[0].value === "|" || e[0].value === "||"); ) {
    const n = e.shift().value, i = oi(e);
    t.type === "expression" && t.operator === n ? t.parameters.push(i) : t = {
      type: "expression",
      operator: n,
      parameters: [t, i]
    };
  }
  return t;
}
function oi(e) {
  if (e[0].value === "(") {
    e.shift();
    const t = zr(e);
    return e[0].value === ")" && e.shift(), t;
  } else
    return e.shift();
}
function el(e) {
  const t = "load", n = e.prefixed("load-src"), i = e.prefixed("ignore");
  let r = {
    defaultStrategy: "eager",
    keepRelativeURLs: !1
  }, s = !1, o = {}, a = 0;
  function l() {
    return a++;
  }
  e.asyncOptions = (h) => {
    r = {
      ...r,
      ...h
    };
  }, e.asyncData = (h, y = !1) => {
    o[h] = {
      loaded: !1,
      download: y
    };
  }, e.asyncUrl = (h, y) => {
    !h || !y || o[h] || (o[h] = {
      loaded: !1,
      download: () => import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        g(y)
      )
    });
  }, e.asyncAlias = (h) => {
    s = h;
  };
  const c = (h) => {
    e.skipDuringClone(() => {
      h._x_async || (h._x_async = "init", h._x_ignore = !0, h.setAttribute(i, ""));
    })();
  }, u = async (h) => {
    e.skipDuringClone(async () => {
      if (h._x_async !== "init") return;
      h._x_async = "await";
      const { name: y, strategy: E } = d(h);
      await Za({
        name: y,
        strategy: E,
        el: h,
        id: h.id || l()
      }), h.isConnected && (await f(y), h.isConnected && (x(h), h._x_async = "loaded"));
    })();
  };
  u.inline = c, e.directive(t, u).before("ignore");
  function d(h) {
    const y = p(h.getAttribute(e.prefixed("data"))), E = h.getAttribute(e.prefixed(t)) || r.defaultStrategy, _ = h.getAttribute(n);
    return _ && e.asyncUrl(y, _), {
      name: y,
      strategy: E
    };
  }
  async function f(h) {
    if (h.startsWith("_x_async_") || (w(h), !o[h] || o[h].loaded)) return;
    const y = await v(h);
    e.data(h, y), o[h].loaded = !0;
  }
  async function v(h) {
    if (!o[h]) return;
    const y = await o[h].download(h);
    return typeof y == "function" ? y : y[h] || y.default || Object.values(y)[0] || !1;
  }
  function x(h) {
    e.destroyTree(h), h._x_ignore = !1, h.removeAttribute(i), !h.closest(`[${i}]`) && e.initTree(h);
  }
  function w(h) {
    if (!(!s || o[h])) {
      if (typeof s == "function") {
        e.asyncData(h, s);
        return;
      }
      e.asyncUrl(h, s.replaceAll("[name]", h));
    }
  }
  function p(h) {
    return (h || "").trim().split(/[({]/g)[0] || `_x_async_${l()}`;
  }
  function g(h) {
    return r.keepRelativeURLs || new RegExp("^(?:[a-z+]+:)?//", "i").test(h) ? h : new URL(h, document.baseURI).href;
  }
}
function tl(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nl(e, t) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
  }
}
function il(e, t, n) {
  return t && nl(e.prototype, t), e;
}
var rl = Object.defineProperty, Z = function(e, t) {
  return rl(e, "name", { value: t, configurable: !0 });
}, sl = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`, ol = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`, al = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, ll = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, cl = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`, ul = Z(function(e) {
  return new DOMParser().parseFromString(e, "text/html").body.childNodes[0];
}, "stringToHTML"), De = Z(function(e) {
  var t = new DOMParser().parseFromString(e, "application/xml");
  return document.importNode(t.documentElement, !0).outerHTML;
}, "getSvgNode"), A = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, te = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, ai = { OUTLINE: "outline", FILLED: "filled" }, Ft = { FADE: "fade", SLIDE: "slide" }, Me = { CLOSE: De(sl), SUCCESS: De(ll), ERROR: De(ol), WARNING: De(cl), INFO: De(al) }, li = Z(function(e) {
  e.wrapper.classList.add(A.NOTIFY_FADE), setTimeout(function() {
    e.wrapper.classList.add(A.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), ci = Z(function(e) {
  e.wrapper.classList.remove(A.NOTIFY_FADE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "fadeOut"), dl = Z(function(e) {
  e.wrapper.classList.add(A.NOTIFY_SLIDE), setTimeout(function() {
    e.wrapper.classList.add(A.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), fl = Z(function(e) {
  e.wrapper.classList.remove(A.NOTIFY_SLIDE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "slideOut"), Fr = function() {
  function e(t) {
    var n = this;
    tl(this, e), this.notifyOut = Z(function(B) {
      B(n);
    }, "notifyOut");
    var i = t.notificationsGap, r = i === void 0 ? 20 : i, s = t.notificationsPadding, o = s === void 0 ? 20 : s, a = t.status, l = a === void 0 ? "success" : a, c = t.effect, u = c === void 0 ? Ft.FADE : c, d = t.type, f = d === void 0 ? "outline" : d, v = t.title, x = t.text, w = t.showIcon, p = w === void 0 ? !0 : w, g = t.customIcon, h = g === void 0 ? "" : g, y = t.customClass, E = y === void 0 ? "" : y, _ = t.speed, m = _ === void 0 ? 500 : _, b = t.showCloseButton, I = b === void 0 ? !0 : b, S = t.autoclose, C = S === void 0 ? !0 : S, T = t.autotimeout, R = T === void 0 ? 3e3 : T, L = t.position, q = L === void 0 ? "right top" : L, P = t.customWrapper, ae = P === void 0 ? "" : P;
    if (this.customWrapper = ae, this.status = l, this.title = v, this.text = x, this.showIcon = p, this.customIcon = h, this.customClass = E, this.speed = m, this.effect = u, this.showCloseButton = I, this.autoclose = C, this.autotimeout = R, this.notificationsGap = r, this.notificationsPadding = o, this.type = f, this.position = q, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  return il(e, [{ key: "checkRequirements", value: function() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function() {
    var n = document.querySelector(".".concat(A.CONTAINER));
    n ? this.container = n : (this.container = document.createElement("div"), this.container.classList.add(A.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function() {
    this.container.classList[this.position === "center" ? "add" : "remove"](A.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](A.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](A.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](A.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](A.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](A.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](A.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function() {
    var n = this, i = document.createElement("div");
    i.classList.add(A.NOTIFY_CLOSE), i.innerHTML = Me.CLOSE, this.wrapper.appendChild(i), i.addEventListener("click", function() {
      n.close();
    });
  } }, { key: "setWrapper", value: function() {
    var n = this;
    switch (this.customWrapper ? this.wrapper = ul(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(A.NOTIFY), this.type) {
      case ai.OUTLINE:
        this.wrapper.classList.add(A.NOTIFY_OUTLINE);
        break;
      case ai.FILLED:
        this.wrapper.classList.add(A.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(A.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case te.SUCCESS:
        this.wrapper.classList.add(A.NOTIFY_SUCCESS);
        break;
      case te.ERROR:
        this.wrapper.classList.add(A.NOTIFY_ERROR);
        break;
      case te.WARNING:
        this.wrapper.classList.add(A.NOTIFY_WARNING);
        break;
      case te.INFO:
        this.wrapper.classList.add(A.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(A.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(i) {
      n.wrapper.classList.add(i);
    });
  } }, { key: "setContent", value: function() {
    var n = document.createElement("div");
    n.classList.add(A.NOTIFY_CONTENT);
    var i, r;
    this.title && (i = document.createElement("div"), i.classList.add(A.NOTIFY_TITLE), i.textContent = this.title.trim(), this.showCloseButton || (i.style.paddingRight = "0")), this.text && (r = document.createElement("div"), r.classList.add(A.NOTIFY_TEXT), r.innerHTML = this.text.trim(), this.title || (r.style.marginTop = "0")), this.wrapper.appendChild(n), this.title && n.appendChild(i), this.text && n.appendChild(r);
  } }, { key: "setIcon", value: function() {
    var n = Z(function(r) {
      switch (r) {
        case te.SUCCESS:
          return Me.SUCCESS;
        case te.ERROR:
          return Me.ERROR;
        case te.WARNING:
          return Me.WARNING;
        case te.INFO:
          return Me.INFO;
      }
    }, "computedIcon"), i = document.createElement("div");
    i.classList.add(A.NOTIFY_ICON), i.innerHTML = this.customIcon || n(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(i);
  } }, { key: "setObserver", value: function() {
    var n = this, i = new IntersectionObserver(function(r) {
      if (r[0].intersectionRatio <= 0) n.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      i.observe(n.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function(t) {
    t(this);
  } }, { key: "autoClose", value: function() {
    var n = this;
    setTimeout(function() {
      n.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function() {
    switch (this.effect) {
      case Ft.FADE:
        this.selectedNotifyInEffect = li, this.selectedNotifyOutEffect = ci;
        break;
      case Ft.SLIDE:
        this.selectedNotifyInEffect = dl, this.selectedNotifyOutEffect = fl;
        break;
      default:
        this.selectedNotifyInEffect = li, this.selectedNotifyOutEffect = ci;
    }
  } }]), e;
}();
Z(Fr, "Notify");
var Br = Fr;
globalThis.Notify = Br;
const jr = ["success", "error", "warning", "info"], Vr = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
], Hr = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: !0,
  autotimeout: 4e3,
  position: "right top"
};
function Pe(e = {}) {
  const t = {
    ...Hr,
    ...e
  };
  jr.includes(t.status) || (console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`), t.status = "info"), Vr.includes(t.position) || (console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`), t.position = "right top"), new Br(t);
}
const hl = {
  custom: Pe,
  success(e, t = "Success", n = {}) {
    Pe({
      status: "success",
      title: t,
      text: e,
      ...n
    });
  },
  error(e, t = "Error", n = {}) {
    Pe({
      status: "error",
      title: t,
      text: e,
      ...n
    });
  },
  warning(e, t = "Warning", n = {}) {
    Pe({
      status: "warning",
      title: t,
      text: e,
      ...n
    });
  },
  info(e, t = "Info", n = {}) {
    Pe({
      status: "info",
      title: t,
      text: e,
      ...n
    });
  },
  setDefaults(e = {}) {
    Object.assign(Hr, e);
  },
  get allowedStatuses() {
    return [...jr];
  },
  get allowedPositions() {
    return [...Vr];
  }
}, ln = function() {
}, He = {}, pt = {}, We = {};
function pl(e, t) {
  e = Array.isArray(e) ? e : [e];
  const n = [];
  let i = e.length, r = i, s, o, a, l;
  for (s = function(c, u) {
    u.length && n.push(c), r--, r || t(n);
  }; i--; ) {
    if (o = e[i], a = pt[o], a) {
      s(o, a);
      continue;
    }
    l = We[o] = We[o] || [], l.push(s);
  }
}
function Wr(e, t) {
  if (!e) return;
  const n = We[e];
  if (pt[e] = t, !!n)
    for (; n.length; )
      n[0](e, t), n.splice(0, 1);
}
function cn(e, t) {
  typeof e == "function" && (e = { success: e }), t.length ? (e.error || ln)(t) : (e.success || ln)(e);
}
function ml(e, t, n, i, r, s, o, a) {
  let l = e.type[0];
  if (a)
    try {
      n.sheet.cssText.length || (l = "e");
    } catch (c) {
      c.code !== 18 && (l = "e");
    }
  if (l === "e") {
    if (s += 1, s < o)
      return qr(t, i, r, s);
  } else if (n.rel === "preload" && n.as === "style") {
    n.rel = "stylesheet";
    return;
  }
  i(t, l, e.defaultPrevented);
}
function qr(e, t, n, i) {
  const r = document, s = n.async, o = (n.numRetries || 0) + 1, a = n.before || ln, l = e.replace(/[\?|#].*$/, ""), c = e.replace(/^(css|img|module|nomodule)!/, "");
  let u, d, f;
  if (i = i || 0, /(^css!|\.css$)/.test(l))
    f = r.createElement("link"), f.rel = "stylesheet", f.href = c, u = "hideFocus" in f, u && f.relList && (u = 0, f.rel = "preload", f.as = "style"), n.inlineStyleNonce && f.setAttribute("nonce", n.inlineStyleNonce);
  else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l))
    f = r.createElement("img"), f.src = c;
  else if (f = r.createElement("script"), f.src = c, f.async = s === void 0 ? !0 : s, n.inlineScriptNonce && f.setAttribute("nonce", n.inlineScriptNonce), d = "noModule" in f, /^module!/.test(l)) {
    if (!d) return t(e, "l");
    f.type = "module";
  } else if (/^nomodule!/.test(l) && d)
    return t(e, "l");
  const v = function(x) {
    ml(x, e, f, t, n, i, o, u);
  };
  f.addEventListener("load", v, { once: !0 }), f.addEventListener("error", v, { once: !0 }), a(e, f) !== !1 && r.head.appendChild(f);
}
function gl(e, t, n) {
  e = Array.isArray(e) ? e : [e];
  let i = e.length, r = [];
  function s(o, a, l) {
    if (a === "e" && r.push(o), a === "b")
      if (l) r.push(o);
      else return;
    i--, i || t(r);
  }
  for (let o = 0; o < e.length; o++)
    qr(e[o], s, n);
}
function ne(e, t, n) {
  let i, r;
  if (t && typeof t == "string" && t.trim && (i = t.trim()), r = (i ? n : t) || {}, i) {
    if (i in He)
      throw "LoadJS";
    He[i] = !0;
  }
  function s(o, a) {
    gl(e, function(l) {
      cn(r, l), o && cn({ success: o, error: a }, l), Wr(i, l);
    }, r);
  }
  if (r.returnPromise)
    return new Promise(s);
  s();
}
ne.ready = function(t, n) {
  return pl(t, function(i) {
    cn(n, i);
  }), ne;
};
ne.done = function(t) {
  Wr(t, []);
};
ne.reset = function() {
  Object.keys(He).forEach((t) => delete He[t]), Object.keys(pt).forEach((t) => delete pt[t]), Object.keys(We).forEach((t) => delete We[t]);
};
ne.isDefined = function(t) {
  return t in He;
};
function vl(e) {
  if (typeof Alpine > "u" || typeof Alpine.$data != "function") {
    console.error(
      "Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data."
    );
    return;
  }
  if (e instanceof Element) {
    const t = bl(e) || e;
    let n = Alpine.$data(t);
    if (n === void 0) {
      const i = t.closest?.("[x-data]");
      i && (n = Alpine.$data(i));
    }
    return n === void 0 && ui("element", t), n;
  }
  if (typeof e == "string") {
    const t = e.trim();
    if (!t) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return;
    }
    const n = `[data-alpine-root="${Yr(t)}"]`;
    let i = null;
    const r = document.getElementById(t);
    if (r && (i = r.matches(n) ? r : r.querySelector(n)), i || (i = Ur(t)), !i) {
      console.warn(
        `Rizzy.$data: Could not locate an Alpine root using ${n} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${t}"' is present.`
      );
      return;
    }
    const s = Alpine.$data(i);
    return s === void 0 && ui(`data-alpine-root="${t}"`, i), s;
  }
  console.warn("Rizzy.$data: Expected a non-empty string id or an Element.");
}
function bl(e) {
  if (!(e instanceof Element)) return null;
  const t = e.tagName?.toLowerCase?.() === "rz-proxy", n = e.getAttribute?.("data-for");
  if (t || n) {
    const i = n || "";
    if (!i) return e;
    const r = Ur(i);
    return r || (console.warn(
      `Rizzy.$data: Proxy element could not resolve Alpine root for id "${i}". Ensure the teleported root rendered with data-alpine-root="${i}".`
    ), null);
  }
  return e;
}
function Ur(e) {
  const t = `[data-alpine-root="${Yr(e)}"]`, n = document.querySelectorAll(t);
  for (const i of n)
    if (i.hasAttribute("x-data")) return i;
  return n.length > 0 ? n[0] : document.getElementById(e) || null;
}
function Yr(e) {
  try {
    if (window.CSS && typeof window.CSS.escape == "function")
      return window.CSS.escape(e);
  } catch {
  }
  return String(e).replace(/"/g, '\\"');
}
function ui(e, t) {
  const n = `${t.tagName?.toLowerCase?.() || "node"}${t.id ? "#" + t.id : ""}${t.classList?.length ? "." + Array.from(t.classList).join(".") : ""}`;
  console.warn(
    `Rizzy.$data: Located target via ${e} (${n}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`
  );
}
function yl(e) {
  e.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: !1,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function wl(e) {
  e.data("accordionItem", () => ({
    open: !1,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true", this.sectionId = this.$el.dataset.sectionId, this.expandedClass = this.$el.dataset.expandedClass;
      const t = this;
      typeof this.selected < "u" && typeof this.allowMultiple < "u" ? this.$watch("selected", (n, i) => {
        n !== t.sectionId && !t.allowMultiple && (t.open = !1);
      }) : console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId, this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function _l(e) {
  e.data("rzAlert", () => ({
    parentElement: null,
    showAlert: !0,
    init() {
      const t = this.$el.dataset.alpineRoot || this.$el.closest("[data-alpine-root]");
      this.parentElement = document.getElementById(t);
    },
    dismiss() {
      this.showAlert = !1;
      const t = this;
      setTimeout(() => {
        t.parentElement.style.display = "none";
      }, 205);
    }
  }));
}
function xl(e) {
  e.data("rzAspectRatio", () => ({
    init() {
      const t = parseFloat(this.$el.dataset.ratio);
      if (!isNaN(t) && t > 0) {
        const n = 100 / t + "%";
        this.$el.style.paddingBottom = n;
      } else
        this.$el.style.paddingBottom = "100%";
    }
  }));
}
function El(e) {
  e.data("rzBrowser", () => ({
    screenSize: "",
    setDesktopScreenSize() {
      this.screenSize = "";
    },
    setTabletScreenSize() {
      this.screenSize = "max-w-2xl";
    },
    setPhoneScreenSize() {
      this.screenSize = "max-w-sm";
    },
    // Get CSS classes for browser border based on screen size
    getBrowserBorderCss() {
      return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
    },
    // Get CSS classes for desktop screen button styling
    getDesktopScreenCss() {
      return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for tablet screen button styling
    getTabletScreenCss() {
      return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for phone screen button styling
    getPhoneScreenCss() {
      return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    }
  }));
}
function Il(e, t) {
  e.data("rzCalendar", () => ({
    calendar: null,
    initialized: !1,
    init() {
      const n = JSON.parse(this.$el.dataset.assets || "[]"), i = this.$el.dataset.configId, r = this.$el.dataset.nonce;
      if (n.length === 0) {
        console.warn("RzCalendar: No assets configured.");
        return;
      }
      t(n, {
        success: () => {
          this.initCalendar(i);
        },
        error: (s) => console.error("RzCalendar: Failed to load assets", s)
      }, r);
    },
    initCalendar(n) {
      const i = document.getElementById(n);
      if (!i) {
        console.error(`RzCalendar: Config element #${n} not found.`);
        return;
      }
      let r = {};
      try {
        r = JSON.parse(i.textContent);
      } catch (a) {
        console.error("RzCalendar: Failed to parse config JSON", a);
        return;
      }
      const s = {
        clickDay: (a, l) => this.dispatchCalendarEvent("clickDay", { event: a, dates: l.selectedDates }),
        clickWeekNumber: (a, l, c, u) => this.dispatchCalendarEvent("clickWeekNumber", { event: a, number: l, days: c, year: u }),
        clickMonth: (a, l) => this.dispatchCalendarEvent("clickMonth", { event: a, month: l }),
        clickYear: (a, l) => this.dispatchCalendarEvent("clickYear", { event: a, year: l }),
        clickArrow: (a, l, c) => this.dispatchCalendarEvent("clickArrow", { event: a, year: l, month: c }),
        changeTime: (a, l, c, u, d) => this.dispatchCalendarEvent("changeTime", { event: a, time: l, hours: c, minutes: u, keeping: d }),
        changeView: (a) => this.dispatchCalendarEvent("changeView", { view: a }),
        getDays: (a, l, c, u, d) => {
        }
      }, o = {
        ...r.options,
        styles: r.styles,
        // Correct property name for VCP
        actions: s
      };
      window.VanillaCalendarPro ? (this.calendar = new VanillaCalendarPro.Calendar(this.$refs.calendarEl, o), this.calendar.init(), this.initialized = !0, this.dispatchCalendarEvent("init", { instance: this.calendar })) : console.error("RzCalendar: VanillaCalendar global not found.");
    },
    dispatchCalendarEvent(n, i) {
      this.$dispatch(`rz:calendar:${n}`, i);
    },
    destroy() {
      this.calendar && (this.calendar.destroy(), this.dispatchCalendarEvent("destroy", {}));
    }
  }));
}
function Sl(e, t) {
  function n(i) {
    if (!i) return {};
    const r = document.getElementById(i);
    if (!r)
      return console.warn(`[rzCarousel] JSON script element #${i} not found.`), {};
    try {
      return JSON.parse(r.textContent || "{}");
    } catch (s) {
      return console.error(`[rzCarousel] Failed to parse JSON from #${i}:`, s), {};
    }
  }
  e.data("rzCarousel", () => ({
    emblaApi: null,
    canScrollPrev: !1,
    canScrollNext: !1,
    selectedIndex: 0,
    scrollSnaps: [],
    init() {
      const i = (() => {
        try {
          return JSON.parse(this.$el.dataset.assets || "[]");
        } catch (c) {
          return console.error("[rzCarousel] Bad assets JSON:", c), [];
        }
      })(), r = this.$el.dataset.nonce || "", s = n(this.$el.dataset.config), o = s.Options || {}, a = s.Plugins || [], l = this;
      i.length > 0 && typeof t == "function" ? t(
        i,
        {
          success() {
            window.EmblaCarousel ? l.initializeEmbla(o, a) : console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.");
          },
          error(c) {
            console.error("[rzCarousel] Failed to load EmblaCarousel assets.", c);
          }
        },
        r
      ) : window.EmblaCarousel ? this.initializeEmbla(o, a) : console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.");
    },
    initializeEmbla(i, r) {
      const s = this.$el.querySelector('[x-ref="viewport"]');
      if (!s) {
        console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');
        return;
      }
      const o = this.instantiatePlugins(r);
      this.emblaApi = window.EmblaCarousel(s, i, o), this.emblaApi.on("select", this.onSelect.bind(this)), this.emblaApi.on("reInit", this.onSelect.bind(this)), this.onSelect();
    },
    instantiatePlugins(i) {
      return !Array.isArray(i) || i.length === 0 ? [] : i.map((r) => {
        const s = window[r.Name];
        if (typeof s != "function")
          return console.error(`[rzCarousel] Plugin constructor '${r.Name}' not found on window object.`), null;
        try {
          return s(r.Options || {});
        } catch (o) {
          return console.error(`[rzCarousel] Error instantiating plugin '${r.Name}':`, o), null;
        }
      }).filter(Boolean);
    },
    destroy() {
      this.emblaApi && this.emblaApi.destroy();
    },
    onSelect() {
      this.emblaApi && (this.selectedIndex = this.emblaApi.selectedScrollSnap(), this.canScrollPrev = this.emblaApi.canScrollPrev(), this.canScrollNext = this.emblaApi.canScrollNext(), this.scrollSnaps = this.emblaApi.scrollSnapList());
    },
    cannotScrollPrev() {
      return !this.canScrollPrev;
    },
    cannotScrollNext() {
      return !this.canScrollNext;
    },
    scrollPrev() {
      this.emblaApi?.scrollPrev();
    },
    scrollNext() {
      this.emblaApi?.scrollNext();
    },
    scrollTo(i) {
      this.emblaApi?.scrollTo(i);
    }
  }));
}
function Cl(e, t) {
  e.data("rzCodeViewer", () => ({
    expand: !1,
    border: !0,
    copied: !1,
    copyTitle: "Copy",
    // Default title
    copiedTitle: "Copied!",
    // Default title
    init() {
      const n = JSON.parse(this.$el.dataset.assets), i = this.$el.dataset.codeid, r = this.$el.dataset.nonce;
      this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle, this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle, t(n, {
        success: function() {
          const s = document.getElementById(i);
          window.hljs && s && window.hljs.highlightElement(s);
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, r);
    },
    // Function to check if code is NOT copied (for x-show)
    notCopied() {
      return !this.copied;
    },
    // Function to reset the copied state (e.g., on blur)
    disableCopied() {
      this.copied = !1;
    },
    // Function to toggle the expand state
    toggleExpand() {
      this.expand = !this.expand;
    },
    // Function to copy code to clipboard
    copyHTML() {
      navigator.clipboard.writeText(this.$refs.codeBlock.textContent), this.copied = !this.copied;
    },
    // Get the title for the copy button (copy/copied)
    getCopiedTitle() {
      return this.copied ? this.copiedTitle : this.copyTitle;
    },
    // Get CSS classes for the copy button based on copied state
    getCopiedCss() {
      return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
    },
    // Get CSS classes for the code container based on expand state
    getExpandCss() {
      return [this.expand ? "" : "max-h-60"];
    },
    // Get CSS classes for the expand button icon based on expand state
    getExpandButtonCss() {
      return this.expand ? "rotate-180" : "rotate-0";
    }
  }));
}
function Tl(e) {
  e.data("rzCollapsible", () => ({
    isOpen: !1,
    init() {
      this.isOpen = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.isOpen = !this.isOpen;
    },
    state() {
      return this.isOpen ? "open" : "closed";
    }
  }));
}
function Al(e, t) {
  e.data("rzCombobox", () => ({
    tomSelect: null,
    init() {
      const n = JSON.parse(this.$el.dataset.assets || "[]"), i = this.$el.dataset.nonce;
      n.length > 0 && typeof t == "function" ? t(n, {
        success: () => this.initTomSelect(),
        error: (r) => console.error("RzCombobox: Failed to load assets.", r)
      }, i) : window.TomSelect && this.initTomSelect();
    },
    initTomSelect() {
      const n = this.$refs.selectInput;
      if (!n) return;
      const i = document.getElementById(this.$el.dataset.configId), r = i ? JSON.parse(i.textContent) : {}, s = {}, o = (a, l) => {
        if (!a) return null;
        const c = document.createElement("div");
        let u = l.item;
        if (typeof u == "string")
          try {
            u = JSON.parse(u);
          } catch {
          }
        const d = {
          ...l,
          item: u
        };
        return e && typeof e.addScopeToNode == "function" ? e.addScopeToNode(c, d) : c._x_dataStack = [d], c.innerHTML = a.innerHTML, c;
      };
      this.$refs.optionTemplate && (s.option = (a, l) => o(this.$refs.optionTemplate, a)), this.$refs.itemTemplate && (s.item = (a, l) => o(this.$refs.itemTemplate, a)), r.dataAttr = "data-item", this.tomSelect = new TomSelect(n, {
        ...r,
        render: s,
        onInitialize: function() {
          this.sync();
        }
      });
    },
    destroy() {
      this.tomSelect && (this.tomSelect.destroy(), this.tomSelect = null);
    }
  }));
}
function Ol(e, t) {
  e.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const n = this.$el.dataset.config, i = document.getElementById(this.$el.dataset.uid + "-input");
      if (n) {
        const o = JSON.parse(n);
        o && (this.options = o.options || {}, this.placeholder = o.placeholder || "", this.prependText = o.prependText || "");
      }
      const r = JSON.parse(this.$el.dataset.assets), s = this.$el.dataset.nonce;
      t(r, {
        success: function() {
          window.flatpickr && i && window.flatpickr(i, this.options);
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, s);
    }
  }));
}
function $l(e) {
  e.data("rzDialog", () => ({
    modalOpen: !1,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: !0,
    closeOnClickOutside: !0,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "", this.bodyId = this.$el.dataset.bodyId || "", this.footerId = this.$el.dataset.footerId || "", this.nonce = this.$el.dataset.nonce || "", this.eventTriggerName = this.$el.dataset.eventTriggerName || "", this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName, this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false", this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false", this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: !0
      })), this.eventTriggerName && (this._openListener = (t) => {
        this.openModal(t);
      }, window.addEventListener(this.eventTriggerName, this._openListener)), this._closeEventListener = (t) => {
        this.modalOpen && this.closeModalInternally("event");
      }, window.addEventListener(this.closeEventName, this._closeEventListener), this._escapeListener = (t) => {
        this.modalOpen && this.closeOnEscape && t.key === "Escape" && this.closeModalInternally("escape");
      }, window.addEventListener("keydown", this._escapeListener), this.$watch("modalOpen", (t) => {
        const n = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", t);
        const i = document.body.offsetWidth - n;
        document.body.style.setProperty("--page-scrollbar-width", `${i}px`), t ? this.$nextTick(() => {
          this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(), this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        }) : this.$nextTick(() => {
          this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        });
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      this._openListener && this.eventTriggerName && window.removeEventListener(this.eventTriggerName, this._openListener), this._closeEventListener && window.removeEventListener(this.closeEventName, this._closeEventListener), this._escapeListener && window.removeEventListener("keydown", this._escapeListener), document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px");
    },
    openModal(t = null) {
      const n = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(n), n.defaultPrevented || (this.modalOpen = !0);
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(t = "unknown") {
      const n = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(n), n.defaultPrevented || (document.activeElement?.blur && document.activeElement.blur(), this.modalOpen = !1, document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px"));
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      this.closeOnClickOutside && this.closeModalInternally("backdrop");
    }
  }));
}
const un = Math.min, we = Math.max, mt = Math.round, K = (e) => ({
  x: e,
  y: e
}), Nl = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, kl = {
  start: "end",
  end: "start"
};
function di(e, t, n) {
  return we(e, un(t, n));
}
function Ot(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function be(e) {
  return e.split("-")[0];
}
function $t(e) {
  return e.split("-")[1];
}
function Kr(e) {
  return e === "x" ? "y" : "x";
}
function Jr(e) {
  return e === "y" ? "height" : "width";
}
function me(e) {
  return ["top", "bottom"].includes(be(e)) ? "y" : "x";
}
function Gr(e) {
  return Kr(me(e));
}
function Rl(e, t, n) {
  n === void 0 && (n = !1);
  const i = $t(e), r = Gr(e), s = Jr(r);
  let o = r === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (o = gt(o)), [o, gt(o)];
}
function Ll(e) {
  const t = gt(e);
  return [dn(e), t, dn(t)];
}
function dn(e) {
  return e.replace(/start|end/g, (t) => kl[t]);
}
function Dl(e, t, n) {
  const i = ["left", "right"], r = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? r : i : t ? i : r;
    case "left":
    case "right":
      return t ? s : o;
    default:
      return [];
  }
}
function Ml(e, t, n, i) {
  const r = $t(e);
  let s = Dl(be(e), n === "start", i);
  return r && (s = s.map((o) => o + "-" + r), t && (s = s.concat(s.map(dn)))), s;
}
function gt(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Nl[t]);
}
function Pl(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function zl(e) {
  return typeof e != "number" ? Pl(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function vt(e) {
  const {
    x: t,
    y: n,
    width: i,
    height: r
  } = e;
  return {
    width: i,
    height: r,
    top: n,
    left: t,
    right: t + i,
    bottom: n + r,
    x: t,
    y: n
  };
}
function fi(e, t, n) {
  let {
    reference: i,
    floating: r
  } = e;
  const s = me(t), o = Gr(t), a = Jr(o), l = be(t), c = s === "y", u = i.x + i.width / 2 - r.width / 2, d = i.y + i.height / 2 - r.height / 2, f = i[a] / 2 - r[a] / 2;
  let v;
  switch (l) {
    case "top":
      v = {
        x: u,
        y: i.y - r.height
      };
      break;
    case "bottom":
      v = {
        x: u,
        y: i.y + i.height
      };
      break;
    case "right":
      v = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      v = {
        x: i.x - r.width,
        y: d
      };
      break;
    default:
      v = {
        x: i.x,
        y: i.y
      };
  }
  switch ($t(t)) {
    case "start":
      v[o] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      v[o] += f * (n && c ? -1 : 1);
      break;
  }
  return v;
}
const Fl = async (e, t, n) => {
  const {
    placement: i = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: o
  } = n, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: d
  } = fi(c, i, l), f = i, v = {}, x = 0;
  for (let w = 0; w < a.length; w++) {
    const {
      name: p,
      fn: g
    } = a[w], {
      x: h,
      y,
      data: E,
      reset: _
    } = await g({
      x: u,
      y: d,
      initialPlacement: i,
      placement: f,
      strategy: r,
      middlewareData: v,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = h ?? u, d = y ?? d, v = {
      ...v,
      [p]: {
        ...v[p],
        ...E
      }
    }, _ && x <= 50 && (x++, typeof _ == "object" && (_.placement && (f = _.placement), _.rects && (c = _.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : _.rects), {
      x: u,
      y: d
    } = fi(c, f, l)), w = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: r,
    middlewareData: v
  };
};
async function Zr(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: i,
    y: r,
    platform: s,
    rects: o,
    elements: a,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: v = 0
  } = Ot(t, e), x = zl(v), p = a[f ? d === "floating" ? "reference" : "floating" : d], g = vt(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(p))) == null || n ? p : p.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), h = d === "floating" ? {
    x: i,
    y: r,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, y = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), E = await (s.isElement == null ? void 0 : s.isElement(y)) ? await (s.getScale == null ? void 0 : s.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, _ = vt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: h,
    offsetParent: y,
    strategy: l
  }) : h);
  return {
    top: (g.top - _.top + x.top) / E.y,
    bottom: (_.bottom - g.bottom + x.bottom) / E.y,
    left: (g.left - _.left + x.left) / E.x,
    right: (_.right - g.right + x.right) / E.x
  };
}
const Bl = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, i;
      const {
        placement: r,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: x = "none",
        flipAlignment: w = !0,
        ...p
      } = Ot(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const g = be(r), h = me(a), y = be(a) === a, E = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), _ = f || (y || !w ? [gt(a)] : Ll(a)), m = x !== "none";
      !f && m && _.push(...Ml(a, w, x, E));
      const b = [a, ..._], I = await Zr(t, p), S = [];
      let C = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (u && S.push(I[g]), d) {
        const P = Rl(r, o, E);
        S.push(I[P[0]], I[P[1]]);
      }
      if (C = [...C, {
        placement: r,
        overflows: S
      }], !S.every((P) => P <= 0)) {
        var T, R;
        const P = (((T = s.flip) == null ? void 0 : T.index) || 0) + 1, ae = b[P];
        if (ae) {
          var L;
          const z = d === "alignment" ? h !== me(ae) : !1, U = ((L = C[0]) == null ? void 0 : L.overflows[0]) > 0;
          if (!z || U)
            return {
              data: {
                index: P,
                overflows: C
              },
              reset: {
                placement: ae
              }
            };
        }
        let B = (R = C.filter((z) => z.overflows[0] <= 0).sort((z, U) => z.overflows[1] - U.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!B)
          switch (v) {
            case "bestFit": {
              var q;
              const z = (q = C.filter((U) => {
                if (m) {
                  const Q = me(U.placement);
                  return Q === h || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Q === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((Q) => Q > 0).reduce((Q, as) => Q + as, 0)]).sort((U, Q) => U[1] - Q[1])[0]) == null ? void 0 : q[0];
              z && (B = z);
              break;
            }
            case "initialPlacement":
              B = a;
              break;
          }
        if (r !== B)
          return {
            reset: {
              placement: B
            }
          };
      }
      return {};
    }
  };
};
async function jl(e, t) {
  const {
    placement: n,
    platform: i,
    elements: r
  } = e, s = await (i.isRTL == null ? void 0 : i.isRTL(r.floating)), o = be(n), a = $t(n), l = me(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = s && l ? -1 : 1, d = Ot(t, e);
  let {
    mainAxis: f,
    crossAxis: v,
    alignmentAxis: x
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof x == "number" && (v = a === "end" ? x * -1 : x), l ? {
    x: v * u,
    y: f * c
  } : {
    x: f * c,
    y: v * u
  };
}
const Vl = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, i;
      const {
        x: r,
        y: s,
        placement: o,
        middlewareData: a
      } = t, l = await jl(t, e);
      return o === ((n = a.offset) == null ? void 0 : n.placement) && (i = a.arrow) != null && i.alignmentOffset ? {} : {
        x: r + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, Hl = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: i,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (p) => {
            let {
              x: g,
              y: h
            } = p;
            return {
              x: g,
              y: h
            };
          }
        },
        ...l
      } = Ot(e, t), c = {
        x: n,
        y: i
      }, u = await Zr(t, l), d = me(be(r)), f = Kr(d);
      let v = c[f], x = c[d];
      if (s) {
        const p = f === "y" ? "top" : "left", g = f === "y" ? "bottom" : "right", h = v + u[p], y = v - u[g];
        v = di(h, v, y);
      }
      if (o) {
        const p = d === "y" ? "top" : "left", g = d === "y" ? "bottom" : "right", h = x + u[p], y = x - u[g];
        x = di(h, x, y);
      }
      const w = a.fn({
        ...t,
        [f]: v,
        [d]: x
      });
      return {
        ...w,
        data: {
          x: w.x - n,
          y: w.y - i,
          enabled: {
            [f]: s,
            [d]: o
          }
        }
      };
    }
  };
};
function Nt() {
  return typeof window < "u";
}
function $e(e) {
  return Xr(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function M(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function X(e) {
  var t;
  return (t = (Xr(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Xr(e) {
  return Nt() ? e instanceof Node || e instanceof M(e).Node : !1;
}
function V(e) {
  return Nt() ? e instanceof Element || e instanceof M(e).Element : !1;
}
function J(e) {
  return Nt() ? e instanceof HTMLElement || e instanceof M(e).HTMLElement : !1;
}
function hi(e) {
  return !Nt() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof M(e).ShadowRoot;
}
function Je(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
    display: r
  } = H(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !["inline", "contents"].includes(r);
}
function Wl(e) {
  return ["table", "td", "th"].includes($e(e));
}
function kt(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Ln(e) {
  const t = Dn(), n = V(e) ? H(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((i) => n[i] ? n[i] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((i) => (n.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (n.contain || "").includes(i));
}
function ql(e) {
  let t = se(e);
  for (; J(t) && !Ie(t); ) {
    if (Ln(t))
      return t;
    if (kt(t))
      return null;
    t = se(t);
  }
  return null;
}
function Dn() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ie(e) {
  return ["html", "body", "#document"].includes($e(e));
}
function H(e) {
  return M(e).getComputedStyle(e);
}
function Rt(e) {
  return V(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function se(e) {
  if ($e(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    hi(e) && e.host || // Fallback.
    X(e)
  );
  return hi(t) ? t.host : t;
}
function Qr(e) {
  const t = se(e);
  return Ie(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : J(t) && Je(t) ? t : Qr(t);
}
function es(e, t, n) {
  var i;
  t === void 0 && (t = []);
  const r = Qr(e), s = r === ((i = e.ownerDocument) == null ? void 0 : i.body), o = M(r);
  return s ? (fn(o), t.concat(o, o.visualViewport || [], Je(r) ? r : [], [])) : t.concat(r, es(r, []));
}
function fn(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function ts(e) {
  const t = H(e);
  let n = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const r = J(e), s = r ? e.offsetWidth : n, o = r ? e.offsetHeight : i, a = mt(n) !== s || mt(i) !== o;
  return a && (n = s, i = o), {
    width: n,
    height: i,
    $: a
  };
}
function ns(e) {
  return V(e) ? e : e.contextElement;
}
function _e(e) {
  const t = ns(e);
  if (!J(t))
    return K(1);
  const n = t.getBoundingClientRect(), {
    width: i,
    height: r,
    $: s
  } = ts(t);
  let o = (s ? mt(n.width) : n.width) / i, a = (s ? mt(n.height) : n.height) / r;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const Ul = /* @__PURE__ */ K(0);
function is(e) {
  const t = M(e);
  return !Dn() || !t.visualViewport ? Ul : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Yl(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== M(e) ? !1 : t;
}
function qe(e, t, n, i) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), s = ns(e);
  let o = K(1);
  t && (i ? V(i) && (o = _e(i)) : o = _e(e));
  const a = Yl(s, n, i) ? is(s) : K(0);
  let l = (r.left + a.x) / o.x, c = (r.top + a.y) / o.y, u = r.width / o.x, d = r.height / o.y;
  if (s) {
    const f = M(s), v = i && V(i) ? M(i) : i;
    let x = f, w = fn(x);
    for (; w && i && v !== x; ) {
      const p = _e(w), g = w.getBoundingClientRect(), h = H(w), y = g.left + (w.clientLeft + parseFloat(h.paddingLeft)) * p.x, E = g.top + (w.clientTop + parseFloat(h.paddingTop)) * p.y;
      l *= p.x, c *= p.y, u *= p.x, d *= p.y, l += y, c += E, x = M(w), w = fn(x);
    }
  }
  return vt({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function Mn(e, t) {
  const n = Rt(e).scrollLeft;
  return t ? t.left + n : qe(X(e)).left + n;
}
function rs(e, t, n) {
  n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), r = i.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Mn(e, i)
  )), s = i.top + t.scrollTop;
  return {
    x: r,
    y: s
  };
}
function Kl(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: i,
    strategy: r
  } = e;
  const s = r === "fixed", o = X(i), a = t ? kt(t.floating) : !1;
  if (i === o || a && s)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = K(1);
  const u = K(0), d = J(i);
  if ((d || !d && !s) && (($e(i) !== "body" || Je(o)) && (l = Rt(i)), J(i))) {
    const v = qe(i);
    c = _e(i), u.x = v.x + i.clientLeft, u.y = v.y + i.clientTop;
  }
  const f = o && !d && !s ? rs(o, l, !0) : K(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function Jl(e) {
  return Array.from(e.getClientRects());
}
function Gl(e) {
  const t = X(e), n = Rt(e), i = e.ownerDocument.body, r = we(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), s = we(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let o = -n.scrollLeft + Mn(e);
  const a = -n.scrollTop;
  return H(i).direction === "rtl" && (o += we(t.clientWidth, i.clientWidth) - r), {
    width: r,
    height: s,
    x: o,
    y: a
  };
}
function Zl(e, t) {
  const n = M(e), i = X(e), r = n.visualViewport;
  let s = i.clientWidth, o = i.clientHeight, a = 0, l = 0;
  if (r) {
    s = r.width, o = r.height;
    const c = Dn();
    (!c || c && t === "fixed") && (a = r.offsetLeft, l = r.offsetTop);
  }
  return {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
function Xl(e, t) {
  const n = qe(e, !0, t === "fixed"), i = n.top + e.clientTop, r = n.left + e.clientLeft, s = J(e) ? _e(e) : K(1), o = e.clientWidth * s.x, a = e.clientHeight * s.y, l = r * s.x, c = i * s.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function pi(e, t, n) {
  let i;
  if (t === "viewport")
    i = Zl(e, n);
  else if (t === "document")
    i = Gl(X(e));
  else if (V(t))
    i = Xl(t, n);
  else {
    const r = is(e);
    i = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return vt(i);
}
function ss(e, t) {
  const n = se(e);
  return n === t || !V(n) || Ie(n) ? !1 : H(n).position === "fixed" || ss(n, t);
}
function Ql(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let i = es(e, []).filter((a) => V(a) && $e(a) !== "body"), r = null;
  const s = H(e).position === "fixed";
  let o = s ? se(e) : e;
  for (; V(o) && !Ie(o); ) {
    const a = H(o), l = Ln(o);
    !l && a.position === "fixed" && (r = null), (s ? !l && !r : !l && a.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || Je(o) && !l && ss(e, o)) ? i = i.filter((u) => u !== o) : r = a, o = se(o);
  }
  return t.set(e, i), i;
}
function ec(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: i,
    strategy: r
  } = e;
  const o = [...n === "clippingAncestors" ? kt(t) ? [] : Ql(t, this._c) : [].concat(n), i], a = o[0], l = o.reduce((c, u) => {
    const d = pi(t, u, r);
    return c.top = we(d.top, c.top), c.right = un(d.right, c.right), c.bottom = un(d.bottom, c.bottom), c.left = we(d.left, c.left), c;
  }, pi(t, a, r));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function tc(e) {
  const {
    width: t,
    height: n
  } = ts(e);
  return {
    width: t,
    height: n
  };
}
function nc(e, t, n) {
  const i = J(t), r = X(t), s = n === "fixed", o = qe(e, !0, s, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = K(0);
  function c() {
    l.x = Mn(r);
  }
  if (i || !i && !s)
    if (($e(t) !== "body" || Je(r)) && (a = Rt(t)), i) {
      const v = qe(t, !0, s, t);
      l.x = v.x + t.clientLeft, l.y = v.y + t.clientTop;
    } else r && c();
  s && !i && r && c();
  const u = r && !i && !s ? rs(r, a) : K(0), d = o.left + a.scrollLeft - l.x - u.x, f = o.top + a.scrollTop - l.y - u.y;
  return {
    x: d,
    y: f,
    width: o.width,
    height: o.height
  };
}
function Bt(e) {
  return H(e).position === "static";
}
function mi(e, t) {
  if (!J(e) || H(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return X(e) === n && (n = n.ownerDocument.body), n;
}
function os(e, t) {
  const n = M(e);
  if (kt(e))
    return n;
  if (!J(e)) {
    let r = se(e);
    for (; r && !Ie(r); ) {
      if (V(r) && !Bt(r))
        return r;
      r = se(r);
    }
    return n;
  }
  let i = mi(e, t);
  for (; i && Wl(i) && Bt(i); )
    i = mi(i, t);
  return i && Ie(i) && Bt(i) && !Ln(i) ? n : i || ql(e) || n;
}
const ic = async function(e) {
  const t = this.getOffsetParent || os, n = this.getDimensions, i = await n(e.floating);
  return {
    reference: nc(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: i.width,
      height: i.height
    }
  };
};
function rc(e) {
  return H(e).direction === "rtl";
}
const sc = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Kl,
  getDocumentElement: X,
  getClippingRect: ec,
  getOffsetParent: os,
  getElementRects: ic,
  getClientRects: Jl,
  getDimensions: tc,
  getScale: _e,
  isElement: V,
  isRTL: rc
}, bt = Vl, yt = Hl, wt = Bl, _t = (e, t, n) => {
  const i = /* @__PURE__ */ new Map(), r = {
    platform: sc,
    ...n
  }, s = {
    ...r.platform,
    _c: i
  };
  return Fl(e, t, {
    ...r,
    platform: s
  });
};
function oc(e) {
  e.data("rzDropdownMenu", () => ({
    // --- STATE ---
    open: !1,
    isModal: !0,
    ariaExpanded: "false",
    trapActive: !1,
    focusedIndex: null,
    menuItems: [],
    parentEl: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when menu opens
    anchor: "bottom",
    pixelOffset: 3,
    isSubmenuActive: !1,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    // --- INIT ---
    init() {
      this.$el.id || (this.$el.id = crypto.randomUUID()), this.selfId = this.$el.id, this.parentEl = this.$el, this.triggerEl = this.$refs.trigger, this.anchor = this.$el.dataset.anchor || "bottom", this.pixelOffset = parseInt(this.$el.dataset.offset) || 6, this.isModal = this.$el.dataset.modal !== "false", this.$watch("open", (t) => {
        t ? (this._lastNavAt = 0, this.$nextTick(() => {
          this.contentEl = document.getElementById(`${this.selfId}-content`), this.contentEl && (this.updatePosition(), this.menuItems = Array.from(
            this.contentEl.querySelectorAll(
              '[role^="menuitem"]:not([disabled],[aria-disabled="true"])'
            )
          ));
        }), this.ariaExpanded = "true", this.triggerEl.dataset.state = "open", this.trapActive = this.isModal) : (this.focusedIndex = null, this.closeAllSubmenus(), this.ariaExpanded = "false", delete this.triggerEl.dataset.state, this.trapActive = !1, this.contentEl = null);
      });
    },
    // --- METHODS ---
    updatePosition() {
      !this.triggerEl || !this.contentEl || (this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width", `${this.triggerEl.offsetWidth}px`), _t(this.triggerEl, this.contentEl, {
        placement: this.anchor,
        middleware: [bt(this.pixelOffset), wt(), yt({ padding: 8 })]
      }).then(({ x: t, y: n }) => {
        Object.assign(this.contentEl.style, { left: `${t}px`, top: `${n}px` });
      }));
    },
    toggle() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      } else
        this.open = !0, this.focusedIndex = -1;
    },
    handleOutsideClick() {
      if (!this.open) return;
      this.open = !1;
      let t = this;
      this.$nextTick(() => t.triggerEl?.focus());
    },
    handleTriggerKeydown(t) {
      ["Enter", " ", "ArrowDown", "ArrowUp"].includes(t.key) && (t.preventDefault(), this.open = !0, this.$nextTick(() => {
        t.key === "ArrowUp" ? this.focusLastItem() : this.focusFirstItem();
      }));
    },
    focusNextItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1, this.focusCurrentItem()));
    },
    focusPreviousItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1, this.focusCurrentItem()));
    },
    focusFirstItem() {
      this.menuItems.length && (this.focusedIndex = 0, this.focusCurrentItem());
    },
    focusLastItem() {
      this.menuItems.length && (this.focusedIndex = this.menuItems.length - 1, this.focusCurrentItem());
    },
    focusCurrentItem() {
      this.focusedIndex !== null && this.menuItems[this.focusedIndex] && this.$nextTick(() => this.menuItems[this.focusedIndex].focus());
    },
    focusSelectedItem(t) {
      if (!t || t.getAttribute("aria-disabled") === "true" || t.hasAttribute("disabled")) return;
      const n = this.menuItems.indexOf(t);
      n !== -1 && (this.focusedIndex = n, t.focus());
    },
    handleItemClick(t) {
      const n = t.currentTarget;
      if (n.getAttribute("aria-disabled") === "true" || n.hasAttribute("disabled")) return;
      if (n.getAttribute("aria-haspopup") === "menu") {
        e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
        return;
      }
      this.open = !1;
      let i = this;
      this.$nextTick(() => i.triggerEl?.focus());
    },
    handleItemMouseEnter(t) {
      const n = t.currentTarget;
      this.focusSelectedItem(n), n.getAttribute("aria-haspopup") !== "menu" && this.closeAllSubmenus();
    },
    handleWindowEscape() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      }
    },
    handleContentTabKey() {
      if (this.open) {
        this.open = !1;
        let t = this;
        this.$nextTick(() => t.triggerEl?.focus());
      }
    },
    handleTriggerMouseover() {
      let t = this;
      this.$nextTick(() => t.$el.firstElementChild?.focus());
    },
    closeAllSubmenus() {
      this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]').forEach((n) => {
        e.$data(n)?.closeSubmenu();
      }), this.isSubmenuActive = !1;
    }
  })), e.data("rzDropdownSubmenu", () => ({
    // --- STATE ---
    open: !1,
    ariaExpanded: "false",
    parentDropdown: null,
    triggerEl: null,
    contentEl: null,
    // Will be populated when submenu opens
    menuItems: [],
    focusedIndex: null,
    anchor: "right-start",
    pixelOffset: 0,
    navThrottle: 100,
    _lastNavAt: 0,
    selfId: null,
    siblingContainer: null,
    closeTimeout: null,
    closeDelay: 150,
    // --- INIT ---
    init() {
      this.$el.id || (this.$el.id = crypto.randomUUID()), this.selfId = this.$el.id;
      const t = this.$el.dataset.parentId;
      if (t) {
        const n = document.getElementById(t);
        n && (this.parentDropdown = e.$data(n));
      }
      if (!this.parentDropdown) {
        console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");
        return;
      }
      this.triggerEl = this.$refs.subTrigger, this.siblingContainer = this.$el.parentElement, this.anchor = this.$el.dataset.subAnchor || this.anchor, this.pixelOffset = parseInt(this.$el.dataset.subOffset) || this.pixelOffset, this.$watch("open", (n) => {
        n ? (this._lastNavAt = 0, this.parentDropdown.isSubmenuActive = !0, this.$nextTick(() => {
          this.contentEl = document.getElementById(`${this.selfId}-subcontent`), this.contentEl && (this.updatePosition(this.contentEl), this.menuItems = Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])')));
        }), this.ariaExpanded = "true", this.triggerEl.dataset.state = "open") : (this.focusedIndex = null, this.ariaExpanded = "false", delete this.triggerEl.dataset.state, this.$nextTick(() => {
          this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]') || (this.parentDropdown.isSubmenuActive = !1);
        }), this.contentEl = null);
      });
    },
    // --- METHODS ---
    updatePosition(t) {
      !this.triggerEl || !t || _t(this.triggerEl, t, {
        placement: this.anchor,
        middleware: [bt(this.pixelOffset), wt(), yt({ padding: 8 })]
      }).then(({ x: n, y: i }) => {
        Object.assign(t.style, { left: `${n}px`, top: `${i}px` });
      });
    },
    handleTriggerMouseEnter() {
      clearTimeout(this.closeTimeout), this.triggerEl.focus(), this.openSubmenu();
    },
    handleTriggerMouseLeave() {
      this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay);
    },
    handleContentMouseEnter() {
      clearTimeout(this.closeTimeout);
    },
    handleContentMouseLeave() {
      const t = this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');
      t && Array.from(t).some((i) => e.$data(i)?.open) || (this.closeTimeout = setTimeout(() => this.closeSubmenu(), this.closeDelay));
    },
    openSubmenu(t = !1) {
      this.open || (this.closeSiblingSubmenus(), this.open = !0, t && this.$nextTick(() => requestAnimationFrame(() => this.focusFirstItem())));
    },
    closeSubmenu() {
      this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]')?.forEach((n) => {
        e.$data(n)?.closeSubmenu();
      }), this.open = !1;
    },
    closeSiblingSubmenus() {
      if (!this.siblingContainer) return;
      Array.from(this.siblingContainer.children).filter(
        (n) => n.hasAttribute("x-data") && n.getAttribute("x-data").startsWith("rzDropdownSubmenu") && n.id !== this.selfId
      ).forEach((n) => {
        e.$data(n)?.closeSubmenu();
      });
    },
    toggleSubmenu() {
      this.open ? this.closeSubmenu() : this.openSubmenu();
    },
    openSubmenuAndFocusFirst() {
      this.openSubmenu(!0);
    },
    handleTriggerKeydown(t) {
      ["ArrowRight", "Enter", " "].includes(t.key) && (t.preventDefault(), this.openSubmenuAndFocusFirst());
    },
    focusNextItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex >= this.menuItems.length - 1 ? 0 : this.focusedIndex + 1, this.focusCurrentItem()));
    },
    focusPreviousItem() {
      const t = Date.now();
      t - this._lastNavAt < this.navThrottle || (this._lastNavAt = t, this.menuItems.length && (this.focusedIndex = this.focusedIndex === null || this.focusedIndex <= 0 ? this.menuItems.length - 1 : this.focusedIndex - 1, this.focusCurrentItem()));
    },
    focusFirstItem() {
      this.menuItems.length && (this.focusedIndex = 0, this.focusCurrentItem());
    },
    focusLastItem() {
      this.menuItems.length && (this.focusedIndex = this.menuItems.length - 1, this.focusCurrentItem());
    },
    focusCurrentItem() {
      this.focusedIndex !== null && this.menuItems[this.focusedIndex] && this.menuItems[this.focusedIndex].focus();
    },
    handleItemClick(t) {
      const n = t.currentTarget;
      if (!(n.getAttribute("aria-disabled") === "true" || n.hasAttribute("disabled"))) {
        if (n.getAttribute("aria-haspopup") === "menu") {
          e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();
          return;
        }
        this.parentDropdown.open = !1, this.$nextTick(() => this.parentDropdown.triggerEl?.focus());
      }
    },
    handleItemMouseEnter(t) {
      const n = t.currentTarget;
      if (n.getAttribute("aria-disabled") === "true" || n.hasAttribute("disabled")) return;
      const i = this.menuItems.indexOf(n);
      i !== -1 && (this.focusedIndex = i, n.focus()), n.getAttribute("aria-haspopup") === "menu" ? e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu() : this.closeSiblingSubmenus();
    },
    handleSubmenuEscape() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    },
    handleSubmenuArrowLeft() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    }
  }));
}
function ac(e) {
  e.data("rzDarkModeToggle", () => ({
    // Proxy all properties to the reactive store
    get mode() {
      return this.$store.theme.mode;
    },
    get prefersDark() {
      return this.$store.theme.prefersDark;
    },
    get effectiveDark() {
      return this.$store.theme.effectiveDark;
    },
    // Proxy properties from the store (isDark/isLight are getters on the store)
    get isDark() {
      return this.$store.theme.isDark;
    },
    get isLight() {
      return this.$store.theme.isLight;
    },
    // Proxy methods
    setLight() {
      this.$store.theme.setLight();
    },
    setDark() {
      this.$store.theme.setDark();
    },
    setAuto() {
      this.$store.theme.setAuto();
    },
    toggle() {
      this.$store.theme.toggle();
    }
  }));
}
function lc(e) {
  e.data("rzEmbeddedPreview", () => ({
    iframe: null,
    onDarkModeToggle: null,
    init() {
      try {
        this.iframe = this.$refs.iframe;
        const t = this.debounce(() => {
          this.resizeIframe(this.iframe);
        }, 50);
        this.resizeIframe(this.iframe), new ResizeObserver((r) => {
          for (let s of r)
            t();
        }).observe(this.iframe);
        const i = this.iframe;
        this.onDarkModeToggle = (r) => {
          i.contentWindow.postMessage(r.detail, "*");
        }, window.addEventListener("darkModeToggle", this.onDarkModeToggle);
      } catch {
        console.error("Cannot access iframe content");
      }
    },
    // Adjusts the iframe height based on its content
    resizeIframe(t) {
      if (t)
        try {
          const n = t.contentDocument || t.contentWindow?.document;
          if (n) {
            const i = n.body;
            if (!i)
              setInterval(() => {
                this.resizeIframe(t);
              }, 150);
            else {
              const r = i.scrollHeight + 15;
              t.style.height = r + "px";
            }
          }
        } catch (n) {
          console.error("Error resizing iframe:", n);
        }
    },
    // Debounce helper to limit function calls
    debounce(t, n = 300) {
      let i;
      return (...r) => {
        clearTimeout(i), i = setTimeout(() => {
          t.apply(this, r);
        }, n);
      };
    },
    destroy() {
      window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
    }
  }));
}
function cc(e) {
  e.data("rzEmpty", () => {
  });
}
function uc(e) {
  e.data("rzHeading", () => ({
    observer: null,
    headingId: "",
    init() {
      this.headingId = this.$el.dataset.alpineRoot;
      const t = this;
      if (typeof this.setCurrentHeading == "function") {
        const n = (r, s) => {
          r.forEach((o) => {
            o.isIntersecting && t.setCurrentHeading(t.headingId);
          });
        }, i = { threshold: 0.5 };
        this.observer = new IntersectionObserver(n, i), this.observer.observe(this.$el);
      } else
        console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
    },
    destroy() {
      this.observer != null && this.observer.disconnect();
    }
  }));
}
function dc(e) {
  e.data("rzIndicator", () => ({
    visible: !1,
    init() {
      const t = this.$el.dataset.color;
      t ? this.$el.style.backgroundColor = t : this.$el.style.backgroundColor = "var(--color-success)", this.$el.dataset.visible === "true" && (this.visible = !0);
    },
    notVisible() {
      return !this.visible;
    },
    setVisible(t) {
      this.visible = t;
    }
  }));
}
function fc(e) {
  e.data("rzInputGroupAddon", () => ({
    handleClick(t) {
      if (t.target.closest("button"))
        return;
      const n = this.$el.parentElement;
      n && n.querySelector("input, textarea")?.focus();
    }
  }));
}
function hc(e, t) {
  e.data("rzMarkdown", () => ({
    init() {
      const n = JSON.parse(this.$el.dataset.assets), i = this.$el.dataset.nonce;
      t(n, {
        success: function() {
          window.hljs.highlightAll();
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, i);
    }
  }));
}
function pc(e, t) {
  e.data("rzNavigationMenu", () => ({
    activeItemId: null,
    open: !1,
    closeTimeout: null,
    prevIndex: null,
    list: null,
    isClosing: !1,
    /* ---------- helpers ---------- */
    _triggerIndex(n) {
      return this.list ? Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]')).findIndex((r) => r.getAttribute("x-ref") === `trigger_${n}`) : -1;
    },
    _contentEl(n) {
      return document.getElementById(`${n}-content`);
    },
    /* ---------- lifecycle ---------- */
    init() {
      this.$el.querySelectorAll("[data-popover]").forEach((i) => {
        i.style.display = "none";
      }), this.$nextTick(() => {
        this.list = this.$refs.list;
      });
    },
    /* ---------- event handlers (from events with no params) ---------- */
    toggleActive(n) {
      const i = n.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.activeItemId === i && this.open ? this.closeMenu() : this.openMenu(i);
    },
    handleTriggerEnter(n) {
      const i = n.currentTarget.getAttribute("x-ref").replace("trigger_", "");
      this.cancelClose(), this.activeItemId !== i && !this.isClosing && requestAnimationFrame(() => this.openMenu(i));
    },
    handleItemEnter(n) {
      const i = n.currentTarget;
      if (!i) return;
      this.cancelClose();
      const r = i.querySelector('[x-ref^="trigger_"]');
      if (r) {
        const s = r.getAttribute("x-ref").replace("trigger_", "");
        this.activeItemId !== s && !this.isClosing && requestAnimationFrame(() => this.openMenu(s));
      } else
        this.open && !this.isClosing && this.closeMenu();
    },
    handleContentEnter() {
      this.cancelClose();
    },
    scheduleClose() {
      this.isClosing || this.closeTimeout || (this.closeTimeout = setTimeout(() => this.closeMenu(), 150));
    },
    cancelClose() {
      this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null), this.isClosing = !1;
    },
    /* ---------- open / close logic with direct DOM manipulation ---------- */
    openMenu(n) {
      this.cancelClose(), this.isClosing = !1;
      const i = this._triggerIndex(n), r = i > (this.prevIndex ?? i) ? "end" : "start", s = this.prevIndex === null;
      if (this.open && this.activeItemId && this.activeItemId !== n) {
        const l = this.$refs[`trigger_${this.activeItemId}`];
        l && delete l.dataset.state;
        const c = this._contentEl(this.activeItemId);
        if (c) {
          const u = r === "end" ? "start" : "end";
          c.setAttribute("data-motion", `to-${u}`), setTimeout(() => {
            c.style.display = "none";
          }, 150);
        }
      }
      this.activeItemId = n, this.open = !0, this.prevIndex = i;
      const o = this.$refs[`trigger_${n}`], a = this._contentEl(n);
      !o || !a || (_t(o, a, {
        placement: "bottom-start",
        middleware: [bt(6), wt(), yt({ padding: 8 })]
      }).then(({ x: l, y: c }) => {
        Object.assign(a.style, { left: `${l}px`, top: `${c}px` });
      }), a.style.display = "block", s ? a.setAttribute("data-motion", "fade-in") : a.setAttribute("data-motion", `from-${r}`), this.$nextTick(() => {
        o.setAttribute("aria-expanded", "true"), o.dataset.state = "open";
      }));
    },
    closeMenu() {
      if (!this.open || this.isClosing) return;
      this.isClosing = !0, this.cancelClose();
      const n = this.activeItemId;
      if (!n) {
        this.isClosing = !1;
        return;
      }
      const i = this.$refs[`trigger_${n}`];
      i && (i.setAttribute("aria-expanded", "false"), delete i.dataset.state);
      const r = this._contentEl(n);
      r && (r.setAttribute("data-motion", "fade-out"), setTimeout(() => {
        r.style.display = "none";
      }, 150)), this.open = !1, this.activeItemId = null, this.prevIndex = null, setTimeout(() => {
        this.isClosing = !1;
      }, 150);
    }
  }));
}
function mc(e) {
  e.data("rzPopover", () => ({
    open: !1,
    ariaExpanded: "false",
    triggerEl: null,
    contentEl: null,
    init() {
      this.triggerEl = this.$refs.trigger, this.contentEl = this.$refs.content, this.$watch("open", (t) => {
        this.ariaExpanded = t.toString(), t && this.$nextTick(() => this.updatePosition());
      });
    },
    updatePosition() {
      if (!this.triggerEl || !this.contentEl) return;
      const t = this.$el.dataset.anchor || "bottom", n = parseInt(this.$el.dataset.offset) || 0, i = parseInt(this.$el.dataset.crossAxisOffset) || 0, r = parseInt(this.$el.dataset.alignmentAxisOffset) || null, s = this.$el.dataset.strategy || "absolute", o = this.$el.dataset.enableFlip !== "false", a = this.$el.dataset.enableShift !== "false", l = parseInt(this.$el.dataset.shiftPadding) || 8;
      let c = [];
      c.push(bt({
        mainAxis: n,
        crossAxis: i,
        alignmentAxis: r
      })), o && c.push(wt()), a && c.push(yt({ padding: l })), _t(this.triggerEl, this.contentEl, {
        placement: t,
        strategy: s,
        middleware: c
      }).then(({ x: u, y: d }) => {
        Object.assign(this.contentEl.style, {
          left: `${u}px`,
          top: `${d}px`
        });
      });
    },
    toggle() {
      this.open = !this.open;
    },
    handleOutsideClick() {
      this.open && (this.open = !1);
    },
    handleWindowEscape() {
      this.open && (this.open = !1, this.$nextTick(() => this.triggerEl?.focus()));
    }
  }));
}
function gc(e) {
  e.data("rzPrependInput", () => ({
    prependContainer: null,
    textInput: null,
    init() {
      this.prependContainer = this.$refs.prependContainer, this.textInput = this.$refs.textInput;
      let t = this;
      setTimeout(() => {
        t.updatePadding();
      }, 50), window.addEventListener("resize", this.updatePadding);
    },
    destroy() {
      window.removeEventListener("resize", this.updatePadding);
    },
    updatePadding() {
      const t = this.prependContainer, n = this.textInput;
      if (!t || !n) {
        n && n.classList.remove("text-transparent");
        return;
      }
      const r = t.offsetWidth + 10;
      n.style.paddingLeft = r + "px", n.classList.remove("text-transparent");
    }
  }));
}
function vc(e) {
  e.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const t = this.$el;
      this.currentVal = parseInt(t.getAttribute("data-current-val")) || 0, this.minVal = parseInt(t.getAttribute("data-min-val")) || 0, this.maxVal = parseInt(t.getAttribute("data-max-val")) || 100, this.label = t.getAttribute("data-label"), this.calculatePercentage(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuemin", this.minVal), t.setAttribute("aria-valuemax", this.maxVal), t.setAttribute("aria-valuetext", `${this.percentage}%`), this.updateProgressBar(), new ResizeObserver((i) => {
        this.updateProgressBar();
      }).observe(t), this.$watch("currentVal", () => {
        this.calculatePercentage(), this.updateProgressBar(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      this.maxVal === this.minVal ? this.percentage = 0 : this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
    },
    buildLabel() {
      var t = this.label || "{percent}%";
      return this.calculatePercentage(), t.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const t = this.$refs.progressBar, n = this.$refs.progressBarLabel, i = this.$refs.innerLabel;
      n && t && i && (i.innerText = this.buildLabel(), n.clientWidth > t.clientWidth ? n.style.left = t.clientWidth + 10 + "px" : n.style.left = t.clientWidth / 2 - n.clientWidth / 2 + "px");
    },
    getLabelCss() {
      const t = this.$refs.progressBarLabel, n = this.$refs.progressBar;
      return t && n && t.clientWidth > n.clientWidth ? "text-foreground dark:text-foreground" : "";
    },
    updateProgressBar() {
      const t = this.$refs.progressBar;
      t && (t.style.width = `${this.percentage}%`, this.buildInsideLabelPosition());
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(t) {
      this.currentVal = t;
    },
    increment(t = 1) {
      this.currentVal = Math.min(this.currentVal + t, this.maxVal);
    },
    decrement(t = 1) {
      this.currentVal = Math.max(this.currentVal - t, this.minVal);
    }
  }));
}
function bc(e) {
  e.data("rzQuickReferenceContainer", () => ({
    headings: [],
    // Array of heading IDs
    currentHeadingId: "",
    // ID of the currently highlighted heading
    // Initializes the component with headings and the initial current heading from data attributes.
    init() {
      this.headings = JSON.parse(this.$el.dataset.headings || "[]"), this.currentHeadingId = this.$el.dataset.currentheadingid || "";
    },
    // Handles click events on quick reference links.
    handleHeadingClick() {
      const t = this.$el.dataset.headingid;
      window.requestAnimationFrame(() => {
        this.currentHeadingId = t;
      });
    },
    // Sets the current heading ID based on intersection observer events from rzHeading.
    setCurrentHeading(t) {
      this.headings.includes(t) && (this.currentHeadingId = t);
    },
    // Provides CSS classes for a link based on whether it's the current heading.
    // Returns an object suitable for :class binding.
    getSelectedCss() {
      const t = this.$el.dataset.headingid;
      return {
        "font-bold": this.currentHeadingId === t
        // Apply 'font-bold' if current
      };
    },
    // Determines the value for the aria-current attribute.
    getSelectedAriaCurrent() {
      const t = this.$el.dataset.headingid;
      return this.currentHeadingId === t ? "true" : null;
    }
  }));
}
function yc(e) {
  e.data("rzSheet", () => ({
    open: !1,
    init() {
      this.open = this.$el.dataset.defaultOpen === "true";
    },
    toggle() {
      this.open = !this.open;
    },
    close() {
      this.open = !1;
    },
    show() {
      this.open = !0;
    },
    state() {
      return this.open ? "open" : "closed";
    }
  }));
}
function wc(e) {
  e.data("rzTabs", () => ({
    selectedTab: "",
    _triggers: [],
    _observer: null,
    init() {
      const t = this.$el.dataset.defaultValue;
      this._observer = new MutationObserver(() => this.refreshTriggers()), this._observer.observe(this.$el, { childList: !0, subtree: !0 }), this.refreshTriggers(), t && this._triggers.some((n) => n.dataset.value === t) ? this.selectedTab = t : this._triggers.length > 0 && (this.selectedTab = this._triggers[0].dataset.value);
    },
    destroy() {
      this._observer && this._observer.disconnect();
    },
    refreshTriggers() {
      this._triggers = Array.from(this.$el.querySelectorAll('[role="tab"]'));
    },
    onTriggerClick(t) {
      const n = t.currentTarget?.dataset?.value;
      !n || t.currentTarget.getAttribute("aria-disabled") === "true" || (this.selectedTab = n, this.$dispatch("rz:tabs-change", { value: this.selectedTab }));
    },
    isSelected(t) {
      return this.selectedTab === t;
    },
    bindTrigger() {
      this.selectedTab;
      const t = this.$el.dataset.value, n = this.isSelected(t), i = this.$el.getAttribute("aria-disabled") === "true";
      return {
        "aria-selected": String(n),
        tabindex: n ? "0" : "-1",
        "data-state": n ? "active" : "inactive",
        ...i && { disabled: !0 }
      };
    },
    _attrDisabled() {
      return this.$el.getAttribute("aria-disabled") === "true" ? "true" : null;
    },
    _attrAriaSelected() {
      return String(this.$el.dataset.value === this.selectedTab);
    },
    _attrHidden() {
      return this.$el.dataset.value === this.selectedTab ? null : "true";
    },
    _attrAriaHidden() {
      return String(this.selectedTab !== this.$el.dataset.value);
    },
    _attrDataState() {
      return this.selectedTab === this.$el.dataset.value ? "active" : "inactive";
    },
    _attrTabIndex() {
      return this.selectedTab === this.$el.dataset.value ? "0" : "-1";
    },
    onListKeydown(t) {
      if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End"].includes(t.key)) {
        t.preventDefault();
        const n = this._triggers.filter((l) => l.getAttribute("aria-disabled") !== "true");
        if (n.length === 0) return;
        const i = n.findIndex((l) => l.dataset.value === this.selectedTab);
        if (i === -1) return;
        const r = t.currentTarget?.getAttribute("aria-orientation") === "vertical", s = r ? "ArrowUp" : "ArrowLeft", o = r ? "ArrowDown" : "ArrowRight";
        let a = i;
        switch (t.key) {
          case s:
            a = i - 1 < 0 ? n.length - 1 : i - 1;
            break;
          case o:
            a = (i + 1) % n.length;
            break;
          case "Home":
            a = 0;
            break;
          case "End":
            a = n.length - 1;
            break;
        }
        if (a >= 0 && a < n.length) {
          const l = n[a];
          this.selectedTab = l.dataset.value, this.$nextTick(() => l.focus());
        }
      }
    }
  }));
}
function _c(e) {
  e.data("rzSidebar", () => ({
    open: !1,
    openMobile: !1,
    isMobile: !1,
    collapsible: "offcanvas",
    shortcut: "b",
    cookieName: "sidebar_state",
    mobileBreakpoint: 768,
    init() {
      this.collapsible = this.$el.dataset.collapsible || "offcanvas", this.shortcut = this.$el.dataset.shortcut || "b", this.cookieName = this.$el.dataset.cookieName || "sidebar_state", this.mobileBreakpoint = parseInt(this.$el.dataset.mobileBreakpoint) || 768;
      const t = this.cookieName ? document.cookie.split("; ").find((i) => i.startsWith(`${this.cookieName}=`))?.split("=")[1] : null, n = this.$el.dataset.defaultOpen === "true";
      this.open = t !== null ? t === "true" : n, this.checkIfMobile(), window.addEventListener("keydown", (i) => {
        (i.ctrlKey || i.metaKey) && i.key.toLowerCase() === this.shortcut.toLowerCase() && (i.preventDefault(), this.toggle());
      }), this.$watch("open", (i) => {
        this.cookieName && (document.cookie = `${this.cookieName}=${i}; path=/; max-age=31536000`);
      });
    },
    checkIfMobile() {
      this.isMobile = window.innerWidth < this.mobileBreakpoint;
    },
    toggle() {
      this.isMobile ? this.openMobile = !this.openMobile : this.open = !this.open;
    },
    close() {
      this.isMobile && (this.openMobile = !1);
    },
    isMobileOpen() {
      return this.openMobile;
    },
    desktopState() {
      return this.open ? "expanded" : "collapsed";
    },
    mobileState() {
      return this.openMobile ? "open" : "closed";
    },
    getCollapsibleAttribute() {
      return this.desktopState() === "collapsed" ? this.collapsible : "";
    }
  }));
}
function xc(e) {
  e.data("rzCommand", () => ({
    // --- STATE ---
    search: "",
    selectedValue: null,
    selectedIndex: -1,
    items: [],
    filteredItems: [],
    groupTemplates: /* @__PURE__ */ new Map(),
    activeDescendantId: null,
    isOpen: !1,
    isEmpty: !0,
    firstRender: !0,
    isLoading: !1,
    error: null,
    // --- CONFIG ---
    loop: !1,
    shouldFilter: !0,
    itemsUrl: null,
    fetchTrigger: "immediate",
    serverFiltering: !1,
    dataItemTemplateId: null,
    _dataFetched: !1,
    _debounceTimer: null,
    // --- COMPUTED (CSP-Compliant Methods) ---
    showLoading() {
      return this.isLoading;
    },
    hasError() {
      return this.error !== null;
    },
    notHasError() {
      return this.error == null;
    },
    shouldShowEmpty() {
      return this.isEmpty && this.search && !this.isLoading && !this.error;
    },
    shouldShowEmptyOrError() {
      return this.isEmpty && this.search && !this.isLoading || this.error !== null;
    },
    // --- LIFECYCLE ---
    init() {
      this.loop = this.$el.dataset.loop === "true", this.shouldFilter = this.$el.dataset.shouldFilter !== "false", this.selectedValue = this.$el.dataset.selectedValue || null, this.itemsUrl = this.$el.dataset.itemsUrl || null, this.fetchTrigger = this.$el.dataset.fetchTrigger || "immediate", this.serverFiltering = this.$el.dataset.serverFiltering === "true", this.dataItemTemplateId = this.$el.dataset.templateId || null;
      const t = this.$el.dataset.itemsId;
      let n = [];
      if (t) {
        const i = document.getElementById(t);
        if (i)
          try {
            n = JSON.parse(i.textContent || "[]");
          } catch (r) {
            console.error(`RzCommand: Failed to parse JSON from script tag #${t}`, r);
          }
      }
      n.length > 0 && !this.dataItemTemplateId && console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them."), n.forEach((i) => {
        i.id = i.id || `static-item-${crypto.randomUUID()}`, i.isDataItem = !0, this.registerItem(i);
      }), this.itemsUrl && this.fetchTrigger === "immediate" && this.fetchItems(), this.$watch("search", (i) => {
        this.firstRender = !1, this.serverFiltering ? (clearTimeout(this._debounceTimer), this._debounceTimer = setTimeout(() => {
          this.fetchItems(i);
        }, 300)) : this.filterAndSortItems();
      }), this.$watch("selectedIndex", (i, r) => {
        if (r > -1) {
          const s = this.filteredItems[r];
          if (s) {
            const o = this.$el.querySelector(`[data-command-item-id="${s.id}"]`);
            o && (o.removeAttribute("data-selected"), o.setAttribute("aria-selected", "false"));
          }
        }
        if (i > -1 && this.filteredItems[i]) {
          const s = this.filteredItems[i];
          this.activeDescendantId = s.id;
          const o = this.$el.querySelector(`[data-command-item-id="${s.id}"]`);
          o && (o.setAttribute("data-selected", "true"), o.setAttribute("aria-selected", "true"), o.scrollIntoView({ block: "nearest" }));
          const a = s.value;
          this.selectedValue !== a && (this.selectedValue = a, this.$dispatch("rz:command:select", { value: a }));
        } else
          this.activeDescendantId = null, this.selectedValue = null;
      }), this.$watch("selectedValue", (i) => {
        const r = this.filteredItems.findIndex((s) => s.value === i);
        this.selectedIndex !== r && (this.selectedIndex = r);
      }), this.$watch("filteredItems", (i) => {
        this.isOpen = i.length > 0 || this.isLoading, this.isEmpty = i.length === 0, this.firstRender || window.dispatchEvent(new CustomEvent("rz:command:list-changed", {
          detail: {
            items: this.filteredItems,
            groups: this.groupTemplates,
            commandId: this.$el.id
          }
        }));
      });
    },
    // --- METHODS ---
    async fetchItems(t = "") {
      if (this.itemsUrl) {
        if (!this.dataItemTemplateId) {
          console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data."), this.error = "Configuration error: No data template found.";
          return;
        }
        this.isLoading = !0, this.error = null;
        try {
          const n = new URL(this.itemsUrl, window.location.origin);
          this.serverFiltering && t && n.searchParams.append("q", t);
          const i = await fetch(n);
          if (!i.ok)
            throw new Error(`Network response was not ok: ${i.statusText}`);
          const r = await i.json();
          this.serverFiltering && (this.items = this.items.filter((s) => !s.isDataItem)), r.forEach((s) => {
            s.id = s.id || `data-item-${crypto.randomUUID()}`, s.isDataItem = !0, this.registerItem(s);
          }), this._dataFetched = !0;
        } catch (n) {
          this.error = n.message || "Failed to fetch command items.", console.error("RzCommand:", this.error);
        } finally {
          this.isLoading = !1, this.filterAndSortItems();
        }
      }
    },
    handleInteraction() {
      this.itemsUrl && this.fetchTrigger === "on-open" && !this._dataFetched && this.fetchItems();
    },
    registerItem(t) {
      this.items.some((n) => n.id === t.id) || (t._order = this.items.length, this.items.push(t), this.selectedIndex === -1 && (this.selectedIndex = 0), this.serverFiltering || this.filterAndSortItems());
    },
    unregisterItem(t) {
      this.items = this.items.filter((n) => n.id !== t), this.filterAndSortItems();
    },
    registerGroupTemplate(t, n) {
      this.groupTemplates.has(t) || this.groupTemplates.set(t, n);
    },
    filterAndSortItems() {
      if (this.serverFiltering && this._dataFetched) {
        this.filteredItems = this.items, this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
        return;
      }
      let t;
      if (!this.shouldFilter || !this.search ? t = this.items.map((n) => ({ ...n, score: 1 })) : t = this.items.map((n) => ({
        ...n,
        score: n.forceMount ? 0 : this.commandScore(n.name, this.search, n.keywords)
      })).filter((n) => n.score > 0 || n.forceMount).sort((n, i) => n.forceMount && !i.forceMount ? 1 : !n.forceMount && i.forceMount ? -1 : i.score !== n.score ? i.score - n.score : (n._order || 0) - (i._order || 0)), this.filteredItems = t, this.selectedValue) {
        const n = this.filteredItems.findIndex((i) => i.value === this.selectedValue);
        this.selectedIndex = n > -1 ? n : this.filteredItems.length > 0 ? 0 : -1;
      } else
        this.selectedIndex = this.filteredItems.length > 0 ? 0 : -1;
    },
    // --- EVENT HANDLERS ---
    handleItemClick(t) {
      const n = t.target.closest("[data-command-item-id]");
      if (!n) return;
      const i = n.dataset.commandItemId, r = this.filteredItems.findIndex((s) => s.id === i);
      if (r > -1) {
        const s = this.filteredItems[r];
        s && !s.disabled && (this.selectedIndex = r, this.$dispatch("rz:command:execute", { value: s.value }));
      }
    },
    handleItemHover(t) {
      const n = t.target.closest("[data-command-item-id]");
      if (!n) return;
      const i = n.dataset.commandItemId, r = this.filteredItems.findIndex((s) => s.id === i);
      if (r > -1) {
        const s = this.filteredItems[r];
        s && !s.disabled && this.selectedIndex !== r && (this.selectedIndex = r);
      }
    },
    // --- KEYBOARD NAVIGATION ---
    handleKeydown(t) {
      switch (t.key) {
        case "ArrowDown":
          t.preventDefault(), this.selectNext();
          break;
        case "ArrowUp":
          t.preventDefault(), this.selectPrev();
          break;
        case "Home":
          t.preventDefault(), this.selectFirst();
          break;
        case "End":
          t.preventDefault(), this.selectLast();
          break;
        case "Enter":
          t.preventDefault();
          const n = this.filteredItems[this.selectedIndex];
          n && !n.disabled && this.$dispatch("rz:command:execute", { value: n.value });
          break;
      }
    },
    selectNext() {
      if (this.filteredItems.length === 0) return;
      let t = this.selectedIndex, n = 0;
      do {
        if (t = t + 1 >= this.filteredItems.length ? this.loop ? 0 : this.filteredItems.length - 1 : t + 1, n++, !this.filteredItems[t]?.disabled) {
          this.selectedIndex = t;
          return;
        }
        if (!this.loop && t === this.filteredItems.length - 1) return;
      } while (n <= this.filteredItems.length);
    },
    selectPrev() {
      if (this.filteredItems.length === 0) return;
      let t = this.selectedIndex, n = 0;
      do {
        if (t = t - 1 < 0 ? this.loop ? this.filteredItems.length - 1 : 0 : t - 1, n++, !this.filteredItems[t]?.disabled) {
          this.selectedIndex = t;
          return;
        }
        if (!this.loop && t === 0) return;
      } while (n <= this.filteredItems.length);
    },
    selectFirst() {
      if (this.filteredItems.length > 0) {
        const t = this.filteredItems.findIndex((n) => !n.disabled);
        t > -1 && (this.selectedIndex = t);
      }
    },
    selectLast() {
      if (this.filteredItems.length > 0) {
        const t = this.filteredItems.map((n) => n.disabled).lastIndexOf(!1);
        t > -1 && (this.selectedIndex = t);
      }
    },
    // --- SCORING ALGORITHM (Adapted from cmdk) ---
    commandScore(t, n, i = []) {
      const d = /[\\/_+.#"@[\(\{&]/, f = /[\s-]/, v = `${t} ${i ? i.join(" ") : ""}`;
      function x(p) {
        return p.toLowerCase().replace(/[\s-]/g, " ");
      }
      function w(p, g, h, y, E, _, m) {
        if (_ === g.length)
          return E === p.length ? 1 : 0.99;
        const b = `${E},${_}`;
        if (m[b] !== void 0) return m[b];
        const I = y.charAt(_);
        let S = h.indexOf(I, E), C = 0;
        for (; S >= 0; ) {
          let T = w(p, g, h, y, S + 1, _ + 1, m);
          T > C && (S === E ? T *= 1 : d.test(p.charAt(S - 1)) ? T *= 0.8 : f.test(p.charAt(S - 1)) ? T *= 0.9 : (T *= 0.17, E > 0 && (T *= Math.pow(0.999, S - E))), p.charAt(S) !== g.charAt(_) && (T *= 0.9999)), T > C && (C = T), S = h.indexOf(I, S + 1);
        }
        return m[b] = C, C;
      }
      return w(v, n, x(v), x(n), 0, 0, {});
    }
  }));
}
function Ec(e) {
  e.data("rzCommandItem", () => ({
    parent: null,
    itemData: {},
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandItem must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.itemData = {
        id: this.$el.id,
        value: this.$el.dataset.value || this.$el.textContent.trim(),
        name: this.$el.dataset.name || this.$el.dataset.value || this.$el.textContent.trim(),
        keywords: JSON.parse(this.$el.dataset.keywords || "[]"),
        group: this.$el.dataset.group || null,
        templateId: this.$el.id + "-template",
        disabled: this.$el.dataset.disabled === "true",
        forceMount: this.$el.dataset.forceMount === "true"
      }, this.parent.registerItem(this.itemData);
    },
    destroy() {
      this.parent && this.parent.unregisterItem(this.itemData.id);
    }
  }));
}
function Ic(e) {
  e.data("rzCommandList", () => ({
    parent: null,
    dataItemTemplate: null,
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandList must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.parent.dataItemTemplateId && (this.dataItemTemplate = document.getElementById(this.parent.dataItemTemplateId));
    },
    renderList(t) {
      if (t.detail.commandId !== this.parent.$el.id) return;
      const n = t.detail.items || [], i = t.detail.groups || /* @__PURE__ */ new Map(), r = this.$el;
      r.querySelectorAll("[data-dynamic-item]").forEach((o) => o.remove());
      const s = /* @__PURE__ */ new Map([["__ungrouped__", []]]);
      n.forEach((o) => {
        const a = o.group || "__ungrouped__";
        s.has(a) || s.set(a, []), s.get(a).push(o);
      }), s.forEach((o, a) => {
        if (o.length === 0) return;
        const l = document.createElement("div");
        if (l.setAttribute("role", "group"), l.setAttribute("data-dynamic-item", "true"), l.setAttribute("data-slot", "command-group"), a !== "__ungrouped__") {
          const c = i.get(a);
          if (c) {
            const u = document.getElementById(c);
            if (u && u.content) {
              const d = u.content.cloneNode(!0), f = d.firstElementChild;
              f && (l.setAttribute("aria-labelledby", f.id), l.appendChild(d));
            }
          }
        }
        o.forEach((c) => {
          const u = this.parent.filteredItems.indexOf(c);
          let d;
          if (c.isDataItem) {
            if (!this.dataItemTemplate)
              return;
            d = this.dataItemTemplate.content.cloneNode(!0).firstElementChild, e.addScopeToNode(d, { item: c });
          } else {
            const f = document.getElementById(c.templateId);
            f && f.content && (d = f.content.cloneNode(!0).querySelector(`[data-command-item-id="${c.id}"]`));
          }
          d && (d.setAttribute("data-command-item-id", c.id), d.setAttribute("data-value", c.value), c.keywords && d.setAttribute("data-keywords", JSON.stringify(c.keywords)), c.group && d.setAttribute("data-group", c.group), c.disabled && d.setAttribute("data-disabled", "true"), c.forceMount && d.setAttribute("data-force-mount", "true"), d.setAttribute("role", "option"), d.setAttribute("aria-selected", this.parent.selectedIndex === u), c.disabled && d.setAttribute("aria-disabled", "true"), this.parent.selectedIndex === u && d.setAttribute("data-selected", "true"), l.appendChild(d), e.initTree(d));
        }), r.appendChild(l);
      });
    }
  }));
}
function Sc(e) {
  e.data("rzCommandGroup", () => ({
    parent: null,
    heading: "",
    templateId: "",
    init() {
      const t = this.$el.closest('[x-data="rzCommand"]');
      if (!t) {
        console.error("CommandGroup must be a child of RzCommand.");
        return;
      }
      this.parent = e.$data(t), this.heading = this.$el.dataset.heading, this.templateId = this.$el.dataset.templateId, this.heading && this.templateId && this.parent.registerGroupTemplate(this.heading, this.templateId);
    }
  }));
}
async function Cc(e) {
  e = [...e].sort();
  const t = e.join("|"), i = new TextEncoder().encode(t), r = await crypto.subtle.digest("SHA-256", i);
  return Array.from(new Uint8Array(r)).map((o) => o.toString(16).padStart(2, "0")).join("");
}
function ce(e, t, n) {
  let i, r;
  typeof t == "function" ? i = { success: t } : t && typeof t == "object" ? i = t : typeof t == "string" && (r = t), !r && typeof n == "string" && (r = n);
  const s = Array.isArray(e) ? e : [e];
  return Cc(s).then((o) => (ne.isDefined(o) || ne(s, o, {
    // keep scripts ordered unless you explicitly change this later
    async: !1,
    // pass CSP nonce to both script and style tags as your loader expects
    inlineScriptNonce: r,
    inlineStyleNonce: r
  }), new Promise((a, l) => {
    ne.ready(o, {
      success: () => {
        try {
          i && typeof i.success == "function" && i.success();
        } catch (c) {
          console.error("[rizzyRequire] success callback threw:", c);
        }
        a({ bundleId: o });
      },
      error: (c) => {
        try {
          i && typeof i.error == "function" && i.error(c);
        } catch (u) {
          console.error("[rizzyRequire] error callback threw:", u);
        }
        l(
          new Error(
            `[rizzyRequire] Failed to load bundle ${o} (missing: ${Array.isArray(c) ? c.join(", ") : String(c)})`
          )
        );
      }
    });
  })));
}
function Tc(e) {
  yl(e), wl(e), _l(e), xl(e), El(e), Il(e, ce), Sl(e, ce), Cl(e, ce), Tl(e), Al(e, ce), Ol(e, ce), $l(e), oc(e), ac(e), lc(e), cc(e), uc(e), dc(e), fc(e), hc(e, ce), pc(e), mc(e), gc(e), vc(e), bc(e), yc(e), wc(e), _c(e), xc(e), Ec(e), Ic(e), Sc(e);
}
function Ac(e) {
  if (!(e instanceof Element))
    return console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el)."), {};
  const t = e.dataset.propsId;
  if (!t)
    return {};
  const n = document.getElementById(t);
  if (!n)
    return console.warn(`[Rizzy.props] Could not find the props script tag with ID '${t}'.`), {};
  try {
    return JSON.parse(n.textContent || "{}");
  } catch (i) {
    return console.error(`[Rizzy.props] Failed to parse JSON from script tag #${t}.`, i), {};
  }
}
const it = /* @__PURE__ */ new Map(), rt = /* @__PURE__ */ new Map();
let gi = !1;
function Oc(e) {
  return rt.has(e) || rt.set(
    e,
    import(e).catch((t) => {
      throw rt.delete(e), t;
    })
  ), rt.get(e);
}
function vi(e, t) {
  const n = globalThis.Alpine;
  return n && typeof n.asyncData == "function" ? (n.asyncData(
    e,
    () => Oc(t).catch((i) => (console.error(
      `[RizzyUI] Failed to load Alpine module '${e}' from '${t}'.`,
      i
    ), () => ({
      _error: !0,
      _errorMessage: `Module '${e}' failed to load.`
    })))
  ), !0) : (console.error(
    `[RizzyUI] Could not register async component '${e}'. AsyncAlpine not available.`
  ), !1);
}
function $c(e, t) {
  if (!e || !t) {
    console.error("[RizzyUI] registerAsyncComponent requires both name and path.");
    return;
  }
  const n = it.get(e);
  n && n.path !== t && console.warn(
    `[RizzyUI] Re-registering '${e}' with a different path.
  Previous: ${n.path}
  New:      ${t}`
  );
  const i = globalThis.Alpine;
  if (i && i.version) {
    const r = !n || n.path !== t;
    if (!(n && n.loaderSet && !r)) {
      const o = vi(e, t);
      it.set(e, { path: t, loaderSet: o });
    }
    return;
  }
  it.set(e, { path: t, loaderSet: !1 }), gi || (gi = !0, document.addEventListener(
    "alpine:init",
    () => {
      for (const [r, s] of it)
        if (!s.loaderSet) {
          const o = vi(r, s.path);
          s.loaderSet = o;
        }
    },
    { once: !0 }
  ));
}
function Nc(e) {
  e.directive("mobile", (t, { modifiers: n, expression: i }, { cleanup: r }) => {
    const s = n.find((g) => g.startsWith("bp-")), o = s ? parseInt(s.slice(3), 10) : 768, a = !!(i && i.length > 0);
    if (typeof window > "u" || !window.matchMedia) {
      t.dataset.mobile = "false", t.dataset.screen = "desktop";
      return;
    }
    const l = () => window.innerWidth < o, c = (g) => {
      t.dataset.mobile = g ? "true" : "false", t.dataset.screen = g ? "mobile" : "desktop";
    }, u = () => typeof e.$data == "function" ? e.$data(t) : t.__x ? t.__x.$data : null, d = (g) => {
      if (!a) return;
      const h = u();
      h && (h[i] = g);
    }, f = (g) => {
      t.dispatchEvent(
        new CustomEvent("screen:change", {
          bubbles: !0,
          detail: { isMobile: g, width: window.innerWidth, breakpoint: o }
        })
      );
    }, v = window.matchMedia(`(max-width: ${o - 1}px)`), x = () => {
      const g = l();
      c(g), d(g), f(g);
    };
    x();
    const w = () => x(), p = () => x();
    v.addEventListener("change", w), window.addEventListener("resize", p, { passive: !0 }), r(() => {
      v.removeEventListener("change", w), window.removeEventListener("resize", p);
    });
  });
}
function kc(e) {
  const t = (n, { expression: i, modifiers: r }, { cleanup: s, effect: o }) => {
    if (!i || typeof i != "string") return;
    const a = (w, p, g) => {
      const y = p.replace(/\[(\d+)\]/g, ".$1").split("."), E = y.pop();
      let _ = w;
      for (const m of y)
        (_[m] == null || typeof _[m] != "object") && (_[m] = isFinite(+m) ? [] : {}), _ = _[m];
      _[E] = g;
    }, l = e.closestDataStack(n) || [], c = l[0] || null, u = l[1] || null;
    if (!c || !u) {
      import.meta?.env?.DEV && console.warn("[x-syncprop] Could not find direct parent/child x-data. Ensure x-syncprop is used one level inside a parent component.");
      return;
    }
    const d = i.split(",").map((w) => w.trim()).filter(Boolean).map((w) => {
      const p = w.split("->").map((g) => g.trim());
      return p.length !== 2 ? (console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ', w), null) : { parentPath: p[0], childPath: p[1] };
    }).filter(Boolean), f = r.includes("init-child") || r.includes("child") || r.includes("childWins"), v = d.map(() => ({
      fromParent: !1,
      fromChild: !1,
      skipChildOnce: f
      // avoid redundant first child->parent write
    })), x = [];
    d.forEach((w, p) => {
      const g = v[p];
      if (f) {
        const E = e.evaluate(n, w.childPath, { scope: c });
        g.fromChild = !0, a(u, w.parentPath, E), queueMicrotask(() => {
          g.fromChild = !1;
        });
      } else {
        const E = e.evaluate(n, w.parentPath, { scope: u });
        g.fromParent = !0, a(c, w.childPath, E), queueMicrotask(() => {
          g.fromParent = !1;
        });
      }
      const h = o(() => {
        const E = e.evaluate(n, w.parentPath, { scope: u });
        g.fromChild || (g.fromParent = !0, a(c, w.childPath, E), queueMicrotask(() => {
          g.fromParent = !1;
        }));
      }), y = o(() => {
        const E = e.evaluate(n, w.childPath, { scope: c });
        if (!g.fromParent) {
          if (g.skipChildOnce) {
            g.skipChildOnce = !1;
            return;
          }
          g.fromChild = !0, a(u, w.parentPath, E), queueMicrotask(() => {
            g.fromChild = !1;
          });
        }
      });
      x.push(h, y);
    }), s(() => {
      for (const w of x)
        try {
          w && w();
        } catch {
        }
    });
  };
  e.directive("syncprop", t);
}
class Rc {
  constructor() {
    this.storageKey = "darkMode", this.eventName = "rz:theme-change", this.darkClass = "dark", this._mode = "auto", this._mq = null, this._initialized = !1, this._onMqChange = null, this._onStorage = null, this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null };
  }
  init() {
    if (this._initialized || typeof window > "u") return;
    this._initialized = !0, this._mq = typeof window.matchMedia == "function" ? window.matchMedia("(prefers-color-scheme: dark)") : null;
    const t = this._safeReadStorage(this.storageKey);
    this._mode = this._normalizeMode(t ?? "auto"), this._sync(), this._onMqChange = () => {
      this._sync();
    }, this._mq && (typeof this._mq.addEventListener == "function" ? this._mq.addEventListener("change", this._onMqChange) : typeof this._mq.addListener == "function" && this._mq.addListener(this._onMqChange)), this._onStorage = (n) => {
      if (n.key !== this.storageKey) return;
      const i = this._normalizeMode(n.newValue ?? "auto");
      i !== this._mode && (this._mode = i, this._sync());
    }, window.addEventListener("storage", this._onStorage);
  }
  destroy() {
    this._initialized && (this._initialized = !1, this._mq && this._onMqChange && (typeof this._mq.removeEventListener == "function" ? this._mq.removeEventListener("change", this._onMqChange) : typeof this._mq.removeListener == "function" && this._mq.removeListener(this._onMqChange)), typeof window < "u" && this._onStorage && window.removeEventListener("storage", this._onStorage), this._onMqChange = null, this._onStorage = null, this._mq = null, this._lastSnapshot = { mode: null, effectiveDark: null, prefersDark: null });
  }
  // ----- Public State Accessors -----
  get mode() {
    return this._mode;
  }
  get prefersDark() {
    return !!this._mq?.matches;
  }
  get effectiveDark() {
    return this._mode === "dark" || this._mode === "auto" && this.prefersDark;
  }
  // ----- Public API Surface -----
  isDark() {
    return this.effectiveDark;
  }
  isLight() {
    return !this.effectiveDark;
  }
  setLight() {
    this._setMode("light");
  }
  setDark() {
    this._setMode("dark");
  }
  setAuto() {
    this._setMode("auto");
  }
  toggle() {
    const t = this.effectiveDark;
    this._setMode(t ? "light" : "dark");
  }
  // ----- Internals -----
  _setMode(t) {
    this._mode = this._normalizeMode(t), this._persist(), this._sync();
  }
  _normalizeMode(t) {
    return t === "light" || t === "dark" || t === "auto" ? t : "auto";
  }
  _safeReadStorage(t) {
    try {
      return window?.localStorage?.getItem(t);
    } catch {
      return null;
    }
  }
  _persist() {
    try {
      window?.localStorage?.setItem(this.storageKey, this._mode);
    } catch {
    }
  }
  _sync() {
    const t = this.effectiveDark, n = this._mode, i = this.prefersDark, r = typeof document < "u" ? document.documentElement : null, s = r ? r.classList.contains(this.darkClass) === t && r.style.colorScheme === (t ? "dark" : "light") : !0;
    this._lastSnapshot.mode === n && this._lastSnapshot.effectiveDark === t && this._lastSnapshot.prefersDark === i && s || (this._lastSnapshot = { mode: n, effectiveDark: t, prefersDark: i }, r && (r.classList.toggle(this.darkClass, t), r.style.colorScheme = t ? "dark" : "light"), typeof window < "u" && window.dispatchEvent(
      new CustomEvent(this.eventName, {
        detail: {
          mode: n,
          darkMode: t,
          // External API uses 'darkMode' convention
          prefersDark: i,
          source: "RizzyUI"
        }
      })
    ));
  }
}
const D = new Rc();
function Lc(e) {
  D.init(), e.store("theme", {
    // Reactive state mirrors
    // We mirror ALL derived properties to ensure Alpine reactivity works 
    // for bindings like x-show="prefersDark" or x-text="mode".
    _mode: D.mode,
    _prefersDark: D.prefersDark,
    _effectiveDark: D.effectiveDark,
    // Listener reference to prevent duplicate registration
    _onThemeChange: null,
    init() {
      this._onThemeChange || (this._onThemeChange = () => this._refresh(), window.addEventListener(D.eventName, this._onThemeChange)), this._refresh();
    },
    _refresh() {
      this._mode = D.mode, this._prefersDark = D.prefersDark, this._effectiveDark = D.effectiveDark;
    },
    // ----- Reactive Getters -----
    // These return the reactive properties from the store, ensuring Alpine
    // properly tracks dependencies.
    get mode() {
      return this._mode;
    },
    get effectiveDark() {
      return this._effectiveDark;
    },
    get prefersDark() {
      return this._prefersDark;
    },
    // Expose as getters (not methods) for consistency
    get isDark() {
      return this._effectiveDark;
    },
    get isLight() {
      return !this._effectiveDark;
    },
    // ----- Proxy Methods -----
    setLight() {
      D.setLight();
    },
    setDark() {
      D.setDark();
    },
    setAuto() {
      D.setAuto();
    },
    toggle() {
      D.toggle();
    }
  });
}
let ze = null;
function Dc(e) {
  return ze || (e.plugin(ya), e.plugin(Ia), e.plugin(qa), e.plugin(el), typeof document < "u" && document.addEventListener("alpine:init", () => {
    Lc(e);
  }), Tc(e), Nc(e), kc(e), ze = {
    Alpine: e,
    require: ce,
    toast: hl,
    $data: vl,
    props: Ac,
    registerAsyncComponent: $c,
    theme: D
  }, typeof window < "u" && (D.init(), window.Alpine = e, window.Rizzy = { ...window.Rizzy || {}, ...ze }, document.dispatchEvent(new CustomEvent("rz:init", {
    detail: { Rizzy: window.Rizzy }
  }))), ze);
}
const zc = Dc(Or);
Or.start();
export {
  zc as default
};
</file>

<file path="wwwroot/js/rizzyui.min.js">
(function(ae,le){typeof exports=="object"&&typeof module<"u"?module.exports=le():typeof define=="function"&&define.amd?define(le):(ae=typeof globalThis<"u"?globalThis:ae||self,ae.RizzyUI=le())})(this,function(){"use strict";var ae=!1,le=!1,ce=[],Mt=-1;function as(e){ls(e)}function ls(e){ce.includes(e)||ce.push(e),us()}function cs(e){let t=ce.indexOf(e);t!==-1&&t>Mt&&ce.splice(t,1)}function us(){!le&&!ae&&(ae=!0,queueMicrotask(ds))}function ds(){ae=!1,le=!0;for(let e=0;e<ce.length;e++)ce[e](),Mt=e;ce.length=0,Mt=-1,le=!1}var xe,ue,Ee,Pn,Pt=!0;function fs(e){Pt=!1,e(),Pt=!0}function hs(e){xe=e.reactive,Ee=e.release,ue=t=>e.effect(t,{scheduler:n=>{Pt?as(n):n()}}),Pn=e.raw}function zn(e){ue=e}function ps(e){let t=()=>{};return[i=>{let r=ue(i);return e._x_effects||(e._x_effects=new Set,e._x_runEffects=()=>{e._x_effects.forEach(s=>s())}),e._x_effects.add(r),t=()=>{r!==void 0&&(e._x_effects.delete(r),Ee(r))},r},()=>{t()}]}function Fn(e,t){let n=!0,i,r=ue(()=>{let s=e();JSON.stringify(s),n?i=s:queueMicrotask(()=>{t(s,i),i=s}),n=!1});return()=>Ee(r)}var Bn=[],jn=[],Vn=[];function ms(e){Vn.push(e)}function zt(e,t){typeof t=="function"?(e._x_cleanups||(e._x_cleanups=[]),e._x_cleanups.push(t)):(t=e,jn.push(t))}function Hn(e){Bn.push(e)}function Wn(e,t,n){e._x_attributeCleanups||(e._x_attributeCleanups={}),e._x_attributeCleanups[t]||(e._x_attributeCleanups[t]=[]),e._x_attributeCleanups[t].push(n)}function qn(e,t){e._x_attributeCleanups&&Object.entries(e._x_attributeCleanups).forEach(([n,i])=>{(t===void 0||t.includes(n))&&(i.forEach(r=>r()),delete e._x_attributeCleanups[n])})}function gs(e){for(e._x_effects?.forEach(cs);e._x_cleanups?.length;)e._x_cleanups.pop()()}var Ft=new MutationObserver(Ht),Bt=!1;function jt(){Ft.observe(document,{subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0}),Bt=!0}function Un(){vs(),Ft.disconnect(),Bt=!1}var ke=[];function vs(){let e=Ft.takeRecords();ke.push(()=>e.length>0&&Ht(e));let t=ke.length;queueMicrotask(()=>{if(ke.length===t)for(;ke.length>0;)ke.shift()()})}function $(e){if(!Bt)return e();Un();let t=e();return jt(),t}var Vt=!1,Xe=[];function bs(){Vt=!0}function ys(){Vt=!1,Ht(Xe),Xe=[]}function Ht(e){if(Vt){Xe=Xe.concat(e);return}let t=[],n=new Set,i=new Map,r=new Map;for(let s=0;s<e.length;s++)if(!e[s].target._x_ignoreMutationObserver&&(e[s].type==="childList"&&(e[s].removedNodes.forEach(o=>{o.nodeType===1&&o._x_marker&&n.add(o)}),e[s].addedNodes.forEach(o=>{if(o.nodeType===1){if(n.has(o)){n.delete(o);return}o._x_marker||t.push(o)}})),e[s].type==="attributes")){let o=e[s].target,a=e[s].attributeName,l=e[s].oldValue,c=()=>{i.has(o)||i.set(o,[]),i.get(o).push({name:a,value:o.getAttribute(a)})},u=()=>{r.has(o)||r.set(o,[]),r.get(o).push(a)};o.hasAttribute(a)&&l===null?c():o.hasAttribute(a)?(u(),c()):u()}r.forEach((s,o)=>{qn(o,s)}),i.forEach((s,o)=>{Bn.forEach(a=>a(o,s))});for(let s of n)t.some(o=>o.contains(s))||jn.forEach(o=>o(s));for(let s of t)s.isConnected&&Vn.forEach(o=>o(s));t=null,n=null,i=null,r=null}function Yn(e){return De(Ie(e))}function Le(e,t,n){return e._x_dataStack=[t,...Ie(n||e)],()=>{e._x_dataStack=e._x_dataStack.filter(i=>i!==t)}}function Ie(e){return e._x_dataStack?e._x_dataStack:typeof ShadowRoot=="function"&&e instanceof ShadowRoot?Ie(e.host):e.parentNode?Ie(e.parentNode):[]}function De(e){return new Proxy({objects:e},ws)}var ws={ownKeys({objects:e}){return Array.from(new Set(e.flatMap(t=>Object.keys(t))))},has({objects:e},t){return t==Symbol.unscopables?!1:e.some(n=>Object.prototype.hasOwnProperty.call(n,t)||Reflect.has(n,t))},get({objects:e},t,n){return t=="toJSON"?_s:Reflect.get(e.find(i=>Reflect.has(i,t))||{},t,n)},set({objects:e},t,n,i){const r=e.find(o=>Object.prototype.hasOwnProperty.call(o,t))||e[e.length-1],s=Object.getOwnPropertyDescriptor(r,t);return s?.set&&s?.get?s.set.call(i,n)||!0:Reflect.set(r,t,n)}};function _s(){return Reflect.ownKeys(this).reduce((t,n)=>(t[n]=Reflect.get(this,n),t),{})}function Kn(e){let t=i=>typeof i=="object"&&!Array.isArray(i)&&i!==null,n=(i,r="")=>{Object.entries(Object.getOwnPropertyDescriptors(i)).forEach(([s,{value:o,enumerable:a}])=>{if(a===!1||o===void 0||typeof o=="object"&&o!==null&&o.__v_skip)return;let l=r===""?s:`${r}.${s}`;typeof o=="object"&&o!==null&&o._x_interceptor?i[s]=o.initialize(e,l,s):t(o)&&o!==i&&!(o instanceof Element)&&n(o,l)})};return n(e)}function Jn(e,t=()=>{}){let n={initialValue:void 0,_x_interceptor:!0,initialize(i,r,s){return e(this.initialValue,()=>xs(i,r),o=>Wt(i,r,o),r,s)}};return t(n),i=>{if(typeof i=="object"&&i!==null&&i._x_interceptor){let r=n.initialize.bind(n);n.initialize=(s,o,a)=>{let l=i.initialize(s,o,a);return n.initialValue=l,r(s,o,a)}}else n.initialValue=i;return n}}function xs(e,t){return t.split(".").reduce((n,i)=>n[i],e)}function Wt(e,t,n){if(typeof t=="string"&&(t=t.split(".")),t.length===1)e[t[0]]=n;else{if(t.length===0)throw error;return e[t[0]]||(e[t[0]]={}),Wt(e[t[0]],t.slice(1),n)}}var Gn={};function B(e,t){Gn[e]=t}function qt(e,t){let n=Es(t);return Object.entries(Gn).forEach(([i,r])=>{Object.defineProperty(e,`$${i}`,{get(){return r(t,n)},enumerable:!1})}),e}function Es(e){let[t,n]=ni(e),i={interceptor:Jn,...t};return zt(e,n),i}function Is(e,t,n,...i){try{return n(...i)}catch(r){Me(r,e,t)}}function Me(e,t,n=void 0){e=Object.assign(e??{message:"No error message given."},{el:t,expression:n}),console.warn(`Alpine Expression Error: ${e.message}
${n?'Expression: "'+n+`"
`:""}`,t),setTimeout(()=>{throw e},0)}var Qe=!0;function Zn(e){let t=Qe;Qe=!1;let n=e();return Qe=t,n}function de(e,t,n={}){let i;return R(e,t)(r=>i=r,n),i}function R(...e){return Xn(...e)}var Xn=Qn;function Ss(e){Xn=e}function Qn(e,t){let n={};qt(n,e);let i=[n,...Ie(e)],r=typeof t=="function"?Cs(i,t):As(i,t,e);return Is.bind(null,e,t,r)}function Cs(e,t){return(n=()=>{},{scope:i={},params:r=[],context:s}={})=>{let o=t.apply(De([i,...e]),r);et(n,o)}}var Ut={};function Ts(e,t){if(Ut[e])return Ut[e];let n=Object.getPrototypeOf(async function(){}).constructor,i=/^[\n\s]*if.*\(.*\)/.test(e.trim())||/^(let|const)\s/.test(e.trim())?`(async()=>{ ${e} })()`:e,s=(()=>{try{let o=new n(["__self","scope"],`with (scope) { __self.result = ${i} }; __self.finished = true; return __self.result;`);return Object.defineProperty(o,"name",{value:`[Alpine] ${e}`}),o}catch(o){return Me(o,t,e),Promise.resolve()}})();return Ut[e]=s,s}function As(e,t,n){let i=Ts(t,n);return(r=()=>{},{scope:s={},params:o=[],context:a}={})=>{i.result=void 0,i.finished=!1;let l=De([s,...e]);if(typeof i=="function"){let c=i.call(a,i,l).catch(u=>Me(u,n,t));i.finished?(et(r,i.result,l,o,n),i.result=void 0):c.then(u=>{et(r,u,l,o,n)}).catch(u=>Me(u,n,t)).finally(()=>i.result=void 0)}}}function et(e,t,n,i,r){if(Qe&&typeof t=="function"){let s=t.apply(n,i);s instanceof Promise?s.then(o=>et(e,o,n,i)).catch(o=>Me(o,r,t)):e(s)}else typeof t=="object"&&t instanceof Promise?t.then(s=>e(s)):e(t)}var Yt="x-";function Se(e=""){return Yt+e}function Os(e){Yt=e}var tt={};function N(e,t){return tt[e]=t,{before(n){if(!tt[n]){console.warn(String.raw`Cannot find directive \`${n}\`. \`${e}\` will use the default order of execution`);return}const i=fe.indexOf(n);fe.splice(i>=0?i:fe.indexOf("DEFAULT"),0,e)}}}function $s(e){return Object.keys(tt).includes(e)}function Kt(e,t,n){if(t=Array.from(t),e._x_virtualDirectives){let s=Object.entries(e._x_virtualDirectives).map(([a,l])=>({name:a,value:l})),o=ei(s);s=s.map(a=>o.find(l=>l.name===a.name)?{name:`x-bind:${a.name}`,value:`"${a.value}"`}:a),t=t.concat(s)}let i={};return t.map(si((s,o)=>i[s]=o)).filter(ai).map(ks(i,n)).sort(Ls).map(s=>Rs(e,s))}function ei(e){return Array.from(e).map(si()).filter(t=>!ai(t))}var Jt=!1,Pe=new Map,ti=Symbol();function Ns(e){Jt=!0;let t=Symbol();ti=t,Pe.set(t,[]);let n=()=>{for(;Pe.get(t).length;)Pe.get(t).shift()();Pe.delete(t)},i=()=>{Jt=!1,n()};e(n),i()}function ni(e){let t=[],n=a=>t.push(a),[i,r]=ps(e);return t.push(r),[{Alpine:Be,effect:i,cleanup:n,evaluateLater:R.bind(R,e),evaluate:de.bind(de,e)},()=>t.forEach(a=>a())]}function Rs(e,t){let n=()=>{},i=tt[t.type]||n,[r,s]=ni(e);Wn(e,t.original,s);let o=()=>{e._x_ignore||e._x_ignoreSelf||(i.inline&&i.inline(e,t,r),i=i.bind(i,e,t,r),Jt?Pe.get(ti).push(i):i())};return o.runCleanups=s,o}var ii=(e,t)=>({name:n,value:i})=>(n.startsWith(e)&&(n=n.replace(e,t)),{name:n,value:i}),ri=e=>e;function si(e=()=>{}){return({name:t,value:n})=>{let{name:i,value:r}=oi.reduce((s,o)=>o(s),{name:t,value:n});return i!==t&&e(i,t),{name:i,value:r}}}var oi=[];function Gt(e){oi.push(e)}function ai({name:e}){return li().test(e)}var li=()=>new RegExp(`^${Yt}([^:^.]+)\\b`);function ks(e,t){return({name:n,value:i})=>{let r=n.match(li()),s=n.match(/:([a-zA-Z0-9\-_:]+)/),o=n.match(/\.[^.\]]+(?=[^\]]*$)/g)||[],a=t||e[n]||n;return{type:r?r[1]:null,value:s?s[1]:null,modifiers:o.map(l=>l.replace(".","")),expression:i,original:a}}}var Zt="DEFAULT",fe=["ignore","ref","data","id","anchor","bind","init","for","model","modelable","transition","show","if",Zt,"teleport"];function Ls(e,t){let n=fe.indexOf(e.type)===-1?Zt:e.type,i=fe.indexOf(t.type)===-1?Zt:t.type;return fe.indexOf(n)-fe.indexOf(i)}function ze(e,t,n={}){e.dispatchEvent(new CustomEvent(t,{detail:n,bubbles:!0,composed:!0,cancelable:!0}))}function he(e,t){if(typeof ShadowRoot=="function"&&e instanceof ShadowRoot){Array.from(e.children).forEach(r=>he(r,t));return}let n=!1;if(t(e,()=>n=!0),n)return;let i=e.firstElementChild;for(;i;)he(i,t),i=i.nextElementSibling}function P(e,...t){console.warn(`Alpine Warning: ${e}`,...t)}var ci=!1;function Ds(){ci&&P("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."),ci=!0,document.body||P("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"),ze(document,"alpine:init"),ze(document,"alpine:initializing"),jt(),ms(t=>G(t,he)),zt(t=>Te(t)),Hn((t,n)=>{Kt(t,n).forEach(i=>i())});let e=t=>!nt(t.parentElement,!0);Array.from(document.querySelectorAll(fi().join(","))).filter(e).forEach(t=>{G(t)}),ze(document,"alpine:initialized"),setTimeout(()=>{Fs()})}var Xt=[],ui=[];function di(){return Xt.map(e=>e())}function fi(){return Xt.concat(ui).map(e=>e())}function hi(e){Xt.push(e)}function pi(e){ui.push(e)}function nt(e,t=!1){return Ce(e,n=>{if((t?fi():di()).some(r=>n.matches(r)))return!0})}function Ce(e,t){if(e){if(t(e))return e;if(e._x_teleportBack&&(e=e._x_teleportBack),!!e.parentElement)return Ce(e.parentElement,t)}}function Ms(e){return di().some(t=>e.matches(t))}var mi=[];function Ps(e){mi.push(e)}var zs=1;function G(e,t=he,n=()=>{}){Ce(e,i=>i._x_ignore)||Ns(()=>{t(e,(i,r)=>{i._x_marker||(n(i,r),mi.forEach(s=>s(i,r)),Kt(i,i.attributes).forEach(s=>s()),i._x_ignore||(i._x_marker=zs++),i._x_ignore&&r())})})}function Te(e,t=he){t(e,n=>{gs(n),qn(n),delete n._x_marker})}function Fs(){[["ui","dialog",["[x-dialog], [x-popover]"]],["anchor","anchor",["[x-anchor]"]],["sort","sort",["[x-sort]"]]].forEach(([t,n,i])=>{$s(n)||i.some(r=>{if(document.querySelector(r))return P(`found "${r}", but missing ${t} plugin`),!0})})}var Qt=[],en=!1;function tn(e=()=>{}){return queueMicrotask(()=>{en||setTimeout(()=>{nn()})}),new Promise(t=>{Qt.push(()=>{e(),t()})})}function nn(){for(en=!1;Qt.length;)Qt.shift()()}function Bs(){en=!0}function rn(e,t){return Array.isArray(t)?gi(e,t.join(" ")):typeof t=="object"&&t!==null?js(e,t):typeof t=="function"?rn(e,t()):gi(e,t)}function gi(e,t){let n=r=>r.split(" ").filter(s=>!e.classList.contains(s)).filter(Boolean),i=r=>(e.classList.add(...r),()=>{e.classList.remove(...r)});return t=t===!0?t="":t||"",i(n(t))}function js(e,t){let n=a=>a.split(" ").filter(Boolean),i=Object.entries(t).flatMap(([a,l])=>l?n(a):!1).filter(Boolean),r=Object.entries(t).flatMap(([a,l])=>l?!1:n(a)).filter(Boolean),s=[],o=[];return r.forEach(a=>{e.classList.contains(a)&&(e.classList.remove(a),o.push(a))}),i.forEach(a=>{e.classList.contains(a)||(e.classList.add(a),s.push(a))}),()=>{o.forEach(a=>e.classList.add(a)),s.forEach(a=>e.classList.remove(a))}}function it(e,t){return typeof t=="object"&&t!==null?Vs(e,t):Hs(e,t)}function Vs(e,t){let n={};return Object.entries(t).forEach(([i,r])=>{n[i]=e.style[i],i.startsWith("--")||(i=Ws(i)),e.style.setProperty(i,r)}),setTimeout(()=>{e.style.length===0&&e.removeAttribute("style")}),()=>{it(e,n)}}function Hs(e,t){let n=e.getAttribute("style",t);return e.setAttribute("style",t),()=>{e.setAttribute("style",n||"")}}function Ws(e){return e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function sn(e,t=()=>{}){let n=!1;return function(){n?t.apply(this,arguments):(n=!0,e.apply(this,arguments))}}N("transition",(e,{value:t,modifiers:n,expression:i},{evaluate:r})=>{typeof i=="function"&&(i=r(i)),i!==!1&&(!i||typeof i=="boolean"?Us(e,n,t):qs(e,i,t))});function qs(e,t,n){vi(e,rn,""),{enter:r=>{e._x_transition.enter.during=r},"enter-start":r=>{e._x_transition.enter.start=r},"enter-end":r=>{e._x_transition.enter.end=r},leave:r=>{e._x_transition.leave.during=r},"leave-start":r=>{e._x_transition.leave.start=r},"leave-end":r=>{e._x_transition.leave.end=r}}[n](t)}function Us(e,t,n){vi(e,it);let i=!t.includes("in")&&!t.includes("out")&&!n,r=i||t.includes("in")||["enter"].includes(n),s=i||t.includes("out")||["leave"].includes(n);t.includes("in")&&!i&&(t=t.filter((g,h)=>h<t.indexOf("out"))),t.includes("out")&&!i&&(t=t.filter((g,h)=>h>t.indexOf("out")));let o=!t.includes("opacity")&&!t.includes("scale"),a=o||t.includes("opacity"),l=o||t.includes("scale"),c=a?0:1,u=l?Fe(t,"scale",95)/100:1,d=Fe(t,"delay",0)/1e3,f=Fe(t,"origin","center"),v="opacity, transform",x=Fe(t,"duration",150)/1e3,w=Fe(t,"duration",75)/1e3,p="cubic-bezier(0.4, 0.0, 0.2, 1)";r&&(e._x_transition.enter.during={transformOrigin:f,transitionDelay:`${d}s`,transitionProperty:v,transitionDuration:`${x}s`,transitionTimingFunction:p},e._x_transition.enter.start={opacity:c,transform:`scale(${u})`},e._x_transition.enter.end={opacity:1,transform:"scale(1)"}),s&&(e._x_transition.leave.during={transformOrigin:f,transitionDelay:`${d}s`,transitionProperty:v,transitionDuration:`${w}s`,transitionTimingFunction:p},e._x_transition.leave.start={opacity:1,transform:"scale(1)"},e._x_transition.leave.end={opacity:c,transform:`scale(${u})`})}function vi(e,t,n={}){e._x_transition||(e._x_transition={enter:{during:n,start:n,end:n},leave:{during:n,start:n,end:n},in(i=()=>{},r=()=>{}){on(e,t,{during:this.enter.during,start:this.enter.start,end:this.enter.end},i,r)},out(i=()=>{},r=()=>{}){on(e,t,{during:this.leave.during,start:this.leave.start,end:this.leave.end},i,r)}})}window.Element.prototype._x_toggleAndCascadeWithTransitions=function(e,t,n,i){const r=document.visibilityState==="visible"?requestAnimationFrame:setTimeout;let s=()=>r(n);if(t){e._x_transition&&(e._x_transition.enter||e._x_transition.leave)?e._x_transition.enter&&(Object.entries(e._x_transition.enter.during).length||Object.entries(e._x_transition.enter.start).length||Object.entries(e._x_transition.enter.end).length)?e._x_transition.in(n):s():e._x_transition?e._x_transition.in(n):s();return}e._x_hidePromise=e._x_transition?new Promise((o,a)=>{e._x_transition.out(()=>{},()=>o(i)),e._x_transitioning&&e._x_transitioning.beforeCancel(()=>a({isFromCancelledTransition:!0}))}):Promise.resolve(i),queueMicrotask(()=>{let o=bi(e);o?(o._x_hideChildren||(o._x_hideChildren=[]),o._x_hideChildren.push(e)):r(()=>{let a=l=>{let c=Promise.all([l._x_hidePromise,...(l._x_hideChildren||[]).map(a)]).then(([u])=>u?.());return delete l._x_hidePromise,delete l._x_hideChildren,c};a(e).catch(l=>{if(!l.isFromCancelledTransition)throw l})})})};function bi(e){let t=e.parentNode;if(t)return t._x_hidePromise?t:bi(t)}function on(e,t,{during:n,start:i,end:r}={},s=()=>{},o=()=>{}){if(e._x_transitioning&&e._x_transitioning.cancel(),Object.keys(n).length===0&&Object.keys(i).length===0&&Object.keys(r).length===0){s(),o();return}let a,l,c;Ys(e,{start(){a=t(e,i)},during(){l=t(e,n)},before:s,end(){a(),c=t(e,r)},after:o,cleanup(){l(),c()}})}function Ys(e,t){let n,i,r,s=sn(()=>{$(()=>{n=!0,i||t.before(),r||(t.end(),nn()),t.after(),e.isConnected&&t.cleanup(),delete e._x_transitioning})});e._x_transitioning={beforeCancels:[],beforeCancel(o){this.beforeCancels.push(o)},cancel:sn(function(){for(;this.beforeCancels.length;)this.beforeCancels.shift()();s()}),finish:s},$(()=>{t.start(),t.during()}),Bs(),requestAnimationFrame(()=>{if(n)return;let o=Number(getComputedStyle(e).transitionDuration.replace(/,.*/,"").replace("s",""))*1e3,a=Number(getComputedStyle(e).transitionDelay.replace(/,.*/,"").replace("s",""))*1e3;o===0&&(o=Number(getComputedStyle(e).animationDuration.replace("s",""))*1e3),$(()=>{t.before()}),i=!0,requestAnimationFrame(()=>{n||($(()=>{t.end()}),nn(),setTimeout(e._x_transitioning.finish,o+a),r=!0)})})}function Fe(e,t,n){if(e.indexOf(t)===-1)return n;const i=e[e.indexOf(t)+1];if(!i||t==="scale"&&isNaN(i))return n;if(t==="duration"||t==="delay"){let r=i.match(/([0-9]+)ms/);if(r)return r[1]}return t==="origin"&&["top","right","left","center","bottom"].includes(e[e.indexOf(t)+2])?[i,e[e.indexOf(t)+2]].join(" "):i}var Q=!1;function ee(e,t=()=>{}){return(...n)=>Q?t(...n):e(...n)}function Ks(e){return(...t)=>Q&&e(...t)}var yi=[];function rt(e){yi.push(e)}function Js(e,t){yi.forEach(n=>n(e,t)),Q=!0,wi(()=>{G(t,(n,i)=>{i(n,()=>{})})}),Q=!1}var an=!1;function Gs(e,t){t._x_dataStack||(t._x_dataStack=e._x_dataStack),Q=!0,an=!0,wi(()=>{Zs(t)}),Q=!1,an=!1}function Zs(e){let t=!1;G(e,(i,r)=>{he(i,(s,o)=>{if(t&&Ms(s))return o();t=!0,r(s,o)})})}function wi(e){let t=ue;zn((n,i)=>{let r=t(n);return Ee(r),()=>{}}),e(),zn(t)}function _i(e,t,n,i=[]){switch(e._x_bindings||(e._x_bindings=xe({})),e._x_bindings[t]=n,t=i.includes("camel")?so(t):t,t){case"value":Xs(e,n);break;case"style":eo(e,n);break;case"class":Qs(e,n);break;case"selected":case"checked":to(e,t,n);break;default:xi(e,t,n);break}}function Xs(e,t){if(Ci(e))e.attributes.value===void 0&&(e.value=t),window.fromModel&&(typeof t=="boolean"?e.checked=st(e.value)===t:e.checked=Ei(e.value,t));else if(ln(e))Number.isInteger(t)?e.value=t:!Array.isArray(t)&&typeof t!="boolean"&&![null,void 0].includes(t)?e.value=String(t):Array.isArray(t)?e.checked=t.some(n=>Ei(n,e.value)):e.checked=!!t;else if(e.tagName==="SELECT")ro(e,t);else{if(e.value===t)return;e.value=t===void 0?"":t}}function Qs(e,t){e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedClasses=rn(e,t)}function eo(e,t){e._x_undoAddedStyles&&e._x_undoAddedStyles(),e._x_undoAddedStyles=it(e,t)}function to(e,t,n){xi(e,t,n),io(e,t,n)}function xi(e,t,n){[null,void 0,!1].includes(n)&&ao(t)?e.removeAttribute(t):(Ii(t)&&(n=t),no(e,t,n))}function no(e,t,n){e.getAttribute(t)!=n&&e.setAttribute(t,n)}function io(e,t,n){e[t]!==n&&(e[t]=n)}function ro(e,t){const n=[].concat(t).map(i=>i+"");Array.from(e.options).forEach(i=>{i.selected=n.includes(i.value)})}function so(e){return e.toLowerCase().replace(/-(\w)/g,(t,n)=>n.toUpperCase())}function Ei(e,t){return e==t}function st(e){return[1,"1","true","on","yes",!0].includes(e)?!0:[0,"0","false","off","no",!1].includes(e)?!1:e?!!e:null}var oo=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootclonable","shadowrootdelegatesfocus","shadowrootserializable"]);function Ii(e){return oo.has(e)}function ao(e){return!["aria-pressed","aria-checked","aria-expanded","aria-selected"].includes(e)}function lo(e,t,n){return e._x_bindings&&e._x_bindings[t]!==void 0?e._x_bindings[t]:Si(e,t,n)}function co(e,t,n,i=!0){if(e._x_bindings&&e._x_bindings[t]!==void 0)return e._x_bindings[t];if(e._x_inlineBindings&&e._x_inlineBindings[t]!==void 0){let r=e._x_inlineBindings[t];return r.extract=i,Zn(()=>de(e,r.expression))}return Si(e,t,n)}function Si(e,t,n){let i=e.getAttribute(t);return i===null?typeof n=="function"?n():n:i===""?!0:Ii(t)?!![t,"true"].includes(i):i}function ln(e){return e.type==="checkbox"||e.localName==="ui-checkbox"||e.localName==="ui-switch"}function Ci(e){return e.type==="radio"||e.localName==="ui-radio"}function Ti(e,t){let n;return function(){const i=this,r=arguments,s=function(){n=null,e.apply(i,r)};clearTimeout(n),n=setTimeout(s,t)}}function Ai(e,t){let n;return function(){let i=this,r=arguments;n||(e.apply(i,r),n=!0,setTimeout(()=>n=!1,t))}}function Oi({get:e,set:t},{get:n,set:i}){let r=!0,s,o=ue(()=>{let a=e(),l=n();if(r)i(cn(a)),r=!1;else{let c=JSON.stringify(a),u=JSON.stringify(l);c!==s?i(cn(a)):c!==u&&t(cn(l))}s=JSON.stringify(e()),JSON.stringify(n())});return()=>{Ee(o)}}function cn(e){return typeof e=="object"?JSON.parse(JSON.stringify(e)):e}function uo(e){(Array.isArray(e)?e:[e]).forEach(n=>n(Be))}var pe={},$i=!1;function fo(e,t){if($i||(pe=xe(pe),$i=!0),t===void 0)return pe[e];pe[e]=t,Kn(pe[e]),typeof t=="object"&&t!==null&&t.hasOwnProperty("init")&&typeof t.init=="function"&&pe[e].init()}function ho(){return pe}var Ni={};function po(e,t){let n=typeof t!="function"?()=>t:t;return e instanceof Element?Ri(e,n()):(Ni[e]=n,()=>{})}function mo(e){return Object.entries(Ni).forEach(([t,n])=>{Object.defineProperty(e,t,{get(){return(...i)=>n(...i)}})}),e}function Ri(e,t,n){let i=[];for(;i.length;)i.pop()();let r=Object.entries(t).map(([o,a])=>({name:o,value:a})),s=ei(r);return r=r.map(o=>s.find(a=>a.name===o.name)?{name:`x-bind:${o.name}`,value:`"${o.value}"`}:o),Kt(e,r,n).map(o=>{i.push(o.runCleanups),o()}),()=>{for(;i.length;)i.pop()()}}var ki={};function go(e,t){ki[e]=t}function vo(e,t){return Object.entries(ki).forEach(([n,i])=>{Object.defineProperty(e,n,{get(){return(...r)=>i.bind(t)(...r)},enumerable:!1})}),e}var bo={get reactive(){return xe},get release(){return Ee},get effect(){return ue},get raw(){return Pn},version:"3.15.0",flushAndStopDeferringMutations:ys,dontAutoEvaluateFunctions:Zn,disableEffectScheduling:fs,startObservingMutations:jt,stopObservingMutations:Un,setReactivityEngine:hs,onAttributeRemoved:Wn,onAttributesAdded:Hn,closestDataStack:Ie,skipDuringClone:ee,onlyDuringClone:Ks,addRootSelector:hi,addInitSelector:pi,interceptClone:rt,addScopeToNode:Le,deferMutations:bs,mapAttributes:Gt,evaluateLater:R,interceptInit:Ps,setEvaluator:Ss,mergeProxies:De,extractProp:co,findClosest:Ce,onElRemoved:zt,closestRoot:nt,destroyTree:Te,interceptor:Jn,transition:on,setStyles:it,mutateDom:$,directive:N,entangle:Oi,throttle:Ai,debounce:Ti,evaluate:de,initTree:G,nextTick:tn,prefixed:Se,prefix:Os,plugin:uo,magic:B,store:fo,start:Ds,clone:Gs,cloneNode:Js,bound:lo,$data:Yn,watch:Fn,walk:he,data:go,bind:po},Be=bo;function yo(e,t){const n=Object.create(null),i=e.split(",");for(let r=0;r<i.length;r++)n[i[r]]=!0;return r=>!!n[r]}var wo=Object.freeze({}),_o=Object.prototype.hasOwnProperty,ot=(e,t)=>_o.call(e,t),me=Array.isArray,je=e=>Li(e)==="[object Map]",xo=e=>typeof e=="string",un=e=>typeof e=="symbol",at=e=>e!==null&&typeof e=="object",Eo=Object.prototype.toString,Li=e=>Eo.call(e),Di=e=>Li(e).slice(8,-1),dn=e=>xo(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Io=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},So=Io(e=>e.charAt(0).toUpperCase()+e.slice(1)),Mi=(e,t)=>e!==t&&(e===e||t===t),fn=new WeakMap,Ve=[],q,ge=Symbol("iterate"),hn=Symbol("Map key iterate");function Co(e){return e&&e._isEffect===!0}function To(e,t=wo){Co(e)&&(e=e.raw);const n=$o(e,t);return t.lazy||n(),n}function Ao(e){e.active&&(Pi(e),e.options.onStop&&e.options.onStop(),e.active=!1)}var Oo=0;function $o(e,t){const n=function(){if(!n.active)return e();if(!Ve.includes(n)){Pi(n);try{return Ro(),Ve.push(n),q=n,e()}finally{Ve.pop(),zi(),q=Ve[Ve.length-1]}}};return n.id=Oo++,n.allowRecurse=!!t.allowRecurse,n._isEffect=!0,n.active=!0,n.raw=e,n.deps=[],n.options=t,n}function Pi(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}var Ae=!0,pn=[];function No(){pn.push(Ae),Ae=!1}function Ro(){pn.push(Ae),Ae=!0}function zi(){const e=pn.pop();Ae=e===void 0?!0:e}function j(e,t,n){if(!Ae||q===void 0)return;let i=fn.get(e);i||fn.set(e,i=new Map);let r=i.get(n);r||i.set(n,r=new Set),r.has(q)||(r.add(q),q.deps.push(r),q.options.onTrack&&q.options.onTrack({effect:q,target:e,type:t,key:n}))}function te(e,t,n,i,r,s){const o=fn.get(e);if(!o)return;const a=new Set,l=u=>{u&&u.forEach(d=>{(d!==q||d.allowRecurse)&&a.add(d)})};if(t==="clear")o.forEach(l);else if(n==="length"&&me(e))o.forEach((u,d)=>{(d==="length"||d>=i)&&l(u)});else switch(n!==void 0&&l(o.get(n)),t){case"add":me(e)?dn(n)&&l(o.get("length")):(l(o.get(ge)),je(e)&&l(o.get(hn)));break;case"delete":me(e)||(l(o.get(ge)),je(e)&&l(o.get(hn)));break;case"set":je(e)&&l(o.get(ge));break}const c=u=>{u.options.onTrigger&&u.options.onTrigger({effect:u,target:e,key:n,type:t,newValue:i,oldValue:r,oldTarget:s}),u.options.scheduler?u.options.scheduler(u):u()};a.forEach(c)}var ko=yo("__proto__,__v_isRef,__isVue"),Fi=new Set(Object.getOwnPropertyNames(Symbol).map(e=>Symbol[e]).filter(un)),Lo=ji(),Do=ji(!0),Bi=Mo();function Mo(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...n){const i=O(this);for(let s=0,o=this.length;s<o;s++)j(i,"get",s+"");const r=i[t](...n);return r===-1||r===!1?i[t](...n.map(O)):r}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...n){No();const i=O(this)[t].apply(this,n);return zi(),i}}),e}function ji(e=!1,t=!1){return function(i,r,s){if(r==="__v_isReactive")return!e;if(r==="__v_isReadonly")return e;if(r==="__v_raw"&&s===(e?t?Go:Ji:t?Jo:Ki).get(i))return i;const o=me(i);if(!e&&o&&ot(Bi,r))return Reflect.get(Bi,r,s);const a=Reflect.get(i,r,s);return(un(r)?Fi.has(r):ko(r))||(e||j(i,"get",r),t)?a:yn(a)?!o||!dn(r)?a.value:a:at(a)?e?Gi(a):bn(a):a}}var Po=zo();function zo(e=!1){return function(n,i,r,s){let o=n[i];if(!e&&(r=O(r),o=O(o),!me(n)&&yn(o)&&!yn(r)))return o.value=r,!0;const a=me(n)&&dn(i)?Number(i)<n.length:ot(n,i),l=Reflect.set(n,i,r,s);return n===O(s)&&(a?Mi(r,o)&&te(n,"set",i,r,o):te(n,"add",i,r)),l}}function Fo(e,t){const n=ot(e,t),i=e[t],r=Reflect.deleteProperty(e,t);return r&&n&&te(e,"delete",t,void 0,i),r}function Bo(e,t){const n=Reflect.has(e,t);return(!un(t)||!Fi.has(t))&&j(e,"has",t),n}function jo(e){return j(e,"iterate",me(e)?"length":ge),Reflect.ownKeys(e)}var Vo={get:Lo,set:Po,deleteProperty:Fo,has:Bo,ownKeys:jo},Ho={get:Do,set(e,t){return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e),!0},deleteProperty(e,t){return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e),!0}},mn=e=>at(e)?bn(e):e,gn=e=>at(e)?Gi(e):e,vn=e=>e,lt=e=>Reflect.getPrototypeOf(e);function ct(e,t,n=!1,i=!1){e=e.__v_raw;const r=O(e),s=O(t);t!==s&&!n&&j(r,"get",t),!n&&j(r,"get",s);const{has:o}=lt(r),a=i?vn:n?gn:mn;if(o.call(r,t))return a(e.get(t));if(o.call(r,s))return a(e.get(s));e!==r&&e.get(t)}function ut(e,t=!1){const n=this.__v_raw,i=O(n),r=O(e);return e!==r&&!t&&j(i,"has",e),!t&&j(i,"has",r),e===r?n.has(e):n.has(e)||n.has(r)}function dt(e,t=!1){return e=e.__v_raw,!t&&j(O(e),"iterate",ge),Reflect.get(e,"size",e)}function Vi(e){e=O(e);const t=O(this);return lt(t).has.call(t,e)||(t.add(e),te(t,"add",e,e)),this}function Hi(e,t){t=O(t);const n=O(this),{has:i,get:r}=lt(n);let s=i.call(n,e);s?Yi(n,i,e):(e=O(e),s=i.call(n,e));const o=r.call(n,e);return n.set(e,t),s?Mi(t,o)&&te(n,"set",e,t,o):te(n,"add",e,t),this}function Wi(e){const t=O(this),{has:n,get:i}=lt(t);let r=n.call(t,e);r?Yi(t,n,e):(e=O(e),r=n.call(t,e));const s=i?i.call(t,e):void 0,o=t.delete(e);return r&&te(t,"delete",e,void 0,s),o}function qi(){const e=O(this),t=e.size!==0,n=je(e)?new Map(e):new Set(e),i=e.clear();return t&&te(e,"clear",void 0,void 0,n),i}function ft(e,t){return function(i,r){const s=this,o=s.__v_raw,a=O(o),l=t?vn:e?gn:mn;return!e&&j(a,"iterate",ge),o.forEach((c,u)=>i.call(r,l(c),l(u),s))}}function ht(e,t,n){return function(...i){const r=this.__v_raw,s=O(r),o=je(s),a=e==="entries"||e===Symbol.iterator&&o,l=e==="keys"&&o,c=r[e](...i),u=n?vn:t?gn:mn;return!t&&j(s,"iterate",l?hn:ge),{next(){const{value:d,done:f}=c.next();return f?{value:d,done:f}:{value:a?[u(d[0]),u(d[1])]:u(d),done:f}},[Symbol.iterator](){return this}}}}function ne(e){return function(...t){{const n=t[0]?`on key "${t[0]}" `:"";console.warn(`${So(e)} operation ${n}failed: target is readonly.`,O(this))}return e==="delete"?!1:this}}function Wo(){const e={get(s){return ct(this,s)},get size(){return dt(this)},has:ut,add:Vi,set:Hi,delete:Wi,clear:qi,forEach:ft(!1,!1)},t={get(s){return ct(this,s,!1,!0)},get size(){return dt(this)},has:ut,add:Vi,set:Hi,delete:Wi,clear:qi,forEach:ft(!1,!0)},n={get(s){return ct(this,s,!0)},get size(){return dt(this,!0)},has(s){return ut.call(this,s,!0)},add:ne("add"),set:ne("set"),delete:ne("delete"),clear:ne("clear"),forEach:ft(!0,!1)},i={get(s){return ct(this,s,!0,!0)},get size(){return dt(this,!0)},has(s){return ut.call(this,s,!0)},add:ne("add"),set:ne("set"),delete:ne("delete"),clear:ne("clear"),forEach:ft(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{e[s]=ht(s,!1,!1),n[s]=ht(s,!0,!1),t[s]=ht(s,!1,!0),i[s]=ht(s,!0,!0)}),[e,n,t,i]}var[qo,Uo,Pc,zc]=Wo();function Ui(e,t){const n=e?Uo:qo;return(i,r,s)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?i:Reflect.get(ot(n,r)&&r in i?n:i,r,s)}var Yo={get:Ui(!1)},Ko={get:Ui(!0)};function Yi(e,t,n){const i=O(n);if(i!==n&&t.call(e,i)){const r=Di(e);console.warn(`Reactive ${r} contains both the raw and reactive versions of the same object${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}var Ki=new WeakMap,Jo=new WeakMap,Ji=new WeakMap,Go=new WeakMap;function Zo(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Xo(e){return e.__v_skip||!Object.isExtensible(e)?0:Zo(Di(e))}function bn(e){return e&&e.__v_isReadonly?e:Zi(e,!1,Vo,Yo,Ki)}function Gi(e){return Zi(e,!0,Ho,Ko,Ji)}function Zi(e,t,n,i,r){if(!at(e))return console.warn(`value cannot be made reactive: ${String(e)}`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=r.get(e);if(s)return s;const o=Xo(e);if(o===0)return e;const a=new Proxy(e,o===2?i:n);return r.set(e,a),a}function O(e){return e&&O(e.__v_raw)||e}function yn(e){return!!(e&&e.__v_isRef===!0)}B("nextTick",()=>tn),B("dispatch",e=>ze.bind(ze,e)),B("watch",(e,{evaluateLater:t,cleanup:n})=>(i,r)=>{let s=t(i),a=Fn(()=>{let l;return s(c=>l=c),l},r);n(a)}),B("store",ho),B("data",e=>Yn(e)),B("root",e=>nt(e)),B("refs",e=>(e._x_refs_proxy||(e._x_refs_proxy=De(Qo(e))),e._x_refs_proxy));function Qo(e){let t=[];return Ce(e,n=>{n._x_refs&&t.push(n._x_refs)}),t}var wn={};function Xi(e){return wn[e]||(wn[e]=0),++wn[e]}function ea(e,t){return Ce(e,n=>{if(n._x_ids&&n._x_ids[t])return!0})}function ta(e,t){e._x_ids||(e._x_ids={}),e._x_ids[t]||(e._x_ids[t]=Xi(t))}B("id",(e,{cleanup:t})=>(n,i=null)=>{let r=`${n}${i?`-${i}`:""}`;return na(e,r,t,()=>{let s=ea(e,n),o=s?s._x_ids[n]:Xi(n);return i?`${n}-${o}-${i}`:`${n}-${o}`})}),rt((e,t)=>{e._x_id&&(t._x_id=e._x_id)});function na(e,t,n,i){if(e._x_id||(e._x_id={}),e._x_id[t])return e._x_id[t];let r=i();return e._x_id[t]=r,n(()=>{delete e._x_id[t]}),r}B("el",e=>e),Qi("Focus","focus","focus"),Qi("Persist","persist","persist");function Qi(e,t,n){B(t,i=>P(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`,i))}N("modelable",(e,{expression:t},{effect:n,evaluateLater:i,cleanup:r})=>{let s=i(t),o=()=>{let u;return s(d=>u=d),u},a=i(`${t} = __placeholder`),l=u=>a(()=>{},{scope:{__placeholder:u}}),c=o();l(c),queueMicrotask(()=>{if(!e._x_model)return;e._x_removeModelListeners.default();let u=e._x_model.get,d=e._x_model.set,f=Oi({get(){return u()},set(v){d(v)}},{get(){return o()},set(v){l(v)}});r(f)})}),N("teleport",(e,{modifiers:t,expression:n},{cleanup:i})=>{e.tagName.toLowerCase()!=="template"&&P("x-teleport can only be used on a <template> tag",e);let r=er(n),s=e.content.cloneNode(!0).firstElementChild;e._x_teleport=s,s._x_teleportBack=e,e.setAttribute("data-teleport-template",!0),s.setAttribute("data-teleport-target",!0),e._x_forwardEvents&&e._x_forwardEvents.forEach(a=>{s.addEventListener(a,l=>{l.stopPropagation(),e.dispatchEvent(new l.constructor(l.type,l))})}),Le(s,{},e);let o=(a,l,c)=>{c.includes("prepend")?l.parentNode.insertBefore(a,l):c.includes("append")?l.parentNode.insertBefore(a,l.nextSibling):l.appendChild(a)};$(()=>{o(s,r,t),ee(()=>{G(s)})()}),e._x_teleportPutBack=()=>{let a=er(n);$(()=>{o(e._x_teleport,a,t)})},i(()=>$(()=>{s.remove(),Te(s)}))});var ia=document.createElement("div");function er(e){let t=ee(()=>document.querySelector(e),()=>ia)();return t||P(`Cannot find x-teleport element for selector: "${e}"`),t}var tr=()=>{};tr.inline=(e,{modifiers:t},{cleanup:n})=>{t.includes("self")?e._x_ignoreSelf=!0:e._x_ignore=!0,n(()=>{t.includes("self")?delete e._x_ignoreSelf:delete e._x_ignore})},N("ignore",tr),N("effect",ee((e,{expression:t},{effect:n})=>{n(R(e,t))}));function _n(e,t,n,i){let r=e,s=l=>i(l),o={},a=(l,c)=>u=>c(l,u);if(n.includes("dot")&&(t=ra(t)),n.includes("camel")&&(t=sa(t)),n.includes("passive")&&(o.passive=!0),n.includes("capture")&&(o.capture=!0),n.includes("window")&&(r=window),n.includes("document")&&(r=document),n.includes("debounce")){let l=n[n.indexOf("debounce")+1]||"invalid-wait",c=pt(l.split("ms")[0])?Number(l.split("ms")[0]):250;s=Ti(s,c)}if(n.includes("throttle")){let l=n[n.indexOf("throttle")+1]||"invalid-wait",c=pt(l.split("ms")[0])?Number(l.split("ms")[0]):250;s=Ai(s,c)}return n.includes("prevent")&&(s=a(s,(l,c)=>{c.preventDefault(),l(c)})),n.includes("stop")&&(s=a(s,(l,c)=>{c.stopPropagation(),l(c)})),n.includes("once")&&(s=a(s,(l,c)=>{l(c),r.removeEventListener(t,s,o)})),(n.includes("away")||n.includes("outside"))&&(r=document,s=a(s,(l,c)=>{e.contains(c.target)||c.target.isConnected!==!1&&(e.offsetWidth<1&&e.offsetHeight<1||e._x_isShown!==!1&&l(c))})),n.includes("self")&&(s=a(s,(l,c)=>{c.target===e&&l(c)})),(aa(t)||nr(t))&&(s=a(s,(l,c)=>{la(c,n)||l(c)})),r.addEventListener(t,s,o),()=>{r.removeEventListener(t,s,o)}}function ra(e){return e.replace(/-/g,".")}function sa(e){return e.toLowerCase().replace(/-(\w)/g,(t,n)=>n.toUpperCase())}function pt(e){return!Array.isArray(e)&&!isNaN(e)}function oa(e){return[" ","_"].includes(e)?e:e.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[_\s]/,"-").toLowerCase()}function aa(e){return["keydown","keyup"].includes(e)}function nr(e){return["contextmenu","click","mouse"].some(t=>e.includes(t))}function la(e,t){let n=t.filter(s=>!["window","document","prevent","stop","once","capture","self","away","outside","passive","preserve-scroll"].includes(s));if(n.includes("debounce")){let s=n.indexOf("debounce");n.splice(s,pt((n[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(n.includes("throttle")){let s=n.indexOf("throttle");n.splice(s,pt((n[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(n.length===0||n.length===1&&ir(e.key).includes(n[0]))return!1;const r=["ctrl","shift","alt","meta","cmd","super"].filter(s=>n.includes(s));return n=n.filter(s=>!r.includes(s)),!(r.length>0&&r.filter(o=>((o==="cmd"||o==="super")&&(o="meta"),e[`${o}Key`])).length===r.length&&(nr(e.type)||ir(e.key).includes(n[0])))}function ir(e){if(!e)return[];e=oa(e);let t={ctrl:"control",slash:"/",space:" ",spacebar:" ",cmd:"meta",esc:"escape",up:"arrow-up",down:"arrow-down",left:"arrow-left",right:"arrow-right",period:".",comma:",",equal:"=",minus:"-",underscore:"_"};return t[e]=e,Object.keys(t).map(n=>{if(t[n]===e)return n}).filter(n=>n)}N("model",(e,{modifiers:t,expression:n},{effect:i,cleanup:r})=>{let s=e;t.includes("parent")&&(s=e.parentNode);let o=R(s,n),a;typeof n=="string"?a=R(s,`${n} = __placeholder`):typeof n=="function"&&typeof n()=="string"?a=R(s,`${n()} = __placeholder`):a=()=>{};let l=()=>{let f;return o(v=>f=v),rr(f)?f.get():f},c=f=>{let v;o(x=>v=x),rr(v)?v.set(f):a(()=>{},{scope:{__placeholder:f}})};typeof n=="string"&&e.type==="radio"&&$(()=>{e.hasAttribute("name")||e.setAttribute("name",n)});let u=e.tagName.toLowerCase()==="select"||["checkbox","radio"].includes(e.type)||t.includes("lazy")?"change":"input",d=Q?()=>{}:_n(e,u,t,f=>{c(xn(e,t,f,l()))});if(t.includes("fill")&&([void 0,null,""].includes(l())||ln(e)&&Array.isArray(l())||e.tagName.toLowerCase()==="select"&&e.multiple)&&c(xn(e,t,{target:e},l())),e._x_removeModelListeners||(e._x_removeModelListeners={}),e._x_removeModelListeners.default=d,r(()=>e._x_removeModelListeners.default()),e.form){let f=_n(e.form,"reset",[],v=>{tn(()=>e._x_model&&e._x_model.set(xn(e,t,{target:e},l())))});r(()=>f())}e._x_model={get(){return l()},set(f){c(f)}},e._x_forceModelUpdate=f=>{f===void 0&&typeof n=="string"&&n.match(/\./)&&(f=""),window.fromModel=!0,$(()=>_i(e,"value",f)),delete window.fromModel},i(()=>{let f=l();t.includes("unintrusive")&&document.activeElement.isSameNode(e)||e._x_forceModelUpdate(f)})});function xn(e,t,n,i){return $(()=>{if(n instanceof CustomEvent&&n.detail!==void 0)return n.detail!==null&&n.detail!==void 0?n.detail:n.target.value;if(ln(e))if(Array.isArray(i)){let r=null;return t.includes("number")?r=En(n.target.value):t.includes("boolean")?r=st(n.target.value):r=n.target.value,n.target.checked?i.includes(r)?i:i.concat([r]):i.filter(s=>!ca(s,r))}else return n.target.checked;else{if(e.tagName.toLowerCase()==="select"&&e.multiple)return t.includes("number")?Array.from(n.target.selectedOptions).map(r=>{let s=r.value||r.text;return En(s)}):t.includes("boolean")?Array.from(n.target.selectedOptions).map(r=>{let s=r.value||r.text;return st(s)}):Array.from(n.target.selectedOptions).map(r=>r.value||r.text);{let r;return Ci(e)?n.target.checked?r=n.target.value:r=i:r=n.target.value,t.includes("number")?En(r):t.includes("boolean")?st(r):t.includes("trim")?r.trim():r}}})}function En(e){let t=e?parseFloat(e):null;return ua(t)?t:e}function ca(e,t){return e==t}function ua(e){return!Array.isArray(e)&&!isNaN(e)}function rr(e){return e!==null&&typeof e=="object"&&typeof e.get=="function"&&typeof e.set=="function"}N("cloak",e=>queueMicrotask(()=>$(()=>e.removeAttribute(Se("cloak"))))),pi(()=>`[${Se("init")}]`),N("init",ee((e,{expression:t},{evaluate:n})=>typeof t=="string"?!!t.trim()&&n(t,{},!1):n(t,{},!1))),N("text",(e,{expression:t},{effect:n,evaluateLater:i})=>{let r=i(t);n(()=>{r(s=>{$(()=>{e.textContent=s})})})}),N("html",(e,{expression:t},{effect:n,evaluateLater:i})=>{let r=i(t);n(()=>{r(s=>{$(()=>{e.innerHTML=s,e._x_ignoreSelf=!0,G(e),delete e._x_ignoreSelf})})})}),Gt(ii(":",ri(Se("bind:"))));var sr=(e,{value:t,modifiers:n,expression:i,original:r},{effect:s,cleanup:o})=>{if(!t){let l={};mo(l),R(e,i)(u=>{Ri(e,u,r)},{scope:l});return}if(t==="key")return da(e,i);if(e._x_inlineBindings&&e._x_inlineBindings[t]&&e._x_inlineBindings[t].extract)return;let a=R(e,i);s(()=>a(l=>{l===void 0&&typeof i=="string"&&i.match(/\./)&&(l=""),$(()=>_i(e,t,l,n))})),o(()=>{e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedStyles&&e._x_undoAddedStyles()})};sr.inline=(e,{value:t,modifiers:n,expression:i})=>{t&&(e._x_inlineBindings||(e._x_inlineBindings={}),e._x_inlineBindings[t]={expression:i,extract:!1})},N("bind",sr);function da(e,t){e._x_keyExpression=t}hi(()=>`[${Se("data")}]`),N("data",(e,{expression:t},{cleanup:n})=>{if(fa(e))return;t=t===""?"{}":t;let i={};qt(i,e);let r={};vo(r,i);let s=de(e,t,{scope:r});(s===void 0||s===!0)&&(s={}),qt(s,e);let o=xe(s);Kn(o);let a=Le(e,o);o.init&&de(e,o.init),n(()=>{o.destroy&&de(e,o.destroy),a()})}),rt((e,t)=>{e._x_dataStack&&(t._x_dataStack=e._x_dataStack,t.setAttribute("data-has-alpine-state",!0))});function fa(e){return Q?an?!0:e.hasAttribute("data-has-alpine-state"):!1}N("show",(e,{modifiers:t,expression:n},{effect:i})=>{let r=R(e,n);e._x_doHide||(e._x_doHide=()=>{$(()=>{e.style.setProperty("display","none",t.includes("important")?"important":void 0)})}),e._x_doShow||(e._x_doShow=()=>{$(()=>{e.style.length===1&&e.style.display==="none"?e.removeAttribute("style"):e.style.removeProperty("display")})});let s=()=>{e._x_doHide(),e._x_isShown=!1},o=()=>{e._x_doShow(),e._x_isShown=!0},a=()=>setTimeout(o),l=sn(d=>d?o():s(),d=>{typeof e._x_toggleAndCascadeWithTransitions=="function"?e._x_toggleAndCascadeWithTransitions(e,d,o,s):d?a():s()}),c,u=!0;i(()=>r(d=>{!u&&d===c||(t.includes("immediate")&&(d?a():s()),l(d),c=d,u=!1)}))}),N("for",(e,{expression:t},{effect:n,cleanup:i})=>{let r=pa(t),s=R(e,r.items),o=R(e,e._x_keyExpression||"index");e._x_prevKeys=[],e._x_lookup={},n(()=>ha(e,r,s,o)),i(()=>{Object.values(e._x_lookup).forEach(a=>$(()=>{Te(a),a.remove()})),delete e._x_prevKeys,delete e._x_lookup})});function ha(e,t,n,i){let r=o=>typeof o=="object"&&!Array.isArray(o),s=e;n(o=>{ma(o)&&o>=0&&(o=Array.from(Array(o).keys(),p=>p+1)),o===void 0&&(o=[]);let a=e._x_lookup,l=e._x_prevKeys,c=[],u=[];if(r(o))o=Object.entries(o).map(([p,g])=>{let h=or(t,g,p,o);i(y=>{u.includes(y)&&P("Duplicate key on x-for",e),u.push(y)},{scope:{index:p,...h}}),c.push(h)});else for(let p=0;p<o.length;p++){let g=or(t,o[p],p,o);i(h=>{u.includes(h)&&P("Duplicate key on x-for",e),u.push(h)},{scope:{index:p,...g}}),c.push(g)}let d=[],f=[],v=[],x=[];for(let p=0;p<l.length;p++){let g=l[p];u.indexOf(g)===-1&&v.push(g)}l=l.filter(p=>!v.includes(p));let w="template";for(let p=0;p<u.length;p++){let g=u[p],h=l.indexOf(g);if(h===-1)l.splice(p,0,g),d.push([w,p]);else if(h!==p){let y=l.splice(p,1)[0],E=l.splice(h-1,1)[0];l.splice(p,0,E),l.splice(h,0,y),f.push([y,E])}else x.push(g);w=g}for(let p=0;p<v.length;p++){let g=v[p];g in a&&($(()=>{Te(a[g]),a[g].remove()}),delete a[g])}for(let p=0;p<f.length;p++){let[g,h]=f[p],y=a[g],E=a[h],_=document.createElement("div");$(()=>{E||P('x-for ":key" is undefined or invalid',s,h,a),E.after(_),y.after(E),E._x_currentIfEl&&E.after(E._x_currentIfEl),_.before(y),y._x_currentIfEl&&y.after(y._x_currentIfEl),_.remove()}),E._x_refreshXForScope(c[u.indexOf(h)])}for(let p=0;p<d.length;p++){let[g,h]=d[p],y=g==="template"?s:a[g];y._x_currentIfEl&&(y=y._x_currentIfEl);let E=c[h],_=u[h],m=document.importNode(s.content,!0).firstElementChild,b=xe(E);Le(m,b,s),m._x_refreshXForScope=I=>{Object.entries(I).forEach(([S,C])=>{b[S]=C})},$(()=>{y.after(m),ee(()=>G(m))()}),typeof _=="object"&&P("x-for key cannot be an object, it must be a string or an integer",s),a[_]=m}for(let p=0;p<x.length;p++)a[x[p]]._x_refreshXForScope(c[u.indexOf(x[p])]);s._x_prevKeys=u})}function pa(e){let t=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,n=/^\s*\(|\)\s*$/g,i=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,r=e.match(i);if(!r)return;let s={};s.items=r[2].trim();let o=r[1].replace(n,"").trim(),a=o.match(t);return a?(s.item=o.replace(t,"").trim(),s.index=a[1].trim(),a[2]&&(s.collection=a[2].trim())):s.item=o,s}function or(e,t,n,i){let r={};return/^\[.*\]$/.test(e.item)&&Array.isArray(t)?e.item.replace("[","").replace("]","").split(",").map(o=>o.trim()).forEach((o,a)=>{r[o]=t[a]}):/^\{.*\}$/.test(e.item)&&!Array.isArray(t)&&typeof t=="object"?e.item.replace("{","").replace("}","").split(",").map(o=>o.trim()).forEach(o=>{r[o]=t[o]}):r[e.item]=t,e.index&&(r[e.index]=n),e.collection&&(r[e.collection]=i),r}function ma(e){return!Array.isArray(e)&&!isNaN(e)}function ar(){}ar.inline=(e,{expression:t},{cleanup:n})=>{let i=nt(e);i._x_refs||(i._x_refs={}),i._x_refs[t]=e,n(()=>delete i._x_refs[t])},N("ref",ar),N("if",(e,{expression:t},{effect:n,cleanup:i})=>{e.tagName.toLowerCase()!=="template"&&P("x-if can only be used on a <template> tag",e);let r=R(e,t),s=()=>{if(e._x_currentIfEl)return e._x_currentIfEl;let a=e.content.cloneNode(!0).firstElementChild;return Le(a,{},e),$(()=>{e.after(a),ee(()=>G(a))()}),e._x_currentIfEl=a,e._x_undoIf=()=>{$(()=>{Te(a),a.remove()}),delete e._x_currentIfEl},a},o=()=>{e._x_undoIf&&(e._x_undoIf(),delete e._x_undoIf)};n(()=>r(a=>{a?s():o()})),i(()=>e._x_undoIf&&e._x_undoIf())}),N("id",(e,{expression:t},{evaluate:n})=>{n(t).forEach(r=>ta(e,r))}),rt((e,t)=>{e._x_ids&&(t._x_ids=e._x_ids)}),Gt(ii("@",ri(Se("on:")))),N("on",ee((e,{value:t,modifiers:n,expression:i},{cleanup:r})=>{let s=i?R(e,i):()=>{};e.tagName.toLowerCase()==="template"&&(e._x_forwardEvents||(e._x_forwardEvents=[]),e._x_forwardEvents.includes(t)||e._x_forwardEvents.push(t));let o=_n(e,t,n,a=>{s(()=>{},{scope:{$event:a},params:[a]})});r(()=>o())})),mt("Collapse","collapse","collapse"),mt("Intersect","intersect","intersect"),mt("Focus","trap","focus"),mt("Mask","mask","mask");function mt(e,t,n){N(t,i=>P(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`,i))}Be.setEvaluator(Qn),Be.setReactivityEngine({reactive:bn,effect:To,release:Ao,raw:O});var ga=Be,lr=ga;function va(e){e.directive("collapse",t),t.inline=(n,{modifiers:i})=>{i.includes("min")&&(n._x_doShow=()=>{},n._x_doHide=()=>{})};function t(n,{modifiers:i}){let r=cr(i,"duration",250)/1e3,s=cr(i,"min",0),o=!i.includes("min");n._x_isShown||(n.style.height=`${s}px`),!n._x_isShown&&o&&(n.hidden=!0),n._x_isShown||(n.style.overflow="hidden");let a=(c,u)=>{let d=e.setStyles(c,u);return u.height?()=>{}:d},l={transitionProperty:"height",transitionDuration:`${r}s`,transitionTimingFunction:"cubic-bezier(0.4, 0.0, 0.2, 1)"};n._x_transition={in(c=()=>{},u=()=>{}){o&&(n.hidden=!1),o&&(n.style.display=null);let d=n.getBoundingClientRect().height;n.style.height="auto";let f=n.getBoundingClientRect().height;d===f&&(d=s),e.transition(n,e.setStyles,{during:l,start:{height:d+"px"},end:{height:f+"px"}},()=>n._x_isShown=!0,()=>{Math.abs(n.getBoundingClientRect().height-f)<1&&(n.style.overflow=null)})},out(c=()=>{},u=()=>{}){let d=n.getBoundingClientRect().height;e.transition(n,a,{during:l,start:{height:d+"px"},end:{height:s+"px"}},()=>n.style.overflow="hidden",()=>{n._x_isShown=!1,n.style.height==`${s}px`&&o&&(n.style.display="none",n.hidden=!0)})}}}}function cr(e,t,n){if(e.indexOf(t)===-1)return n;const i=e[e.indexOf(t)+1];if(!i)return n;if(t==="duration"){let r=i.match(/([0-9]+)ms/);if(r)return r[1]}if(t==="min"){let r=i.match(/([0-9]+)px/);if(r)return r[1]}return i}var ba=va;function ya(e){e.directive("intersect",e.skipDuringClone((t,{value:n,expression:i,modifiers:r},{evaluateLater:s,cleanup:o})=>{let a=s(i),l={rootMargin:xa(r),threshold:wa(r)},c=new IntersectionObserver(u=>{u.forEach(d=>{d.isIntersecting!==(n==="leave")&&(a(),r.includes("once")&&c.disconnect())})},l);c.observe(t),o(()=>{c.disconnect()})}))}function wa(e){if(e.includes("full"))return .99;if(e.includes("half"))return .5;if(!e.includes("threshold"))return 0;let t=e[e.indexOf("threshold")+1];return t==="100"?1:t==="0"?0:+`.${t}`}function _a(e){let t=e.match(/^(-?[0-9]+)(px|%)?$/);return t?t[1]+(t[2]||"px"):void 0}function xa(e){const t="margin",n="0px 0px 0px 0px",i=e.indexOf(t);if(i===-1)return n;let r=[];for(let s=1;s<5;s++)r.push(_a(e[i+s]||""));return r=r.filter(s=>s!==void 0),r.length?r.join(" ").trim():n}var Ea=ya,ur=["input","select","textarea","a[href]","button","[tabindex]:not(slot)","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])',"details>summary:first-of-type","details"],gt=ur.join(","),dr=typeof Element>"u",ve=dr?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,In=!dr&&Element.prototype.getRootNode?function(e){return e.getRootNode()}:function(e){return e.ownerDocument},fr=function(t,n,i){var r=Array.prototype.slice.apply(t.querySelectorAll(gt));return n&&ve.call(t,gt)&&r.unshift(t),r=r.filter(i),r},hr=function e(t,n,i){for(var r=[],s=Array.from(t);s.length;){var o=s.shift();if(o.tagName==="SLOT"){var a=o.assignedElements(),l=a.length?a:o.children,c=e(l,!0,i);i.flatten?r.push.apply(r,c):r.push({scope:o,candidates:c})}else{var u=ve.call(o,gt);u&&i.filter(o)&&(n||!t.includes(o))&&r.push(o);var d=o.shadowRoot||typeof i.getShadowRoot=="function"&&i.getShadowRoot(o),f=!i.shadowRootFilter||i.shadowRootFilter(o);if(d&&f){var v=e(d===!0?o.children:d.children,!0,i);i.flatten?r.push.apply(r,v):r.push({scope:o,candidates:v})}else s.unshift.apply(s,o.children)}}return r},pr=function(t,n){return t.tabIndex<0&&(n||/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName)||t.isContentEditable)&&isNaN(parseInt(t.getAttribute("tabindex"),10))?0:t.tabIndex},Ia=function(t,n){return t.tabIndex===n.tabIndex?t.documentOrder-n.documentOrder:t.tabIndex-n.tabIndex},mr=function(t){return t.tagName==="INPUT"},Sa=function(t){return mr(t)&&t.type==="hidden"},Ca=function(t){var n=t.tagName==="DETAILS"&&Array.prototype.slice.apply(t.children).some(function(i){return i.tagName==="SUMMARY"});return n},Ta=function(t,n){for(var i=0;i<t.length;i++)if(t[i].checked&&t[i].form===n)return t[i]},Aa=function(t){if(!t.name)return!0;var n=t.form||In(t),i=function(a){return n.querySelectorAll('input[type="radio"][name="'+a+'"]')},r;if(typeof window<"u"&&typeof window.CSS<"u"&&typeof window.CSS.escape=="function")r=i(window.CSS.escape(t.name));else try{r=i(t.name)}catch(o){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",o.message),!1}var s=Ta(r,t.form);return!s||s===t},Oa=function(t){return mr(t)&&t.type==="radio"},$a=function(t){return Oa(t)&&!Aa(t)},gr=function(t){var n=t.getBoundingClientRect(),i=n.width,r=n.height;return i===0&&r===0},Na=function(t,n){var i=n.displayCheck,r=n.getShadowRoot;if(getComputedStyle(t).visibility==="hidden")return!0;var s=ve.call(t,"details>summary:first-of-type"),o=s?t.parentElement:t;if(ve.call(o,"details:not([open]) *"))return!0;var a=In(t).host,l=a?.ownerDocument.contains(a)||t.ownerDocument.contains(t);if(!i||i==="full"){if(typeof r=="function"){for(var c=t;t;){var u=t.parentElement,d=In(t);if(u&&!u.shadowRoot&&r(u)===!0)return gr(t);t.assignedSlot?t=t.assignedSlot:!u&&d!==t.ownerDocument?t=d.host:t=u}t=c}if(l)return!t.getClientRects().length}else if(i==="non-zero-area")return gr(t);return!1},Ra=function(t){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))for(var n=t.parentElement;n;){if(n.tagName==="FIELDSET"&&n.disabled){for(var i=0;i<n.children.length;i++){var r=n.children.item(i);if(r.tagName==="LEGEND")return ve.call(n,"fieldset[disabled] *")?!0:!r.contains(t)}return!0}n=n.parentElement}return!1},vt=function(t,n){return!(n.disabled||Sa(n)||Na(n,t)||Ca(n)||Ra(n))},Sn=function(t,n){return!($a(n)||pr(n)<0||!vt(t,n))},ka=function(t){var n=parseInt(t.getAttribute("tabindex"),10);return!!(isNaN(n)||n>=0)},La=function e(t){var n=[],i=[];return t.forEach(function(r,s){var o=!!r.scope,a=o?r.scope:r,l=pr(a,o),c=o?e(r.candidates):a;l===0?o?n.push.apply(n,c):n.push(a):i.push({documentOrder:s,tabIndex:l,item:r,isScope:o,content:c})}),i.sort(Ia).reduce(function(r,s){return s.isScope?r.push.apply(r,s.content):r.push(s.content),r},[]).concat(n)},Da=function(t,n){n=n||{};var i;return n.getShadowRoot?i=hr([t],n.includeContainer,{filter:Sn.bind(null,n),flatten:!1,getShadowRoot:n.getShadowRoot,shadowRootFilter:ka}):i=fr(t,n.includeContainer,Sn.bind(null,n)),La(i)},vr=function(t,n){n=n||{};var i;return n.getShadowRoot?i=hr([t],n.includeContainer,{filter:vt.bind(null,n),flatten:!0,getShadowRoot:n.getShadowRoot}):i=fr(t,n.includeContainer,vt.bind(null,n)),i},bt=function(t,n){if(n=n||{},!t)throw new Error("No node provided");return ve.call(t,gt)===!1?!1:Sn(n,t)},Ma=ur.concat("iframe").join(","),yt=function(t,n){if(n=n||{},!t)throw new Error("No node provided");return ve.call(t,Ma)===!1?!1:vt(n,t)};function br(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),n.push.apply(n,i)}return n}function yr(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?br(Object(n),!0).forEach(function(i){Pa(e,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):br(Object(n)).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))})}return e}function Pa(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var wr=function(){var e=[];return{activateTrap:function(n){if(e.length>0){var i=e[e.length-1];i!==n&&i.pause()}var r=e.indexOf(n);r===-1||e.splice(r,1),e.push(n)},deactivateTrap:function(n){var i=e.indexOf(n);i!==-1&&e.splice(i,1),e.length>0&&e[e.length-1].unpause()}}}(),za=function(t){return t.tagName&&t.tagName.toLowerCase()==="input"&&typeof t.select=="function"},Fa=function(t){return t.key==="Escape"||t.key==="Esc"||t.keyCode===27},Ba=function(t){return t.key==="Tab"||t.keyCode===9},_r=function(t){return setTimeout(t,0)},xr=function(t,n){var i=-1;return t.every(function(r,s){return n(r)?(i=s,!1):!0}),i},He=function(t){for(var n=arguments.length,i=new Array(n>1?n-1:0),r=1;r<n;r++)i[r-1]=arguments[r];return typeof t=="function"?t.apply(void 0,i):t},wt=function(t){return t.target.shadowRoot&&typeof t.composedPath=="function"?t.composedPath()[0]:t.target},ja=function(t,n){var i=n?.document||document,r=yr({returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0},n),s={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0},o,a=function(m,b,I){return m&&m[b]!==void 0?m[b]:r[I||b]},l=function(m){return s.containerGroups.findIndex(function(b){var I=b.container,S=b.tabbableNodes;return I.contains(m)||S.find(function(C){return C===m})})},c=function(m){var b=r[m];if(typeof b=="function"){for(var I=arguments.length,S=new Array(I>1?I-1:0),C=1;C<I;C++)S[C-1]=arguments[C];b=b.apply(void 0,S)}if(b===!0&&(b=void 0),!b){if(b===void 0||b===!1)return b;throw new Error("`".concat(m,"` was specified but was not a node, or did not return a node"))}var T=b;if(typeof b=="string"&&(T=i.querySelector(b),!T))throw new Error("`".concat(m,"` as selector refers to no known node"));return T},u=function(){var m=c("initialFocus");if(m===!1)return!1;if(m===void 0)if(l(i.activeElement)>=0)m=i.activeElement;else{var b=s.tabbableGroups[0],I=b&&b.firstTabbableNode;m=I||c("fallbackFocus")}if(!m)throw new Error("Your focus-trap needs to have at least one focusable element");return m},d=function(){if(s.containerGroups=s.containers.map(function(m){var b=Da(m,r.tabbableOptions),I=vr(m,r.tabbableOptions);return{container:m,tabbableNodes:b,focusableNodes:I,firstTabbableNode:b.length>0?b[0]:null,lastTabbableNode:b.length>0?b[b.length-1]:null,nextTabbableNode:function(C){var T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,L=I.findIndex(function(D){return D===C});if(!(L<0))return T?I.slice(L+1).find(function(D){return bt(D,r.tabbableOptions)}):I.slice(0,L).reverse().find(function(D){return bt(D,r.tabbableOptions)})}}}),s.tabbableGroups=s.containerGroups.filter(function(m){return m.tabbableNodes.length>0}),s.tabbableGroups.length<=0&&!c("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")},f=function _(m){if(m!==!1&&m!==i.activeElement){if(!m||!m.focus){_(u());return}m.focus({preventScroll:!!r.preventScroll}),s.mostRecentlyFocusedNode=m,za(m)&&m.select()}},v=function(m){var b=c("setReturnFocus",m);return b||(b===!1?!1:m)},x=function(m){var b=wt(m);if(!(l(b)>=0)){if(He(r.clickOutsideDeactivates,m)){o.deactivate({returnFocus:r.returnFocusOnDeactivate&&!yt(b,r.tabbableOptions)});return}He(r.allowOutsideClick,m)||m.preventDefault()}},w=function(m){var b=wt(m),I=l(b)>=0;I||b instanceof Document?I&&(s.mostRecentlyFocusedNode=b):(m.stopImmediatePropagation(),f(s.mostRecentlyFocusedNode||u()))},p=function(m){var b=wt(m);d();var I=null;if(s.tabbableGroups.length>0){var S=l(b),C=S>=0?s.containerGroups[S]:void 0;if(S<0)m.shiftKey?I=s.tabbableGroups[s.tabbableGroups.length-1].lastTabbableNode:I=s.tabbableGroups[0].firstTabbableNode;else if(m.shiftKey){var T=xr(s.tabbableGroups,function(W){var F=W.firstTabbableNode;return b===F});if(T<0&&(C.container===b||yt(b,r.tabbableOptions)&&!bt(b,r.tabbableOptions)&&!C.nextTabbableNode(b,!1))&&(T=S),T>=0){var L=T===0?s.tabbableGroups.length-1:T-1,D=s.tabbableGroups[L];I=D.lastTabbableNode}}else{var K=xr(s.tabbableGroups,function(W){var F=W.lastTabbableNode;return b===F});if(K<0&&(C.container===b||yt(b,r.tabbableOptions)&&!bt(b,r.tabbableOptions)&&!C.nextTabbableNode(b))&&(K=S),K>=0){var z=K===s.tabbableGroups.length-1?0:K+1,_e=s.tabbableGroups[z];I=_e.firstTabbableNode}}}else I=c("fallbackFocus");I&&(m.preventDefault(),f(I))},g=function(m){if(Fa(m)&&He(r.escapeDeactivates,m)!==!1){m.preventDefault(),o.deactivate();return}if(Ba(m)){p(m);return}},h=function(m){var b=wt(m);l(b)>=0||He(r.clickOutsideDeactivates,m)||He(r.allowOutsideClick,m)||(m.preventDefault(),m.stopImmediatePropagation())},y=function(){if(s.active)return wr.activateTrap(o),s.delayInitialFocusTimer=r.delayInitialFocus?_r(function(){f(u())}):f(u()),i.addEventListener("focusin",w,!0),i.addEventListener("mousedown",x,{capture:!0,passive:!1}),i.addEventListener("touchstart",x,{capture:!0,passive:!1}),i.addEventListener("click",h,{capture:!0,passive:!1}),i.addEventListener("keydown",g,{capture:!0,passive:!1}),o},E=function(){if(s.active)return i.removeEventListener("focusin",w,!0),i.removeEventListener("mousedown",x,!0),i.removeEventListener("touchstart",x,!0),i.removeEventListener("click",h,!0),i.removeEventListener("keydown",g,!0),o};return o={get active(){return s.active},get paused(){return s.paused},activate:function(m){if(s.active)return this;var b=a(m,"onActivate"),I=a(m,"onPostActivate"),S=a(m,"checkCanFocusTrap");S||d(),s.active=!0,s.paused=!1,s.nodeFocusedBeforeActivation=i.activeElement,b&&b();var C=function(){S&&d(),y(),I&&I()};return S?(S(s.containers.concat()).then(C,C),this):(C(),this)},deactivate:function(m){if(!s.active)return this;var b=yr({onDeactivate:r.onDeactivate,onPostDeactivate:r.onPostDeactivate,checkCanReturnFocus:r.checkCanReturnFocus},m);clearTimeout(s.delayInitialFocusTimer),s.delayInitialFocusTimer=void 0,E(),s.active=!1,s.paused=!1,wr.deactivateTrap(o);var I=a(b,"onDeactivate"),S=a(b,"onPostDeactivate"),C=a(b,"checkCanReturnFocus"),T=a(b,"returnFocus","returnFocusOnDeactivate");I&&I();var L=function(){_r(function(){T&&f(v(s.nodeFocusedBeforeActivation)),S&&S()})};return T&&C?(C(v(s.nodeFocusedBeforeActivation)).then(L,L),this):(L(),this)},pause:function(){return s.paused||!s.active?this:(s.paused=!0,E(),this)},unpause:function(){return!s.paused||!s.active?this:(s.paused=!1,d(),y(),this)},updateContainerElements:function(m){var b=[].concat(m).filter(Boolean);return s.containers=b.map(function(I){return typeof I=="string"?i.querySelector(I):I}),s.active&&d(),this}},o.updateContainerElements(t),o};function Va(e){let t,n;window.addEventListener("focusin",()=>{t=n,n=document.activeElement}),e.magic("focus",i=>{let r=i;return{__noscroll:!1,__wrapAround:!1,within(s){return r=s,this},withoutScrolling(){return this.__noscroll=!0,this},noscroll(){return this.__noscroll=!0,this},withWrapAround(){return this.__wrapAround=!0,this},wrap(){return this.withWrapAround()},focusable(s){return yt(s)},previouslyFocused(){return t},lastFocused(){return t},focused(){return n},focusables(){return Array.isArray(r)?r:vr(r,{displayCheck:"none"})},all(){return this.focusables()},isFirst(s){let o=this.all();return o[0]&&o[0].isSameNode(s)},isLast(s){let o=this.all();return o.length&&o.slice(-1)[0].isSameNode(s)},getFirst(){return this.all()[0]},getLast(){return this.all().slice(-1)[0]},getNext(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===s.length-1?s[0]:s[s.indexOf(o)+1]},getPrevious(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===0?s.slice(-1)[0]:s[s.indexOf(o)-1]},first(){this.focus(this.getFirst())},last(){this.focus(this.getLast())},next(){this.focus(this.getNext())},previous(){this.focus(this.getPrevious())},prev(){return this.previous()},focus(s){s&&setTimeout(()=>{s.hasAttribute("tabindex")||s.setAttribute("tabindex","0"),s.focus({preventScroll:this.__noscroll})})}}}),e.directive("trap",e.skipDuringClone((i,{expression:r,modifiers:s},{effect:o,evaluateLater:a,cleanup:l})=>{let c=a(r),u=!1,d={escapeDeactivates:!1,allowOutsideClick:!0,fallbackFocus:()=>i},f=()=>{};if(s.includes("noautofocus"))d.initialFocus=!1;else{let p=i.querySelector("[autofocus]");p&&(d.initialFocus=p)}s.includes("inert")&&(d.onPostActivate=()=>{e.nextTick(()=>{f=Er(i)})});let v=ja(i,d),x=()=>{};const w=()=>{f(),f=()=>{},x(),x=()=>{},v.deactivate({returnFocus:!s.includes("noreturn")})};o(()=>c(p=>{u!==p&&(p&&!u&&(s.includes("noscroll")&&(x=Ha()),setTimeout(()=>{v.activate()},15)),!p&&u&&w(),u=!!p)})),l(w)},(i,{expression:r,modifiers:s},{evaluate:o})=>{s.includes("inert")&&o(r)&&Er(i)}))}function Er(e){let t=[];return Ir(e,n=>{let i=n.hasAttribute("aria-hidden");n.setAttribute("aria-hidden","true"),t.push(()=>i||n.removeAttribute("aria-hidden"))}),()=>{for(;t.length;)t.pop()()}}function Ir(e,t){e.isSameNode(document.body)||!e.parentNode||Array.from(e.parentNode.children).forEach(n=>{n.isSameNode(e)?Ir(e.parentNode,t):t(n)})}function Ha(){let e=document.documentElement.style.overflow,t=document.documentElement.style.paddingRight,n=window.innerWidth-document.documentElement.clientWidth;return document.documentElement.style.overflow="hidden",document.documentElement.style.paddingRight=`${n}px`,()=>{document.documentElement.style.overflow=e,document.documentElement.style.paddingRight=t}}var Wa=Va;/*! Bundled license information:
  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)
  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  */function qa(){return!0}function Ua({component:e,argument:t}){return new Promise(n=>{if(t)window.addEventListener(t,()=>n(),{once:!0});else{const i=r=>{r.detail.id===e.id&&(window.removeEventListener("async-alpine:load",i),n())};window.addEventListener("async-alpine:load",i)}})}function Ya(){return new Promise(e=>{"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,200)})}function Ka({argument:e}){return new Promise(t=>{if(!e)return console.log("Async Alpine: media strategy requires a media query. Treating as 'eager'"),t();const n=window.matchMedia(`(${e})`);n.matches?t():n.addEventListener("change",t,{once:!0})})}function Ja({component:e,argument:t}){return new Promise(n=>{const i=t||"0px 0px 0px 0px",r=new IntersectionObserver(s=>{s[0].isIntersecting&&(r.disconnect(),n())},{rootMargin:i});r.observe(e.el)})}var Sr={eager:qa,event:Ua,idle:Ya,media:Ka,visible:Ja};async function Ga(e){const t=Za(e.strategy);await Cn(e,t)}async function Cn(e,t){if(t.type==="expression"){if(t.operator==="&&")return Promise.all(t.parameters.map(n=>Cn(e,n)));if(t.operator==="||")return Promise.any(t.parameters.map(n=>Cn(e,n)))}return Sr[t.method]?Sr[t.method]({component:e,argument:t.argument}):!1}function Za(e){const t=Xa(e);let n=Cr(t);return n.type==="method"?{type:"expression",operator:"&&",parameters:[n]}:n}function Xa(e){const t=/\s*([()])\s*|\s*(\|\||&&|\|)\s*|\s*((?:[^()&|]+\([^()]+\))|[^()&|]+)\s*/g,n=[];let i;for(;(i=t.exec(e))!==null;){const[r,s,o,a]=i;if(s!==void 0)n.push({type:"parenthesis",value:s});else if(o!==void 0)n.push({type:"operator",value:o==="|"?"&&":o});else{const l={type:"method",method:a.trim()};a.includes("(")&&(l.method=a.substring(0,a.indexOf("(")).trim(),l.argument=a.substring(a.indexOf("(")+1,a.indexOf(")"))),a.method==="immediate"&&(a.method="eager"),n.push(l)}}return n}function Cr(e){let t=Tr(e);for(;e.length>0&&(e[0].value==="&&"||e[0].value==="|"||e[0].value==="||");){const n=e.shift().value,i=Tr(e);t.type==="expression"&&t.operator===n?t.parameters.push(i):t={type:"expression",operator:n,parameters:[t,i]}}return t}function Tr(e){if(e[0].value==="("){e.shift();const t=Cr(e);return e[0].value===")"&&e.shift(),t}else return e.shift()}function Qa(e){const t="load",n=e.prefixed("load-src"),i=e.prefixed("ignore");let r={defaultStrategy:"eager",keepRelativeURLs:!1},s=!1,o={},a=0;function l(){return a++}e.asyncOptions=h=>{r={...r,...h}},e.asyncData=(h,y=!1)=>{o[h]={loaded:!1,download:y}},e.asyncUrl=(h,y)=>{!h||!y||o[h]||(o[h]={loaded:!1,download:()=>import(g(y))})},e.asyncAlias=h=>{s=h};const c=h=>{e.skipDuringClone(()=>{h._x_async||(h._x_async="init",h._x_ignore=!0,h.setAttribute(i,""))})()},u=async h=>{e.skipDuringClone(async()=>{if(h._x_async!=="init")return;h._x_async="await";const{name:y,strategy:E}=d(h);await Ga({name:y,strategy:E,el:h,id:h.id||l()}),h.isConnected&&(await f(y),h.isConnected&&(x(h),h._x_async="loaded"))})()};u.inline=c,e.directive(t,u).before("ignore");function d(h){const y=p(h.getAttribute(e.prefixed("data"))),E=h.getAttribute(e.prefixed(t))||r.defaultStrategy,_=h.getAttribute(n);return _&&e.asyncUrl(y,_),{name:y,strategy:E}}async function f(h){if(h.startsWith("_x_async_")||(w(h),!o[h]||o[h].loaded))return;const y=await v(h);e.data(h,y),o[h].loaded=!0}async function v(h){if(!o[h])return;const y=await o[h].download(h);return typeof y=="function"?y:y[h]||y.default||Object.values(y)[0]||!1}function x(h){e.destroyTree(h),h._x_ignore=!1,h.removeAttribute(i),!h.closest(`[${i}]`)&&e.initTree(h)}function w(h){if(!(!s||o[h])){if(typeof s=="function"){e.asyncData(h,s);return}e.asyncUrl(h,s.replaceAll("[name]",h))}}function p(h){return(h||"").trim().split(/[({]/g)[0]||`_x_async_${l()}`}function g(h){return r.keepRelativeURLs||new RegExp("^(?:[a-z+]+:)?//","i").test(h)?h:new URL(h,document.baseURI).href}}function el(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function tl(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function nl(e,t,n){return t&&tl(e.prototype,t),e}var il=Object.defineProperty,Z=function(e,t){return il(e,"name",{value:t,configurable:!0})},rl=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`,sl=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`,ol=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,al=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,ll=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`,cl=Z(function(e){return new DOMParser().parseFromString(e,"text/html").body.childNodes[0]},"stringToHTML"),We=Z(function(e){var t=new DOMParser().parseFromString(e,"application/xml");return document.importNode(t.documentElement,!0).outerHTML},"getSvgNode"),A={CONTAINER:"sn-notifications-container",NOTIFY:"sn-notify",NOTIFY_CONTENT:"sn-notify-content",NOTIFY_ICON:"sn-notify-icon",NOTIFY_CLOSE:"sn-notify-close",NOTIFY_TITLE:"sn-notify-title",NOTIFY_TEXT:"sn-notify-text",IS_X_CENTER:"sn-is-x-center",IS_Y_CENTER:"sn-is-y-center",IS_CENTER:"sn-is-center",IS_LEFT:"sn-is-left",IS_RIGHT:"sn-is-right",IS_TOP:"sn-is-top",IS_BOTTOM:"sn-is-bottom",NOTIFY_OUTLINE:"sn-notify-outline",NOTIFY_FILLED:"sn-notify-filled",NOTIFY_ERROR:"sn-notify-error",NOTIFY_WARNING:"sn-notify-warning",NOTIFY_SUCCESS:"sn-notify-success",NOTIFY_INFO:"sn-notify-info",NOTIFY_FADE:"sn-notify-fade",NOTIFY_FADE_IN:"sn-notify-fade-in",NOTIFY_SLIDE:"sn-notify-slide",NOTIFY_SLIDE_IN:"sn-notify-slide-in",NOTIFY_AUTOCLOSE:"sn-notify-autoclose"},ie={ERROR:"error",WARNING:"warning",SUCCESS:"success",INFO:"info"},Ar={OUTLINE:"outline",FILLED:"filled"},Tn={FADE:"fade",SLIDE:"slide"},qe={CLOSE:We(rl),SUCCESS:We(al),ERROR:We(sl),WARNING:We(ll),INFO:We(ol)},Or=Z(function(e){e.wrapper.classList.add(A.NOTIFY_FADE),setTimeout(function(){e.wrapper.classList.add(A.NOTIFY_FADE_IN)},100)},"fadeIn"),$r=Z(function(e){e.wrapper.classList.remove(A.NOTIFY_FADE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"fadeOut"),ul=Z(function(e){e.wrapper.classList.add(A.NOTIFY_SLIDE),setTimeout(function(){e.wrapper.classList.add(A.NOTIFY_SLIDE_IN)},100)},"slideIn"),dl=Z(function(e){e.wrapper.classList.remove(A.NOTIFY_SLIDE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"slideOut"),Nr=function(){function e(t){var n=this;el(this,e),this.notifyOut=Z(function(W){W(n)},"notifyOut");var i=t.notificationsGap,r=i===void 0?20:i,s=t.notificationsPadding,o=s===void 0?20:s,a=t.status,l=a===void 0?"success":a,c=t.effect,u=c===void 0?Tn.FADE:c,d=t.type,f=d===void 0?"outline":d,v=t.title,x=t.text,w=t.showIcon,p=w===void 0?!0:w,g=t.customIcon,h=g===void 0?"":g,y=t.customClass,E=y===void 0?"":y,_=t.speed,m=_===void 0?500:_,b=t.showCloseButton,I=b===void 0?!0:b,S=t.autoclose,C=S===void 0?!0:S,T=t.autotimeout,L=T===void 0?3e3:T,D=t.position,K=D===void 0?"right top":D,z=t.customWrapper,_e=z===void 0?"":z;if(this.customWrapper=_e,this.status=l,this.title=v,this.text=x,this.showIcon=p,this.customIcon=h,this.customClass=E,this.speed=m,this.effect=u,this.showCloseButton=I,this.autoclose=C,this.autotimeout=L,this.notificationsGap=r,this.notificationsPadding=o,this.type=f,this.position=K,!this.checkRequirements()){console.error("You must specify 'title' or 'text' at least.");return}this.setContainer(),this.setWrapper(),this.setPosition(),this.showIcon&&this.setIcon(),this.showCloseButton&&this.setCloseButton(),this.setContent(),this.container.prepend(this.wrapper),this.setEffect(),this.notifyIn(this.selectedNotifyInEffect),this.autoclose&&this.autoClose(),this.setObserver()}return nl(e,[{key:"checkRequirements",value:function(){return!!(this.title||this.text)}},{key:"setContainer",value:function(){var n=document.querySelector(".".concat(A.CONTAINER));n?this.container=n:(this.container=document.createElement("div"),this.container.classList.add(A.CONTAINER),document.body.appendChild(this.container)),this.notificationsPadding&&this.container.style.setProperty("--sn-notifications-padding","".concat(this.notificationsPadding,"px")),this.notificationsGap&&this.container.style.setProperty("--sn-notifications-gap","".concat(this.notificationsGap,"px"))}},{key:"setPosition",value:function(){this.container.classList[this.position==="center"?"add":"remove"](A.IS_CENTER),this.container.classList[this.position.includes("left")?"add":"remove"](A.IS_LEFT),this.container.classList[this.position.includes("right")?"add":"remove"](A.IS_RIGHT),this.container.classList[this.position.includes("top")?"add":"remove"](A.IS_TOP),this.container.classList[this.position.includes("bottom")?"add":"remove"](A.IS_BOTTOM),this.container.classList[this.position.includes("x-center")?"add":"remove"](A.IS_X_CENTER),this.container.classList[this.position.includes("y-center")?"add":"remove"](A.IS_Y_CENTER)}},{key:"setCloseButton",value:function(){var n=this,i=document.createElement("div");i.classList.add(A.NOTIFY_CLOSE),i.innerHTML=qe.CLOSE,this.wrapper.appendChild(i),i.addEventListener("click",function(){n.close()})}},{key:"setWrapper",value:function(){var n=this;switch(this.customWrapper?this.wrapper=cl(this.customWrapper):this.wrapper=document.createElement("div"),this.wrapper.style.setProperty("--sn-notify-transition-duration","".concat(this.speed,"ms")),this.wrapper.classList.add(A.NOTIFY),this.type){case Ar.OUTLINE:this.wrapper.classList.add(A.NOTIFY_OUTLINE);break;case Ar.FILLED:this.wrapper.classList.add(A.NOTIFY_FILLED);break;default:this.wrapper.classList.add(A.NOTIFY_OUTLINE)}switch(this.status){case ie.SUCCESS:this.wrapper.classList.add(A.NOTIFY_SUCCESS);break;case ie.ERROR:this.wrapper.classList.add(A.NOTIFY_ERROR);break;case ie.WARNING:this.wrapper.classList.add(A.NOTIFY_WARNING);break;case ie.INFO:this.wrapper.classList.add(A.NOTIFY_INFO);break}this.autoclose&&(this.wrapper.classList.add(A.NOTIFY_AUTOCLOSE),this.wrapper.style.setProperty("--sn-notify-autoclose-timeout","".concat(this.autotimeout+this.speed,"ms"))),this.customClass&&this.customClass.split(" ").forEach(function(i){n.wrapper.classList.add(i)})}},{key:"setContent",value:function(){var n=document.createElement("div");n.classList.add(A.NOTIFY_CONTENT);var i,r;this.title&&(i=document.createElement("div"),i.classList.add(A.NOTIFY_TITLE),i.textContent=this.title.trim(),this.showCloseButton||(i.style.paddingRight="0")),this.text&&(r=document.createElement("div"),r.classList.add(A.NOTIFY_TEXT),r.innerHTML=this.text.trim(),this.title||(r.style.marginTop="0")),this.wrapper.appendChild(n),this.title&&n.appendChild(i),this.text&&n.appendChild(r)}},{key:"setIcon",value:function(){var n=Z(function(r){switch(r){case ie.SUCCESS:return qe.SUCCESS;case ie.ERROR:return qe.ERROR;case ie.WARNING:return qe.WARNING;case ie.INFO:return qe.INFO}},"computedIcon"),i=document.createElement("div");i.classList.add(A.NOTIFY_ICON),i.innerHTML=this.customIcon||n(this.status),(this.status||this.customIcon)&&this.wrapper.appendChild(i)}},{key:"setObserver",value:function(){var n=this,i=new IntersectionObserver(function(r){if(r[0].intersectionRatio<=0)n.close();else return},{threshold:0});setTimeout(function(){i.observe(n.wrapper)},this.speed)}},{key:"notifyIn",value:function(t){t(this)}},{key:"autoClose",value:function(){var n=this;setTimeout(function(){n.close()},this.autotimeout+this.speed)}},{key:"close",value:function(){this.notifyOut(this.selectedNotifyOutEffect)}},{key:"setEffect",value:function(){switch(this.effect){case Tn.FADE:this.selectedNotifyInEffect=Or,this.selectedNotifyOutEffect=$r;break;case Tn.SLIDE:this.selectedNotifyInEffect=ul,this.selectedNotifyOutEffect=dl;break;default:this.selectedNotifyInEffect=Or,this.selectedNotifyOutEffect=$r}}}]),e}();Z(Nr,"Notify");var Rr=Nr;globalThis.Notify=Rr;const kr=["success","error","warning","info"],Lr=["right top","top right","right bottom","bottom right","left top","top left","left bottom","bottom left","center top","x-center top","center bottom","x-center bottom","left center","left y-center","y-center left","right center","right y-center","y-center right","top center","top x-center","bottom center","bottom x-center","center"],Dr={status:"info",title:"Notification",text:"",effect:"fade",speed:300,autoclose:!0,autotimeout:4e3,position:"right top"};function Ue(e={}){const t={...Dr,...e};kr.includes(t.status)||(console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`),t.status="info"),Lr.includes(t.position)||(console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`),t.position="right top"),new Rr(t)}const fl={custom:Ue,success(e,t="Success",n={}){Ue({status:"success",title:t,text:e,...n})},error(e,t="Error",n={}){Ue({status:"error",title:t,text:e,...n})},warning(e,t="Warning",n={}){Ue({status:"warning",title:t,text:e,...n})},info(e,t="Info",n={}){Ue({status:"info",title:t,text:e,...n})},setDefaults(e={}){Object.assign(Dr,e)},get allowedStatuses(){return[...kr]},get allowedPositions(){return[...Lr]}},An=function(){},Ye={},_t={},Ke={};function hl(e,t){e=Array.isArray(e)?e:[e];const n=[];let i=e.length,r=i,s,o,a,l;for(s=function(c,u){u.length&&n.push(c),r--,r||t(n)};i--;){if(o=e[i],a=_t[o],a){s(o,a);continue}l=Ke[o]=Ke[o]||[],l.push(s)}}function Mr(e,t){if(!e)return;const n=Ke[e];if(_t[e]=t,!!n)for(;n.length;)n[0](e,t),n.splice(0,1)}function On(e,t){typeof e=="function"&&(e={success:e}),t.length?(e.error||An)(t):(e.success||An)(e)}function pl(e,t,n,i,r,s,o,a){let l=e.type[0];if(a)try{n.sheet.cssText.length||(l="e")}catch(c){c.code!==18&&(l="e")}if(l==="e"){if(s+=1,s<o)return Pr(t,i,r,s)}else if(n.rel==="preload"&&n.as==="style"){n.rel="stylesheet";return}i(t,l,e.defaultPrevented)}function Pr(e,t,n,i){const r=document,s=n.async,o=(n.numRetries||0)+1,a=n.before||An,l=e.replace(/[\?|#].*$/,""),c=e.replace(/^(css|img|module|nomodule)!/,"");let u,d,f;if(i=i||0,/(^css!|\.css$)/.test(l))f=r.createElement("link"),f.rel="stylesheet",f.href=c,u="hideFocus"in f,u&&f.relList&&(u=0,f.rel="preload",f.as="style"),n.inlineStyleNonce&&f.setAttribute("nonce",n.inlineStyleNonce);else if(/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l))f=r.createElement("img"),f.src=c;else if(f=r.createElement("script"),f.src=c,f.async=s===void 0?!0:s,n.inlineScriptNonce&&f.setAttribute("nonce",n.inlineScriptNonce),d="noModule"in f,/^module!/.test(l)){if(!d)return t(e,"l");f.type="module"}else if(/^nomodule!/.test(l)&&d)return t(e,"l");const v=function(x){pl(x,e,f,t,n,i,o,u)};f.addEventListener("load",v,{once:!0}),f.addEventListener("error",v,{once:!0}),a(e,f)!==!1&&r.head.appendChild(f)}function ml(e,t,n){e=Array.isArray(e)?e:[e];let i=e.length,r=[];function s(o,a,l){if(a==="e"&&r.push(o),a==="b")if(l)r.push(o);else return;i--,i||t(r)}for(let o=0;o<e.length;o++)Pr(e[o],s,n)}function re(e,t,n){let i,r;if(t&&typeof t=="string"&&t.trim&&(i=t.trim()),r=(i?n:t)||{},i){if(i in Ye)throw"LoadJS";Ye[i]=!0}function s(o,a){ml(e,function(l){On(r,l),o&&On({success:o,error:a},l),Mr(i,l)},r)}if(r.returnPromise)return new Promise(s);s()}re.ready=function(t,n){return hl(t,function(i){On(n,i)}),re},re.done=function(t){Mr(t,[])},re.reset=function(){Object.keys(Ye).forEach(t=>delete Ye[t]),Object.keys(_t).forEach(t=>delete _t[t]),Object.keys(Ke).forEach(t=>delete Ke[t])},re.isDefined=function(t){return t in Ye};function gl(e){if(typeof Alpine>"u"||typeof Alpine.$data!="function"){console.error("Rizzy.$data: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and started before calling $data.");return}if(e instanceof Element){const t=vl(e)||e;let n=Alpine.$data(t);if(n===void 0){const i=t.closest?.("[x-data]");i&&(n=Alpine.$data(i))}return n===void 0&&Br("element",t),n}if(typeof e=="string"){const t=e.trim();if(!t){console.warn("Rizzy.$data: Invalid componentId provided (empty string).");return}const n=`[data-alpine-root="${Fr(t)}"]`;let i=null;const r=document.getElementById(t);if(r&&(i=r.matches(n)?r:r.querySelector(n)),i||(i=zr(t)),!i){console.warn(`Rizzy.$data: Could not locate an Alpine root using ${n} locally or globally. Verify that the teleported root rendered and that 'data-alpine-root="${t}"' is present.`);return}const s=Alpine.$data(i);return s===void 0&&Br(`data-alpine-root="${t}"`,i),s}console.warn("Rizzy.$data: Expected a non-empty string id or an Element.")}function vl(e){if(!(e instanceof Element))return null;const t=e.tagName?.toLowerCase?.()==="rz-proxy",n=e.getAttribute?.("data-for");if(t||n){const i=n||"";if(!i)return e;const r=zr(i);return r||(console.warn(`Rizzy.$data: Proxy element could not resolve Alpine root for id "${i}". Ensure the teleported root rendered with data-alpine-root="${i}".`),null)}return e}function zr(e){const t=`[data-alpine-root="${Fr(e)}"]`,n=document.querySelectorAll(t);for(const i of n)if(i.hasAttribute("x-data"))return i;return n.length>0?n[0]:document.getElementById(e)||null}function Fr(e){try{if(window.CSS&&typeof window.CSS.escape=="function")return window.CSS.escape(e)}catch{}return String(e).replace(/"/g,'\\"')}function Br(e,t){const n=`${t.tagName?.toLowerCase?.()||"node"}${t.id?"#"+t.id:""}${t.classList?.length?"."+Array.from(t.classList).join("."):""}`;console.warn(`Rizzy.$data: Located target via ${e} (${n}), but Alpine.$data returned undefined. Ensure this element (or its nearest [x-data] ancestor) has an initialized Alpine component.`)}function bl(e){e.data("rzAccordion",()=>({selected:"",allowMultiple:!1,init(){this.allowMultiple=this.$el.dataset.multiple==="true"},destroy(){}}))}function yl(e){e.data("accordionItem",()=>({open:!1,sectionId:"",expandedClass:"",init(){this.open=this.$el.dataset.isOpen==="true",this.sectionId=this.$el.dataset.sectionId,this.expandedClass=this.$el.dataset.expandedClass;const t=this;typeof this.selected<"u"&&typeof this.allowMultiple<"u"?this.$watch("selected",(n,i)=>{n!==t.sectionId&&!t.allowMultiple&&(t.open=!1)}):console.warn("accordionItem: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.")},destroy(){},toggle(){this.selected=this.sectionId,this.open=!this.open},getExpandedCss(){return this.open?this.expandedClass:""},getAriaExpanded(){return this.open?"true":"false"}}))}function wl(e){e.data("rzAlert",()=>({parentElement:null,showAlert:!0,init(){const t=this.$el.dataset.alpineRoot||this.$el.closest("[data-alpine-root]");this.parentElement=document.getElementById(t)},dismiss(){this.showAlert=!1;const t=this;setTimeout(()=>{t.parentElement.style.display="none"},205)}}))}function _l(e){e.data("rzAspectRatio",()=>({init(){const t=parseFloat(this.$el.dataset.ratio);if(!isNaN(t)&&t>0){const n=100/t+"%";this.$el.style.paddingBottom=n}else this.$el.style.paddingBottom="100%"}}))}function xl(e){e.data("rzBrowser",()=>({screenSize:"",setDesktopScreenSize(){this.screenSize=""},setTabletScreenSize(){this.screenSize="max-w-2xl"},setPhoneScreenSize(){this.screenSize="max-w-sm"},getBrowserBorderCss(){return[this.screenSize,this.screenSize===""?"border-none":"border-x"]},getDesktopScreenCss(){return[this.screenSize===""?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getTabletScreenCss(){return[this.screenSize==="max-w-2xl"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getPhoneScreenCss(){return[this.screenSize==="max-w-sm"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]}}))}function El(e,t){e.data("rzCalendar",()=>({calendar:null,initialized:!1,init(){const n=JSON.parse(this.$el.dataset.assets||"[]"),i=this.$el.dataset.configId,r=this.$el.dataset.nonce;if(n.length===0){console.warn("RzCalendar: No assets configured.");return}t(n,{success:()=>{this.initCalendar(i)},error:s=>console.error("RzCalendar: Failed to load assets",s)},r)},initCalendar(n){const i=document.getElementById(n);if(!i){console.error(`RzCalendar: Config element #${n} not found.`);return}let r={};try{r=JSON.parse(i.textContent)}catch(a){console.error("RzCalendar: Failed to parse config JSON",a);return}const s={clickDay:(a,l)=>this.dispatchCalendarEvent("clickDay",{event:a,dates:l.selectedDates}),clickWeekNumber:(a,l,c,u)=>this.dispatchCalendarEvent("clickWeekNumber",{event:a,number:l,days:c,year:u}),clickMonth:(a,l)=>this.dispatchCalendarEvent("clickMonth",{event:a,month:l}),clickYear:(a,l)=>this.dispatchCalendarEvent("clickYear",{event:a,year:l}),clickArrow:(a,l,c)=>this.dispatchCalendarEvent("clickArrow",{event:a,year:l,month:c}),changeTime:(a,l,c,u,d)=>this.dispatchCalendarEvent("changeTime",{event:a,time:l,hours:c,minutes:u,keeping:d}),changeView:a=>this.dispatchCalendarEvent("changeView",{view:a}),getDays:(a,l,c,u,d)=>{}},o={...r.options,styles:r.styles,actions:s};window.VanillaCalendarPro?(this.calendar=new VanillaCalendarPro.Calendar(this.$refs.calendarEl,o),this.calendar.init(),this.initialized=!0,this.dispatchCalendarEvent("init",{instance:this.calendar})):console.error("RzCalendar: VanillaCalendar global not found.")},dispatchCalendarEvent(n,i){this.$dispatch(`rz:calendar:${n}`,i)},destroy(){this.calendar&&(this.calendar.destroy(),this.dispatchCalendarEvent("destroy",{}))}}))}function Il(e,t){function n(i){if(!i)return{};const r=document.getElementById(i);if(!r)return console.warn(`[rzCarousel] JSON script element #${i} not found.`),{};try{return JSON.parse(r.textContent||"{}")}catch(s){return console.error(`[rzCarousel] Failed to parse JSON from #${i}:`,s),{}}}e.data("rzCarousel",()=>({emblaApi:null,canScrollPrev:!1,canScrollNext:!1,selectedIndex:0,scrollSnaps:[],init(){const i=(()=>{try{return JSON.parse(this.$el.dataset.assets||"[]")}catch(c){return console.error("[rzCarousel] Bad assets JSON:",c),[]}})(),r=this.$el.dataset.nonce||"",s=n(this.$el.dataset.config),o=s.Options||{},a=s.Plugins||[],l=this;i.length>0&&typeof t=="function"?t(i,{success(){window.EmblaCarousel?l.initializeEmbla(o,a):console.error("[rzCarousel] EmblaCarousel not found on window after loading assets.")},error(c){console.error("[rzCarousel] Failed to load EmblaCarousel assets.",c)}},r):window.EmblaCarousel?this.initializeEmbla(o,a):console.error("[rzCarousel] EmblaCarousel not found and no assets specified for loading.")},initializeEmbla(i,r){const s=this.$el.querySelector('[x-ref="viewport"]');if(!s){console.error('[rzCarousel] Carousel viewport with x-ref="viewport" not found.');return}const o=this.instantiatePlugins(r);this.emblaApi=window.EmblaCarousel(s,i,o),this.emblaApi.on("select",this.onSelect.bind(this)),this.emblaApi.on("reInit",this.onSelect.bind(this)),this.onSelect()},instantiatePlugins(i){return!Array.isArray(i)||i.length===0?[]:i.map(r=>{const s=window[r.Name];if(typeof s!="function")return console.error(`[rzCarousel] Plugin constructor '${r.Name}' not found on window object.`),null;try{return s(r.Options||{})}catch(o){return console.error(`[rzCarousel] Error instantiating plugin '${r.Name}':`,o),null}}).filter(Boolean)},destroy(){this.emblaApi&&this.emblaApi.destroy()},onSelect(){this.emblaApi&&(this.selectedIndex=this.emblaApi.selectedScrollSnap(),this.canScrollPrev=this.emblaApi.canScrollPrev(),this.canScrollNext=this.emblaApi.canScrollNext(),this.scrollSnaps=this.emblaApi.scrollSnapList())},cannotScrollPrev(){return!this.canScrollPrev},cannotScrollNext(){return!this.canScrollNext},scrollPrev(){this.emblaApi?.scrollPrev()},scrollNext(){this.emblaApi?.scrollNext()},scrollTo(i){this.emblaApi?.scrollTo(i)}}))}function Sl(e,t){e.data("rzCodeViewer",()=>({expand:!1,border:!0,copied:!1,copyTitle:"Copy",copiedTitle:"Copied!",init(){const n=JSON.parse(this.$el.dataset.assets),i=this.$el.dataset.codeid,r=this.$el.dataset.nonce;this.copyTitle=this.$el.dataset.copyTitle||this.copyTitle,this.copiedTitle=this.$el.dataset.copiedTitle||this.copiedTitle,t(n,{success:function(){const s=document.getElementById(i);window.hljs&&s&&window.hljs.highlightElement(s)},error:function(){console.error("Failed to load Highlight.js")}},r)},notCopied(){return!this.copied},disableCopied(){this.copied=!1},toggleExpand(){this.expand=!this.expand},copyHTML(){navigator.clipboard.writeText(this.$refs.codeBlock.textContent),this.copied=!this.copied},getCopiedTitle(){return this.copied?this.copiedTitle:this.copyTitle},getCopiedCss(){return[this.copied?"focus-visible:outline-success":"focus-visible:outline-foreground"]},getExpandCss(){return[this.expand?"":"max-h-60"]},getExpandButtonCss(){return this.expand?"rotate-180":"rotate-0"}}))}function Cl(e){e.data("rzCollapsible",()=>({isOpen:!1,init(){this.isOpen=this.$el.dataset.defaultOpen==="true"},toggle(){this.isOpen=!this.isOpen},state(){return this.isOpen?"open":"closed"}}))}function Tl(e,t){e.data("rzCombobox",()=>({tomSelect:null,init(){const n=JSON.parse(this.$el.dataset.assets||"[]"),i=this.$el.dataset.nonce;n.length>0&&typeof t=="function"?t(n,{success:()=>this.initTomSelect(),error:r=>console.error("RzCombobox: Failed to load assets.",r)},i):window.TomSelect&&this.initTomSelect()},initTomSelect(){const n=this.$refs.selectInput;if(!n)return;const i=document.getElementById(this.$el.dataset.configId),r=i?JSON.parse(i.textContent):{},s={},o=(a,l)=>{if(!a)return null;const c=document.createElement("div");let u=l.item;if(typeof u=="string")try{u=JSON.parse(u)}catch{}const d={...l,item:u};return e&&typeof e.addScopeToNode=="function"?e.addScopeToNode(c,d):c._x_dataStack=[d],c.innerHTML=a.innerHTML,c};this.$refs.optionTemplate&&(s.option=(a,l)=>o(this.$refs.optionTemplate,a)),this.$refs.itemTemplate&&(s.item=(a,l)=>o(this.$refs.itemTemplate,a)),r.dataAttr="data-item",this.tomSelect=new TomSelect(n,{...r,render:s,onInitialize:function(){this.sync()}})},destroy(){this.tomSelect&&(this.tomSelect.destroy(),this.tomSelect=null)}}))}function Al(e,t){e.data("rzDateEdit",()=>({options:{},placeholder:"",prependText:"",init(){const n=this.$el.dataset.config,i=document.getElementById(this.$el.dataset.uid+"-input");if(n){const o=JSON.parse(n);o&&(this.options=o.options||{},this.placeholder=o.placeholder||"",this.prependText=o.prependText||"")}const r=JSON.parse(this.$el.dataset.assets),s=this.$el.dataset.nonce;t(r,{success:function(){window.flatpickr&&i&&window.flatpickr(i,this.options)},error:function(){console.error("Failed to load Flatpickr assets.")}},s)}}))}function Ol(e){e.data("rzDialog",()=>({modalOpen:!1,eventTriggerName:"",closeEventName:"rz:modal-close",closeOnEscape:!0,closeOnClickOutside:!0,modalId:"",bodyId:"",footerId:"",nonce:"",_escapeListener:null,_openListener:null,_closeEventListener:null,init(){this.modalId=this.$el.dataset.modalId||"",this.bodyId=this.$el.dataset.bodyId||"",this.footerId=this.$el.dataset.footerId||"",this.nonce=this.$el.dataset.nonce||"",this.eventTriggerName=this.$el.dataset.eventTriggerName||"",this.closeEventName=this.$el.dataset.closeEventName||this.closeEventName,this.closeOnEscape=this.$el.dataset.closeOnEscape!=="false",this.closeOnClickOutside=this.$el.dataset.closeOnClickOutside!=="false",this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized",{detail:{modalId:this.modalId,bodyId:this.bodyId,footerId:this.footerId},bubbles:!0})),this.eventTriggerName&&(this._openListener=t=>{this.openModal(t)},window.addEventListener(this.eventTriggerName,this._openListener)),this._closeEventListener=t=>{this.modalOpen&&this.closeModalInternally("event")},window.addEventListener(this.closeEventName,this._closeEventListener),this._escapeListener=t=>{this.modalOpen&&this.closeOnEscape&&t.key==="Escape"&&this.closeModalInternally("escape")},window.addEventListener("keydown",this._escapeListener),this.$watch("modalOpen",t=>{const n=document.body.offsetWidth;document.body.classList.toggle("overflow-hidden",t);const i=document.body.offsetWidth-n;document.body.style.setProperty("--page-scrollbar-width",`${i}px`),t?this.$nextTick(()=>{this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(),this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open",{detail:{modalId:this.modalId},bubbles:!0}))}):this.$nextTick(()=>{this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close",{detail:{modalId:this.modalId},bubbles:!0}))})})},notModalOpen(){return!this.modalOpen},destroy(){this._openListener&&this.eventTriggerName&&window.removeEventListener(this.eventTriggerName,this._openListener),this._closeEventListener&&window.removeEventListener(this.closeEventName,this._closeEventListener),this._escapeListener&&window.removeEventListener("keydown",this._escapeListener),document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px")},openModal(t=null){const n=new CustomEvent("rz:modal-before-open",{detail:{modalId:this.modalId,originalEvent:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(n),n.defaultPrevented||(this.modalOpen=!0)},closeModalInternally(t="unknown"){const n=new CustomEvent("rz:modal-before-close",{detail:{modalId:this.modalId,reason:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(n),n.defaultPrevented||(document.activeElement?.blur&&document.activeElement.blur(),this.modalOpen=!1,document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px"))},closeModal(){this.closeModalInternally("button")},handleClickOutside(){this.closeOnClickOutside&&this.closeModalInternally("backdrop")}}))}const $n=Math.min,Oe=Math.max,xt=Math.round,U=e=>({x:e,y:e}),$l={left:"right",right:"left",bottom:"top",top:"bottom"},Nl={start:"end",end:"start"};function jr(e,t,n){return Oe(e,$n(t,n))}function Et(e,t){return typeof e=="function"?e(t):e}function be(e){return e.split("-")[0]}function It(e){return e.split("-")[1]}function Vr(e){return e==="x"?"y":"x"}function Hr(e){return e==="y"?"height":"width"}function ye(e){return["top","bottom"].includes(be(e))?"y":"x"}function Wr(e){return Vr(ye(e))}function Rl(e,t,n){n===void 0&&(n=!1);const i=It(e),r=Wr(e),s=Hr(r);let o=r==="x"?i===(n?"end":"start")?"right":"left":i==="start"?"bottom":"top";return t.reference[s]>t.floating[s]&&(o=St(o)),[o,St(o)]}function kl(e){const t=St(e);return[Nn(e),t,Nn(t)]}function Nn(e){return e.replace(/start|end/g,t=>Nl[t])}function Ll(e,t,n){const i=["left","right"],r=["right","left"],s=["top","bottom"],o=["bottom","top"];switch(e){case"top":case"bottom":return n?t?r:i:t?i:r;case"left":case"right":return t?s:o;default:return[]}}function Dl(e,t,n,i){const r=It(e);let s=Ll(be(e),n==="start",i);return r&&(s=s.map(o=>o+"-"+r),t&&(s=s.concat(s.map(Nn)))),s}function St(e){return e.replace(/left|right|bottom|top/g,t=>$l[t])}function Ml(e){return{top:0,right:0,bottom:0,left:0,...e}}function Pl(e){return typeof e!="number"?Ml(e):{top:e,right:e,bottom:e,left:e}}function Ct(e){const{x:t,y:n,width:i,height:r}=e;return{width:i,height:r,top:n,left:t,right:t+i,bottom:n+r,x:t,y:n}}function qr(e,t,n){let{reference:i,floating:r}=e;const s=ye(t),o=Wr(t),a=Hr(o),l=be(t),c=s==="y",u=i.x+i.width/2-r.width/2,d=i.y+i.height/2-r.height/2,f=i[a]/2-r[a]/2;let v;switch(l){case"top":v={x:u,y:i.y-r.height};break;case"bottom":v={x:u,y:i.y+i.height};break;case"right":v={x:i.x+i.width,y:d};break;case"left":v={x:i.x-r.width,y:d};break;default:v={x:i.x,y:i.y}}switch(It(t)){case"start":v[o]-=f*(n&&c?-1:1);break;case"end":v[o]+=f*(n&&c?-1:1);break}return v}const zl=async(e,t,n)=>{const{placement:i="bottom",strategy:r="absolute",middleware:s=[],platform:o}=n,a=s.filter(Boolean),l=await(o.isRTL==null?void 0:o.isRTL(t));let c=await o.getElementRects({reference:e,floating:t,strategy:r}),{x:u,y:d}=qr(c,i,l),f=i,v={},x=0;for(let w=0;w<a.length;w++){const{name:p,fn:g}=a[w],{x:h,y,data:E,reset:_}=await g({x:u,y:d,initialPlacement:i,placement:f,strategy:r,middlewareData:v,rects:c,platform:o,elements:{reference:e,floating:t}});u=h??u,d=y??d,v={...v,[p]:{...v[p],...E}},_&&x<=50&&(x++,typeof _=="object"&&(_.placement&&(f=_.placement),_.rects&&(c=_.rects===!0?await o.getElementRects({reference:e,floating:t,strategy:r}):_.rects),{x:u,y:d}=qr(c,f,l)),w=-1)}return{x:u,y:d,placement:f,strategy:r,middlewareData:v}};async function Ur(e,t){var n;t===void 0&&(t={});const{x:i,y:r,platform:s,rects:o,elements:a,strategy:l}=e,{boundary:c="clippingAncestors",rootBoundary:u="viewport",elementContext:d="floating",altBoundary:f=!1,padding:v=0}=Et(t,e),x=Pl(v),p=a[f?d==="floating"?"reference":"floating":d],g=Ct(await s.getClippingRect({element:(n=await(s.isElement==null?void 0:s.isElement(p)))==null||n?p:p.contextElement||await(s.getDocumentElement==null?void 0:s.getDocumentElement(a.floating)),boundary:c,rootBoundary:u,strategy:l})),h=d==="floating"?{x:i,y:r,width:o.floating.width,height:o.floating.height}:o.reference,y=await(s.getOffsetParent==null?void 0:s.getOffsetParent(a.floating)),E=await(s.isElement==null?void 0:s.isElement(y))?await(s.getScale==null?void 0:s.getScale(y))||{x:1,y:1}:{x:1,y:1},_=Ct(s.convertOffsetParentRelativeRectToViewportRelativeRect?await s.convertOffsetParentRelativeRectToViewportRelativeRect({elements:a,rect:h,offsetParent:y,strategy:l}):h);return{top:(g.top-_.top+x.top)/E.y,bottom:(_.bottom-g.bottom+x.bottom)/E.y,left:(g.left-_.left+x.left)/E.x,right:(_.right-g.right+x.right)/E.x}}const Fl=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(t){var n,i;const{placement:r,middlewareData:s,rects:o,initialPlacement:a,platform:l,elements:c}=t,{mainAxis:u=!0,crossAxis:d=!0,fallbackPlacements:f,fallbackStrategy:v="bestFit",fallbackAxisSideDirection:x="none",flipAlignment:w=!0,...p}=Et(e,t);if((n=s.arrow)!=null&&n.alignmentOffset)return{};const g=be(r),h=ye(a),y=be(a)===a,E=await(l.isRTL==null?void 0:l.isRTL(c.floating)),_=f||(y||!w?[St(a)]:kl(a)),m=x!=="none";!f&&m&&_.push(...Dl(a,w,x,E));const b=[a,..._],I=await Ur(t,p),S=[];let C=((i=s.flip)==null?void 0:i.overflows)||[];if(u&&S.push(I[g]),d){const z=Rl(r,o,E);S.push(I[z[0]],I[z[1]])}if(C=[...C,{placement:r,overflows:S}],!S.every(z=>z<=0)){var T,L;const z=(((T=s.flip)==null?void 0:T.index)||0)+1,_e=b[z];if(_e){var D;const F=d==="alignment"?h!==ye(_e):!1,J=((D=C[0])==null?void 0:D.overflows[0])>0;if(!F||J)return{data:{index:z,overflows:C},reset:{placement:_e}}}let W=(L=C.filter(F=>F.overflows[0]<=0).sort((F,J)=>F.overflows[1]-J.overflows[1])[0])==null?void 0:L.placement;if(!W)switch(v){case"bestFit":{var K;const F=(K=C.filter(J=>{if(m){const oe=ye(J.placement);return oe===h||oe==="y"}return!0}).map(J=>[J.placement,J.overflows.filter(oe=>oe>0).reduce((oe,Mc)=>oe+Mc,0)]).sort((J,oe)=>J[1]-oe[1])[0])==null?void 0:K[0];F&&(W=F);break}case"initialPlacement":W=a;break}if(r!==W)return{reset:{placement:W}}}return{}}}};async function Bl(e,t){const{placement:n,platform:i,elements:r}=e,s=await(i.isRTL==null?void 0:i.isRTL(r.floating)),o=be(n),a=It(n),l=ye(n)==="y",c=["left","top"].includes(o)?-1:1,u=s&&l?-1:1,d=Et(t,e);let{mainAxis:f,crossAxis:v,alignmentAxis:x}=typeof d=="number"?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:d.mainAxis||0,crossAxis:d.crossAxis||0,alignmentAxis:d.alignmentAxis};return a&&typeof x=="number"&&(v=a==="end"?x*-1:x),l?{x:v*u,y:f*c}:{x:f*c,y:v*u}}const jl=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(t){var n,i;const{x:r,y:s,placement:o,middlewareData:a}=t,l=await Bl(t,e);return o===((n=a.offset)==null?void 0:n.placement)&&(i=a.arrow)!=null&&i.alignmentOffset?{}:{x:r+l.x,y:s+l.y,data:{...l,placement:o}}}}},Vl=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:i,placement:r}=t,{mainAxis:s=!0,crossAxis:o=!1,limiter:a={fn:p=>{let{x:g,y:h}=p;return{x:g,y:h}}},...l}=Et(e,t),c={x:n,y:i},u=await Ur(t,l),d=ye(be(r)),f=Vr(d);let v=c[f],x=c[d];if(s){const p=f==="y"?"top":"left",g=f==="y"?"bottom":"right",h=v+u[p],y=v-u[g];v=jr(h,v,y)}if(o){const p=d==="y"?"top":"left",g=d==="y"?"bottom":"right",h=x+u[p],y=x-u[g];x=jr(h,x,y)}const w=a.fn({...t,[f]:v,[d]:x});return{...w,data:{x:w.x-n,y:w.y-i,enabled:{[f]:s,[d]:o}}}}}};function Tt(){return typeof window<"u"}function $e(e){return Yr(e)?(e.nodeName||"").toLowerCase():"#document"}function M(e){var t;return(e==null||(t=e.ownerDocument)==null?void 0:t.defaultView)||window}function X(e){var t;return(t=(Yr(e)?e.ownerDocument:e.document)||window.document)==null?void 0:t.documentElement}function Yr(e){return Tt()?e instanceof Node||e instanceof M(e).Node:!1}function V(e){return Tt()?e instanceof Element||e instanceof M(e).Element:!1}function Y(e){return Tt()?e instanceof HTMLElement||e instanceof M(e).HTMLElement:!1}function Kr(e){return!Tt()||typeof ShadowRoot>"u"?!1:e instanceof ShadowRoot||e instanceof M(e).ShadowRoot}function Je(e){const{overflow:t,overflowX:n,overflowY:i,display:r}=H(e);return/auto|scroll|overlay|hidden|clip/.test(t+i+n)&&!["inline","contents"].includes(r)}function Hl(e){return["table","td","th"].includes($e(e))}function At(e){return[":popover-open",":modal"].some(t=>{try{return e.matches(t)}catch{return!1}})}function Rn(e){const t=kn(),n=V(e)?H(e):e;return["transform","translate","scale","rotate","perspective"].some(i=>n[i]?n[i]!=="none":!1)||(n.containerType?n.containerType!=="normal":!1)||!t&&(n.backdropFilter?n.backdropFilter!=="none":!1)||!t&&(n.filter?n.filter!=="none":!1)||["transform","translate","scale","rotate","perspective","filter"].some(i=>(n.willChange||"").includes(i))||["paint","layout","strict","content"].some(i=>(n.contain||"").includes(i))}function Wl(e){let t=se(e);for(;Y(t)&&!Ne(t);){if(Rn(t))return t;if(At(t))return null;t=se(t)}return null}function kn(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function Ne(e){return["html","body","#document"].includes($e(e))}function H(e){return M(e).getComputedStyle(e)}function Ot(e){return V(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.scrollX,scrollTop:e.scrollY}}function se(e){if($e(e)==="html")return e;const t=e.assignedSlot||e.parentNode||Kr(e)&&e.host||X(e);return Kr(t)?t.host:t}function Jr(e){const t=se(e);return Ne(t)?e.ownerDocument?e.ownerDocument.body:e.body:Y(t)&&Je(t)?t:Jr(t)}function Gr(e,t,n){var i;t===void 0&&(t=[]);const r=Jr(e),s=r===((i=e.ownerDocument)==null?void 0:i.body),o=M(r);return s?(Ln(o),t.concat(o,o.visualViewport||[],Je(r)?r:[],[])):t.concat(r,Gr(r,[]))}function Ln(e){return e.parent&&Object.getPrototypeOf(e.parent)?e.frameElement:null}function Zr(e){const t=H(e);let n=parseFloat(t.width)||0,i=parseFloat(t.height)||0;const r=Y(e),s=r?e.offsetWidth:n,o=r?e.offsetHeight:i,a=xt(n)!==s||xt(i)!==o;return a&&(n=s,i=o),{width:n,height:i,$:a}}function Xr(e){return V(e)?e:e.contextElement}function Re(e){const t=Xr(e);if(!Y(t))return U(1);const n=t.getBoundingClientRect(),{width:i,height:r,$:s}=Zr(t);let o=(s?xt(n.width):n.width)/i,a=(s?xt(n.height):n.height)/r;return(!o||!Number.isFinite(o))&&(o=1),(!a||!Number.isFinite(a))&&(a=1),{x:o,y:a}}const ql=U(0);function Qr(e){const t=M(e);return!kn()||!t.visualViewport?ql:{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}}function Ul(e,t,n){return t===void 0&&(t=!1),!n||t&&n!==M(e)?!1:t}function Ge(e,t,n,i){t===void 0&&(t=!1),n===void 0&&(n=!1);const r=e.getBoundingClientRect(),s=Xr(e);let o=U(1);t&&(i?V(i)&&(o=Re(i)):o=Re(e));const a=Ul(s,n,i)?Qr(s):U(0);let l=(r.left+a.x)/o.x,c=(r.top+a.y)/o.y,u=r.width/o.x,d=r.height/o.y;if(s){const f=M(s),v=i&&V(i)?M(i):i;let x=f,w=Ln(x);for(;w&&i&&v!==x;){const p=Re(w),g=w.getBoundingClientRect(),h=H(w),y=g.left+(w.clientLeft+parseFloat(h.paddingLeft))*p.x,E=g.top+(w.clientTop+parseFloat(h.paddingTop))*p.y;l*=p.x,c*=p.y,u*=p.x,d*=p.y,l+=y,c+=E,x=M(w),w=Ln(x)}}return Ct({width:u,height:d,x:l,y:c})}function Dn(e,t){const n=Ot(e).scrollLeft;return t?t.left+n:Ge(X(e)).left+n}function es(e,t,n){n===void 0&&(n=!1);const i=e.getBoundingClientRect(),r=i.left+t.scrollLeft-(n?0:Dn(e,i)),s=i.top+t.scrollTop;return{x:r,y:s}}function Yl(e){let{elements:t,rect:n,offsetParent:i,strategy:r}=e;const s=r==="fixed",o=X(i),a=t?At(t.floating):!1;if(i===o||a&&s)return n;let l={scrollLeft:0,scrollTop:0},c=U(1);const u=U(0),d=Y(i);if((d||!d&&!s)&&(($e(i)!=="body"||Je(o))&&(l=Ot(i)),Y(i))){const v=Ge(i);c=Re(i),u.x=v.x+i.clientLeft,u.y=v.y+i.clientTop}const f=o&&!d&&!s?es(o,l,!0):U(0);return{width:n.width*c.x,height:n.height*c.y,x:n.x*c.x-l.scrollLeft*c.x+u.x+f.x,y:n.y*c.y-l.scrollTop*c.y+u.y+f.y}}function Kl(e){return Array.from(e.getClientRects())}function Jl(e){const t=X(e),n=Ot(e),i=e.ownerDocument.body,r=Oe(t.scrollWidth,t.clientWidth,i.scrollWidth,i.clientWidth),s=Oe(t.scrollHeight,t.clientHeight,i.scrollHeight,i.clientHeight);let o=-n.scrollLeft+Dn(e);const a=-n.scrollTop;return H(i).direction==="rtl"&&(o+=Oe(t.clientWidth,i.clientWidth)-r),{width:r,height:s,x:o,y:a}}function Gl(e,t){const n=M(e),i=X(e),r=n.visualViewport;let s=i.clientWidth,o=i.clientHeight,a=0,l=0;if(r){s=r.width,o=r.height;const c=kn();(!c||c&&t==="fixed")&&(a=r.offsetLeft,l=r.offsetTop)}return{width:s,height:o,x:a,y:l}}function Zl(e,t){const n=Ge(e,!0,t==="fixed"),i=n.top+e.clientTop,r=n.left+e.clientLeft,s=Y(e)?Re(e):U(1),o=e.clientWidth*s.x,a=e.clientHeight*s.y,l=r*s.x,c=i*s.y;return{width:o,height:a,x:l,y:c}}function ts(e,t,n){let i;if(t==="viewport")i=Gl(e,n);else if(t==="document")i=Jl(X(e));else if(V(t))i=Zl(t,n);else{const r=Qr(e);i={x:t.x-r.x,y:t.y-r.y,width:t.width,height:t.height}}return Ct(i)}function ns(e,t){const n=se(e);return n===t||!V(n)||Ne(n)?!1:H(n).position==="fixed"||ns(n,t)}function Xl(e,t){const n=t.get(e);if(n)return n;let i=Gr(e,[]).filter(a=>V(a)&&$e(a)!=="body"),r=null;const s=H(e).position==="fixed";let o=s?se(e):e;for(;V(o)&&!Ne(o);){const a=H(o),l=Rn(o);!l&&a.position==="fixed"&&(r=null),(s?!l&&!r:!l&&a.position==="static"&&!!r&&["absolute","fixed"].includes(r.position)||Je(o)&&!l&&ns(e,o))?i=i.filter(u=>u!==o):r=a,o=se(o)}return t.set(e,i),i}function Ql(e){let{element:t,boundary:n,rootBoundary:i,strategy:r}=e;const o=[...n==="clippingAncestors"?At(t)?[]:Xl(t,this._c):[].concat(n),i],a=o[0],l=o.reduce((c,u)=>{const d=ts(t,u,r);return c.top=Oe(d.top,c.top),c.right=$n(d.right,c.right),c.bottom=$n(d.bottom,c.bottom),c.left=Oe(d.left,c.left),c},ts(t,a,r));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function ec(e){const{width:t,height:n}=Zr(e);return{width:t,height:n}}function tc(e,t,n){const i=Y(t),r=X(t),s=n==="fixed",o=Ge(e,!0,s,t);let a={scrollLeft:0,scrollTop:0};const l=U(0);function c(){l.x=Dn(r)}if(i||!i&&!s)if(($e(t)!=="body"||Je(r))&&(a=Ot(t)),i){const v=Ge(t,!0,s,t);l.x=v.x+t.clientLeft,l.y=v.y+t.clientTop}else r&&c();s&&!i&&r&&c();const u=r&&!i&&!s?es(r,a):U(0),d=o.left+a.scrollLeft-l.x-u.x,f=o.top+a.scrollTop-l.y-u.y;return{x:d,y:f,width:o.width,height:o.height}}function Mn(e){return H(e).position==="static"}function is(e,t){if(!Y(e)||H(e).position==="fixed")return null;if(t)return t(e);let n=e.offsetParent;return X(e)===n&&(n=n.ownerDocument.body),n}function rs(e,t){const n=M(e);if(At(e))return n;if(!Y(e)){let r=se(e);for(;r&&!Ne(r);){if(V(r)&&!Mn(r))return r;r=se(r)}return n}let i=is(e,t);for(;i&&Hl(i)&&Mn(i);)i=is(i,t);return i&&Ne(i)&&Mn(i)&&!Rn(i)?n:i||Wl(e)||n}const nc=async function(e){const t=this.getOffsetParent||rs,n=this.getDimensions,i=await n(e.floating);return{reference:tc(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,width:i.width,height:i.height}}};function ic(e){return H(e).direction==="rtl"}const rc={convertOffsetParentRelativeRectToViewportRelativeRect:Yl,getDocumentElement:X,getClippingRect:Ql,getOffsetParent:rs,getElementRects:nc,getClientRects:Kl,getDimensions:ec,getScale:Re,isElement:V,isRTL:ic},$t=jl,Nt=Vl,Rt=Fl,kt=(e,t,n)=>{const i=new Map,r={platform:rc,...n},s={...r.platform,_c:i};return zl(e,t,{...r,platform:s})};function sc(e){e.data("rzDropdownMenu",()=>({open:!1,isModal:!0,ariaExpanded:"false",trapActive:!1,focusedIndex:null,menuItems:[],parentEl:null,triggerEl:null,contentEl:null,anchor:"bottom",pixelOffset:3,isSubmenuActive:!1,navThrottle:100,_lastNavAt:0,selfId:null,init(){this.$el.id||(this.$el.id=crypto.randomUUID()),this.selfId=this.$el.id,this.parentEl=this.$el,this.triggerEl=this.$refs.trigger,this.anchor=this.$el.dataset.anchor||"bottom",this.pixelOffset=parseInt(this.$el.dataset.offset)||6,this.isModal=this.$el.dataset.modal!=="false",this.$watch("open",t=>{t?(this._lastNavAt=0,this.$nextTick(()=>{this.contentEl=document.getElementById(`${this.selfId}-content`),this.contentEl&&(this.updatePosition(),this.menuItems=Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled],[aria-disabled="true"])')))}),this.ariaExpanded="true",this.triggerEl.dataset.state="open",this.trapActive=this.isModal):(this.focusedIndex=null,this.closeAllSubmenus(),this.ariaExpanded="false",delete this.triggerEl.dataset.state,this.trapActive=!1,this.contentEl=null)})},updatePosition(){!this.triggerEl||!this.contentEl||(this.contentEl.style.setProperty("--rizzy-dropdown-trigger-width",`${this.triggerEl.offsetWidth}px`),kt(this.triggerEl,this.contentEl,{placement:this.anchor,middleware:[$t(this.pixelOffset),Rt(),Nt({padding:8})]}).then(({x:t,y:n})=>{Object.assign(this.contentEl.style,{left:`${t}px`,top:`${n}px`})}))},toggle(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}else this.open=!0,this.focusedIndex=-1},handleOutsideClick(){if(!this.open)return;this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())},handleTriggerKeydown(t){["Enter"," ","ArrowDown","ArrowUp"].includes(t.key)&&(t.preventDefault(),this.open=!0,this.$nextTick(()=>{t.key==="ArrowUp"?this.focusLastItem():this.focusFirstItem()}))},focusNextItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex>=this.menuItems.length-1?0:this.focusedIndex+1,this.focusCurrentItem()))},focusPreviousItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex<=0?this.menuItems.length-1:this.focusedIndex-1,this.focusCurrentItem()))},focusFirstItem(){this.menuItems.length&&(this.focusedIndex=0,this.focusCurrentItem())},focusLastItem(){this.menuItems.length&&(this.focusedIndex=this.menuItems.length-1,this.focusCurrentItem())},focusCurrentItem(){this.focusedIndex!==null&&this.menuItems[this.focusedIndex]&&this.$nextTick(()=>this.menuItems[this.focusedIndex].focus())},focusSelectedItem(t){if(!t||t.getAttribute("aria-disabled")==="true"||t.hasAttribute("disabled"))return;const n=this.menuItems.indexOf(t);n!==-1&&(this.focusedIndex=n,t.focus())},handleItemClick(t){const n=t.currentTarget;if(n.getAttribute("aria-disabled")==="true"||n.hasAttribute("disabled"))return;if(n.getAttribute("aria-haspopup")==="menu"){e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();return}this.open=!1;let i=this;this.$nextTick(()=>i.triggerEl?.focus())},handleItemMouseEnter(t){const n=t.currentTarget;this.focusSelectedItem(n),n.getAttribute("aria-haspopup")!=="menu"&&this.closeAllSubmenus()},handleWindowEscape(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}},handleContentTabKey(){if(this.open){this.open=!1;let t=this;this.$nextTick(()=>t.triggerEl?.focus())}},handleTriggerMouseover(){let t=this;this.$nextTick(()=>t.$el.firstElementChild?.focus())},closeAllSubmenus(){this.parentEl.querySelectorAll('[x-data^="rzDropdownSubmenu"]').forEach(n=>{e.$data(n)?.closeSubmenu()}),this.isSubmenuActive=!1}})),e.data("rzDropdownSubmenu",()=>({open:!1,ariaExpanded:"false",parentDropdown:null,triggerEl:null,contentEl:null,menuItems:[],focusedIndex:null,anchor:"right-start",pixelOffset:0,navThrottle:100,_lastNavAt:0,selfId:null,siblingContainer:null,closeTimeout:null,closeDelay:150,init(){this.$el.id||(this.$el.id=crypto.randomUUID()),this.selfId=this.$el.id;const t=this.$el.dataset.parentId;if(t){const n=document.getElementById(t);n&&(this.parentDropdown=e.$data(n))}if(!this.parentDropdown){console.error("RzDropdownSubmenu could not find its parent RzDropdownMenu controller.");return}this.triggerEl=this.$refs.subTrigger,this.siblingContainer=this.$el.parentElement,this.anchor=this.$el.dataset.subAnchor||this.anchor,this.pixelOffset=parseInt(this.$el.dataset.subOffset)||this.pixelOffset,this.$watch("open",n=>{n?(this._lastNavAt=0,this.parentDropdown.isSubmenuActive=!0,this.$nextTick(()=>{this.contentEl=document.getElementById(`${this.selfId}-subcontent`),this.contentEl&&(this.updatePosition(this.contentEl),this.menuItems=Array.from(this.contentEl.querySelectorAll('[role^="menuitem"]:not([disabled], [aria-disabled="true"])')))}),this.ariaExpanded="true",this.triggerEl.dataset.state="open"):(this.focusedIndex=null,this.ariaExpanded="false",delete this.triggerEl.dataset.state,this.$nextTick(()=>{this.parentDropdown.parentEl.querySelector('[x-data^="rzDropdownSubmenu"] [data-state="open"]')||(this.parentDropdown.isSubmenuActive=!1)}),this.contentEl=null)})},updatePosition(t){!this.triggerEl||!t||kt(this.triggerEl,t,{placement:this.anchor,middleware:[$t(this.pixelOffset),Rt(),Nt({padding:8})]}).then(({x:n,y:i})=>{Object.assign(t.style,{left:`${n}px`,top:`${i}px`})})},handleTriggerMouseEnter(){clearTimeout(this.closeTimeout),this.triggerEl.focus(),this.openSubmenu()},handleTriggerMouseLeave(){this.closeTimeout=setTimeout(()=>this.closeSubmenu(),this.closeDelay)},handleContentMouseEnter(){clearTimeout(this.closeTimeout)},handleContentMouseLeave(){const t=this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]');t&&Array.from(t).some(i=>e.$data(i)?.open)||(this.closeTimeout=setTimeout(()=>this.closeSubmenu(),this.closeDelay))},openSubmenu(t=!1){this.open||(this.closeSiblingSubmenus(),this.open=!0,t&&this.$nextTick(()=>requestAnimationFrame(()=>this.focusFirstItem())))},closeSubmenu(){this.contentEl?.querySelectorAll('[x-data^="rzDropdownSubmenu"]')?.forEach(n=>{e.$data(n)?.closeSubmenu()}),this.open=!1},closeSiblingSubmenus(){if(!this.siblingContainer)return;Array.from(this.siblingContainer.children).filter(n=>n.hasAttribute("x-data")&&n.getAttribute("x-data").startsWith("rzDropdownSubmenu")&&n.id!==this.selfId).forEach(n=>{e.$data(n)?.closeSubmenu()})},toggleSubmenu(){this.open?this.closeSubmenu():this.openSubmenu()},openSubmenuAndFocusFirst(){this.openSubmenu(!0)},handleTriggerKeydown(t){["ArrowRight","Enter"," "].includes(t.key)&&(t.preventDefault(),this.openSubmenuAndFocusFirst())},focusNextItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex>=this.menuItems.length-1?0:this.focusedIndex+1,this.focusCurrentItem()))},focusPreviousItem(){const t=Date.now();t-this._lastNavAt<this.navThrottle||(this._lastNavAt=t,this.menuItems.length&&(this.focusedIndex=this.focusedIndex===null||this.focusedIndex<=0?this.menuItems.length-1:this.focusedIndex-1,this.focusCurrentItem()))},focusFirstItem(){this.menuItems.length&&(this.focusedIndex=0,this.focusCurrentItem())},focusLastItem(){this.menuItems.length&&(this.focusedIndex=this.menuItems.length-1,this.focusCurrentItem())},focusCurrentItem(){this.focusedIndex!==null&&this.menuItems[this.focusedIndex]&&this.menuItems[this.focusedIndex].focus()},handleItemClick(t){const n=t.currentTarget;if(!(n.getAttribute("aria-disabled")==="true"||n.hasAttribute("disabled"))){if(n.getAttribute("aria-haspopup")==="menu"){e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.toggleSubmenu();return}this.parentDropdown.open=!1,this.$nextTick(()=>this.parentDropdown.triggerEl?.focus())}},handleItemMouseEnter(t){const n=t.currentTarget;if(n.getAttribute("aria-disabled")==="true"||n.hasAttribute("disabled"))return;const i=this.menuItems.indexOf(n);i!==-1&&(this.focusedIndex=i,n.focus()),n.getAttribute("aria-haspopup")==="menu"?e.$data(n.closest('[x-data^="rzDropdownSubmenu"]'))?.openSubmenu():this.closeSiblingSubmenus()},handleSubmenuEscape(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))},handleSubmenuArrowLeft(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))}}))}function oc(e){e.data("rzDarkModeToggle",()=>({get mode(){return this.$store.theme.mode},get prefersDark(){return this.$store.theme.prefersDark},get effectiveDark(){return this.$store.theme.effectiveDark},get isDark(){return this.$store.theme.isDark},get isLight(){return this.$store.theme.isLight},setLight(){this.$store.theme.setLight()},setDark(){this.$store.theme.setDark()},setAuto(){this.$store.theme.setAuto()},toggle(){this.$store.theme.toggle()}}))}function ac(e){e.data("rzEmbeddedPreview",()=>({iframe:null,onDarkModeToggle:null,init(){try{this.iframe=this.$refs.iframe;const t=this.debounce(()=>{this.resizeIframe(this.iframe)},50);this.resizeIframe(this.iframe),new ResizeObserver(r=>{for(let s of r)t()}).observe(this.iframe);const i=this.iframe;this.onDarkModeToggle=r=>{i.contentWindow.postMessage(r.detail,"*")},window.addEventListener("darkModeToggle",this.onDarkModeToggle)}catch{console.error("Cannot access iframe content")}},resizeIframe(t){if(t)try{const n=t.contentDocument||t.contentWindow?.document;if(n){const i=n.body;if(!i)setInterval(()=>{this.resizeIframe(t)},150);else{const r=i.scrollHeight+15;t.style.height=r+"px"}}}catch(n){console.error("Error resizing iframe:",n)}},debounce(t,n=300){let i;return(...r)=>{clearTimeout(i),i=setTimeout(()=>{t.apply(this,r)},n)}},destroy(){window.removeEventListener("darkModeToggle",this.onDarkModeToggle)}}))}function lc(e){e.data("rzEmpty",()=>{})}function cc(e){e.data("rzHeading",()=>({observer:null,headingId:"",init(){this.headingId=this.$el.dataset.alpineRoot;const t=this;if(typeof this.setCurrentHeading=="function"){const n=(r,s)=>{r.forEach(o=>{o.isIntersecting&&t.setCurrentHeading(t.headingId)})},i={threshold:.5};this.observer=new IntersectionObserver(n,i),this.observer.observe(this.$el)}else console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.")},destroy(){this.observer!=null&&this.observer.disconnect()}}))}function uc(e){e.data("rzIndicator",()=>({visible:!1,init(){const t=this.$el.dataset.color;t?this.$el.style.backgroundColor=t:this.$el.style.backgroundColor="var(--color-success)",this.$el.dataset.visible==="true"&&(this.visible=!0)},notVisible(){return!this.visible},setVisible(t){this.visible=t}}))}function dc(e){e.data("rzInputGroupAddon",()=>({handleClick(t){if(t.target.closest("button"))return;const n=this.$el.parentElement;n&&n.querySelector("input, textarea")?.focus()}}))}function fc(e,t){e.data("rzMarkdown",()=>({init(){const n=JSON.parse(this.$el.dataset.assets),i=this.$el.dataset.nonce;t(n,{success:function(){window.hljs.highlightAll()},error:function(){console.error("Failed to load Highlight.js")}},i)}}))}function hc(e,t){e.data("rzNavigationMenu",()=>({activeItemId:null,open:!1,closeTimeout:null,prevIndex:null,list:null,isClosing:!1,_triggerIndex(n){return this.list?Array.from(this.list.querySelectorAll('[x-ref^="trigger_"]')).findIndex(r=>r.getAttribute("x-ref")===`trigger_${n}`):-1},_contentEl(n){return document.getElementById(`${n}-content`)},init(){this.$el.querySelectorAll("[data-popover]").forEach(i=>{i.style.display="none"}),this.$nextTick(()=>{this.list=this.$refs.list})},toggleActive(n){const i=n.currentTarget.getAttribute("x-ref").replace("trigger_","");this.activeItemId===i&&this.open?this.closeMenu():this.openMenu(i)},handleTriggerEnter(n){const i=n.currentTarget.getAttribute("x-ref").replace("trigger_","");this.cancelClose(),this.activeItemId!==i&&!this.isClosing&&requestAnimationFrame(()=>this.openMenu(i))},handleItemEnter(n){const i=n.currentTarget;if(!i)return;this.cancelClose();const r=i.querySelector('[x-ref^="trigger_"]');if(r){const s=r.getAttribute("x-ref").replace("trigger_","");this.activeItemId!==s&&!this.isClosing&&requestAnimationFrame(()=>this.openMenu(s))}else this.open&&!this.isClosing&&this.closeMenu()},handleContentEnter(){this.cancelClose()},scheduleClose(){this.isClosing||this.closeTimeout||(this.closeTimeout=setTimeout(()=>this.closeMenu(),150))},cancelClose(){this.closeTimeout&&(clearTimeout(this.closeTimeout),this.closeTimeout=null),this.isClosing=!1},openMenu(n){this.cancelClose(),this.isClosing=!1;const i=this._triggerIndex(n),r=i>(this.prevIndex??i)?"end":"start",s=this.prevIndex===null;if(this.open&&this.activeItemId&&this.activeItemId!==n){const l=this.$refs[`trigger_${this.activeItemId}`];l&&delete l.dataset.state;const c=this._contentEl(this.activeItemId);if(c){const u=r==="end"?"start":"end";c.setAttribute("data-motion",`to-${u}`),setTimeout(()=>{c.style.display="none"},150)}}this.activeItemId=n,this.open=!0,this.prevIndex=i;const o=this.$refs[`trigger_${n}`],a=this._contentEl(n);!o||!a||(kt(o,a,{placement:"bottom-start",middleware:[$t(6),Rt(),Nt({padding:8})]}).then(({x:l,y:c})=>{Object.assign(a.style,{left:`${l}px`,top:`${c}px`})}),a.style.display="block",s?a.setAttribute("data-motion","fade-in"):a.setAttribute("data-motion",`from-${r}`),this.$nextTick(()=>{o.setAttribute("aria-expanded","true"),o.dataset.state="open"}))},closeMenu(){if(!this.open||this.isClosing)return;this.isClosing=!0,this.cancelClose();const n=this.activeItemId;if(!n){this.isClosing=!1;return}const i=this.$refs[`trigger_${n}`];i&&(i.setAttribute("aria-expanded","false"),delete i.dataset.state);const r=this._contentEl(n);r&&(r.setAttribute("data-motion","fade-out"),setTimeout(()=>{r.style.display="none"},150)),this.open=!1,this.activeItemId=null,this.prevIndex=null,setTimeout(()=>{this.isClosing=!1},150)}}))}function pc(e){e.data("rzPopover",()=>({open:!1,ariaExpanded:"false",triggerEl:null,contentEl:null,init(){this.triggerEl=this.$refs.trigger,this.contentEl=this.$refs.content,this.$watch("open",t=>{this.ariaExpanded=t.toString(),t&&this.$nextTick(()=>this.updatePosition())})},updatePosition(){if(!this.triggerEl||!this.contentEl)return;const t=this.$el.dataset.anchor||"bottom",n=parseInt(this.$el.dataset.offset)||0,i=parseInt(this.$el.dataset.crossAxisOffset)||0,r=parseInt(this.$el.dataset.alignmentAxisOffset)||null,s=this.$el.dataset.strategy||"absolute",o=this.$el.dataset.enableFlip!=="false",a=this.$el.dataset.enableShift!=="false",l=parseInt(this.$el.dataset.shiftPadding)||8;let c=[];c.push($t({mainAxis:n,crossAxis:i,alignmentAxis:r})),o&&c.push(Rt()),a&&c.push(Nt({padding:l})),kt(this.triggerEl,this.contentEl,{placement:t,strategy:s,middleware:c}).then(({x:u,y:d})=>{Object.assign(this.contentEl.style,{left:`${u}px`,top:`${d}px`})})},toggle(){this.open=!this.open},handleOutsideClick(){this.open&&(this.open=!1)},handleWindowEscape(){this.open&&(this.open=!1,this.$nextTick(()=>this.triggerEl?.focus()))}}))}function mc(e){e.data("rzPrependInput",()=>({prependContainer:null,textInput:null,init(){this.prependContainer=this.$refs.prependContainer,this.textInput=this.$refs.textInput;let t=this;setTimeout(()=>{t.updatePadding()},50),window.addEventListener("resize",this.updatePadding)},destroy(){window.removeEventListener("resize",this.updatePadding)},updatePadding(){const t=this.prependContainer,n=this.textInput;if(!t||!n){n&&n.classList.remove("text-transparent");return}const r=t.offsetWidth+10;n.style.paddingLeft=r+"px",n.classList.remove("text-transparent")}}))}function gc(e){e.data("rzProgress",()=>({currentVal:0,minVal:0,maxVal:100,percentage:0,label:"",init(){const t=this.$el;this.currentVal=parseInt(t.getAttribute("data-current-val"))||0,this.minVal=parseInt(t.getAttribute("data-min-val"))||0,this.maxVal=parseInt(t.getAttribute("data-max-val"))||100,this.label=t.getAttribute("data-label"),this.calculatePercentage(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuemin",this.minVal),t.setAttribute("aria-valuemax",this.maxVal),t.setAttribute("aria-valuetext",`${this.percentage}%`),this.updateProgressBar(),new ResizeObserver(i=>{this.updateProgressBar()}).observe(t),this.$watch("currentVal",()=>{this.calculatePercentage(),this.updateProgressBar(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuetext",`${this.percentage}%`)})},calculatePercentage(){this.maxVal===this.minVal?this.percentage=0:this.percentage=Math.min(Math.max((this.currentVal-this.minVal)/(this.maxVal-this.minVal)*100,0),100)},buildLabel(){var t=this.label||"{percent}%";return this.calculatePercentage(),t.replace("{percent}",this.percentage)},buildInsideLabelPosition(){const t=this.$refs.progressBar,n=this.$refs.progressBarLabel,i=this.$refs.innerLabel;n&&t&&i&&(i.innerText=this.buildLabel(),n.clientWidth>t.clientWidth?n.style.left=t.clientWidth+10+"px":n.style.left=t.clientWidth/2-n.clientWidth/2+"px")},getLabelCss(){const t=this.$refs.progressBarLabel,n=this.$refs.progressBar;return t&&n&&t.clientWidth>n.clientWidth?"text-foreground dark:text-foreground":""},updateProgressBar(){const t=this.$refs.progressBar;t&&(t.style.width=`${this.percentage}%`,this.buildInsideLabelPosition())},setProgress(t){this.currentVal=t},increment(t=1){this.currentVal=Math.min(this.currentVal+t,this.maxVal)},decrement(t=1){this.currentVal=Math.max(this.currentVal-t,this.minVal)}}))}function vc(e){e.data("rzQuickReferenceContainer",()=>({headings:[],currentHeadingId:"",init(){this.headings=JSON.parse(this.$el.dataset.headings||"[]"),this.currentHeadingId=this.$el.dataset.currentheadingid||""},handleHeadingClick(){const t=this.$el.dataset.headingid;window.requestAnimationFrame(()=>{this.currentHeadingId=t})},setCurrentHeading(t){this.headings.includes(t)&&(this.currentHeadingId=t)},getSelectedCss(){const t=this.$el.dataset.headingid;return{"font-bold":this.currentHeadingId===t}},getSelectedAriaCurrent(){const t=this.$el.dataset.headingid;return this.currentHeadingId===t?"true":null}}))}function bc(e){e.data("rzSheet",()=>({open:!1,init(){this.open=this.$el.dataset.defaultOpen==="true"},toggle(){this.open=!this.open},close(){this.open=!1},show(){this.open=!0},state(){return this.open?"open":"closed"}}))}function yc(e){e.data("rzTabs",()=>({selectedTab:"",_triggers:[],_observer:null,init(){const t=this.$el.dataset.defaultValue;this._observer=new MutationObserver(()=>this.refreshTriggers()),this._observer.observe(this.$el,{childList:!0,subtree:!0}),this.refreshTriggers(),t&&this._triggers.some(n=>n.dataset.value===t)?this.selectedTab=t:this._triggers.length>0&&(this.selectedTab=this._triggers[0].dataset.value)},destroy(){this._observer&&this._observer.disconnect()},refreshTriggers(){this._triggers=Array.from(this.$el.querySelectorAll('[role="tab"]'))},onTriggerClick(t){const n=t.currentTarget?.dataset?.value;!n||t.currentTarget.getAttribute("aria-disabled")==="true"||(this.selectedTab=n,this.$dispatch("rz:tabs-change",{value:this.selectedTab}))},isSelected(t){return this.selectedTab===t},bindTrigger(){this.selectedTab;const t=this.$el.dataset.value,n=this.isSelected(t),i=this.$el.getAttribute("aria-disabled")==="true";return{"aria-selected":String(n),tabindex:n?"0":"-1","data-state":n?"active":"inactive",...i&&{disabled:!0}}},_attrDisabled(){return this.$el.getAttribute("aria-disabled")==="true"?"true":null},_attrAriaSelected(){return String(this.$el.dataset.value===this.selectedTab)},_attrHidden(){return this.$el.dataset.value===this.selectedTab?null:"true"},_attrAriaHidden(){return String(this.selectedTab!==this.$el.dataset.value)},_attrDataState(){return this.selectedTab===this.$el.dataset.value?"active":"inactive"},_attrTabIndex(){return this.selectedTab===this.$el.dataset.value?"0":"-1"},onListKeydown(t){if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End"].includes(t.key)){t.preventDefault();const n=this._triggers.filter(l=>l.getAttribute("aria-disabled")!=="true");if(n.length===0)return;const i=n.findIndex(l=>l.dataset.value===this.selectedTab);if(i===-1)return;const r=t.currentTarget?.getAttribute("aria-orientation")==="vertical",s=r?"ArrowUp":"ArrowLeft",o=r?"ArrowDown":"ArrowRight";let a=i;switch(t.key){case s:a=i-1<0?n.length-1:i-1;break;case o:a=(i+1)%n.length;break;case"Home":a=0;break;case"End":a=n.length-1;break}if(a>=0&&a<n.length){const l=n[a];this.selectedTab=l.dataset.value,this.$nextTick(()=>l.focus())}}}}))}function wc(e){e.data("rzSidebar",()=>({open:!1,openMobile:!1,isMobile:!1,collapsible:"offcanvas",shortcut:"b",cookieName:"sidebar_state",mobileBreakpoint:768,init(){this.collapsible=this.$el.dataset.collapsible||"offcanvas",this.shortcut=this.$el.dataset.shortcut||"b",this.cookieName=this.$el.dataset.cookieName||"sidebar_state",this.mobileBreakpoint=parseInt(this.$el.dataset.mobileBreakpoint)||768;const t=this.cookieName?document.cookie.split("; ").find(i=>i.startsWith(`${this.cookieName}=`))?.split("=")[1]:null,n=this.$el.dataset.defaultOpen==="true";this.open=t!==null?t==="true":n,this.checkIfMobile(),window.addEventListener("keydown",i=>{(i.ctrlKey||i.metaKey)&&i.key.toLowerCase()===this.shortcut.toLowerCase()&&(i.preventDefault(),this.toggle())}),this.$watch("open",i=>{this.cookieName&&(document.cookie=`${this.cookieName}=${i}; path=/; max-age=31536000`)})},checkIfMobile(){this.isMobile=window.innerWidth<this.mobileBreakpoint},toggle(){this.isMobile?this.openMobile=!this.openMobile:this.open=!this.open},close(){this.isMobile&&(this.openMobile=!1)},isMobileOpen(){return this.openMobile},desktopState(){return this.open?"expanded":"collapsed"},mobileState(){return this.openMobile?"open":"closed"},getCollapsibleAttribute(){return this.desktopState()==="collapsed"?this.collapsible:""}}))}function _c(e){e.data("rzCommand",()=>({search:"",selectedValue:null,selectedIndex:-1,items:[],filteredItems:[],groupTemplates:new Map,activeDescendantId:null,isOpen:!1,isEmpty:!0,firstRender:!0,isLoading:!1,error:null,loop:!1,shouldFilter:!0,itemsUrl:null,fetchTrigger:"immediate",serverFiltering:!1,dataItemTemplateId:null,_dataFetched:!1,_debounceTimer:null,showLoading(){return this.isLoading},hasError(){return this.error!==null},notHasError(){return this.error==null},shouldShowEmpty(){return this.isEmpty&&this.search&&!this.isLoading&&!this.error},shouldShowEmptyOrError(){return this.isEmpty&&this.search&&!this.isLoading||this.error!==null},init(){this.loop=this.$el.dataset.loop==="true",this.shouldFilter=this.$el.dataset.shouldFilter!=="false",this.selectedValue=this.$el.dataset.selectedValue||null,this.itemsUrl=this.$el.dataset.itemsUrl||null,this.fetchTrigger=this.$el.dataset.fetchTrigger||"immediate",this.serverFiltering=this.$el.dataset.serverFiltering==="true",this.dataItemTemplateId=this.$el.dataset.templateId||null;const t=this.$el.dataset.itemsId;let n=[];if(t){const i=document.getElementById(t);if(i)try{n=JSON.parse(i.textContent||"[]")}catch(r){console.error(`RzCommand: Failed to parse JSON from script tag #${t}`,r)}}n.length>0&&!this.dataItemTemplateId&&console.error("RzCommand: `Items` were provided, but no `<CommandItemTemplate>` was found to render them."),n.forEach(i=>{i.id=i.id||`static-item-${crypto.randomUUID()}`,i.isDataItem=!0,this.registerItem(i)}),this.itemsUrl&&this.fetchTrigger==="immediate"&&this.fetchItems(),this.$watch("search",i=>{this.firstRender=!1,this.serverFiltering?(clearTimeout(this._debounceTimer),this._debounceTimer=setTimeout(()=>{this.fetchItems(i)},300)):this.filterAndSortItems()}),this.$watch("selectedIndex",(i,r)=>{if(r>-1){const s=this.filteredItems[r];if(s){const o=this.$el.querySelector(`[data-command-item-id="${s.id}"]`);o&&(o.removeAttribute("data-selected"),o.setAttribute("aria-selected","false"))}}if(i>-1&&this.filteredItems[i]){const s=this.filteredItems[i];this.activeDescendantId=s.id;const o=this.$el.querySelector(`[data-command-item-id="${s.id}"]`);o&&(o.setAttribute("data-selected","true"),o.setAttribute("aria-selected","true"),o.scrollIntoView({block:"nearest"}));const a=s.value;this.selectedValue!==a&&(this.selectedValue=a,this.$dispatch("rz:command:select",{value:a}))}else this.activeDescendantId=null,this.selectedValue=null}),this.$watch("selectedValue",i=>{const r=this.filteredItems.findIndex(s=>s.value===i);this.selectedIndex!==r&&(this.selectedIndex=r)}),this.$watch("filteredItems",i=>{this.isOpen=i.length>0||this.isLoading,this.isEmpty=i.length===0,this.firstRender||window.dispatchEvent(new CustomEvent("rz:command:list-changed",{detail:{items:this.filteredItems,groups:this.groupTemplates,commandId:this.$el.id}}))})},async fetchItems(t=""){if(this.itemsUrl){if(!this.dataItemTemplateId){console.error("RzCommand: `ItemsUrl` was provided, but no `<CommandItemTemplate>` was found to render the data."),this.error="Configuration error: No data template found.";return}this.isLoading=!0,this.error=null;try{const n=new URL(this.itemsUrl,window.location.origin);this.serverFiltering&&t&&n.searchParams.append("q",t);const i=await fetch(n);if(!i.ok)throw new Error(`Network response was not ok: ${i.statusText}`);const r=await i.json();this.serverFiltering&&(this.items=this.items.filter(s=>!s.isDataItem)),r.forEach(s=>{s.id=s.id||`data-item-${crypto.randomUUID()}`,s.isDataItem=!0,this.registerItem(s)}),this._dataFetched=!0}catch(n){this.error=n.message||"Failed to fetch command items.",console.error("RzCommand:",this.error)}finally{this.isLoading=!1,this.filterAndSortItems()}}},handleInteraction(){this.itemsUrl&&this.fetchTrigger==="on-open"&&!this._dataFetched&&this.fetchItems()},registerItem(t){this.items.some(n=>n.id===t.id)||(t._order=this.items.length,this.items.push(t),this.selectedIndex===-1&&(this.selectedIndex=0),this.serverFiltering||this.filterAndSortItems())},unregisterItem(t){this.items=this.items.filter(n=>n.id!==t),this.filterAndSortItems()},registerGroupTemplate(t,n){this.groupTemplates.has(t)||this.groupTemplates.set(t,n)},filterAndSortItems(){if(this.serverFiltering&&this._dataFetched){this.filteredItems=this.items,this.selectedIndex=this.filteredItems.length>0?0:-1;return}let t;if(!this.shouldFilter||!this.search?t=this.items.map(n=>({...n,score:1})):t=this.items.map(n=>({...n,score:n.forceMount?0:this.commandScore(n.name,this.search,n.keywords)})).filter(n=>n.score>0||n.forceMount).sort((n,i)=>n.forceMount&&!i.forceMount?1:!n.forceMount&&i.forceMount?-1:i.score!==n.score?i.score-n.score:(n._order||0)-(i._order||0)),this.filteredItems=t,this.selectedValue){const n=this.filteredItems.findIndex(i=>i.value===this.selectedValue);this.selectedIndex=n>-1?n:this.filteredItems.length>0?0:-1}else this.selectedIndex=this.filteredItems.length>0?0:-1},handleItemClick(t){const n=t.target.closest("[data-command-item-id]");if(!n)return;const i=n.dataset.commandItemId,r=this.filteredItems.findIndex(s=>s.id===i);if(r>-1){const s=this.filteredItems[r];s&&!s.disabled&&(this.selectedIndex=r,this.$dispatch("rz:command:execute",{value:s.value}))}},handleItemHover(t){const n=t.target.closest("[data-command-item-id]");if(!n)return;const i=n.dataset.commandItemId,r=this.filteredItems.findIndex(s=>s.id===i);if(r>-1){const s=this.filteredItems[r];s&&!s.disabled&&this.selectedIndex!==r&&(this.selectedIndex=r)}},handleKeydown(t){switch(t.key){case"ArrowDown":t.preventDefault(),this.selectNext();break;case"ArrowUp":t.preventDefault(),this.selectPrev();break;case"Home":t.preventDefault(),this.selectFirst();break;case"End":t.preventDefault(),this.selectLast();break;case"Enter":t.preventDefault();const n=this.filteredItems[this.selectedIndex];n&&!n.disabled&&this.$dispatch("rz:command:execute",{value:n.value});break}},selectNext(){if(this.filteredItems.length===0)return;let t=this.selectedIndex,n=0;do{if(t=t+1>=this.filteredItems.length?this.loop?0:this.filteredItems.length-1:t+1,n++,!this.filteredItems[t]?.disabled){this.selectedIndex=t;return}if(!this.loop&&t===this.filteredItems.length-1)return}while(n<=this.filteredItems.length)},selectPrev(){if(this.filteredItems.length===0)return;let t=this.selectedIndex,n=0;do{if(t=t-1<0?this.loop?this.filteredItems.length-1:0:t-1,n++,!this.filteredItems[t]?.disabled){this.selectedIndex=t;return}if(!this.loop&&t===0)return}while(n<=this.filteredItems.length)},selectFirst(){if(this.filteredItems.length>0){const t=this.filteredItems.findIndex(n=>!n.disabled);t>-1&&(this.selectedIndex=t)}},selectLast(){if(this.filteredItems.length>0){const t=this.filteredItems.map(n=>n.disabled).lastIndexOf(!1);t>-1&&(this.selectedIndex=t)}},commandScore(t,n,i=[]){const d=/[\\/_+.#"@[\(\{&]/,f=/[\s-]/,v=`${t} ${i?i.join(" "):""}`;function x(p){return p.toLowerCase().replace(/[\s-]/g," ")}function w(p,g,h,y,E,_,m){if(_===g.length)return E===p.length?1:.99;const b=`${E},${_}`;if(m[b]!==void 0)return m[b];const I=y.charAt(_);let S=h.indexOf(I,E),C=0;for(;S>=0;){let T=w(p,g,h,y,S+1,_+1,m);T>C&&(S===E?T*=1:d.test(p.charAt(S-1))?T*=.8:f.test(p.charAt(S-1))?T*=.9:(T*=.17,E>0&&(T*=Math.pow(.999,S-E))),p.charAt(S)!==g.charAt(_)&&(T*=.9999)),T>C&&(C=T),S=h.indexOf(I,S+1)}return m[b]=C,C}return w(v,n,x(v),x(n),0,0,{})}}))}function xc(e){e.data("rzCommandItem",()=>({parent:null,itemData:{},init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandItem must be a child of RzCommand.");return}this.parent=e.$data(t),this.itemData={id:this.$el.id,value:this.$el.dataset.value||this.$el.textContent.trim(),name:this.$el.dataset.name||this.$el.dataset.value||this.$el.textContent.trim(),keywords:JSON.parse(this.$el.dataset.keywords||"[]"),group:this.$el.dataset.group||null,templateId:this.$el.id+"-template",disabled:this.$el.dataset.disabled==="true",forceMount:this.$el.dataset.forceMount==="true"},this.parent.registerItem(this.itemData)},destroy(){this.parent&&this.parent.unregisterItem(this.itemData.id)}}))}function Ec(e){e.data("rzCommandList",()=>({parent:null,dataItemTemplate:null,init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandList must be a child of RzCommand.");return}this.parent=e.$data(t),this.parent.dataItemTemplateId&&(this.dataItemTemplate=document.getElementById(this.parent.dataItemTemplateId))},renderList(t){if(t.detail.commandId!==this.parent.$el.id)return;const n=t.detail.items||[],i=t.detail.groups||new Map,r=this.$el;r.querySelectorAll("[data-dynamic-item]").forEach(o=>o.remove());const s=new Map([["__ungrouped__",[]]]);n.forEach(o=>{const a=o.group||"__ungrouped__";s.has(a)||s.set(a,[]),s.get(a).push(o)}),s.forEach((o,a)=>{if(o.length===0)return;const l=document.createElement("div");if(l.setAttribute("role","group"),l.setAttribute("data-dynamic-item","true"),l.setAttribute("data-slot","command-group"),a!=="__ungrouped__"){const c=i.get(a);if(c){const u=document.getElementById(c);if(u&&u.content){const d=u.content.cloneNode(!0),f=d.firstElementChild;f&&(l.setAttribute("aria-labelledby",f.id),l.appendChild(d))}}}o.forEach(c=>{const u=this.parent.filteredItems.indexOf(c);let d;if(c.isDataItem){if(!this.dataItemTemplate)return;d=this.dataItemTemplate.content.cloneNode(!0).firstElementChild,e.addScopeToNode(d,{item:c})}else{const f=document.getElementById(c.templateId);f&&f.content&&(d=f.content.cloneNode(!0).querySelector(`[data-command-item-id="${c.id}"]`))}d&&(d.setAttribute("data-command-item-id",c.id),d.setAttribute("data-value",c.value),c.keywords&&d.setAttribute("data-keywords",JSON.stringify(c.keywords)),c.group&&d.setAttribute("data-group",c.group),c.disabled&&d.setAttribute("data-disabled","true"),c.forceMount&&d.setAttribute("data-force-mount","true"),d.setAttribute("role","option"),d.setAttribute("aria-selected",this.parent.selectedIndex===u),c.disabled&&d.setAttribute("aria-disabled","true"),this.parent.selectedIndex===u&&d.setAttribute("data-selected","true"),l.appendChild(d),e.initTree(d))}),r.appendChild(l)})}}))}function Ic(e){e.data("rzCommandGroup",()=>({parent:null,heading:"",templateId:"",init(){const t=this.$el.closest('[x-data="rzCommand"]');if(!t){console.error("CommandGroup must be a child of RzCommand.");return}this.parent=e.$data(t),this.heading=this.$el.dataset.heading,this.templateId=this.$el.dataset.templateId,this.heading&&this.templateId&&this.parent.registerGroupTemplate(this.heading,this.templateId)}}))}async function Sc(e){e=[...e].sort();const t=e.join("|"),i=new TextEncoder().encode(t),r=await crypto.subtle.digest("SHA-256",i);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}function we(e,t,n){let i,r;typeof t=="function"?i={success:t}:t&&typeof t=="object"?i=t:typeof t=="string"&&(r=t),!r&&typeof n=="string"&&(r=n);const s=Array.isArray(e)?e:[e];return Sc(s).then(o=>(re.isDefined(o)||re(s,o,{async:!1,inlineScriptNonce:r,inlineStyleNonce:r}),new Promise((a,l)=>{re.ready(o,{success:()=>{try{i&&typeof i.success=="function"&&i.success()}catch(c){console.error("[rizzyRequire] success callback threw:",c)}a({bundleId:o})},error:c=>{try{i&&typeof i.error=="function"&&i.error(c)}catch(u){console.error("[rizzyRequire] error callback threw:",u)}l(new Error(`[rizzyRequire] Failed to load bundle ${o} (missing: ${Array.isArray(c)?c.join(", "):String(c)})`))}})})))}function Cc(e){bl(e),yl(e),wl(e),_l(e),xl(e),El(e,we),Il(e,we),Sl(e,we),Cl(e),Tl(e,we),Al(e,we),Ol(e),sc(e),oc(e),ac(e),lc(e),cc(e),uc(e),dc(e),fc(e,we),hc(e),pc(e),mc(e),gc(e),vc(e),bc(e),yc(e),wc(e),_c(e),xc(e),Ec(e),Ic(e)}function Tc(e){if(!(e instanceof Element))return console.warn("[Rizzy.props] Invalid input. Expected an Alpine.js root element (this.$el)."),{};const t=e.dataset.propsId;if(!t)return{};const n=document.getElementById(t);if(!n)return console.warn(`[Rizzy.props] Could not find the props script tag with ID '${t}'.`),{};try{return JSON.parse(n.textContent||"{}")}catch(i){return console.error(`[Rizzy.props] Failed to parse JSON from script tag #${t}.`,i),{}}}const Lt=new Map,Dt=new Map;let ss=!1;function Ac(e){return Dt.has(e)||Dt.set(e,import(e).catch(t=>{throw Dt.delete(e),t})),Dt.get(e)}function os(e,t){const n=globalThis.Alpine;return n&&typeof n.asyncData=="function"?(n.asyncData(e,()=>Ac(t).catch(i=>(console.error(`[RizzyUI] Failed to load Alpine module '${e}' from '${t}'.`,i),()=>({_error:!0,_errorMessage:`Module '${e}' failed to load.`})))),!0):(console.error(`[RizzyUI] Could not register async component '${e}'. AsyncAlpine not available.`),!1)}function Oc(e,t){if(!e||!t){console.error("[RizzyUI] registerAsyncComponent requires both name and path.");return}const n=Lt.get(e);n&&n.path!==t&&console.warn(`[RizzyUI] Re-registering '${e}' with a different path.
  Previous: ${n.path}
  New:      ${t}`);const i=globalThis.Alpine;if(i&&i.version){const r=!n||n.path!==t;if(!(n&&n.loaderSet&&!r)){const o=os(e,t);Lt.set(e,{path:t,loaderSet:o})}return}Lt.set(e,{path:t,loaderSet:!1}),ss||(ss=!0,document.addEventListener("alpine:init",()=>{for(const[r,s]of Lt)if(!s.loaderSet){const o=os(r,s.path);s.loaderSet=o}},{once:!0}))}function $c(e){e.directive("mobile",(t,{modifiers:n,expression:i},{cleanup:r})=>{const s=n.find(g=>g.startsWith("bp-")),o=s?parseInt(s.slice(3),10):768,a=!!(i&&i.length>0);if(typeof window>"u"||!window.matchMedia){t.dataset.mobile="false",t.dataset.screen="desktop";return}const l=()=>window.innerWidth<o,c=g=>{t.dataset.mobile=g?"true":"false",t.dataset.screen=g?"mobile":"desktop"},u=()=>typeof e.$data=="function"?e.$data(t):t.__x?t.__x.$data:null,d=g=>{if(!a)return;const h=u();h&&(h[i]=g)},f=g=>{t.dispatchEvent(new CustomEvent("screen:change",{bubbles:!0,detail:{isMobile:g,width:window.innerWidth,breakpoint:o}}))},v=window.matchMedia(`(max-width: ${o-1}px)`),x=()=>{const g=l();c(g),d(g),f(g)};x();const w=()=>x(),p=()=>x();v.addEventListener("change",w),window.addEventListener("resize",p,{passive:!0}),r(()=>{v.removeEventListener("change",w),window.removeEventListener("resize",p)})})}function Nc(e){const t=(n,{expression:i,modifiers:r},{cleanup:s,effect:o})=>{if(!i||typeof i!="string")return;const a=(w,p,g)=>{const y=p.replace(/\[(\d+)\]/g,".$1").split("."),E=y.pop();let _=w;for(const m of y)(_[m]==null||typeof _[m]!="object")&&(_[m]=isFinite(+m)?[]:{}),_=_[m];_[E]=g},l=e.closestDataStack(n)||[],c=l[0]||null,u=l[1]||null;if(!c||!u)return;const d=i.split(",").map(w=>w.trim()).filter(Boolean).map(w=>{const p=w.split("->").map(g=>g.trim());return p.length!==2?(console.warn('[x-syncprop] Invalid mapping (expected "parent.path -> child.path"): ',w),null):{parentPath:p[0],childPath:p[1]}}).filter(Boolean),f=r.includes("init-child")||r.includes("child")||r.includes("childWins"),v=d.map(()=>({fromParent:!1,fromChild:!1,skipChildOnce:f})),x=[];d.forEach((w,p)=>{const g=v[p];if(f){const E=e.evaluate(n,w.childPath,{scope:c});g.fromChild=!0,a(u,w.parentPath,E),queueMicrotask(()=>{g.fromChild=!1})}else{const E=e.evaluate(n,w.parentPath,{scope:u});g.fromParent=!0,a(c,w.childPath,E),queueMicrotask(()=>{g.fromParent=!1})}const h=o(()=>{const E=e.evaluate(n,w.parentPath,{scope:u});g.fromChild||(g.fromParent=!0,a(c,w.childPath,E),queueMicrotask(()=>{g.fromParent=!1}))}),y=o(()=>{const E=e.evaluate(n,w.childPath,{scope:c});if(!g.fromParent){if(g.skipChildOnce){g.skipChildOnce=!1;return}g.fromChild=!0,a(u,w.parentPath,E),queueMicrotask(()=>{g.fromChild=!1})}});x.push(h,y)}),s(()=>{for(const w of x)try{w&&w()}catch{}})};e.directive("syncprop",t)}class Rc{constructor(){this.storageKey="darkMode",this.eventName="rz:theme-change",this.darkClass="dark",this._mode="auto",this._mq=null,this._initialized=!1,this._onMqChange=null,this._onStorage=null,this._lastSnapshot={mode:null,effectiveDark:null,prefersDark:null}}init(){if(this._initialized||typeof window>"u")return;this._initialized=!0,this._mq=typeof window.matchMedia=="function"?window.matchMedia("(prefers-color-scheme: dark)"):null;const t=this._safeReadStorage(this.storageKey);this._mode=this._normalizeMode(t??"auto"),this._sync(),this._onMqChange=()=>{this._sync()},this._mq&&(typeof this._mq.addEventListener=="function"?this._mq.addEventListener("change",this._onMqChange):typeof this._mq.addListener=="function"&&this._mq.addListener(this._onMqChange)),this._onStorage=n=>{if(n.key!==this.storageKey)return;const i=this._normalizeMode(n.newValue??"auto");i!==this._mode&&(this._mode=i,this._sync())},window.addEventListener("storage",this._onStorage)}destroy(){this._initialized&&(this._initialized=!1,this._mq&&this._onMqChange&&(typeof this._mq.removeEventListener=="function"?this._mq.removeEventListener("change",this._onMqChange):typeof this._mq.removeListener=="function"&&this._mq.removeListener(this._onMqChange)),typeof window<"u"&&this._onStorage&&window.removeEventListener("storage",this._onStorage),this._onMqChange=null,this._onStorage=null,this._mq=null,this._lastSnapshot={mode:null,effectiveDark:null,prefersDark:null})}get mode(){return this._mode}get prefersDark(){return!!this._mq?.matches}get effectiveDark(){return this._mode==="dark"||this._mode==="auto"&&this.prefersDark}isDark(){return this.effectiveDark}isLight(){return!this.effectiveDark}setLight(){this._setMode("light")}setDark(){this._setMode("dark")}setAuto(){this._setMode("auto")}toggle(){const t=this.effectiveDark;this._setMode(t?"light":"dark")}_setMode(t){this._mode=this._normalizeMode(t),this._persist(),this._sync()}_normalizeMode(t){return t==="light"||t==="dark"||t==="auto"?t:"auto"}_safeReadStorage(t){try{return window?.localStorage?.getItem(t)}catch{return null}}_persist(){try{window?.localStorage?.setItem(this.storageKey,this._mode)}catch{}}_sync(){const t=this.effectiveDark,n=this._mode,i=this.prefersDark,r=typeof document<"u"?document.documentElement:null,s=r?r.classList.contains(this.darkClass)===t&&r.style.colorScheme===(t?"dark":"light"):!0;this._lastSnapshot.mode===n&&this._lastSnapshot.effectiveDark===t&&this._lastSnapshot.prefersDark===i&&s||(this._lastSnapshot={mode:n,effectiveDark:t,prefersDark:i},r&&(r.classList.toggle(this.darkClass,t),r.style.colorScheme=t?"dark":"light"),typeof window<"u"&&window.dispatchEvent(new CustomEvent(this.eventName,{detail:{mode:n,darkMode:t,prefersDark:i,source:"RizzyUI"}})))}}const k=new Rc;function kc(e){k.init(),e.store("theme",{_mode:k.mode,_prefersDark:k.prefersDark,_effectiveDark:k.effectiveDark,_onThemeChange:null,init(){this._onThemeChange||(this._onThemeChange=()=>this._refresh(),window.addEventListener(k.eventName,this._onThemeChange)),this._refresh()},_refresh(){this._mode=k.mode,this._prefersDark=k.prefersDark,this._effectiveDark=k.effectiveDark},get mode(){return this._mode},get effectiveDark(){return this._effectiveDark},get prefersDark(){return this._prefersDark},get isDark(){return this._effectiveDark},get isLight(){return!this._effectiveDark},setLight(){k.setLight()},setDark(){k.setDark()},setAuto(){k.setAuto()},toggle(){k.toggle()}})}let Ze=null;function Lc(e){return Ze||(e.plugin(ba),e.plugin(Ea),e.plugin(Wa),e.plugin(Qa),typeof document<"u"&&document.addEventListener("alpine:init",()=>{kc(e)}),Cc(e),$c(e),Nc(e),Ze={Alpine:e,require:we,toast:fl,$data:gl,props:Tc,registerAsyncComponent:Oc,theme:k},typeof window<"u"&&(k.init(),window.Alpine=e,window.Rizzy={...window.Rizzy||{},...Ze},document.dispatchEvent(new CustomEvent("rz:init",{detail:{Rizzy:window.Rizzy}}))),Ze)}const Dc=Lc(lr);return lr.start(),Dc});
</file>

<file path="wwwroot/js/safelist.js">
module.exports = ["@container/card-header","@container/field-group","pointer-events-auto","pointer-events-none","collapse","invisible","visible","sr-only","absolute","fixed","relative","static","sticky","inset-0","inset-x-0","inset-y-0","inset-y-4","top-0","top-1/2","top-2.5","top-4","top-6","top-16","top-[1px]","top-[50%]","top-full","-right-12","right-0","right-1","right-2","right-3","right-3.5","right-4","right-full","bottom-0","bottom-8","bottom-full","-left-12","left-0","left-1","left-1/2","left-3","left-4","left-[50%]","left-full","isolate","z-0","z-1","z-10","z-20","z-30","z-40","z-50","z-60","z-[1]","z-[10004]","order-first","order-last","col-start-2","row-span-2","row-start-1","container","!m-0","m-0","-mx-1","mx-2","mx-3.5","mx-4","mx-auto","-my-2","-my-4","my-0","my-1","my-3","my-4","my-5","my-8","my-auto","my-px","ms-2","me-2","mt-1","mt-1.5","mt-2","mt-3","mt-4","mt-16","mt-auto","mr-1","mr-2","mr-4","mr-auto","mb-1","mb-2","mb-3","mb-4","mb-5","mb-10","-ml-px","ml-0","ml-1","ml-2","ml-3.5","ml-4","ml-8","ml-12","ml-auto","ml-px","line-clamp-1","line-clamp-2","block","contents","flex","grid","hidden","inline","inline-block","inline-flex","inline-grid","list-item","table","table-cell","table-footer-group","table-header-group","field-sizing-content","aspect-square","size-2","size-2.5","size-3","size-3.5","size-3/5","size-4","size-5","size-6","size-7","size-8","size-10","size-12","size-14","size-16","size-20","size-full","h-0.5","h-1.5","h-2","h-2.5","h-4","h-5","h-6","h-7","h-8","h-9","h-10","h-11","h-12","h-14","h-16","h-96","h-[--radix-navigation-menu-viewport-height]","h-[1.15rem]","h-[2px]","h-[calc(100%-1px)]","h-[var(--radix-navigation-menu-viewport-height)]","h-auto","h-full","h-px","h-svh","max-h-60","max-h-[300px]","max-h-[400px]","min-h-0","min-h-4","min-h-16","min-h-28","min-h-svh","w-0.5","w-1/2","w-1/3","w-3/4","w-4","w-5","w-6","w-7","w-8","w-9","w-48","w-56","w-60","w-64","w-72","w-80","w-[--radix-navigation-menu-viewport-width]","w-[3.25rem]","w-[var(--radix-navigation-menu-viewport-width)]","w-[var(--sidebar-mobile-width)]","w-[var(--sidebar-width)]","w-auto","w-fit","w-full","w-max","w-min","w-screen","max-w-2xl","max-w-3xl","max-w-4xl","max-w-5xl","max-w-6xl","max-w-7xl","max-w-[calc(100%-2rem)]","max-w-lg","max-w-max","max-w-md","max-w-none","max-w-prose","max-w-screen-lg","max-w-screen-md","max-w-sm","max-w-xl","max-w-xs","min-w-0","min-w-5","min-w-[8rem]","flex-1","flex-none","flex-shrink","shrink","shrink-0","flex-grow","grow","grow-0","basis-full","caption-bottom","border-collapse","origin-bottom","origin-bottom-left","origin-bottom-right","origin-center","origin-left","origin-right","origin-top","origin-top-left","origin-top-right","-translate-x-1/2","-translate-x-60","translate-x-0","translate-x-[-50%]","translate-x-px","-translate-y-1/2","translate-y-0","translate-y-0.5","translate-y-1","translate-y-2","translate-y-[-50%]","scale-50","scale-90","scale-95","scale-100","scale-125","!rotate-180","rotate-0","rotate-180","transform","animate-in","animate-out","animate-ping","cursor-default","cursor-not-allowed","cursor-pointer","cursor-text","resize","resize-none","scroll-m-20","scroll-py-1","list-disc","list-none","appearance-none","auto-rows-min","grid-cols-1","grid-cols-2","grid-cols-3","grid-cols-4","grid-cols-5","grid-cols-6","grid-cols-7","grid-cols-8","grid-cols-9","grid-cols-10","grid-cols-11","grid-cols-12","grid-cols-[0_1fr]","grid-rows-[auto_auto]","flex-col","flex-col-reverse","flex-row","flex-wrap","content-center","items-center","items-end","items-start","items-stretch","justify-between","justify-center","justify-end","justify-start","justify-items-start","gap-0","gap-0.5","gap-1","gap-1.5","gap-2","gap-2.5","gap-3","gap-4","gap-6","gap-7","gap-14","space-y-1","space-y-2","space-y-6","gap-x-3","-space-x-px","space-x-0.5","space-x-2","space-x-3","space-x-4","gap-y-0.5","gap-y-1","divide-y","divide-gray-100","self-start","self-stretch","justify-self-end","truncate","overflow-auto","overflow-hidden","overflow-visible","overflow-x-auto","overflow-x-hidden","overflow-y-auto","overflow-y-hidden","rounded","rounded-2xl","rounded-[4px]","rounded-[calc(var(--radius)-5px)]","rounded-full","rounded-lg","rounded-md","rounded-none","rounded-sm","rounded-xl","rounded-xs","rounded-t-none","rounded-l-lg","rounded-l-md","rounded-r-lg","rounded-r-md","!rounded-b-none","rounded-b","rounded-b-none","rounded-b-xl","border","border-0","border-2","border-x","border-t","border-t-0","border-r","border-b","border-b-0","border-b-1","border-l","border-l-0","border-dashed","border-dotted","border-none","border-solid","!border-border","border-accent","border-accent/20","border-accent/50","border-accent/70","border-amber-500","border-amber-500/50","border-background","border-blue-500","border-blue-500/50","border-border","border-destructive","border-destructive/20","border-destructive/50","border-foreground","border-foreground/10","border-gray-200","border-green-500","border-green-500/50","border-info","border-info/20","border-input","border-input/50","border-primary","border-primary/20","border-primary/50","border-secondary","border-secondary/20","border-secondary/50","border-sidebar-border","border-slate-300","border-success","border-success/20","border-transparent","border-warning","border-warning/20","border-white","!bg-card","bg-accent","bg-accent-foreground","bg-accent/10","bg-accent/15","bg-accent/20","bg-amber-50","bg-amber-100","bg-amber-500","bg-amber-500/10","bg-amber-500/15","bg-amber-500/20","bg-background","bg-background/10","bg-background/15","bg-background/50","bg-background/75","bg-black","bg-black/50","bg-blue-100","bg-blue-200","bg-blue-500","bg-blue-500/10","bg-blue-600","bg-border","bg-card","bg-card-foreground","bg-destructive","bg-destructive-foreground","bg-destructive/10","bg-destructive/15","bg-destructive/20","bg-emerald-200","bg-emerald-800","bg-foreground","bg-foreground/10","bg-foreground/15","bg-gray-50","bg-gray-100","bg-gray-300","bg-gray-400","bg-green-100","bg-green-500","bg-green-500/10","bg-green-600","bg-indigo-200","bg-indigo-700","bg-info","bg-info/10","bg-info/15","bg-input","bg-input/50","bg-muted","bg-muted-foreground","bg-muted/10","bg-muted/15","bg-muted/50","bg-neutral-100","bg-orange-200","bg-orange-500","bg-pink-200","bg-pink-500","bg-popover","bg-popover-foreground","bg-primary","bg-primary-foreground","bg-primary/10","bg-primary/15","bg-purple-200","bg-purple-600","bg-red-200","bg-red-500","bg-ring","bg-rose-500","bg-secondary","bg-secondary-foreground","bg-secondary/10","bg-secondary/15","bg-secondary/40","bg-secondary/75","bg-sidebar","bg-slate-900","bg-success","bg-success-foreground","bg-success/10","bg-success/15","bg-teal-200","bg-teal-600","bg-transparent","bg-warning","bg-warning-foreground","bg-warning/10","bg-warning/15","bg-white","bg-yellow-300","bg-yellow-500","bg-gradient-to-r","bg-none","from-primary","to-secondary","mask-repeat","fill-accent","fill-accent-foreground","fill-background","fill-border","fill-card","fill-card-foreground","fill-destructive","fill-destructive-foreground","fill-foreground","fill-info","fill-info-foreground","fill-input","fill-muted","fill-muted-foreground","fill-popover","fill-popover-foreground","fill-primary","fill-primary-foreground","fill-ring","fill-secondary","fill-secondary-foreground","fill-success","fill-success-foreground","fill-warning","fill-warning-foreground","object-cover","p-0","p-0.5","p-1","p-2","p-2.5","p-3","p-4","p-5","p-6","p-8","p-10","p-[3px]","p-px","px-1","px-1.5","px-2","px-2.5","px-3","px-4","px-5","px-6","px-8","py-0.5","py-1","py-1.5","py-2","py-3","py-4","py-6","ps-14","pt-1","pt-2","pt-3","pr-0","pr-1","pr-2","pr-3","pr-8","pr-9","pb-1","pb-2","pb-3","pb-4","pb-5","pb-6","pl-0","pl-2","pl-2.5","pl-3","pl-4","text-center","text-justify","text-left","text-right","align-middle","font-mono","font-sans","font-serif","text-2xl","text-3xl","text-4xl","text-5xl","text-base","text-base/7","text-lg","text-sm","text-sm/relaxed","text-xl","text-xs","text-[0.8rem]","leading-5","leading-6","leading-7","leading-[175%]","leading-loose","leading-none","leading-normal","leading-relaxed","leading-snug","leading-tight","font-bold","font-extrabold","font-light","font-medium","font-normal","font-semibold","font-thin","tracking-normal","tracking-tight","tracking-tighter","tracking-wide","tracking-wider","tracking-widest","text-balance","text-pretty","break-words","break-all","whitespace-nowrap","!text-card-foreground","text-accent","text-accent-foreground","text-amber-700","text-amber-900","text-background","text-black","text-blue-600","text-blue-700","text-border","text-card","text-card-foreground","text-current","text-destructive","text-destructive-foreground","text-emerald-500","text-emerald-700","text-foreground","text-foreground/60","text-foreground/70","text-gray-300","text-gray-500","text-gray-600","text-gray-700","text-green-700","text-indigo-700","text-info","text-info-foreground","text-inherit","text-input","text-muted","text-muted-foreground","text-orange-700","text-pink-700","text-popover","text-popover-foreground","text-primary","text-primary-foreground","text-purple-700","text-red-600","text-red-700","text-ring","text-rose-500","text-secondary","text-secondary-foreground","text-sidebar-foreground","text-sidebar-foreground/70","text-slate-400","text-success","text-success-foreground","text-teal-700","text-transparent","text-warning","text-warning-foreground","text-white","text-yellow-800","capitalize","lowercase","normal-case","uppercase","italic","ordinal","line-through","no-underline","overline","underline","underline-offset-2","placeholder-foreground","placeholder-gray-500","placeholder-muted-foreground","accent-foreground","accent-primary","opacity-0","opacity-25","opacity-50","opacity-60","opacity-70","opacity-90","opacity-100","shadow","shadow-2xl","shadow-2xs","shadow-[0_0_0_1px_hsl(var(--sidebar-border))]","shadow-lg","shadow-md","shadow-none","shadow-sm","shadow-xl","shadow-xs","ring","ring-0","ring-1","ring-2","ring-black","ring-border","ring-primary","ring-sidebar-ring","ring-offset-background","outline","outline-2","outline-offset-2","blur","invert","filter","filter!","backdrop-blur-sm","backdrop-blur-xl","backdrop-blur-xs","backdrop-brightness-75","transition","transition-[color,box-shadow]","transition-[left,right,width]","transition-[left]","transition-[margin,opacity]","transition-[margin-left]","transition-[opacity,scale]","transition-[width,height,padding]","transition-[width,left]","transition-[width]","transition-all","transition-colors","transition-opacity","transition-shadow","transition-transform","duration-75","duration-100","duration-150","duration-200","duration-300","duration-500","duration-600","ease-in","ease-in-out","ease-linear","ease-out","[will-change:transform,opacity]","will-change-[opacity,transform]","forced-color-adjust-auto","fade-in-80","outline-none","select-none","zoom-in-90","zoom-out-95","fade-in","fade-out","paused","perspective-[2000px]","running","slide-in-from-left","slide-in-from-right","slide-out-to-left","slide-out-to-right","zoom-in","zoom-out","group-open:rotate-180","group","group-hover:border-primary","group-hover:opacity-50","group-hover/menu-item:opacity-100","group/menu-item","group-has-[.peer:checked]:border-primary","peer","group-has-[.peer:checked]:bg-primary","group-has-[.peer:checked]:opacity-100","group-has-[.peer:focus-visible]:ring-2","group-has-[.peer:focus-visible]:ring-ring","group-has-[.peer:focus-visible]:ring-offset-2","group-has-[[data-orientation=horizontal]]/field:text-balance","group/field","group-has-[[data-slot=item-description]]/item:translate-y-0.5","group/item","group-has-[[data-slot=item-description]]/item:self-start","group-has-[>input]/input-group:pt-2.5","group/input-group","group-has-[>input]/input-group:pb-2.5","group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem)]","group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+1rem+2px)]","group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]","group-data-[collapsible=icon]:overflow-hidden","group-data-[collapsible=icon]:p-0","group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]","group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]","group-data-[collapsible=offcanvas]:w-0","group-data-[collapsible=offcanvas]/sidebar-wrapper:translate-x-0","group/sidebar-wrapper","group-data-[disabled=true]:pointer-events-none","group-data-[disabled=true]:opacity-50","group-data-[disabled=true]/field:opacity-50","group-data-[disabled=true]/input-group:opacity-50","group-data-[side=left]:border-r","group-data-[side=left]/sidebar-wrapper:-right-4","group-data-[side=left]/sidebar-wrapper:cursor-w-resize","group-data-[side=right]:order-last","group-data-[side=right]:border-l","group-data-[side=right]/sidebar-wrapper:left-0","group-data-[side=right]/sidebar-wrapper:cursor-e-resize","group-data-[state=collapsed]/sidebar:mx-auto","group/sidebar","group-data-[state=collapsed]/sidebar:w-8","group-data-[state=collapsed]/sidebar:justify-center","group-data-[state=collapsed]/sidebar:opacity-0","group-data-[state=open]:rotate-180","group-data-[variant=outline]/field-group:-mb-2","group/field-group","group-data-[variant=sidebar]:border-r","group-data-[variant=sidebar]:border-l","group-data-[vc-date-disabled]:text-muted-foreground","group-data-[vc-date-disabled]:line-through","group-data-[vc-date-disabled]:opacity-50","group-data-[vc-date-month=next]:text-muted-foreground","group-data-[vc-date-month=next]:opacity-50","group-data-[vc-date-month=prev]:text-muted-foreground","group-data-[vc-date-month=prev]:opacity-50","group-data-[vc-date-selected=first]:rounded-l-md","group-data-[vc-date-selected=first]:rounded-r-none","group-data-[vc-date-selected=first]:bg-primary","group-data-[vc-date-selected=first]:text-primary-foreground","group-data-[vc-date-selected=first-and-last]:rounded-md","group-data-[vc-date-selected=last]:rounded-l-none","group-data-[vc-date-selected=last]:rounded-r-md","group-data-[vc-date-selected=last]:bg-primary","group-data-[vc-date-selected=last]:text-primary-foreground","group-data-[vc-date-selected=middle]:rounded-none","group-data-[vc-date-selected=middle]:bg-accent","group-data-[vc-date-selected=middle]:text-accent-foreground","group-data-[vc-date-today]:bg-accent","group-data-[vc-date-today]:text-accent-foreground","peer-checked:translate-x-[calc(100%-2px)]","peer-checked:scale-100","peer-checked:border-primary","peer-checked:bg-primary","peer-checked:bg-secondary","peer-checked:opacity-100","peer-focus:ring","peer-focus:ring-primary","peer-focus-visible:ring-2","peer-focus-visible:ring-ring","peer-focus-visible:ring-offset-2","peer-disabled:cursor-not-allowed","peer-disabled:opacity-50","peer-disabled:opacity-70","peer-data-[state=collapsed]:ml-[var(--sidebar-width-icon)]","selection:bg-primary","selection:text-primary-foreground","file:inline-flex","file:h-7","file:border-0","file:bg-transparent","file:text-sm","file:font-medium","file:text-foreground","placeholder:text-muted-foreground","before:pointer-events-none","before:absolute","before:inset-0","before:top-1/2","before:left-1/2","before:me-6","before:mb-2","before:block","before:inline-block","before:size-2","before:size-4","before:size-6","before:w-px","before:flex-1","before:-translate-x-1/2","before:translate-x-0","before:-translate-y-1/2","before:-rotate-90","before:rotate-90","before:transform","before:rounded-full","before:border-t","before:border-r","before:border-dashed","before:border-dotted","before:border-solid","before:border-border","before:bg-background","before:bg-current","before:bg-primary","before:bg-primary-foreground","before:mask-[url('{ArrowSvgBase64}')]","before:mask-center","before:mask-no-repeat","before:opacity-0","before:shadow","before:ring-0","before:transition","before:transition-all","before:transition-opacity","before:duration-200","before:ease-in-out","before:content-['']","peer-checked:before:absolute","peer-checked:before:top-1/2","peer-checked:before:left-1/2","peer-checked:before:size-2","peer-checked:before:-translate-x-1/2","peer-checked:before:-translate-y-1/2","peer-checked:before:rounded-full","peer-checked:before:bg-primary","peer-checked:before:content-['']","after:absolute","after:relative","after:inset-y-0","after:-top-1","after:top-6","after:-bottom-11","after:bottom-0","after:left-0","after:left-1/2","after:left-3","after:ms-6","after:mt-2","after:size-2","after:h-0.5","after:h-full","after:w-0.5","after:w-[2px]","after:w-full","after:w-px","after:flex-1","after:rotate-45","after:border-t","after:border-r","after:border-dashed","after:border-dotted","after:border-solid","after:border-border","after:bg-accent","after:bg-accent-foreground","after:bg-background","after:bg-border","after:bg-card","after:bg-card-foreground","after:bg-destructive","after:bg-destructive-foreground","after:bg-foreground","after:bg-info","after:bg-info-foreground","after:bg-input","after:bg-muted","after:bg-muted-foreground","after:bg-popover","after:bg-popover-foreground","after:bg-primary","after:bg-primary-foreground","after:bg-ring","after:bg-secondary","after:bg-secondary-foreground","after:bg-success","after:bg-success-foreground","after:bg-warning","after:bg-warning-foreground","after:content-['']","group-data-[collapsible=offcanvas]/sidebar-wrapper:after:left-full","first:mt-0","first:mt-2","first:rounded-l-md","last:mt-0","last:rounded-r-md","last:rounded-b-lg","last:border-b-0","checked:border-primary","checked:bg-primary","checked:bg-none","checked:text-primary","checked:before:ms-3.5","checked:before:translate-x-full","checked:before:bg-primary-foreground","checked:before:opacity-100","focus-within:relative","focus-within:z-20","hover:border-l-2","hover:bg-accent","hover:bg-accent/10","hover:bg-accent/20","hover:bg-accent/80","hover:bg-accent/90","hover:bg-amber-500/90","hover:bg-background/10","hover:bg-background/75","hover:bg-blue-600/90","hover:bg-destructive/10","hover:bg-destructive/20","hover:bg-destructive/80","hover:bg-destructive/90","hover:bg-foreground/10","hover:bg-foreground/20","hover:bg-foreground/80","hover:bg-foreground/90","hover:bg-gray-100","hover:bg-green-600/90","hover:bg-info/10","hover:bg-info/20","hover:bg-info/80","hover:bg-info/90","hover:bg-input/80","hover:bg-muted/50","hover:bg-primary","hover:bg-primary/5","hover:bg-primary/10","hover:bg-primary/20","hover:bg-primary/80","hover:bg-primary/90","hover:bg-secondary","hover:bg-secondary/10","hover:bg-secondary/20","hover:bg-secondary/50","hover:bg-secondary/75","hover:bg-secondary/80","hover:bg-secondary/90","hover:bg-sidebar-accent","hover:bg-success/10","hover:bg-success/20","hover:bg-success/80","hover:bg-success/90","hover:bg-warning/10","hover:bg-warning/20","hover:bg-warning/80","hover:bg-warning/90","hover:text-accent-foreground","hover:text-black","hover:text-foreground","hover:text-primary","hover:text-primary-foreground","hover:text-sidebar-accent-foreground","hover:underline","hover:opacity-75","hover:opacity-100","hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]","hover:shadow-sm","hover:group-data-[collapsible=offcanvas]/sidebar-wrapper:bg-sidebar","hover:after:bg-sidebar-border","focus:z-10","focus:border-primary","focus:bg-accent","focus:bg-primary","focus:text-accent-foreground","focus:text-primary-foreground","focus:underline","focus:ring","focus:ring-1","focus:ring-2","focus:ring-3","focus:ring-primary","focus:ring-primary/25","focus:ring-primary/50","focus:ring-ring","focus:ring-sidebar-ring","focus:ring-offset-2","focus:outline-hidden","focus:outline-offset-0","focus:outline-none","focus:ring-inset","focus:checked:border-primary","focus-visible:rounded-t-none","focus-visible:border-2","focus-visible:border-primary","focus-visible:border-ring","focus-visible:bg-accent","focus-visible:bg-primary/10","focus-visible:bg-secondary/10","focus-visible:bg-secondary/75","focus-visible:text-accent-foreground","focus-visible:text-foreground","focus-visible:underline","focus-visible:ring-0","focus-visible:ring-2","focus-visible:ring-[3px]","focus-visible:ring-accent/20","focus-visible:ring-destructive","focus-visible:ring-destructive/20","focus-visible:ring-foreground/20","focus-visible:ring-info","focus-visible:ring-info/20","focus-visible:ring-primary","focus-visible:ring-primary/20","focus-visible:ring-ring","focus-visible:ring-ring/50","focus-visible:ring-secondary","focus-visible:ring-secondary/20","focus-visible:ring-success","focus-visible:ring-success/20","focus-visible:ring-warning","focus-visible:ring-warning/20","focus-visible:ring-offset-2","focus-visible:outline-hidden","focus-visible:outline-1","focus-visible:outline-2","focus-visible:outline-destructive","focus-visible:outline-foreground","focus-visible:outline-info","focus-visible:outline-primary","focus-visible:outline-ring","focus-visible:outline-secondary","focus-visible:outline-success","focus-visible:outline-warning","focus-visible:outline-none","active:scale-90","active:scale-95","active:bg-sidebar-accent","active:text-sidebar-accent-foreground","active:opacity-100","active:shadow-none","active:-outline-offset-2","disabled:pointer-events-none","disabled:cursor-not-allowed","disabled:opacity-50","disabled:opacity-75","has-data-[slot=card-action]:grid-cols-[1fr_auto]","has-data-[state=checked]:border-primary","has-data-[state=checked]:bg-primary/5","has-data-[variant=inset]:bg-sidebar","has-[[data-slot=input-group-control]:focus-visible]:border-ring","has-[[data-slot=input-group-control]:focus-visible]:ring-[3px]","has-[[data-slot=input-group-control]:focus-visible]:ring-ring/50","has-[[data-slot][aria-invalid=true]]:border-destructive","has-[[data-slot][aria-invalid=true]]:ring-destructive/20","has-[select:disabled]:opacity-50","has-[>[data-align=block-end]]:h-auto","has-[>[data-align=block-end]]:flex-col","has-[>[data-align=block-start]]:h-auto","has-[>[data-align=block-start]]:flex-col","has-[>[data-slot=button-group]]:gap-2","has-[>[data-slot=checkbox-group]]:gap-3","has-[>[data-slot=field-content]]:items-start","has-[>[data-slot=field]]:w-full","has-[>[data-slot=field]]:flex-col","has-[>[data-slot=field]]:rounded-md","has-[>[data-slot=field]]:border","has-[>[data-slot=radio-group]]:gap-3","has-[>button]:mr-[-0.45rem]","has-[>button]:ml-[-0.45rem]","has-[>kbd]:mr-[-0.35rem]","has-[>kbd]:ml-[-0.35rem]","has-[>svg]:grid-cols-[calc(var(--spacing,1rem)*1)_1fr]","has-[>svg]:gap-x-3","has-[>svg]:p-0","has-[>svg]:px-2","has-[>svg]:px-2.5","has-[>svg]:px-3","has-[>svg]:px-4","has-[>svg]:px-6","has-[>textarea]:h-auto","aria-disabled:pointer-events-none","aria-disabled:opacity-50","aria-invalid:border-destructive","aria-invalid:ring-destructive/20","aria-pressed:bg-accent","aria-pressed:bg-accent/10","aria-pressed:bg-accent/80","aria-pressed:bg-accent/90","aria-pressed:bg-amber-500/90","aria-pressed:bg-blue-600/90","aria-pressed:bg-destructive/10","aria-pressed:bg-destructive/90","aria-pressed:bg-foreground/10","aria-pressed:bg-foreground/90","aria-pressed:bg-green-600/90","aria-pressed:bg-info/10","aria-pressed:bg-info/90","aria-pressed:bg-primary/10","aria-pressed:bg-primary/90","aria-pressed:bg-secondary/10","aria-pressed:bg-secondary/80","aria-pressed:bg-secondary/90","aria-pressed:bg-success/10","aria-pressed:bg-success/90","aria-pressed:bg-warning/10","aria-pressed:bg-warning/90","aria-pressed:text-accent-foreground","aria-pressed:opacity-75","aria-selected:bg-primary","aria-selected:text-primary-foreground","aria-selected:opacity-100","aria-selected:hover:bg-primary","aria-selected:hover:text-primary-foreground","aria-selected:focus:bg-primary","aria-selected:focus:text-primary-foreground","aria-[current=page]:z-10","aria-[current=page]:ring-2","aria-[current=page]:ring-primary","data-[active]:bg-accent/50","data-[active=true]:bg-accent","data-[active=true]:bg-accent/50","data-[active=true]:text-accent-foreground","data-[disabled]:pointer-events-none","data-[disabled]:opacity-50","data-[invalid=true]:text-destructive","data-[mobile-state=open]:translate-x-0","data-[motion=fade-in]:animate-in","data-[motion=fade-in]:fade-in-0","data-[motion=fade-in]:fade-in","data-[motion=fade-out]:animate-out","data-[motion=fade-out]:fade-out-0","data-[motion=fade-out]:fade-out","data-[motion=from-end]:slide-in-from-right-52","data-[motion=from-start]:slide-in-from-left-52","data-[motion=to-end]:slide-out-to-right-52","data-[motion=to-start]:slide-out-to-left-52","data-[motion^=from-]:animate-in","data-[motion^=from-]:fade-in","data-[motion^=to-]:animate-out","data-[motion^=to-]:fade-out","data-[orientation=vertical]:h-auto","data-[selected=true]:bg-accent","data-[selected=true]:text-accent-foreground","data-[side=bottom]:slide-in-from-top-2","data-[side=left]:border-r","data-[side=left]:slide-in-from-right-2","data-[side=left]:data-[mobile-state=closed]:-translate-x-full","data-[side=right]:border-l","data-[side=right]:slide-in-from-left-2","data-[side=right]:data-[mobile-state=closed]:translate-x-full","data-[side=top]:slide-in-from-bottom-2","data-[slot=checkbox-group]:gap-3","**:data-[slot=command-input-wrapper]:h-12","data-[slot=radio-group]:gap-3","data-[state=active]:bg-background","data-[state=active]:shadow-sm","data-[state=checked]:border-primary","data-[state=checked]:bg-primary","data-[state=checked]:text-primary-foreground","data-[state=closed]:animate-collapsible-up","data-[state=closed]:animate-out","data-[state=closed]:duration-300","data-[state=closed]:duration-500","data-[state=closed]:fade-out-0","data-[state=closed]:zoom-out-95","data-[state=closed]:slide-out-to-bottom","data-[state=closed]:slide-out-to-left","data-[state=closed]:slide-out-to-right","data-[state=closed]:slide-out-to-top","data-[state=hidden]:w-0","data-[state=hidden]:animate-out","data-[state=hidden]:opacity-0","data-[state=hidden]:fade-out","data-[state=open]:animate-collapsible-down","data-[state=open]:animate-in","data-[state=open]:bg-accent","data-[state=open]:bg-accent/50","data-[state=open]:bg-secondary","data-[state=open]:text-accent-foreground","data-[state=open]:text-muted-foreground","data-[state=open]:duration-500","data-[state=open]:fade-in-0","data-[state=open]:zoom-in-90","data-[state=open]:zoom-in-95","data-[state=open]:slide-in-from-bottom","data-[state=open]:slide-in-from-left","data-[state=open]:slide-in-from-right","data-[state=open]:slide-in-from-top","data-[state=visible]:animate-in","data-[state=visible]:fade-in","nth-last-2:-mt-1","motion-safe:animate-spin","motion-safe:transition-transform","motion-reduce:animate-none","motion-reduce:transition-opacity","motion-reduce:transition-none","max-md:fixed","max-md:inset-0","max-md:z-40","max-md:bg-black/50","sm:flex","sm:inline","sm:w-64","sm:max-w-2xl","sm:max-w-3xl","sm:max-w-4xl","sm:max-w-5xl","sm:max-w-6xl","sm:max-w-7xl","sm:max-w-lg","sm:max-w-md","sm:max-w-sm","sm:max-w-xl","sm:max-w-xs","sm:flex-row","sm:items-center","sm:justify-between","sm:justify-end","sm:gap-2.5","sm:bg-red-500","sm:text-left","sm:text-2xl","sm:text-base","sm:text-lg","sm:text-sm","sm:text-xl","md:left-[var(--sidebar-width)]","md:-my-4","md:ml-[--sidebar-width]","md:ml-[var(--sidebar-width)]","md:block","md:flex","md:hidden","md:w-1/2","md:w-1/3","md:w-60","md:w-[var(--sidebar-width)]","md:w-auto","md:flex-none","md:translate-x-0","md:flex-row","md:items-center","md:gap-2","md:space-x-5","md:p-6","md:p-12","md:pl-60","md:text-2xl","md:text-3xl","md:text-lg","md:text-sm","md:text-xl","md:group-data-[state=collapsed]:left-[var(--sidebar-width-icon)]","md:group-data-[state=collapsed]/sidebar-wrapper:left-[var(--sidebar-width-icon)]","md:group-data-[state=expanded]:left-[var(--sidebar-width)]","md:group-data-[state=expanded]/sidebar-wrapper:left-[var(--sidebar-width)]","md:peer-data-[state=collapsed]:left-[var(--sidebar-width-icon)]","md:peer-data-[state=expanded]:left-[var(--sidebar-width)]","md:peer-data-[variant=inset]:m-2","md:peer-data-[variant=inset]:ml-0","md:peer-data-[variant=inset]:rounded-xl","md:peer-data-[variant=inset]:shadow-sm","md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2","lg:flex","lg:p-8","lg:py-1.5","lg:text-2xl","lg:text-3xl","lg:text-4xl","lg:text-5xl","xl:flex","xl:pr-48","xl:pr-56","xl:pr-64","xl:pr-72","xl:pr-80","@md/field-group:flex-row","@md/field-group:items-center","@md/field-group:has-[>[data-slot=field-content]]:items-start","dark:divide-gray-700","dark","dark:border-accent","dark:border-amber-700","dark:border-amber-950","dark:border-blue-700","dark:border-destructive","dark:border-foreground","dark:border-gray-600","dark:border-green-700","dark:border-info","dark:border-input","dark:border-primary","dark:border-secondary","dark:border-slate-700","dark:border-success","dark:border-transparent","dark:border-warning","dark:bg-accent/60","dark:bg-amber-900/30","dark:bg-amber-950","dark:bg-background","dark:bg-background/10","dark:bg-blue-900/30","dark:bg-destructive","dark:bg-destructive/10","dark:bg-destructive/15","dark:bg-destructive/60","dark:bg-emerald-800","dark:bg-foreground","dark:bg-foreground/60","dark:bg-gray-700","dark:bg-gray-800","dark:bg-gray-900/50","dark:bg-green-900/30","dark:bg-info","dark:bg-info/10","dark:bg-info/15","dark:bg-info/60","dark:bg-input/30","dark:bg-input/80","dark:bg-neutral-700","dark:bg-primary","dark:bg-primary/60","dark:bg-secondary","dark:bg-secondary/60","dark:bg-success","dark:bg-success/10","dark:bg-success/15","dark:bg-success/60","dark:bg-transparent","dark:bg-warning","dark:bg-warning/10","dark:bg-warning/15","dark:bg-warning/60","dark:text-amber-100","dark:text-amber-300","dark:text-blue-300","dark:text-destructive","dark:text-destructive-foreground","dark:text-foreground","dark:text-gray-300","dark:text-gray-400","dark:text-gray-500","dark:text-green-300","dark:text-info","dark:text-info-foreground","dark:text-muted-foreground","dark:text-primary","dark:text-primary-foreground","dark:text-red-400","dark:text-secondary","dark:text-success","dark:text-success-foreground","dark:text-warning","dark:text-warning-foreground","dark:placeholder-gray-400","dark:placeholder-muted-foreground","dark:shadow-gray-900","dark:ring-gray-700","dark:ring-offset-gray-900","dark:peer-checked:border-primary","dark:peer-checked:bg-primary","dark:peer-checked:bg-primary-foreground","dark:peer-checked:bg-secondary","dark:before:bg-foreground","dark:before:bg-primary-foreground","dark:peer-checked:before:bg-primary","dark:checked:border-primary","dark:checked:border-transparent","dark:checked:bg-primary","dark:checked:before:bg-primary","dark:checked:before:bg-primary-foreground","dark:hover:bg-accent","dark:hover:bg-accent/20","dark:hover:bg-accent/50","dark:hover:bg-background/5","dark:hover:bg-background/10","dark:hover:bg-destructive/20","dark:hover:bg-destructive/50","dark:hover:bg-foreground/20","dark:hover:bg-foreground/50","dark:hover:bg-info/20","dark:hover:bg-info/50","dark:hover:bg-input/50","dark:hover:bg-primary/5","dark:hover:bg-primary/20","dark:hover:bg-primary/50","dark:hover:bg-secondary","dark:hover:bg-secondary/20","dark:hover:bg-secondary/50","dark:hover:bg-secondary/75","dark:hover:bg-success/20","dark:hover:bg-success/50","dark:hover:bg-warning/20","dark:hover:bg-warning/50","dark:hover:text-accent-foreground","dark:hover:text-foreground","dark:hover:text-white","dark:focus:border-primary","dark:focus:ring-primary","dark:focus:ring-primary/40","dark:focus:ring-offset-neutral-600","dark:focus-visible:border-primary","dark:focus-visible:bg-background/10","dark:focus-visible:bg-primary/10","dark:focus-visible:bg-secondary/75","dark:focus-visible:text-foreground","dark:focus-visible:ring-accent/40","dark:focus-visible:ring-destructive","dark:focus-visible:ring-destructive/40","dark:focus-visible:ring-foreground/40","dark:focus-visible:ring-info","dark:focus-visible:ring-info/40","dark:focus-visible:ring-primary","dark:focus-visible:ring-primary/40","dark:focus-visible:ring-secondary","dark:focus-visible:ring-secondary/40","dark:focus-visible:ring-success","dark:focus-visible:ring-success/40","dark:focus-visible:ring-warning","dark:focus-visible:ring-warning/40","dark:focus-visible:ring-offset-background","dark:focus-visible:ring-offset-secondary","dark:focus-visible:outline-destructive","dark:focus-visible:outline-foreground","dark:focus-visible:outline-info","dark:focus-visible:outline-primary","dark:focus-visible:outline-secondary","dark:focus-visible:outline-success","dark:focus-visible:outline-warning","dark:has-data-[state=checked]:bg-primary/10","dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40","dark:aria-invalid:ring-destructive/40","dark:aria-pressed:bg-accent/20","dark:aria-pressed:bg-accent/50","dark:aria-pressed:bg-destructive/20","dark:aria-pressed:bg-destructive/50","dark:aria-pressed:bg-foreground/20","dark:aria-pressed:bg-foreground/50","dark:aria-pressed:bg-info/20","dark:aria-pressed:bg-info/50","dark:aria-pressed:bg-primary/20","dark:aria-pressed:bg-primary/50","dark:aria-pressed:bg-secondary/20","dark:aria-pressed:bg-secondary/50","dark:aria-pressed:bg-success/20","dark:aria-pressed:bg-success/50","dark:aria-pressed:bg-warning/20","dark:aria-pressed:bg-warning/50","dark:data-[state=active]:border-input","dark:data-[state=active]:bg-input/30","dark:data-[state=active]:text-foreground","dark:data-[state=checked]:bg-primary","[&_.ts-control]:!border-destructive","ts-control","[&_.ts-control]:!ring-destructive/20","[&_[data-slot=command-group-heading]]:px-2","[&_[data-slot=command-group-heading]]:font-medium","[&_[data-slot=command-group-heading]]:text-muted-foreground","[&_[data-slot=command-group]]:px-2","[&_[data-slot=command-group]:not([hidden])_~[data-slot=command-group]]:pt-0","[&_[data-slot=command-input-wrapper]]:h-12","[&_[data-slot=command-input-wrapper]_svg]:h-5","[&_[data-slot=command-input-wrapper]_svg]:w-5","[&_[data-slot=command-input]]:h-12","[&_[data-slot=command-item]]:px-2","[&_[data-slot=command-item]]:py-3","[&_[data-slot=command-item]_svg]:h-5","[&_[data-slot=command-item]_svg]:w-5","peer-checked:[&_[data-slot=indicator]]:opacity-100","[&_img]:size-full","[&_img]:object-cover","[&_p]:leading-relaxed","[&_svg]:pointer-events-none","[&_svg]:shrink-0","[&_svg:not([class*='size-'])]:size-3","[&_svg:not([class*='size-'])]:size-4","[&_svg:not([class*='size-'])]:size-6","[&_svg:not([class*='text-'])]:text-muted-foreground","[&_tr]:border-b","[&_tr:last-child]:border-0","[&_ul]:list-inside","[&_ul]:list-disc","[&+[data-slot=item-content]]:flex-none","[&:has([aria-selected])]:bg-accent","first:[&:has([aria-selected])]:rounded-l-md","last:[&:has([aria-selected])]:rounded-r-md","[&:has([aria-selected].day-outside)]:bg-accent/50","day-outside","[&:has([aria-selected].day-range-end)]:rounded-r-md","day-range-end","[&:has([role=checkbox])]:pr-0","[.border-b]:pb-3","[.border-b]:pb-6","[.border-t]:pt-3","[.border-t]:pt-6","[a]:transition-colors","[a]:hover:bg-accent/50","[aria-selected='true']:bg-background","[aria-selected='true']:shadow-sm","[aria-selected='true']:dark:border-input","[aria-selected='true']:dark:bg-input/30","[aria-selected='true']:dark:text-foreground","[&:not(:first-child)]:mt-6","[&:not([aria-selected='true'])]:bg-transparent","[&>*]:w-full","[&>*]:shadow-none","[&>*]:focus-visible:relative","[&>*]:focus-visible:z-10","[&>*]:data-[slot=field]:p-4","@md/field-group:[&>*]:w-auto","[&>*:not(:first-child)]:rounded-t-none","[&>*:not(:first-child)]:rounded-l-none","[&>*:not(:first-child)]:border-t-0","[&>*:not(:first-child)]:border-l-0","[&>*:not(:last-child)]:rounded-r-none","[&>*:not(:last-child)]:rounded-b-none","[&>.sr-only]:w-auto","[&>[data-slot=field-group]]:gap-4","[&>[data-slot=field-label]]:flex-auto","@md/field-group:[&>[data-slot=field-label]]:flex-auto","has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md","[&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit","[&>[role=checkbox]]:translate-y-[2px]","has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px","@md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px","[&>a]:underline","[&>a]:underline-offset-4","[&>a:hover]:text-primary","[&>button]:hidden","[&>input]:flex-1","has-[>[data-align=block-end]]:[&>input]:pt-3","has-[>[data-align=block-start]]:[&>input]:pb-3","has-[>[data-align=inline-end]]:[&>input]:pr-2","has-[>[data-align=inline-start]]:[&>input]:pl-2","[&>kbd]:rounded-[calc(var(--radius)-5px)]","peer-checked:[&>span]:translate-x-[calc(100%-2px)]","dark:peer-checked:[&>span]:bg-primary-foreground","[&>span:last-child]:truncate","group-data-[state=collapsed]/sidebar:[&>span:last-child]:hidden","[&>svg]:size-4","[&>svg]:shrink-0","[&>svg:not([class*='size-'])]:size-3.5","[&>svg:not([class*='size-'])]:size-4","[&>tr]:last:border-b-0","[&[aria-current=page]]:bg-sidebar-accent","[&[aria-current=page]]:font-medium","[&[aria-current=page]]:text-sidebar-accent-foreground","[[data-side=left][data-collapsible=offcanvas]_&]:-right-2","[[data-side=left][data-state=collapsed]_&]:cursor-e-resize","[[data-side=right][data-collapsible=offcanvas]_&]:-left-2","[[data-side=right][data-state=collapsed]_&]:cursor-w-resize","[[data-slot=tooltip-content]_&]:bg-background/20","[[data-slot=tooltip-content]_&]:text-background","dark:[[data-slot=tooltip-content]_&]:bg-background/10","[[data-variant=legend]+&]:-mt-1.5","[a&]:hover:bg-accent","[a&]:hover:bg-destructive/90","[a&]:hover:bg-primary/90","[a&]:hover:bg-secondary/90","[a&]:hover:text-accent-foreground","sn-notifications-container","sn-is-x-center","sn-is-y-center","sn-is-center","sn-is-left","sn-is-right","sn-is-top","sn-is-bottom","sn-notify","sn-notify-icon","sn-notify-close","sn-notify-title","sn-notify-text","sn-notify-outline","sn-notify-success","sn-notify-error","sn-notify-warning","sn-notify-info","sn-notify-filled","sn-notify-fade","sn-notify-fade-in","sn-notify-slide","sn-notify-slide-in","sn-notify-autoclose","form-children-spacing","validation-errors","field-validation-error","input-validation-error","input-validation-valid","validation-summary-errors","validation-summary-valid","hljs","hljs-subst","hljs-comment","hljs-keyword","hljs-selector-tag","hljs-meta","hljs-doctag","hljs-section","hljs-attr","hljs-attribute","hljs-name","hljs-type","hljs-number","hljs-selector-id","hljs-quote","hljs-template-tag","hljs-selector-class","hljs-string","hljs-regexp","hljs-symbol","hljs-variable","hljs-template-variable","hljs-link","hljs-selector-attr","hljs-selector-pseudo","hljs-built_in","hljs-title","hljs-literal","hljs-bullet","hljs-code","hljs-deletion","hljs-addition","hljs-emphasis","hljs-strong","flatpickr-calendar","open","animate","arrowTop","arrowBottom","arrowCenter","rightMost","arrowRight","flatpickr-wrapper","flatpickr-months","flatpickr-month","flatpickr-prev-month","flatpickr-next-month","flatpickr-current-month","cur-month","numInputWrapper","cur-year","flatpickr-monthDropdown-months","flatpickr-weekdays","flatpickr-weekdaycontainer","flatpickr-weekday","flatpickr-days","dayContainer","flatpickr-day","inRange","today","selected","startRange","endRange","flatpickr-disabled","prevMonthDay","nextMonthDay","notAllowed","flatpickr-weekwrapper","flatpickr-weeks","flatpickr-innerContainer","flatpickr-rContainer","flatpickr-time","hasSeconds","time24hr","flatpickr-hour","flatpickr-minute","flatpickr-second","flatpickr-time-separator","flatpickr-am-pm","ts-wrapper","focus","disabled","invalid","is-invalid","has-items","item","active","ts-dropdown","ts-dropdown-content","option","highlight","optgroup-header","optgroup","no-results","create","plugin-remove_button","remove","plugin-clear_button","clear-button","plugin-drag_drop","ts-dragging","plugin-checkbox_options","plugin-dropdown_input","dropdown-input-wrap","dropdown-input","loading","single","ts-hidden-accessible","scrollbar","prose","not-prose","lead","large","small","muted","rizzy-vc-arrow","card","form","input","dialog","label","popover","select","tabs","textarea","prose-compact","prose-comfortable","prose-relaxed","prose-wide","prose-ultrawide","prose-full","scrollbar-hover","grid-pattern"];
</file>

</files>

<instruction>
### **The Definitive Guide to Authoring a RizzyUI Component (Version 3.3 - `data-slot` and TailwindVariants.NET Pattern)**

**Fully expanded specification for code-generation models  May 2025, rev 3.3**

---

## 0. Why this file exists

This guide is a **contract for any large-language model**ChatGPT, Claude, Gemini, Azure OpenAI, etc.that emits source code destined for the **RizzyUI** repository.
If the model follows every rule, a maintainer can:

1.  Paste the generated files into `src/RizzyUI/`.
2.  Apply the indicated cross-file edits (see  14).
3.  Run `dotnet build`.

The solution should compile, pass unit tests, and conform to RizzyUIs conventions **without manual tweaks**.

SPECIAL NOTE: @* *@ comments in this document are used to provide LLM guidance only. They are **not** to be included in the generated code.

---

## 1. Output-file syntax (mandatory for new or replacement files)

When the user requests code, wrap each file in a single **`output` block** so automation scripts know where to save it.

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">
  <!-- Razor markup -->
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">
  <!-- C# code-behind -->
  </file>
</files>
```
````

*   Never nest `<files>` elements.
*   Always close every `<file>` tag.
*   If no new files are needed, **omit** the `output` block entirely.
*   Wrap the entire files response in a single markdown `output` block when generating multiple files.

---

## 2. Root element pattern (in every `.razor` file)

```razor
<HtmlElement Element="@EffectiveElement"
             id="@Id"
             class="@SlotClasses.GetBase()"
             data-slot="fancy-thing"
             @attributes="@AdditionalAttributes">
    @* Optional content here, like an Alpine child-container *@
</HtmlElement>
```

*   `Element="@EffectiveElement"` keeps the tag overridable (default "div" in `RzComponent`).
*   `@Id` is required for HTMX, Alpine, and tests.
*   `@SlotClasses.GetBase()` is supplied by the `TailwindVariants.NET` system in the code-behind.
*   `data-slot="component-name"` is a **mandatory** attribute. The value should be the kebab-case version of the component's name (e.g., `RzFancyThing` becomes `fancy-thing`).
*   **Always** convert enum values used as data- attributes into kebab-case (e.g. MyEnumProperty.ToString().ToKebabCase()).
*   **Always** write `@attributes="@AdditionalAttributes"` (note the leading `@`).
*   **Never** use @* *@ comments inside Razor markup for elements that will be rendered.
*   To change the `Element` type, override `OnInitialized()` in the code-behind. Set `Element` to the new type only if `Element` is empty or null.
    ```csharp
            if (string.IsNullOrEmpty(Element))
                Element = "nav";
    ```

---

## 3. `.razor` File Guidelines

*   **Namespace:** Add `@namespace RizzyUI`.
*   **Inheritance:** Add `@inherits RzComponent<ComponentName.Slots>` for non-generic components or `@inherits RzComponent<ComponentNameSlots>` for generic components.
*   **Component Naming Convention:**
    *   For **root-level components**, the component name MUST be prefixed with `Rz` (e.g., `RzDropdownMenu`).
    *   For **nested components**, the `Rz` prefix MUST be omitted (e.g., `DropdownMenuLabel`).
*   **Root Element:** Use the pattern in 2.
*   **CSS Classes and `data-slot` for Internal Elements:**
    *   Every HTML element *inside* the root element that receives styling from a slot **MUST** have both a `class` attribute and a `data-slot` attribute.
    *   The `class` attribute MUST use the source-generated `SlotClasses.Get...()` accessor (e.g., `class="@SlotClasses.GetIcon()"`).
    *   The `data-slot` attribute's value MUST be retrieved using the source-generated `SlotNames.NameOf(...)` helper. The syntax depends on whether the component is generic.
        *   **Non-Generic Components** (nested `Slots` class): `data-slot="@RzComponentName.SlotNames.NameOf(SlotTypes.SlotPropertyName)"`
            *   Example: `data-slot="@RzFancyThing.SlotNames.NameOf(SlotTypes.Icon)"`
        *   **Generic Components** (external `Slots` class): `data-slot="@ComponentNameSlotNames.NameOf(ComponentNameSlotTypes.SlotPropertyName)"`
            *   Example: `data-slot="@TableHeaderCellSlotNames.NameOf(TableHeaderCellSlotTypes.SortIndicator)"`
*   **Alpine Integration:** See 10 for the Alpine child-container convention if Alpine is used.
*   **Accessibility:** Refer to 8 for accessibility guidelines.
*   **Localization:** Refer to 9 for localization guidelines.

---

## 4. Code-behind skeleton (`.razor.cs`)

```csharp
// src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using Blazicons;
using TailwindVariants.NET;
// Add other necessary using statements

namespace RizzyUI;

/// <summary>
/// Brief description of RzFancyThing and its purpose.
/// </summary>
public partial class RzFancyThing : RzComponent<RzFancyThing.Slots>
{
    /// <summary>
    /// Defines the default styling for the RzFancyThing component.
    /// </summary>
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(
        @base: "inline-flex items-center font-medium rounded",
        slots: new()
        {
            [s => s.Icon] = "size-5"
        },
        variants: new()
        {
            [c => ((RzFancyThing)c).Size] = new Variant<Size, Slots>
            {
                [Size.Small] = new() { [s => s.Base] = "text-xs py-1 px-2" },
                [Size.Medium] = new() { [s => s.Base] = "text-sm py-2 px-3" }
            },
            [c => ((RzFancyThing)c).IsActive] = new Variant<bool, Slots>
            {
                [true] = new() { [s => s.Base] = "ring-2 ring-primary" }
            }
        }
    );

    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public SvgIcon? Icon { get; set; }
    [Parameter] public Size Size { get; set; } = Size.Medium;
    [Parameter] public bool IsActive { get; set; }
    [Parameter] public string? AriaLabel { get; set; }

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzFancyThing;

    /// <summary>
    /// Defines the slots available for styling in the RzFancyThing component.
    /// </summary>
    public sealed partial class Slots : ISlots
    {
        [Slot("fancy-thing")]
        public string? Base { get; set; }
        [Slot("icon")]
        public string? Icon { get; set; }
    }
}
```

Important for the LLM:

*   Start with `/// <summary>...</summary>` for the class.
*   **All** public members get `<summary>` XML docs.
*   Inherit from `RzComponent<TSlots>` or `RzAsChildComponent<TSlots>`.
*   Define a `public sealed partial class Slots : ISlots` inside the component class for non-generic components.
*   **All properties in the `Slots` class MUST be decorated with the `[Slot("kebab-case-name")]` attribute.** The name should match `shadcn/ui` conventions where applicable.
*   For components inheriting from `RzAsChildComponent`, the `Base` slot's classes are merged onto the child element. The `[Slot(...)]` attribute is still required on the `Base` property in the `Slots` class.
*   Define a `public static readonly TvDescriptor<...>` with all base, slot, and variant styles.
*   Implement `protected override TvDescriptor<...> GetDescriptor() => Theme.ComponentName;`.
*   Handle default localized strings for parameters like `AriaLabel` (9).

---

## 5. Icon-passing protocol

```razor
@* Inside RzFancyThing.razor *@
@if (Icon is not null)
{
    <Blazicon Svg="@Icon"
              class="@SlotClasses.GetIcon()"
              data-slot="@RzFancyThing.SlotNames.NameOf(SlotTypes.Icon)"
              aria-hidden="true" />
}
```

*   Accept icons as `SvgIcon?`.
*   Style the `<Blazicon>` using the source-generated `SlotClasses.Get...()` accessor.
*   Add the mandatory `data-slot` attribute using the `SlotNames.NameOf(...)` helper.
*   Add `aria-hidden="true"` if the icon is purely decorative.

---

## 6. Styling with TailwindVariants.NET

RizzyUI uses its own **Tailwind 4 plugin** that defines a palette of **CSS custom-property tokens** (e.g., `--background`, `--primary`).

### 6.1 Semantic tokens, not raw palette colors

You never hard-code `text-blue-600` or `bg-slate-900`. Instead, you write utilities that reference the semantic tokens:

```
bg-background
text-foreground
hover:bg-accent
ring-primary
```

Because the token names stay identical across light and dark modes, you do **not** need `dark:` prefixes for these semantic tokens.

### 6.2 Where utilities live

All styling logicbase classes, slot-specific classes, and conditional variantsbelongs in the `TvDescriptor` defined within the component's `.razor.cs` or `Styling/ComponentNameStyles.cs` file.

### 6.3 Automatic Class Merging

The `RzComponent<TSlots>` base class automatically handles merging classes. The `TwVariants.Invoke` method combines classes from the `TvDescriptor` with any `class` attribute provided by the user on the component tag. You do not need to manually call `TwMerge`.

### 6.4 Defining Variants in the Descriptor

Variants are defined within the `variants` property of the `TvDescriptor`. They map a component parameter's value to a set of CSS classes.

```csharp
// In the TvDescriptor
variants: new()
{
    [c => ((RzFancyThing)c).Size] = new Variant<Size, Slots>
    {
        [Size.Small] = new() { [s => s.Base] = "text-xs py-1 px-2" },
        [Size.Medium] = new() { [s => s.Base] = "text-sm py-2 px-3" }
    }
}
```

### 6.5 Handling Nullable Enum Parameters in Variants

When a component `[Parameter]` is a **nullable enum** (e.g., `public SemanticColor? TextColor { get; set; }`), the corresponding `Variant` definition in the `TvDescriptor` **MUST** use the **non-nullable** enum type for its generic parameter. The library automatically handles `null` values by not applying a variant class.

** WRONG:** The generic type `Variant<SemanticColor?, Slots>` is nullable.
```csharp
// This is incorrect and will cause issues.
[c => ((RzHeading)c).TextColor] = new Variant<SemanticColor?, Slots> { ... }
```

** CORRECT:** The generic type `Variant<SemanticColor, Slots>` is non-nullable.
```csharp
// This is the correct pattern.
[c => ((RzHeading)c).TextColor] = new Variant<SemanticColor, Slots> { ... }
```

---

## 7. The TvDescriptor Pattern (Styling Providers)

The styling system is based on the `TvDescriptor`, which encapsulates all styling logic for a component. The implementation pattern differs depending on whether the component is generic.

### 7.1 For Non-Generic Components (Self-Contained Pattern)

For a non-generic component like `RzButton`, the `Slots` class and the `DefaultDescriptor` are defined directly within the component's `.razor.cs` file.

```csharp
// src/RizzyUI/Components/Form/RzButton/RzButton.razor.cs
public partial class RzButton : RzComponent<RzButton.Slots>
{
    public static readonly TvDescriptor<RzComponent<Slots>, Slots> DefaultDescriptor = new(/* ... */);

    // ... parameters ...

    protected override TvDescriptor<RzComponent<Slots>, Slots> GetDescriptor() => Theme.RzButton;

    public sealed partial class Slots : ISlots
    {
        [Slot("button")]
        public string? Base { get; set; }
    }
}
```

### 7.2 For Generic Components (External Styling Pattern)

If a component is generic (e.g., `TableHeaderCell<TItem>`) or requires decoupled styling, you **MUST** NOT define the `Slots` or `TvDescriptor` in the main `.razor.cs` file. Instead, use the External Styling Pattern.

**1. Create the Styles File:**
Create a file named `Styling/{ComponentName}Styles.cs` within the component's directory.

**2. Define Three Types in the Styles File:**
This file MUST contain exactly these three types:
*   **A Styling Interface:** `public interface IHas{ComponentName}StylingProperties` containing only the properties needed for variants.
*   **The Slots Class:** `public sealed partial class {ComponentName}Slots : ISlots` with all `[Slot]` decorated properties.
*   **A Static Styles Class:** `public static class {ComponentName}Styles` containing the `DefaultDescriptor`.

**Example: `Styling/TableHeaderCellStyles.cs`**

```csharp
using TailwindVariants.NET;

namespace RizzyUI;

// 1. Styling Interface
public interface IHasTableHeaderCellStylingProperties
{
    public bool Sortable { get; }
    public SortDirection CurrentSortDirection { get; }
}

// 2. Slots Class
public sealed partial class TableHeaderCellSlots : ISlots
{
    [Slot("table-header-cell")]
    public string? Base { get; set; }
    [Slot("sort-indicator")]
    public string? SortIndicator { get; set; }
}

// 3. Static Styles Class
public static class TableHeaderCellStyles
{
    public static readonly TvDescriptor<RzComponent<TableHeaderCellSlots>, TableHeaderCellSlots> DefaultDescriptor = new(
        @base: "...",
        variants: new()
        {
            // Cast to the interface in variant expressions
            [c => ((IHasTableHeaderCellStylingProperties)c).Sortable] = new Variant<bool, TableHeaderCellSlots> { ... }
        }
    );
}```

**3. Update the Component (`.razor.cs`):**
The component must then inherit from `RzComponent<{ComponentName}Slots>` and implement the styling interface.

```csharp
public partial class TableHeaderCell<TItem> : RzComponent<TableHeaderCellSlots>, IHasTableHeaderCellStylingProperties
{
    // ... implementation ...
    protected override TvDescriptor<RzComponent<TableHeaderCellSlots>, TableHeaderCellSlots> GetDescriptor() => Theme.TableHeaderCell;
}
```

---

## 8. Accessibility Best Practices

Ensuring components are accessible is paramount. LLMs must generate components that strive to adhere to WCAG standards where applicable.

*   **Semantic HTML:**
    *   Use the most appropriate HTML element for the component's role. The `Element` property in `RzComponent` (defaulting to "div") should be overridden in `OnInitialized()` if a more semantic tag like `<nav>`, `<button>`, `<aside>`, etc., is suitable.
    *   Example: A navigation component should use `<nav>`, a button should use `<button>` or `<a>` with `role="button"`.

*   **ARIA Attributes:**
    *   **Roles:** Apply appropriate `role` attributes (e.g., `role="alert"`, `role="dialog"`, `role="menuitem"`, `role="tab"`, `role="switch"`). The root element pattern in 2 can have its `role` set via `AdditionalAttributes` or directly if static.
    *   **Labels & Descriptions:**
        *   Every interactive component MUST have an accessible name. This is typically provided via an `AriaLabel` parameter in the `.razor.cs` file. If the component has visible text that serves as its label, ensure it's associated (e.g., `<label for="...">` for form inputs, or `aria-labelledby` pointing to the ID of the visible text element).
        *   Use `aria-label` for concise labels when visible text is insufficient or absent (e.g., icon-only buttons).
        *   Use `aria-labelledby` to associate the component with existing visible text that acts as its label.
        *   Use `aria-describedby` to associate the component with descriptive text that provides more context.
    *   **States & Properties:** Use ARIA attributes to convey state:
        *   `aria-expanded` (for accordions, dropdowns, collapsible sections)
        *   `aria-selected` (for tabs, items in a listbox)
        *   `aria-current` (for pagination, breadcrumbs, steps - e.g., `aria-current="page"` or `aria-current="step"`)
        *   `aria-pressed` (for toggle buttons)
        *   `aria-hidden` (use judiciously, e.g., for purely decorative icons or off-screen content)
        *   `aria-modal="true"` (for modal dialogs)
        *   `aria-live` (for dynamic content updates, e.g., alerts, status messages)
        *   `aria-controls` (to link a control to the region it manages)
        *   For inputs: `aria-required`, `aria-invalid`.

*   **Keyboard Navigation & Focus Management:**
    *   All interactive elements MUST be keyboard operable.
    *   Use `tabindex="0"` for custom interactive elements that should be in the tab order.
    *   Use `tabindex="-1"` for elements that should be programmatically focusable but not in the default tab order.
    *   For composite widgets (like dropdowns, menus, tabs), implement appropriate keyboard navigation patterns (arrow keys, Home/End, Enter/Space). This is often handled by the Alpine.js logic.
    *   Ensure a visible focus indicator. RizzyUI themes generally provide this, but be mindful if overriding default focus styles.
    *   For modals and dropdowns that trap focus, use Alpine's `x-trap.inert="isOpen"` directive.

*   **Screen Reader Text:**
    *   Use the `sr-only` Tailwind class (or equivalent CSS) for text that should only be available to screen readers (e.g., providing context for an icon button).
        ```razor
        <button aria-label="@Localizer["RzComponentName.CloseButtonAriaLabel"]">
            <Blazicon Svg="@MdiIcon.Close" aria-hidden="true" />
            <span class="sr-only">@Localizer["RzComponentName.CloseButtonSrText"]</span> @* Alternative if aria-label isn't sufficient *@
        </button>
        ```

*   **Images & Icons:**
    *   Decorative icons should have `aria-hidden="true"`.
    *   Informative icons (if not accompanied by text) need an accessible label (e.g., via `aria-label` on the button or a `sr-only` span).
    *   Images (e.g., `RzAvatar`) must have meaningful `alt` text or `aria-label`.

*   **Forms:**
    *   Associate labels with form controls using `<label for="...">` and matching `id` on the input. `RzFieldLabel` handles this if `For` is provided.
    *   Use `fieldset` and `legend` for groups of related controls (e.g., radio button groups).
    *   Provide clear validation messages, associated with inputs using `aria-describedby`. `RzValidationMessage` typically handles this.

---

## 9. Localization

All user-facing strings within components (default labels, ARIA labels, titles, placeholders, etc.) MUST be localizable.

*   **Accessing Localizer:**
    *   The `RzComponent` base class injects `IStringLocalizer<RizzyLocalization> Localizer`. Use this to retrieve localized strings.

*   **Resource Key Convention:**
    *   Resource keys should follow the pattern: `ComponentName.ResourceKeyName`.
    *   Example: For a default ARIA label in `RzFancyThing`, the key would be `RzFancyThing.DefaultAriaLabel`.
    *   Example: For a "Close" button text, `RzModal.CloseButtonText`.

*   **Parameter Defaults & Localization:**
    *   Component parameters that accept user-facing strings (e.g., `AriaLabel`, `Title`, `Placeholder`) should allow users to provide their own values.
    *   If the user does *not* provide a value for such a parameter (i.e., it remains `null` or its default), the component should attempt to load a localized default string.
    *   This is typically done in `OnInitialized()` and/or `OnParametersSet()`:
        ```csharp
        // In RzFancyThing.razor.cs
        [Parameter] public string? AriaLabel { get; set; }
        [Parameter] public string? PlaceholderText { get; set; }

        protected override void OnInitialized()
        {
            base.OnInitialized();
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }

        protected override void OnParametersSet()
        {
            base.OnParametersSet();
            // If parameters can be changed after init and might become null
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }
        ```

*   **Providing New Resource Strings (LLM Output):**
    *   When generating a new component that introduces new localizable strings, the LLM MUST provide the English (default culture) versions of these strings.
    *   These should be presented in a clear key-value format, suitable for a developer to copy into the `src/RizzyUI/Resources/RizzyLocalization.resx` file.
    *   This information should be provided *outside* the main ````output ... ```` block, typically alongside the "Manual Edits Required for Theme Integration" section.

    **Example Presentation for New Resource Strings:**

    ````markdown
    **New English Localization Strings for `RizzyLocalization.resx`:**

    Please add the following entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

    | Name                               | Value                         | Comment (Optional)                  |
    |------------------------------------|-------------------------------|-------------------------------------|
    | `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
    | `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |
    | `RzAnotherComponent.SomeText`      | `Another default string`      |                                     |

    Alternatively, in raw .resx XML format:
    ```xml
    <data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
      <value>Fancy interactive element</value>
      <comment>Default ARIA label for RzFancyThing</comment>
    </data>
    <data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
      <value>Enter fancy text here...</value>
      <comment>Placeholder for RzFancyThing input</comment>
    </data>
    <data name="RzAnotherComponent.SomeText" xml:space="preserve">
      <value>Another default string</value>
    </data>
    ```
    ````

---

## 10. Alpine.js Integration & Asset Bundling

RizzyUI components that require client-side interactivity leverage Alpine.js. The integration follows a specific pattern for defining components, managing their assets, and ensuring CSP compliance.

### 10.1 Alpine.js API Restrictions (CSP Build)

**It is CRITICAL to understand and adhere to these API restrictions when writing Alpine.js code for RizzyUI components.** Since Alpine.js, when built for Content Security Policy (CSP) compliance, can no longer interpret strings as plain JavaScript, it has to parse and construct JavaScript functions from them manually.

Due to this limitation, you **MUST** use `Alpine.data` to register your `x-data` objects, and **MUST** reference properties and methods from it by key only.

For example, an inline component like this **will not work** with the CSP build:

```html
<!-- Bad -->
<div x-data="{ count: 1 }">
    <button @click="count++">Increment</button>
    <span x-text="count"></span>
</div>
```

However, breaking out the expressions into external APIs, the following is **valid** with the CSP build:

```html
<!-- Good -->
<div x-data="counter">
    <button @click="increment">Increment</button>
    <span x-text="count"></span>
</div>
```

```javascript
Alpine.data('counter', () => ({
    count: 1,
    increment() {
        this.count++
    },
}))
```

The CSP build supports accessing nested properties (property accessors) using the dot notation:

```html
<!-- This works too -->
<div x-data="counter">
    <button @click="foo.increment">Increment</button>
    <span x-text="foo.count"></span>
</div>
```

```javascript
Alpine.data('counter', () => ({
    foo: {
        count: 1,
        increment() {
            this.count++
        },
    },
}))
```

**Key Takeaways for LLMs:**
*   **Always use `Alpine.data`** for `x-data` definitions. Never inline `x-data` objects.
*   **Reference properties and methods by key only** (e.g., `increment`, `count`, `foo.increment`). Avoid complex inline expressions like `count++`, `isActive = !isActive`, or `myFunction(param1, param2)`. Instead, encapsulate such logic within methods defined in your `Alpine.data` object.
*   Dot notation for nested properties is allowed.

### 10.2 Alpine Child-Container Convention (in `.razor` file)

If a RizzyUI component uses Alpine.js, its root `<HtmlElement>` in the `.razor` file MUST contain a direct child `<div>` with the following attributes. This `div` serves as the root for the Alpine component.

```razor
<HtmlElement Element="@EffectiveElement" id="@Id" class="@SlotClasses.GetBase()" @attributes="@AdditionalAttributes">
    <div data-alpine-root="@Id" @* Crucial: Must match the Blazor component's @Id *@
         x-data="rzFancyThing"   @* Alpine component name, e.g., 'rzComponentName' *@
         data-assets="@_assets"   @* Serialized JSON string of asset URLs for this component *@
         data-nonce="@Nonce">     @* CSP nonce for inline scripts/styles loaded by this component *@
        @* Alpine-interactive content, x-ref, x-on:, :class, etc. goes here *@
    </div>
</HtmlElement>
```

*   `data-alpine-root="@Id"`: This attribute is **essential**. It MUST exactly match the Blazor component's `@Id`. It's used by the `Rizzy.$data()` helper to locate the Alpine component's scope.
*   `x-data="rzComponentName"`: Specifies the name of the Alpine.js component to initialize on this `div`. The name should follow the `rzComponentName` convention, where `rz` corresponds to `Rz` prefixed Blazor components.
*   `data-assets="@_assets"`: A JSON stringified array of asset URLs (JavaScript/CSS) that this specific Alpine component instance needs. This is populated from the C# code-behind.
*   `data-nonce="@Nonce"`: The CSP nonce value, passed from the C# `RzComponent` base. This is used by the `require` utility to load assets in a CSP-compliant manner.

### 10.3 Asset Declaration and Loading (Centralized)

Components **do not** hardcode asset URLs. Instead, they declare their dependencies using logical keys, which are resolved to URLs from a central configuration.

1.  **Define Asset Keys (`.razor.cs`):**
    *   The component defines a `ComponentAssetKeys` parameter, which is a `string[]`. This parameter should have a default value containing the logical keys for its required assets.
    *   Example:
        ```csharp
        // In RzFancyThing.razor.cs
        [Parameter]
        public string[] ComponentAssetKeys { get; set; } = ["FancyThingCoreScript", "SomeOtherDependency"];
        ```

2.  **Inject Configuration (`.razor.cs`):**
    *   The component injects `IOptions<RizzyUIConfig>` to access the central asset URL mapping.
        ```csharp
        // In RzFancyThing.razor.cs
        [Inject]
        private IOptions<RizzyUIConfig> RizzyUIConfig { get; set; } = default!;
        ```

3.  **Resolve and Serialize URLs (`.razor.cs`):**
    *   A private method (e.g., `UpdateAssets`) is called in `OnInitialized` and `OnParametersSet`.
    *   This method looks up the URLs for each key in `ComponentAssetKeys` from `RizzyUIConfig.Value.AssetUrls`.
    *   The resolved URLs are serialized into a JSON string and stored in a private field (e.g., `_assets`), which is then bound to the `data-assets` attribute in the Razor markup.
        ```csharp
        // In RzFancyThing.razor.cs
        private string _assets = "[]";

        private void UpdateAssets()
        {
            var assetUrls = ComponentAssetKeys
                .Select(key => RizzyUIConfig.Value.AssetUrls.TryGetValue(key, out var url) ? url : null)
                .Where(url => !string.IsNullOrEmpty(url))
                .ToList();
            _assets = System.Text.Json.JsonSerializer.Serialize(assetUrls);
        }
        ```

### 10.4 Alpine Component Definition (Individual JavaScript File)

*   Each new Alpine component (e.g., `rzFancyThing`) MUST have its logic defined in a **new, separate JavaScript file**.
*   Location: `packages/rizzyui/src/js/lib/components/rzFancyThing.js` (replace `rzFancyThing` with the actual component name).
*   This file MUST export a default function.
    *   The first argument to this function will always be the `Alpine` instance.
    *   If the component needs to dynamically load assets (using the `data-assets` attribute), the function should accept `require` as a second argument. This `require` is the `rizzyRequire` utility provided by `components.js`.
*   Inside this exported function, the Alpine component is defined using `Alpine.data('rzFancyThing', () => ({ /* component logic */ }));`. The name used here (e.g., `'rzFancyThing'`) MUST match the `x-data` attribute in the Razor markup.
*   The `init()` method within the Alpine data object is typically responsible for:
    1.  Retrieving `assetsToLoad` by parsing `this.$el.dataset.assets`.
    2.  Retrieving `nonce` from `this.$el.dataset.nonce`.
    3.  If `assetsToLoad` is not empty and the `require` function was passed in, call `require(assetsToLoad, { success: callback, error: errCallback }, nonce)`.
    4.  Place any Alpine initialization logic that *depends* on these external assets (e.g., initializing a third-party library like Flatpickr or Highlight.js) inside the `success` callback of `require`.
    5.  Other initialization logic (e.g., setting up internal state, watchers) can be placed directly in `init()` or in a separate method called from `init()` (either before or after `require`, or within its callbacks, as appropriate).

**Example: `packages/rizzyui/src/js/lib/components/rzFancyThing.js`**

```javascript
// This component demonstrates conditional asset loading.
// If data-assets is empty or 'require' is not provided, it proceeds without loading.
export default function(Alpine, require) { // 'require' is optional here
    Alpine.data('rzFancyThing', () => ({
        someProperty: 'initialValue',
        assetsLoaded: false,

        init() {
            const assetsToLoad = JSON.parse(this.$el.dataset.assets || '[]');
            const nonce = this.$el.dataset.nonce || '';
            const self = this; // Retain 'this' context for callbacks

            // Example: Read an initial value from a data attribute
            this.someProperty = this.$el.dataset.initialFancyValue || 'default fancy value';

            if (assetsToLoad.length > 0 && typeof require === 'function') {
                console.log(`rzFancyThing (${this.$el.id}): Attempting to load assets:`, assetsToLoad);
                require(assetsToLoad, {
                    success: function() {
                        console.log(`rzFancyThing (${self.$el.id}): Assets loaded successfully.`);
                        self.assetsLoaded = true;
                        // Example: Initialize a library if 'some-library.js' was loaded
                        // if (window.SomeLibrary) {
                        //     self.libraryInstance = new window.SomeLibrary(self.$el.querySelector('.target-for-lib'));
                        // }
                        self.setupInteractivity(); // Call main logic after assets
                    },
                    error: function(err) {
                        console.error(`rzFancyThing (${self.$el.id}): Failed to load assets.`, err);
                        // Decide if setupInteractivity should still run or if it's critical
                        self.setupInteractivity(); // Or handle error state
                    }
                }, nonce);
            } else {
                // No assets to load, or 'require' function not available/needed by this component.
                // Proceed with non-asset-dependent setup.
                console.log(`rzFancyThing (${this.$el.id}): No assets to load or require not provided.`);
                self.setupInteractivity();
            }
        },

        setupInteractivity() {
            // Main Alpine logic that runs (potentially after assets are loaded)
            console.log(`rzFancyThing (${this.$el.id}): Setting up interactivity. Current someProperty:`, this.someProperty);
            
            // Example: Watch for changes to 'someProperty'
            // this.$watch('someProperty', (value) => {
            //    console.log(`rzFancyThing (${this.$el.id}): someProperty changed to:`, value);
            // });
        },

        updateFancyProperty(newValue) {
            this.someProperty = newValue;
        }
        // ... other methods and properties for rzFancyThing
    }));
}
```

### 10.5 Alpine Component Registration (in `packages/rizzyui/src/js/lib/components.js`)

*   The newly created component registration function (e.g., `registerRzFancyThing` which is the default export from `rzFancyThing.js`) MUST be imported into `packages/rizzyui/src/js/lib/components.js`.
*   It must then be called within the `registerComponents(Alpine)` function in `components.js`. Pass the `Alpine` instance. If the component's registration function (e.g., `export default function(Alpine, require)`) expects the `require` utility, pass `rizzyRequire` (which is `loadjs` aliased as `require` in this file) as the second argument.

**Example: Modifying `packages/rizzyui/src/js/lib/components.js`**

```javascript
// packages/rizzyui/src/js/lib/components.js
import loadjs from "./loadjs/loadjs.js"; // Underlying asset loader

// ... other existing component imports ...
import registerRzAccordion from './components/rzAccordion.js';
import registerRzFancyThing from './components/rzFancyThing.js'; // <-- NEW IMPORT

// ... (rizzyRequire function definition using loadjs) ...
// async function generateBundleId(paths) { ... }
// function rizzyRequire(paths, callbackFn, nonce) { ... }


function registerComponents(Alpine) {
    // ... other existing component registrations ...
    registerRzAccordion(Alpine); // Example of a component not needing 'require'
    
    // Register the new component.
    // Pass 'rizzyRequire' if its definition function expects it.
    registerRzFancyThing(Alpine, rizzyRequire); // <-- NEW REGISTRATION
}

export { registerComponents, rizzyRequire as require };
```

---

## 11. Unit tests (bUnit) (IMPORTANT: ONLY ON REQUEST)

When unit tests are specifically requested for a new or modified component, they should be generated using bUnit and adhere to the following guidelines. Tests ensure component correctness, accessibility, and integration with the RizzyUI theme system and Alpine.js patterns.

*   **File Location and Naming:**
    *   Test files should reside in the `src/RizzyUI.Tests/Components/` directory, mirroring the component's path under `src/RizzyUI/Components/`.
    *   Example: For `src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor`, the test file would be `src/RizzyUI.Tests/Components/Fancy/RzFancyThingTests.cs`.
    *   Use file-scoped namespaces matching the directory structure within the test project (e.g., `namespace RizzyUI.Tests.Components.Fancy;`).

*   **Test Class Structure:**
    *   Test classes MUST inherit from `BunitAlbaContext`.
    *   Test classes MUST implement `IClassFixture<WebAppFixture>`.
    *   The constructor MUST accept a `WebAppFixture` parameter and pass it to the `base(fixture)` constructor.
    *   The `WebAppFixture` (via `BunitAlbaContext`) handles the setup of essential services like `IHttpContextAccessor`, `IRizzyNonceProvider`, and automatically calls `AddRizzyUI()`, which registers `TwMerge` and the default `RzTheme`.

    ```csharp
    // Example: src/RizzyUI.Tests/Components/Fancy/RzFancyThingTests.cs
    using Bunit;
    using Microsoft.AspNetCore.Components; // For RenderFragment, etc.
    using RizzyUI.Components.Fancy.RzFancyThing; // Import the component being tested
    // Add other necessary using statements (e.g., Blazicons, System.Linq.Expressions)

    namespace RizzyUI.Tests.Components.Fancy; // File-scoped namespace

    public class RzFancyThingTests : BunitAlbaContext, IClassFixture<WebAppFixture>
    {
        // private readonly IAlbaHost _host; // Only needed if testing HTTP interactions via Alba

        public RzFancyThingTests(WebAppFixture fixture) : base(fixture)
        {
            // _host = fixture.Host; // Store if needed for Alba HTTP tests
            // Services.AddRizzyUI(); // This is ALREADY CALLED by WebAppFixture, no need to call again.
        }

        // ... Test methods ...
    }
    ```

*   **Test Method Guidelines (`[Fact]` or `[Theory]`):**

    1.  **Default Render Test:**
        *   Render the component with minimal or no parameters (or only required ones like `Id`).
        *   Assert the root element exists and has the correct default tag (e.g., `div` unless overridden).
        *   Verify the `Id` is correctly applied.
        *   Assert that `cut.Find("selector").ClassList` contains the expected base classes from the `DefaultDescriptor`.
        *   Assert default ARIA attributes (e.g., `role`, default `aria-label` if applicable from localization).
        *   If the component uses Alpine.js:
            *   Assert the presence of the Alpine child-container (`div[data-alpine-root='@Id']`).
            *   Assert `x-data` attribute matches the component's Alpine module name.
            *   Assert `data-assets` attribute is present and contains the JSON serialized URLs resolved from the default `ComponentAssetKeys`.
            *   Assert `data-nonce` attribute is present.

    2.  **Parameter Variation Tests:**
        *   For each significant parameter, create tests to verify its effect on rendering.
        *   **CSS Classes:** Use `cut.Find("selector").ClassList.Contains("expected-class")`. Verify that dynamic style provider methods (e.g., `GetSizeCss`, `GetVariantCss`) are correctly applying classes.
        *   **ARIA Attributes:** Assert that ARIA attributes change correctly based on parameters (e.g., `aria-expanded`, `aria-pressed`, `aria-current`).
        *   **Conditional Rendering:** Assert elements are rendered or hidden based on boolean parameters (e.g., `ShowIcon`, `Dismissable`).
        *   **Content Parameters:**
            *   Test `Label` parameter vs. `ChildContent` precedence if applicable.
            *   Verify `RenderFragment` parameters like `ChildContent`, `LeadingIcon`, `TrailingIcon`, `HeaderContent`, `FooterContent` are rendered correctly.
            *   For icons (`SvgIcon?`), assert that `<Blazicon Svg="@IconParameter" ... />` is rendered with appropriate classes and `aria-hidden="true"` if decorative.

    3.  **Accessibility Tests:**
        *   Explicitly verify that `AriaLabel` parameter, when set, overrides any default.
        *   Verify that if `AriaLabel` is *not* set, the component applies a default localized ARIA label (retrieved via `Localizer["ComponentName.DefaultAriaLabel"]`).
        *   Check for other critical ARIA attributes relevant to the component's role.

    4.  **Interaction Tests (if applicable):**
        *   For interactive components (e.g., buttons, toggles), simulate user actions:
            *   `cut.Find("button").Click()`
            *   `cut.Find("input").Change("new value")`
        *   Assert that `EventCallback` parameters are invoked.
        *   Assert that component state (if exposed or reflected in markup/ARIA) changes as expected.

    5.  **Styling and `AdditionalAttributes`:**
        *   Verify that classes passed via `AdditionalAttributes` (e.g., `<RzFancyThing class="my-custom-style">`) are correctly merged into the root element's class list.
        *   Verify other `AdditionalAttributes` are passed through to the root element.

    6.  **Localization of Defaults:**
        *   Test that default text values (e.g., for `AriaLabel`, `Placeholder`, `Title` if not provided by user) are correctly sourced from `Localizer["ComponentName.ResourceKey"]`.

*   **bUnit Assertions:**
    *   Use `cut.Find("css-selector")` to locate elements.
    *   Use `element.MarkupMatches("expected html")` for precise structural and attribute checks. Use `diff.MissingAttributes` or `diff.MissingChildren` from the diff result for debugging.
    *   Use `element.ClassList` for asserting CSS classes.
    *   Use `element.GetAttribute("attribute-name")` for asserting attribute values.
    *   Use `cut.Instance` to access the component instance's properties and methods if needed (e.g., to check the `_assets` field).

*   **Output Format:**
    *   When tests are requested, the generated `.cs` test file(s) should be included within the `<files>` block of the ````output ... ```` section, just like component files.

---

## 12. The output block example (canonical)

When asked to generate `RzFancyThing` (a non-generic component):

```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor"></file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs"></file>
</files>
```

When asked to generate `RzGenericThing<TItem>`:

```output
<files>
  <file path="src/RizzyUI/Components/Generic/RzGenericThing/RzGenericThing.razor"></file>
  <file path="src/RizzyUI/Components/Generic/RzGenericThing/RzGenericThing.razor.cs"></file>
  <file path="src/RizzyUI/Components/Generic/RzGenericThing/Styling/RzGenericThingStyles.cs"></file>
</files>
```

---

## 13. What **not** to place in the `output` block

Changes to **global theme scaffolding** (`RzTheme.cs`, `RzTheme.StyleProviders.cs`), **configuration** (`RizzyUIConfig.cs`, `ServiceCollectionExtensions.cs`), and **localization resource files** (`RizzyLocalization.resx`) go in a **separate, preface section** that appears *before* the `output` block.
That section must identify each existing file and show the lines/entries to insert, either as a diff or as verbatim code snippets/tables.
Never embed these edits in `<file>` tags because CI merges them manually.

---

## 14. Theme, Localization, and Asset Integration (cross-file edits)

Whenever a new component is introduced, instruct the user accordingly:

**Manual Edits Required for Integration:**

**Theme Integration:**

1.  **Add to `src/RizzyUI/RzTheme.StyleProviders.cs`**:
    ```csharp
    // For a non-generic component
    public virtual TvDescriptor<RzComponent<RzFancyThing.Slots>, RzFancyThing.Slots> RzFancyThing { get; set; }

    // For a generic component
    public virtual TvDescriptor<RzComponent<RzGenericThingSlots>, RzGenericThingSlots> RzGenericThing { get; set; }
    ```

2.  **Add to `src/RizzyUI/RzTheme.cs` constructor**:
    ```csharp
    // For a non-generic component
    RzFancyThing = RizzyUI.RzFancyThing.DefaultDescriptor;

    // For a generic component
    RzGenericThing = RizzyUI.RzGenericThingStyles.DefaultDescriptor;
    ```

**Localization:**

Please add the following English (default culture) entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

| Name                               | Value                         | Comment (Optional)                  |
|------------------------------------|-------------------------------|-------------------------------------|
| `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |

**Asset Management Integration:**

Please add the following default asset URLs to the `PostConfigure` action in `src/RizzyUI/Extensions/ServiceCollectionExtensions.cs`:

| Key (`string`)           | URL (`string`)                                       |
|--------------------------|------------------------------------------------------|
| `"FancyThingCoreScript"` | `"https://cdn.jsdelivr.net/npm/fancylib@1.2.3/dist/fancy.min.js"` |

**JavaScript Integration (if new Alpine component `rzFancyThing` was created):**

1.  **Modify `packages/rizzyui/src/js/lib/components.js`**:
    *   Add an import statement for your new component module at the top of the file:
        ```javascript
        import registerRzFancyThing from './components/rzFancyThing.js'; 
        ```
    *   Call the imported registration function within the `registerComponents(Alpine)` function:
        ```javascript
        function registerComponents(Alpine) {
            // ...
            registerRzFancyThing(Alpine, rizzyRequire); 
        }
        ```

---

## 15. Final checklist for the LLM

*   CRITICAL - Only generate or modify code directly related to the task requested. You are not permitted to modify code outside the scope of the request.
*   **Component Naming:** Ensure only root-level components are prefixed with `Rz`.
*   Prepend the cross-file edit instructions for theme, localization, and asset management if needed (14).
*   Provide an `output` block for new or replaced component-specific files only (1, 12).
*   Use the root element pattern (2) and Alpine child-container convention if Alpine is used (10.2).
*   `.razor` files: Use `@inherits RzComponent<...>` and `SlotClasses.Get...()` for all classes (3, 5).
*   `.razor.cs` files:
    *   Start with `/// <summary>...</summary>` for the class and public members.
    *   Inherit from `RzComponent<TSlots>` or `RzAsChildComponent<TSlots>`.
    *   **For non-generic components:** Define `Slots` and `DefaultDescriptor` inside the class.
    *   **For generic components:** Implement the `IHas...StylingProperties` interface.
    *   Implement `protected override TvDescriptor<...> GetDescriptor() => Theme.ComponentName;`.
    *   **Ensure `RootClass()` method is NOT present.**
    *   Handle default localized strings for parameters like `AriaLabel` (9).
*   Styling files (`Styling/ComponentNameStyles.cs` for generics):
    *   Define the non-generic `Slots` class.
    *   Define the `static class` containing the `DefaultDescriptor`.
    *   Variant expressions in the descriptor **MUST** cast to the `IHas...StylingProperties` interface.
*   Alpine.js: Strictly adhere to API restrictions by always using `Alpine.data` and referencing properties/methods by key only.
*   Include unit tests *only* when specifically requested (11).
*   Adhere to all specified conventions and avoid manual concatenation of class strings.
*   Do not include comments in Razor markup or using statements. Any comments in code blocks should be production-ready.

---

### **Final Sign-Off Checklist (Version 3.3)**

#### **Part A: LLM Automated Verification Checklist**

-   **[ ] 1. `Slots` Class Definition:**
    -   For **non-generic** components: The `.razor.cs` file contains a `public sealed partial class Slots : ISlots`.
    -   For **generic** components: The `Styling/{ComponentName}Styles.cs` file contains a `public sealed partial class {ComponentName}Slots : ISlots`.
-   **[ ] 2. `Slots` Properties:** The `Slots` class has a `string?` property for *every* slot consumed by a `SlotClasses.Get...()` call in the `.razor` file.
-   **[ ] 3. `[Slot]` Attribute:** Every property in every `Slots` class is decorated with `[Slot("kebab-case-name")]`.
-   **[ ] 4. `DefaultDescriptor` Location:**
    -   For **non-generic** components: The `.razor.cs` file contains a `public static readonly TvDescriptor`.
    -   For **generic** components: The `Styling/{ComponentName}Styles.cs` file contains a `public static class {ComponentName}Styles` holding the `public static readonly TvDescriptor`.
-   **[ ] 5. Descriptor Completeness:** The `DefaultDescriptor` provides a default class string for *every* slot defined in the `Slots` class.
-   **[ ] 6. Interface Implementation (Generic Components Only):** For generic components, the component's `.razor.cs` file **implements** the `IHas...StylingProperties` interface.
-   **[ ] 7. Styling File Structure (Generic Components Only):** The `Styling/{ComponentName}Styles.cs` file exists and contains the styling interface, the slots class, and the static styles class.
-   **[ ] 8. Correct Variant Syntax:** All `variants` and `compoundVariants` that target a slot other than `Base` **MUST** use the `new() { [s => s.SlotName] = "..." }` syntax. For generic components, variant expressions **MUST** cast the component instance to the styling interface (e.g., `c => ((IHas...StylingProperties)c).PropertyName`).
-   **[ ] 9. Nullable Enum Variant Type:** For nullable enum `[Parameter]`s used in variants, the `Variant<T, TSlots>` definition uses the **non-nullable** enum type for `T`.
-   **[ ] 10. Inheritance:** The component's `.razor.cs` file inherits from `RzComponent<TSlots>` or `RzAsChildComponent<TSlots>`, where `TSlots` is the correct (and possibly non-generic) slots type.
-   **[ ] 11. Correct `GetDescriptor` Implementation:** The component's `.razor.cs` file **MUST** contain the method `protected override TvDescriptor<...> GetDescriptor() => Theme.ComponentName;`.
-   **[ ] 12. `RootClass()` Method Removed:** The `RootClass()` method has been completely removed from the component's `.razor.cs` file.
-   **[ ] 13. Markup Inheritance:** The component's `.razor` file has the correct `@inherits` directive.
-   **[ ] 14. Markup Class Attributes:** All `class` attributes in the `.razor` file have been updated to use the `SlotClasses.Get...()` accessors.
-   **[ ] 15. `data-slot` on Root Element:** The root `HtmlElement` has a `data-slot="component-name"` attribute with a hardcoded, kebab-case name.
-   **[ ] 16. `data-slot` on Internal Elements:** Every internal element with a `class="@SlotClasses.Get...()"` attribute also has a corresponding `data-slot="@...SlotNames.NameOf(...)"` attribute.
-   **[ ] 17. Alpine Directives Preserved:** All non-class Alpine directives are present in the `.razor` file on their original elements.

#### **Part B: Human Developer Validation Checklist**

-   **[ ] 18. Theme Integration:** Have the manual edits to `RzTheme.StyleProviders.cs` and `RzTheme.cs` been applied correctly?
-   **[ ] 19. Obsolete Files Deleted:** Have the old `Default...Styles.cs` and `RzStylesBase...cs` files for the component been deleted?
-   **[ ] 20. Build Success:** Does the entire `RizzyUI` solution build without errors?
-   **[ ] 21. Unit Tests:** Do all existing unit tests for the component pass?
-   **[ ] 22. Demo Application:** Visually confirm that the component renders and behaves exactly as it did before the refactor in the `RizzyUI.Docs` application.
</instruction>
