This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document. The content has been processed where empty lines have been removed.
Generated by Repomix on: 2025-05-23T12:22:54.162Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.razor, **/*.razor.cs, **/*.cs, **/js/*.js
- Files matching these patterns are excluded: obj/, bin/, **/js/vendor/*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
_Imports.razor
Colors.cs
ColorScale.cs
Components/DataTable/Models/ColumnDefinition.cs
Components/DataTable/Models/PaginationState.cs
Components/DataTable/Models/SortDirection.cs
Components/DataTable/Models/TableRequestModel.cs
Components/DataTable/Models/TableSelectionMode.cs
Components/DataTable/RzPagination/RzPagination.razor
Components/DataTable/RzPagination/RzPagination.razor.cs
Components/DataTable/RzPagination/Styling/DefaultRzPaginationStyles.cs
Components/DataTable/RzTable/RzTable.razor
Components/DataTable/RzTable/RzTable.razor.cs
Components/DataTable/RzTable/Styling/DefaultRzTableStyles.cs
Components/DataTable/RzTableBody/RzTableBody.razor
Components/DataTable/RzTableBody/RzTableBody.razor.cs
Components/DataTable/RzTableBody/Styling/DefaultRzTableBodyStyles.cs
Components/DataTable/RzTableCell/RzTableCell.razor
Components/DataTable/RzTableCell/RzTableCell.razor.cs
Components/DataTable/RzTableCell/Styling/DefaultRzTableCellStyles.cs
Components/DataTable/RzTableHeaderCell/RzTableHeaderCell.razor
Components/DataTable/RzTableHeaderCell/RzTableHeaderCell.razor.cs
Components/DataTable/RzTableHeaderCell/Styling/DefaultRzTableHeaderCellStyles.cs
Components/DataTable/RzTableRow/RzTableRow.razor
Components/DataTable/RzTableRow/RzTableRow.razor.cs
Components/DataTable/RzTableRow/Styling/DefaultRzTableRowStyles.cs
Components/Display/RzAvatar/RzAvatar.razor
Components/Display/RzAvatar/RzAvatar.razor.cs
Components/Display/RzAvatar/Styling/DefaultRzAvatarStyles.cs
Components/Display/RzBadge/RzBadge.razor
Components/Display/RzBadge/RzBadge.razor.cs
Components/Display/RzBadge/Styling/DefaultRzBadgeStyles.cs
Components/Display/RzDivider/RzDivider.razor
Components/Display/RzDivider/RzDivider.razor.cs
Components/Display/RzDivider/Styling/DefaultRzDividerStyles.cs
Components/Display/RzProgress/RzProgress.razor
Components/Display/RzProgress/RzProgress.razor.cs
Components/Display/RzProgress/Styling/DefaultRzProgressStyles.cs
Components/Document/Models/HeadingItem.cs
Components/Document/RzArticle/RzArticle.razor
Components/Document/RzArticle/RzArticle.razor.cs
Components/Document/RzArticle/Styling/DefaultRzArticleStyles.cs
Components/Document/RzBrowser/RzBrowser.razor
Components/Document/RzBrowser/RzBrowser.razor.cs
Components/Document/RzBrowser/Styling/DefaultRzBrowserStyles.cs
Components/Document/RzCodeViewer/CodeLanguage.cs
Components/Document/RzCodeViewer/RzCodeViewer.razor
Components/Document/RzCodeViewer/RzCodeViewer.razor.cs
Components/Document/RzCodeViewer/Styling/DefaultRzCodeViewerStyles.cs
Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor
Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor.cs
Components/Document/RzEmbeddedPreview/Styling/DefaultRzEmbeddedPreviewStyles.cs
Components/Document/RzMarkdown/RzMarkdown.razor
Components/Document/RzMarkdown/RzMarkdown.razor.cs
Components/Document/RzMarkdown/Styling/DefaultRzMarkdownStyles.cs
Components/Document/RzQuickReference/RzQuickReference.razor
Components/Document/RzQuickReference/RzQuickReference.razor.cs
Components/Document/RzQuickReference/RzQuickReferenceContainer.razor
Components/Document/RzQuickReference/RzQuickReferenceContainer.razor.cs
Components/Document/RzQuickReference/Styling/DefaultRzQuickReferenceStyles.cs
Components/Feedback/RzAlert/RzAlert.razor
Components/Feedback/RzAlert/RzAlert.razor.cs
Components/Feedback/RzAlert/RzAlertDescription.razor
Components/Feedback/RzAlert/RzAlertDescription.razor.cs
Components/Feedback/RzAlert/RzAlertTitle.razor
Components/Feedback/RzAlert/RzAlertTitle.razor.cs
Components/Feedback/RzAlert/Styling/DefaultRzAlertStyles.cs
Components/Feedback/RzModal/RzModal.razor
Components/Feedback/RzModal/RzModal.razor.cs
Components/Feedback/RzModal/Styling/DefaultRzModalStyles.cs
Components/Feedback/RzSpinner/RzSpinner.razor
Components/Feedback/RzSpinner/RzSpinner.razor.cs
Components/Feedback/RzSpinner/Styling/DefaultRzSpinnerStyles.cs
Components/Form/_Imports.razor
Components/Form/Enum/Orientation.cs
Components/Form/Enum/SectionLayout.cs
Components/Form/Enum/TextRole.cs
Components/Form/InputBase.cs
Components/Form/Models/FlatpickrOptions.cs
Components/Form/RzButton/RzButton.razor
Components/Form/RzButton/RzButton.razor.cs
Components/Form/RzButton/RzButtonGroup.razor
Components/Form/RzButton/RzButtonGroup.razor.cs
Components/Form/RzButton/Styling/DefaultRzButtonGroupStyles.cs
Components/Form/RzButton/Styling/DefaultRzButtonStyles.cs
Components/Form/RzCheckbox/RzCheckboxGroup.razor
Components/Form/RzCheckbox/RzCheckboxGroup.razor.cs
Components/Form/RzCheckbox/RzCheckboxGroupField.razor
Components/Form/RzCheckbox/RzCheckboxGroupField.razor.cs
Components/Form/RzCheckbox/RzCheckboxGroupItem.razor
Components/Form/RzCheckbox/RzCheckboxGroupItem.razor.cs
Components/Form/RzCheckbox/Styling/DefaultRzCheckboxStyles.cs
Components/Form/RzDateEdit/RzDateEdit.razor
Components/Form/RzDateEdit/RzDateEdit.razor.cs
Components/Form/RzDateEdit/Styling/DefaultRzDateEditStyles.cs
Components/Form/RzField/RzField.razor
Components/Form/RzField/RzField.razor.cs
Components/Form/RzField/RzFieldHelp.razor
Components/Form/RzField/RzFieldHelp.razor.cs
Components/Form/RzField/RzFieldLabel.razor
Components/Form/RzField/RzFieldLabel.razor.cs
Components/Form/RzField/Styling/DefaultRzFieldStyles.cs
Components/Form/RzFormSection/RzFormSection.razor
Components/Form/RzFormSection/RzFormSection.razor.cs
Components/Form/RzFormSection/Styling/DefaultRzFormSectionStyles.cs
Components/Form/RzNumber/RzNumberEdit.razor
Components/Form/RzNumber/RzNumberEdit.razor.cs
Components/Form/RzNumber/RzNumberField.razor
Components/Form/RzNumber/RzNumberField.razor.cs
Components/Form/RzNumber/Styling/DefaultRzNumberStyles.cs
Components/Form/RzRadio/RzRadioGroup.razor
Components/Form/RzRadio/RzRadioGroup.razor.cs
Components/Form/RzRadio/RzRadioGroupField.razor
Components/Form/RzRadio/RzRadioGroupField.razor.cs
Components/Form/RzRadio/RzRadioGroupItem.razor
Components/Form/RzRadio/RzRadioGroupItem.razor.cs
Components/Form/RzRadio/Styling/DefaultRzRadioStyles.cs
Components/Form/RzText/RzTextEdit.razor
Components/Form/RzText/RzTextEdit.razor.cs
Components/Form/RzText/RzTextField.razor
Components/Form/RzText/RzTextField.razor.cs
Components/Form/RzText/Styling/DefaultRzTextStyles.cs
Components/Form/RzToggle/RzToggle.razor
Components/Form/RzToggle/RzToggle.razor.cs
Components/Form/RzToggle/RzToggleField.razor
Components/Form/RzToggle/RzToggleField.razor.cs
Components/Form/RzToggle/Styling/DefaultRzToggleStyles.cs
Components/FragmentComponent.cs
Components/HtmlElement.cs
Components/Layout/RzAccordion/RzAccordion.razor
Components/Layout/RzAccordion/RzAccordion.razor.cs
Components/Layout/RzAccordion/RzAccordionSection.razor
Components/Layout/RzAccordion/RzAccordionSection.razor.cs
Components/Layout/RzAccordion/Styling/DefaultRzAccordionSectionStyles.cs
Components/Layout/RzAccordion/Styling/DefaultRzAccordionStyles.cs
Components/Layout/RzCard/RzCard.razor
Components/Layout/RzCard/RzCard.razor.cs
Components/Layout/RzCard/RzCardBody.razor
Components/Layout/RzCard/RzCardBody.razor.cs
Components/Layout/RzCard/RzCardButtons.razor
Components/Layout/RzCard/RzCardButtons.razor.cs
Components/Layout/RzCard/RzCardFooter.razor
Components/Layout/RzCard/RzCardFooter.razor.cs
Components/Layout/RzCard/RzCardHeader.razor
Components/Layout/RzCard/RzCardHeader.razor.cs
Components/Layout/RzCard/RzCardSubtitle.razor
Components/Layout/RzCard/RzCardSubtitle.razor.cs
Components/Layout/RzCard/RzCardTitle.razor
Components/Layout/RzCard/RzCardTitle.razor.cs
Components/Layout/RzCard/Styling/DefaultRzCardStyles.cs
Components/Layout/RzSearchButton/RzSearchButton.razor
Components/Layout/RzSearchButton/RzSearchButton.razor.cs
Components/Layout/RzSearchButton/Styling/DefaultRzSearchButtonStyles.cs
Components/Layout/RzStep/RzStep.cs
Components/Layout/RzStep/RzSteps.razor
Components/Layout/RzStep/RzSteps.razor.cs
Components/Layout/RzStep/StepData.cs
Components/Layout/RzStep/StepStatus.cs
Components/Layout/RzStep/Styling/DefaultRzStepsStyles.cs
Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor
Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor.cs
Components/Navigation/RzBreadcrumb/RzBreadcrumbItem.cs
Components/Navigation/RzBreadcrumb/Styling/DefaultRzBreadcrumbStyles.cs
Components/Navigation/RzDropdown/RzDropdown.razor
Components/Navigation/RzDropdown/RzDropdown.razor.cs
Components/Navigation/RzDropdown/RzDropdownMenuItem.razor
Components/Navigation/RzDropdown/RzDropdownMenuItem.razor.cs
Components/Navigation/RzDropdown/RzDropdownSection.razor
Components/Navigation/RzDropdown/RzDropdownSection.razor.cs
Components/Navigation/RzDropdown/Styling/DefaultRzDropdownStyles.cs
Components/Navigation/RzLink/RzLink.razor
Components/Navigation/RzLink/RzLink.razor.cs
Components/Navigation/RzLink/Styling/DefaultRzLinkStyles.cs
Components/Navigation/RzNavbar/RzNavbar.razor
Components/Navigation/RzNavbar/RzNavbar.razor.cs
Components/Navigation/RzNavbar/Styling/DefaultRzNavbarStyles.cs
Components/Navigation/RzSidebar/RzSidebar.razor
Components/Navigation/RzSidebar/RzSidebar.razor.cs
Components/Navigation/RzSidebar/RzSidebarLinkItem.razor
Components/Navigation/RzSidebar/RzSidebarLinkItem.razor.cs
Components/Navigation/RzSidebar/RzSidebarLinks.razor
Components/Navigation/RzSidebar/RzSidebarLinks.razor.cs
Components/Navigation/RzSidebar/Styling/DefaultRzSidebarStyles.cs
Components/Navigation/RzTab/RzTab.razor
Components/Navigation/RzTab/RzTab.razor.cs
Components/Navigation/RzTab/RzTabPanel.razor
Components/Navigation/RzTab/RzTabPanel.razor.cs
Components/Navigation/RzTab/RzTabs.razor
Components/Navigation/RzTab/RzTabs.razor.cs
Components/Navigation/RzTab/RzTabStrip.razor
Components/Navigation/RzTab/RzTabStrip.razor.cs
Components/Navigation/RzTab/Styling/DefaultRzTabStyles.cs
Components/Theme/RzDarkMode/RzDarkModeToggle.razor
Components/Theme/RzDarkMode/RzDarkModeToggle.razor.cs
Components/Theme/RzDarkMode/Styling/RzDarkModeToggleStyles.cs
Components/Theme/RzThemeProvider.cs
Components/Theme/Themes/ArcticTheme.cs
Components/Theme/Themes/Code/CodeThemes.cs
Components/Theme/Themes/Code/RizzyCodeTheme.cs
Components/Theme/Themes/HighContrastTheme.cs
Components/Theme/Themes/ModernTheme.cs
Components/Theme/Themes/NewsTheme.cs
Components/Typography/RzHeading.razor
Components/Typography/RzHeading.razor.cs
Components/Typography/RzParagraph.razor
Components/Typography/RzParagraph.razor.cs
Components/Typography/RzTypographyBase.cs
Components/Typography/Styles.cs
Components/Typography/Styling/DefaultRzTypographyStyles.cs
Components/Utility/ColorUtil.cs
Components/Variants.cs
Constants.cs
Extensions/MarkdigExtensions.cs
Extensions/ServiceCollectionExtensions.cs
Extensions/StringExtensions.cs
Extensions/TwMergeExtensions.cs
GlobalSuppressions.cs
GlobalUsings.cs
Localization/DummyRizzyStringLocalizer.cs
Localization/RizzyStringLocalizer.cs
Localization/RizzyStringLocalizerFactory.cs
Oklch.cs
RizzyLocalization.cs
RizzyUIConfig.cs
RzComponent.cs
RzTheme.cs
RzTheme.StyleProviders.cs
RzThemeVariant.cs
Styles/RzStylesBase.cs
Styles/RzStylesBase.RzAccordionStylesBase.cs
Styles/RzStylesBase.RzAlertStylesBase.cs
Styles/RzStylesBase.RzArticleStylesBase.cs
Styles/RzStylesBase.RzAvatarStylesBase.cs
Styles/RzStylesBase.RzBadgeStylesBase.cs
Styles/RzStylesBase.RzBreadcrumbStylesBase.cs
Styles/RzStylesBase.RzBrowserStylesBase.cs
Styles/RzStylesBase.RzButtonStylesBase.cs
Styles/RzStylesBase.RzCardStylesBase.cs
Styles/RzStylesBase.RzCheckboxGroupStylesBase.cs
Styles/RzStylesBase.RzCodeViewerStylesBase.cs
Styles/RzStylesBase.RzDateEditStylesBase.cs
Styles/RzStylesBase.RzDividerStylesBase.cs
Styles/RzStylesBase.RzDropdownStylesBase.cs
Styles/RzStylesBase.RzEmbeddedPreviewStylesBase.cs
Styles/RzStylesBase.RzFieldStylesBase.cs
Styles/RzStylesBase.RzFormSectionStylesBase.cs
Styles/RzStylesBase.RzHeadingStylesBase.cs
Styles/RzStylesBase.RzLinkStylesBase.cs
Styles/RzStylesBase.RzMarkdownStylesBase.cs
Styles/RzStylesBase.RzModalStylesBase.cs
Styles/RzStylesBase.RzNavbarStylesBase.cs
Styles/RzStylesBase.RzNumberEditStylesBase.cs
Styles/RzStylesBase.RzParagraphStylesBase.cs
Styles/RzStylesBase.RzProgressStylesBase.cs
Styles/RzStylesBase.RzQuickReferenceStylesBase.cs
Styles/RzStylesBase.RzRadioGroupStylesBase.cs
Styles/RzStylesBase.RzSidebarStylesBase.cs
Styles/RzStylesBase.RzSpinnerStylesBase.cs
Styles/RzStylesBase.RzStepsStylesBase.cs
Styles/RzStylesBase.RzTableRowStylesBase.cs
Styles/RzStylesBase.RzTableStylesBase.cs
Styles/RzStylesBase.RzTabsStylesBase.cs
Styles/RzStylesBase.RzTextEditStylesBase.cs
Styles/RzStylesBase.RzToggleStylesBase.cs
Styles/RzStylesBase.RzTypographyStylesBase.cs
Utility/Serialization/Converters/CalendarPositionConverter.cs
Utility/Serialization/Converters/RawStringConverter.cs
Utility/Serialization/Converters/SingleQuoteStringConverter.cs
wwwroot/js/antiforgerySnippet.js
wwwroot/js/antiforgerySnippet.min.js
wwwroot/js/rizzyui-csp.es.js
wwwroot/js/rizzyui-csp.min.es.js
wwwroot/js/rizzyui-csp.min.umd.js
wwwroot/js/rizzyui-csp.umd.js
wwwroot/js/rizzyui.es.js
wwwroot/js/rizzyui.min.es.js
wwwroot/js/rizzyui.min.umd.js
wwwroot/js/rizzyui.umd.js
wwwroot/js/safelist.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_Imports.razor">
@using Microsoft.AspNetCore.Components.Web
@using RizzyUI.Extensions
</file>

<file path="Colors.cs">
namespace RizzyUI;
/// <summary>
///     Provides static readonly properties to access each Tailwind color palette.
///     Example: Colors.Rose.L500 or Colors.Rose["500"]
/// </summary>
public static class Colors
{
	/// <summary>
	///     Transparent
	/// </summary>
	public static readonly Color Transparent = new(new Oklch(0, 0, 0, 0));
	/// <summary>
	///     The color white.
	/// </summary>
	public static readonly Color White = new("--color-white", "white");
	/// <summary>
	///     The color black.
	/// </summary>
	public static readonly Color Black = new("--color-black", "black");
	/// <summary>
	///     Red color scale.
	/// </summary>
	public static readonly ColorScale Red = new Red();
	/// <summary>
	///     Orange color scale.
	/// </summary>
	public static readonly ColorScale Orange = new Orange();
	/// <summary>
	///     Amber color scale.
	/// </summary>
	public static readonly ColorScale Amber = new Amber();
	/// <summary>
	///     Yellow color scale.
	/// </summary>
	public static readonly ColorScale Yellow = new Yellow();
	/// <summary>
	///     Lime color scale.
	/// </summary>
	public static readonly ColorScale Lime = new Lime();
	/// <summary>
	///     Green color scale.
	/// </summary>
	public static readonly ColorScale Green = new Green();
	/// <summary>
	///     Emerald color scale.
	/// </summary>
	public static readonly ColorScale Emerald = new Emerald();
	/// <summary>
	///     Teal color scale.
	/// </summary>
	public static readonly ColorScale Teal = new Teal();
	/// <summary>
	///     Cyan color scale.
	/// </summary>
	public static readonly ColorScale Cyan = new Cyan();
	/// <summary>
	///     Sky color scale.
	/// </summary>
	public static readonly ColorScale Sky = new Sky();
	/// <summary>
	///     Blue color scale.
	/// </summary>
	public static readonly ColorScale Blue = new Blue();
	/// <summary>
	///     Indigo color scale.
	/// </summary>
	public static readonly ColorScale Indigo = new Indigo();
	/// <summary>
	///     Violet color scale.
	/// </summary>
	public static readonly ColorScale Violet = new Violet();
	/// <summary>
	///     Purple color scale.
	/// </summary>
	public static readonly ColorScale Purple = new Purple();
	/// <summary>
	///     Fuchsia color scale.
	/// </summary>
	public static readonly ColorScale Fuchsia = new Fuchsia();
	/// <summary>
	///     Pink color scale.
	/// </summary>
	public static readonly ColorScale Pink = new Pink();
	/// <summary>
	///     Rose color scale.
	/// </summary>
	public static readonly ColorScale Rose = new Rose();
	/// <summary>
	///     Stone color scale.
	/// </summary>
	public static readonly ColorScale Stone = new Stone();
	/// <summary>
	///     Neutral color scale.
	/// </summary>
	public static readonly ColorScale Neutral = new Neutral();
	/// <summary>
	///     Zinc color scale.
	/// </summary>
	public static readonly ColorScale Zinc = new Zinc();
	/// <summary>
	///     Gray color scale.
	/// </summary>
	public static readonly ColorScale Gray = new Gray();
	/// <summary>
	///     Slate color scale.
	/// </summary>
	public static readonly ColorScale Slate = new Slate();
}
</file>

<file path="ColorScale.cs">
namespace RizzyUI;
/// <summary>
///     Represents a scale of colors with various lightness levels.
/// </summary>
public abstract class ColorScale
{
    /// <summary>
    ///     Gets the color shade at level 50.
    /// </summary>
    public abstract Color L50 { get; }
    /// <summary>
    ///     Gets the color shade at level 100.
    /// </summary>
    public abstract Color L100 { get; }
    /// <summary>
    ///     Gets the color shade at level 200.
    /// </summary>
    public abstract Color L200 { get; }
    /// <summary>
    ///     Gets the color shade at level 300.
    /// </summary>
    public abstract Color L300 { get; }
    /// <summary>
    ///     Gets the color shade at level 400.
    /// </summary>
    public abstract Color L400 { get; }
    /// <summary>
    ///     Gets the color shade at level 500.
    /// </summary>
    public abstract Color L500 { get; }
    /// <summary>
    ///     Gets the color shade at level 600.
    /// </summary>
    public abstract Color L600 { get; }
    /// <summary>
    ///     Gets the color shade at level 700.
    /// </summary>
    public abstract Color L700 { get; }
    /// <summary>
    ///     Gets the color shade at level 800.
    /// </summary>
    public abstract Color L800 { get; }
    /// <summary>
    ///     Gets the color shade at level 900.
    /// </summary>
    public abstract Color L900 { get; }
    /// <summary>
    ///     Gets the color shade at level 950.
    /// </summary>
    public abstract Color L950 { get; }
}
/// <summary>
///     Represents the red color scale.
/// </summary>
public sealed class Red : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-red-50", "red-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-red-100", "red-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-red-200", "red-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-red-300", "red-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-red-400", "red-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-red-500", "red-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-red-600", "red-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-red-700", "red-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-red-800", "red-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-red-900", "red-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-red-950", "red-950");
}
/// <summary>
///     Represents the orange color scale.
/// </summary>
public sealed class Orange : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-orange-50", "orange-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-orange-100", "orange-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-orange-200", "orange-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-orange-300", "orange-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-orange-400", "orange-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-orange-500", "orange-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-orange-600", "orange-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-orange-700", "orange-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-orange-800", "orange-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-orange-900", "orange-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-orange-950", "orange-950");
}
/// <summary>
///     Represents the amber color scale.
/// </summary>
public sealed class Amber : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-amber-50", "amber-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-amber-100", "amber-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-amber-200", "amber-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-amber-300", "amber-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-amber-400", "amber-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-amber-500", "amber-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-amber-600", "amber-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-amber-700", "amber-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-amber-800", "amber-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-amber-900", "amber-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-amber-950", "amber-950");
}
/// <summary>
///     Represents the yellow color scale.
/// </summary>
public sealed class Yellow : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-yellow-50", "yellow-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-yellow-100", "yellow-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-yellow-200", "yellow-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-yellow-300", "yellow-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-yellow-400", "yellow-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-yellow-500", "yellow-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-yellow-600", "yellow-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-yellow-700", "yellow-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-yellow-800", "yellow-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-yellow-900", "yellow-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-yellow-950", "yellow-950");
}
/// <summary>
///     Represents the lime color scale.
/// </summary>
public sealed class Lime : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-lime-50", "lime-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-lime-100", "lime-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-lime-200", "lime-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-lime-300", "lime-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-lime-400", "lime-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-lime-500", "lime-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-lime-600", "lime-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-lime-700", "lime-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-lime-800", "lime-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-lime-900", "lime-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-lime-950", "lime-950");
}
/// <summary>
///     Represents the green color scale.
/// </summary>
public sealed class Green : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-green-50", "green-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-green-100", "green-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-green-200", "green-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-green-300", "green-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-green-400", "green-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-green-500", "green-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-green-600", "green-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-green-700", "green-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-green-800", "green-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-green-900", "green-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-green-950", "green-950");
}
/// <summary>
///     Represents the emerald color scale.
/// </summary>
public sealed class Emerald : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-emerald-50", "emerald-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-emerald-100", "emerald-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-emerald-200", "emerald-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-emerald-300", "emerald-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-emerald-400", "emerald-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-emerald-500", "emerald-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-emerald-600", "emerald-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-emerald-700", "emerald-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-emerald-800", "emerald-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-emerald-900", "emerald-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-emerald-950", "emerald-950");
}
/// <summary>
///     Represents the teal color scale.
/// </summary>
public sealed class Teal : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-teal-50", "teal-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-teal-100", "teal-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-teal-200", "teal-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-teal-300", "teal-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-teal-400", "teal-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-teal-500", "teal-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-teal-600", "teal-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-teal-700", "teal-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-teal-800", "teal-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-teal-900", "teal-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-teal-950", "teal-950");
}
/// <summary>
///     Represents the cyan color scale.
/// </summary>
public sealed class Cyan : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-cyan-50", "cyan-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-cyan-100", "cyan-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-cyan-200", "cyan-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-cyan-300", "cyan-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-cyan-400", "cyan-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-cyan-500", "cyan-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-cyan-600", "cyan-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-cyan-700", "cyan-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-cyan-800", "cyan-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-cyan-900", "cyan-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-cyan-950", "cyan-950");
}
/// <summary>
///     Represents the sky color scale.
/// </summary>
public sealed class Sky : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-sky-50", "sky-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-sky-100", "sky-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-sky-200", "sky-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-sky-300", "sky-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-sky-400", "sky-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-sky-500", "sky-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-sky-600", "sky-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-sky-700", "sky-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-sky-800", "sky-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-sky-900", "sky-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-sky-950", "sky-950");
}
/// <summary>
///     Represents the blue color scale.
/// </summary>
public sealed class Blue : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-blue-50", "blue-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-blue-100", "blue-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-blue-200", "blue-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-blue-300", "blue-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-blue-400", "blue-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-blue-500", "blue-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-blue-600", "blue-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-blue-700", "blue-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-blue-800", "blue-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-blue-900", "blue-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-blue-950", "blue-950");
}
/// <summary>
///     Represents the indigo color scale.
/// </summary>
public sealed class Indigo : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-indigo-50", "indigo-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-indigo-100", "indigo-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-indigo-200", "indigo-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-indigo-300", "indigo-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-indigo-400", "indigo-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-indigo-500", "indigo-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-indigo-600", "indigo-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-indigo-700", "indigo-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-indigo-800", "indigo-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-indigo-900", "indigo-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-indigo-950", "indigo-950");
}
/// <summary>
///     Represents the violet color scale.
/// </summary>
public sealed class Violet : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-violet-50", "violet-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-violet-100", "violet-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-violet-200", "violet-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-violet-300", "violet-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-violet-400", "violet-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-violet-500", "violet-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-violet-600", "violet-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-violet-700", "violet-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-violet-800", "violet-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-violet-900", "violet-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-violet-950", "violet-950");
}
/// <summary>
///     Represents the purple color scale.
/// </summary>
public sealed class Purple : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-purple-50", "purple-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-purple-100", "purple-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-purple-200", "purple-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-purple-300", "purple-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-purple-400", "purple-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-purple-500", "purple-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-purple-600", "purple-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-purple-700", "purple-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-purple-800", "purple-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-purple-900", "purple-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-purple-950", "purple-950");
}
/// <summary>
///     Represents the fuchsia color scale.
/// </summary>
public sealed class Fuchsia : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-fuchsia-50", "fuchsia-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-fuchsia-100", "fuchsia-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-fuchsia-200", "fuchsia-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-fuchsia-300", "fuchsia-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-fuchsia-400", "fuchsia-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-fuchsia-500", "fuchsia-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-fuchsia-600", "fuchsia-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-fuchsia-700", "fuchsia-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-fuchsia-800", "fuchsia-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-fuchsia-900", "fuchsia-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-fuchsia-950", "fuchsia-950");
}
/// <summary>
///     Represents the pink color scale.
/// </summary>
public sealed class Pink : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-pink-50", "pink-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-pink-100", "pink-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-pink-200", "pink-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-pink-300", "pink-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-pink-400", "pink-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-pink-500", "pink-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-pink-600", "pink-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-pink-700", "pink-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-pink-800", "pink-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-pink-900", "pink-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-pink-950", "pink-950");
}
/// <summary>
///     Represents the rose color scale.
/// </summary>
public sealed class Rose : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-rose-50", "rose-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-rose-100", "rose-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-rose-200", "rose-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-rose-300", "rose-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-rose-400", "rose-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-rose-500", "rose-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-rose-600", "rose-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-rose-700", "rose-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-rose-800", "rose-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-rose-900", "rose-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-rose-950", "rose-950");
}
/// <summary>
///     Represents the slate color scale.
/// </summary>
public sealed class Slate : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-slate-50", "slate-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-slate-100", "slate-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-slate-200", "slate-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-slate-300", "slate-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-slate-400", "slate-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-slate-500", "slate-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-slate-600", "slate-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-slate-700", "slate-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-slate-800", "slate-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-slate-900", "slate-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-slate-950", "slate-950");
}
/// <summary>
///     Represents the gray color scale.
/// </summary>
public sealed class Gray : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-gray-50", "gray-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-gray-100", "gray-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-gray-200", "gray-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-gray-300", "gray-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-gray-400", "gray-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-gray-500", "gray-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-gray-600", "gray-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-gray-700", "gray-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-gray-800", "gray-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-gray-900", "gray-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-gray-950", "gray-950");
}
/// <summary>
///     Represents the zinc color scale.
/// </summary>
public sealed class Zinc : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-zinc-50", "zinc-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-zinc-100", "zinc-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-zinc-200", "zinc-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-zinc-300", "zinc-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-zinc-400", "zinc-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-zinc-500", "zinc-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-zinc-600", "zinc-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-zinc-700", "zinc-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-zinc-800", "zinc-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-zinc-900", "zinc-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-zinc-950", "zinc-950");
}
/// <summary>
///     Represents the neutral color scale.
/// </summary>
public sealed class Neutral : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-neutral-50", "neutral-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-neutral-100", "neutral-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-neutral-200", "neutral-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-neutral-300", "neutral-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-neutral-400", "neutral-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-neutral-500", "neutral-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-neutral-600", "neutral-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-neutral-700", "neutral-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-neutral-800", "neutral-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-neutral-900", "neutral-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-neutral-950", "neutral-950");
}
/// <summary>
///     Represents the stone color scale.
/// </summary>
public sealed class Stone : ColorScale
{
    /// <inheritdoc />
    public override Color L50 => new("--color-stone-50", "stone-50");
    /// <inheritdoc />
    public override Color L100 => new("--color-stone-100", "stone-100");
    /// <inheritdoc />
    public override Color L200 => new("--color-stone-200", "stone-200");
    /// <inheritdoc />
    public override Color L300 => new("--color-stone-300", "stone-300");
    /// <inheritdoc />
    public override Color L400 => new("--color-stone-400", "stone-400");
    /// <inheritdoc />
    public override Color L500 => new("--color-stone-500", "stone-500");
    /// <inheritdoc />
    public override Color L600 => new("--color-stone-600", "stone-600");
    /// <inheritdoc />
    public override Color L700 => new("--color-stone-700", "stone-700");
    /// <inheritdoc />
    public override Color L800 => new("--color-stone-800", "stone-800");
    /// <inheritdoc />
    public override Color L900 => new("--color-stone-900", "stone-900");
    /// <inheritdoc />
    public override Color L950 => new("--color-stone-950", "stone-950");
}
</file>

<file path="Components/DataTable/Models/ColumnDefinition.cs">
using Microsoft.AspNetCore.Components; // Required for RenderFragment
using System;
using System.Linq.Expressions;
namespace RizzyUI;
/// <summary>
/// Represents the definition of a table column, primarily used by RzTable to store
/// information about columns declared via RzTableHeaderCell.
/// </summary>
/// <typeparam name="TItem">The type of data item for the row.</typeparam>
/// <param name="Key">A unique key for the column, typically derived from the property name.</param>
/// <param name="TitleFragment">The RenderFragment for the header cell's title.</param>
/// <param name="IsSortable">Indicates if the column can be sorted.</param>
/// <param name="InitialSortDirection">The initial sort direction if the column is sortable.</param>
/// <param name="PropertyExpression">The lambda expression pointing to the TItem property this column represents. Can be null if column is not directly mapped to a property.</param>
internal record ColumnDefinition<TItem>(
    string Key,
    RenderFragment TitleFragment,
    bool IsSortable,
    SortDirection InitialSortDirection,
    Expression<Func<TItem, object?>>? PropertyExpression
);
</file>

<file path="Components/DataTable/Models/PaginationState.cs">
namespace RizzyUI;
/// <summary>
/// Represents the state of pagination for a data set.
/// </summary>
/// <param name="CurrentPage">The current page number (1-based).</param>
/// <param name="TotalPages">The total number of pages available.</param>
/// <param name="PageSize">The number of items displayed per page.</param>
/// <param name="TotalItems">The total number of items in the entire data set.</param>
public record PaginationState(int CurrentPage, int TotalPages, int PageSize, long TotalItems);
</file>

<file path="Components/DataTable/Models/SortDirection.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the direction of sorting for a table column.
/// </summary>
public enum SortDirection
{
    /// <summary>
    /// No sorting is applied, or the column is not currently sorted.
    /// </summary>
    Unset,
    /// <summary>
    /// Sort in ascending order (e.g., A-Z, 0-9).
    /// </summary>
    Ascending,
    /// <summary>
    /// Sort in descending order (e.g., Z-A, 9-0).
    /// </summary>
    Descending
}
</file>

<file path="Components/DataTable/Models/TableRequestModel.cs">
using Microsoft.AspNetCore.Http.Extensions; // For QueryBuilder
using Microsoft.AspNetCore.WebUtilities; // For QueryHelpers
using System.Collections.Generic;
using System.Linq;
using System.Text;
namespace RizzyUI;
/// <summary>
/// Represents the parameters for an HTMX table request, including pagination, sorting, and filtering.
/// </summary>
public record TableRequestModel
{
    /// <summary>
    /// Free-text search query. Corresponds to the 'q' parameter.
    /// </summary>
    public string? Query { get; init; }
    /// <summary>
    /// Current page number (1-based). Corresponds to the 'page' parameter.
    /// </summary>
    public int Page { get; init; } = 1;
    /// <summary>
    /// Number of items per page. Corresponds to the 'pageSize' parameter.
    /// </summary>
    public int PageSize { get; init; } = 10;
    /// <summary>
    /// Column(s) to sort by. Can be a single column key or comma-separated for multi-column sort.
    /// Corresponds to the 'sortBy' parameter.
    /// For nested properties, use dot notation (e.g., "Category.Name") if the server-side binder supports it,
    /// or ensure your ColumnKey on RzTableHeaderCell matches what the server expects.
    /// </summary>
    public string? SortBy { get; init; }
    /// <summary>
    /// Sort direction(s) ("asc" or "desc"). Can be a single direction or comma-separated for multi-column sort,
    /// corresponding to the SortBy columns. Corresponds to the 'sortDir' parameter.
    /// </summary>
    public string? SortDir { get; init; }
    /// <summary>
    /// Column-specific filters. Keys are in the format "filter.{columnKey}".
    /// </summary>
    public Dictionary<string, string> Filters { get; init; } = new();
    /// <summary>
    /// Converts the model to a query string, excluding null/empty values and default pagination.
    /// </summary>
    /// <returns>A query string representation.</returns>
    public string ToQueryString()
    {
        var queryParams = new Dictionary<string, string?>();
        if (!string.IsNullOrWhiteSpace(Query))
            queryParams["q"] = Query;
        if (Page > 1) // Only include page if not the first page
            queryParams["page"] = Page.ToString();
        // Only include pageSize if not the default (assuming 10 is default)
        // However, it's often safer to always include pageSize if it's part of the request contract
        // For this example, let's include it if it's not the absolute common default or has been set.
        if (PageSize != 10) 
             queryParams["pageSize"] = PageSize.ToString();
        if (!string.IsNullOrWhiteSpace(SortBy))
        {
            queryParams["sortBy"] = SortBy;
            if (!string.IsNullOrWhiteSpace(SortDir)) // Only include sortDir if sortBy is present
            {
                queryParams["sortDir"] = SortDir;
            }
        }
        foreach (var filter in Filters.Where(f => !string.IsNullOrWhiteSpace(f.Value)))
        {
            queryParams[filter.Key] = filter.Value;
        }
        var builder = new QueryBuilder();
        foreach(var kvp in queryParams.Where(kvp => kvp.Value != null))
        {
            builder.Add(kvp.Key, kvp.Value!);
        }
        return builder.ToQueryString().ToString();
    }
    /// <summary>
    /// Converts the model to a query string, excluding pagination parameters (page and pageSize)
    /// but including sort and filter parameters. Useful for constructing pagination links
    /// that preserve current sort/filter state.
    /// </summary>
    /// <returns>A query string representation without pagination parameters.</returns>
    public string ToQueryStringSansPage()
    {
        var queryParams = new Dictionary<string, string?>();
        if (!string.IsNullOrWhiteSpace(Query))
            queryParams["q"] = Query;
        // Page and PageSize are intentionally omitted
        if (!string.IsNullOrWhiteSpace(SortBy))
        {
            queryParams["sortBy"] = SortBy;
            if (!string.IsNullOrWhiteSpace(SortDir))
            {
                queryParams["sortDir"] = SortDir;
            }
        }
        foreach (var filter in Filters.Where(f => !string.IsNullOrWhiteSpace(f.Value)))
        {
            queryParams[filter.Key] = filter.Value;
        }
        var builder = new QueryBuilder();
        foreach(var kvp in queryParams.Where(kvp => kvp.Value != null))
        {
            builder.Add(kvp.Key, kvp.Value!);
        }
        return builder.ToQueryString().ToString();
    }
}
</file>

<file path="Components/DataTable/Models/TableSelectionMode.cs">
namespace RizzyUI;
/// <summary>
/// Specifies the row selection behavior for an RzTable.
/// </summary>
public enum TableSelectionMode
{
    /// <summary>
    /// Row selection is disabled.
    /// </summary>
    None,
    /// <summary>
    /// Only a single row can be selected at a time.
    /// </summary>
    Single,
    /// <summary>
    /// Multiple rows can be selected.
    /// </summary>
    Multiple
}
</file>

<file path="Components/DataTable/RzPagination/RzPagination.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()" aria-label="@NavigationAriaLabel">
    @if (EffectivePaginationState.TotalPages > 1) 
    {
        <ul class="@Theme.RzPagination.List">
            <li>
                @if (CanGoPrevious)
                {
                    <button type="button"
                            class="@Theme.RzPagination.Link"
                            aria-label="@PreviousButtonLabel"
                            @attributes="GetPageLinkHxAttributes(EffectivePaginationState.CurrentPage - 1)">
                        @PreviousButtonLabel
                    </button>
                }
                else
                {
                    <span class="@Theme.RzPagination.LinkDisabled" aria-disabled="true">
                        @PreviousButtonLabel
                    </span>
                }
            </li>

            @foreach (var link in GetPageLinks())
            {
                <li>
                    @if (link.IsEllipsis)
                    {
                        <span class="@Theme.RzPagination.Ellipsis">@link.Text</span>
                    }
                    else
                    {
                        <button type="button"
                                class="@(link.IsCurrent ? Theme.RzPagination.LinkCurrent : Theme.RzPagination.Link)"
                                aria-current="@(link.IsCurrent ? "page" : null)"
                                aria-label="@($"Go to page {link.PageNumber}")"
                                disabled="@link.IsCurrent" 
                                @attributes="link.IsCurrent ? null : GetPageLinkHxAttributes(link.PageNumber)">
                            @link.Text
                        </button>
                    }
                </li>
            }

            <li>
                @if (CanGoNext)
                {
                    <button type="button"
                            class="@Theme.RzPagination.Link"
                            aria-label="@NextButtonLabel"
                            @attributes="GetPageLinkHxAttributes(EffectivePaginationState.CurrentPage + 1)">
                        @NextButtonLabel
                    </button>
                }
                else
                {
                    <span class="@Theme.RzPagination.LinkDisabled" aria-disabled="true">
                        @NextButtonLabel
                    </span>
                }
            </li>
        </ul>
    }
    else if (EffectivePaginationState.TotalItems > 0 && EffectivePaginationState.TotalPages <= 1)
    {
        // Optionally show nothing or a minimal message if only one page or no items?
    }
</HtmlElement>
</file>

<file path="Components/DataTable/RzPagination/RzPagination.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using System.Collections.Generic;
using System; // For Math
namespace RizzyUI;
/// <summary>
/// Renders a pagination control UI based on the provided or cascaded PaginationState.
/// Generates HTMX-enabled links to navigate through pages of data in an RzTable.
/// This component is generic and will infer TItem from its parent RzTable.
/// </summary>
[CascadingTypeParameter(nameof(TItem))] 
public partial class RzPagination<TItem> : RzComponent
{
    /// <summary>
    /// Cascaded parent RzTable instance, providing context like HxControllerUrl and CurrentTableRequest.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Optional. The pagination state. If not provided, it attempts to use the
    /// CurrentPaginationState from the cascaded ParentRzTable.
    /// </summary>
    [Parameter] public PaginationState? PaginationState { get; set; }
    /// <summary>
    /// Optional. The base URL for HTMX pagination requests.
    /// If not provided, it uses HxControllerUrl from the cascaded ParentRzTable.
    /// </summary>
    [Parameter] public string? HxControllerUrl { get; set; }
    /// <summary>
    /// Optional. The CSS selector for the HTMX target.
    /// If not provided, it uses EffectiveHxTargetSelector from the cascaded ParentRzTable.
    /// </summary>
    [Parameter] public string? HxTargetSelector { get; set; }
    /// <summary>
    /// Optional. The HTMX swap mode.
    /// If not provided, it uses HxSwapMode from the cascaded ParentRzTable.
    /// </summary>
    [Parameter] public string? HxSwapMode { get; set; }
    /// <summary>
    /// Optional. The HTMX indicator selector.
    /// If not provided, it uses HxIndicatorSelector from the cascaded ParentRzTable.
    /// </summary>
    [Parameter] public string? HxIndicatorSelector { get; set; }
    /// <summary>
    /// Optional dictionary of HTMX attributes to apply to each generated page link/button.
    /// These will merge with or override the component's default HTMX attributes.
    /// These are applied only to active (non-disabled, non-ellipsis) links.
    /// </summary>
    [Parameter] public Dictionary<string, object>? HxPageLinkAttributes { get; set; }
    /// <summary>
    /// The maximum number of page links to display directly (e.g., 1, 2, 3, ..., 10).
    /// Others will be represented by ellipses. Defaults to 7. Must be >= 5 for reasonable display.
    /// </summary>
    [Parameter] public int MaxVisiblePageLinks { get; set; } = 7;
    /// <summary>
    /// Label for the "Previous" page button. Defaults to a localized "Previous".
    /// </summary>
    [Parameter] public string? PreviousButtonLabel { get; set; }
    /// <summary>
    /// Label for the "Next" page button. Defaults to a localized "Next".
    /// </summary>
    [Parameter] public string? NextButtonLabel { get; set; }
    /// <summary>
    /// ARIA label for the pagination navigation container. Defaults to a localized "Pagination Navigation".
    /// </summary>
    [Parameter] public string? NavigationAriaLabel { get; set; }
    /// <summary>
    /// Gets the effective pagination state, using the parameter or falling back to the parent table or a default.
    /// </summary>
    protected PaginationState EffectivePaginationState => PaginationState ?? ParentRzTable?.CurrentPaginationState ?? new PaginationState(1, 0, 10, 0);
    /// <summary>
    /// Gets the current table request from the parent table or a new default.
    /// </summary>
    protected TableRequestModel CurrentTableRequest => ParentRzTable?.CurrentTableRequest ?? new TableRequestModel();
    /// <summary>
    /// Gets the effective controller URL for HTMX requests.
    /// </summary>
    protected string EffectiveHxControllerUrl => HxControllerUrl ?? ParentRzTable?.HxControllerUrl ?? string.Empty;
    /// <summary>
    /// Gets the effective HTMX target selector.
    /// </summary>
    protected string EffectiveHxTargetSelector => HxTargetSelector ?? ParentRzTable?.EffectiveHxTargetSelector ?? $"#{(ParentRzTable?.TableBodyIdInternal ?? ParentRzTable?.Id + "-tbody-default")}";
    /// <summary>
    /// Gets the effective HTMX swap mode.
    /// </summary>
    protected string EffectiveHxSwapMode => HxSwapMode ?? ParentRzTable?.HxSwapMode ?? "innerHTML";
    /// <summary>
    /// Gets the effective HTMX indicator selector.
    /// </summary>
    protected string? EffectiveHxIndicatorSelector => HxIndicatorSelector ?? ParentRzTable?.HxIndicatorSelector ?? $"#{(ParentRzTable?.TableBodyIdInternal ?? ParentRzTable?.Id + "-tbody-default")}-spinner";
    /// <summary>
    /// Gets a value indicating whether the "Previous" button should be enabled.
    /// </summary>
    protected bool CanGoPrevious => EffectivePaginationState.CurrentPage > 1;
    /// <summary>
    /// Gets a value indicating whether the "Next" button should be enabled.
    /// </summary>
    protected bool CanGoNext => EffectivePaginationState.CurrentPage < EffectivePaginationState.TotalPages;
    /// <summary>
    /// Called when the component is initialized.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav"; 
        if (ParentRzTable == null && (PaginationState == null || string.IsNullOrEmpty(HxControllerUrl)))
        {
            throw new InvalidOperationException($"{GetType().Name} requires either to be within an RzTable, or to have PaginationState and HxControllerUrl parameters provided.");
        }
        EnsureParameterDefaults();
    }
    /// <summary>
    /// Called when component parameters are set.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        if (MaxVisiblePageLinks < 5) MaxVisiblePageLinks = 5; // Enforce a minimum for sensible layout
        EnsureParameterDefaults();
    }
    /// <summary>
    /// Ensures that parameter defaults are set for labels and ARIA attributes.
    /// </summary>
    private void EnsureParameterDefaults()
    {
        PreviousButtonLabel ??= Localizer["RzPagination.PreviousButtonLabel"];
        NextButtonLabel ??= Localizer["RzPagination.NextButtonLabel"];
        NavigationAriaLabel ??= Localizer["RzPagination.NavigationAriaLabel"];
    }
    /// <summary>
    /// Gets the URL for a specific page number.
    /// </summary>
    /// <param name="pageNumber">The page number.</param>
    /// <returns>The URL for the page.</returns>
    protected string GetPageUrl(int pageNumber)
    {
        if (string.IsNullOrEmpty(EffectiveHxControllerUrl) || pageNumber < 1) return "#";
        var requestParams = CurrentTableRequest with { Page = pageNumber, PageSize = EffectivePaginationState.PageSize };
        return $"{EffectiveHxControllerUrl}{requestParams.ToQueryString()}";
    }
    /// <summary>
    /// Gets the HTMX attributes for a page link.
    /// </summary>
    /// <param name="pageNumber">The page number.</param>
    /// <returns>A dictionary of HTMX attributes.</returns>
    protected Dictionary<string, object> GetPageLinkHxAttributes(int pageNumber)
    {
        var defaultAttributes = new Dictionary<string, object>
        {
            { "hx-get", GetPageUrl(pageNumber) },
            { "hx-target", EffectiveHxTargetSelector },
            { "hx-swap", EffectiveHxSwapMode }
        };
        if(!string.IsNullOrEmpty(EffectiveHxIndicatorSelector))
        {
            defaultAttributes["hx-indicator"] = EffectiveHxIndicatorSelector;
        }
        if (HxPageLinkAttributes != null)
        {
            foreach (var attr in HxPageLinkAttributes)
            {
                defaultAttributes[attr.Key] = attr.Value; 
            }
        }
        return defaultAttributes;
    }
    /// <summary>
    /// Gets the list of page links to display in the pagination control.
    /// </summary>
    /// <returns>A list of page links.</returns>
    protected List<PageLink> GetPageLinks()
    {
        var links = new List<PageLink>();
        var totalPages = EffectivePaginationState.TotalPages;
        var currentPage = EffectivePaginationState.CurrentPage;
        if (totalPages <= 0) return links;
        if (totalPages <= MaxVisiblePageLinks)
        {
            for (int i = 1; i <= totalPages; i++)
            {
                links.Add(new PageLink(i.ToString(), i, i == currentPage, false));
            }
        }
        else
        {
            // MaxVisiblePageLinks must be at least 5 for this logic (first, last, current, 2 ellipses or 2 numbers)
            // Calculate how many numbers to show on each side of current page
            int linksToShow = MaxVisiblePageLinks - 2; // slots for first, last
            bool hasStartEllipsis = false;
            bool hasEndEllipsis = false;
            if (currentPage > linksToShow / 2 + 1 && totalPages > linksToShow)
            {
                hasStartEllipsis = true;
                linksToShow--; // for start ellipsis
            }
            if (currentPage < totalPages - linksToShow / 2 && totalPages > linksToShow)
            {
                hasEndEllipsis = true;
                linksToShow--; // for end ellipsis
            }
            links.Add(new PageLink("1", 1, currentPage == 1, false));
            if (hasStartEllipsis)
            {
                links.Add(new PageLink("...", -1, false, true));
            }
            int rangeStart = Math.Max(2, currentPage - (linksToShow / 2) + (hasStartEllipsis && !hasEndEllipsis && (MaxVisiblePageLinks % 2 == 0) ? 1 : 0) );
            int rangeEnd = Math.Min(totalPages - 1, rangeStart + linksToShow -1);
            // Adjust rangeStart if rangeEnd is too small due to proximity to totalPages
            if (rangeEnd == totalPages -1 && (rangeEnd - rangeStart + 1) < linksToShow) {
                rangeStart = Math.Max(2, rangeEnd - linksToShow +1);
            }
            for (int i = rangeStart; i <= rangeEnd; i++)
            {
                if (i == 1 && links.Any(l => l.PageNumber == 1)) continue; // Already added
                if (i == totalPages && links.Any(l=>l.PageNumber == totalPages)) continue; // Will be added
                links.Add(new PageLink(i.ToString(), i, i == currentPage, false));
            }
            if (hasEndEllipsis)
            {
                 if(links.Last().PageNumber < totalPages -1 ) // ensure ellipsis is not redundant with last page
                    links.Add(new PageLink("...", -2, false, true)); // Use -2 for end ellipsis to differentiate
            }
            if(totalPages > 1) // Only add last page if it's not the same as the first page
                links.Add(new PageLink(totalPages.ToString(), totalPages, totalPages == currentPage, false));
        }
        // Deduplicate (e.g. if totalPages = 1, it might be added twice)
        // Simple distinct by PageNumber, then by IsEllipsis to prioritize numbers over ellipses if they overlap
        return links.GroupBy(l => l.PageNumber)
                    .Select(g => g.OrderBy(l => l.IsEllipsis).First())
                    .OrderBy(l => l.PageNumber == -2 ? totalPages -0.5 : (l.PageNumber == -1 ? 1.5 : l.PageNumber )   ) // Sort ellipses correctly
                    .ToList();
    }
    /// <summary>
    /// Returns the CSS class for the root element of the pagination component.
    /// </summary>
    /// <returns>The merged CSS class string.</returns>
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzPagination.Container);
    }
    /// <summary>
    /// Represents a link in the pagination control.
    /// </summary>
    /// <param name="Text">The text of the link.</param>
    /// <param name="PageNumber">The page number the link points to.</param>
    /// <param name="IsCurrent">Indicates if the link is for the current page.</param>
    /// <param name="IsEllipsis">Indicates if the link is an ellipsis.</param>
    protected record PageLink(string Text, int PageNumber, bool IsCurrent, bool IsEllipsis);
}
</file>

<file path="Components/DataTable/RzPagination/Styling/DefaultRzPaginationStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzPagination component.
/// </summary>
public class DefaultRzPaginationStyles : RzStylesBase.RzPaginationStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzPaginationStyles"/> class with the specified theme.
    /// </summary>
    /// <param name="theme">The theme to use for styling.</param>
    public DefaultRzPaginationStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    /// Gets the CSS classes for the pagination container element.
    /// Default styles center the pagination controls and add vertical padding.
    /// </summary>
    public override string Container => "flex justify-center items-center py-2"; 
    /// <summary>
    /// Gets the CSS classes for the pagination list element.
    /// Default styles create an inline flex container with small gaps between pagination items.
    /// </summary>
    public override string List => "inline-flex items-center gap-1 text-sm rounded-theme"; 
    /// <summary>
    /// Gets the base CSS styles used by multiple pagination link types.
    /// Contains shared styles for links including dimensions, spacing, and focus states.
    /// This is a private helper method used internally by the component.
    /// </summary>
    private string BaseLinkStyle => 
        "flex items-center justify-center px-3 h-8 leading-tight no-underline " +
        "text-foreground bg-background border border-outline " +
        "hover:bg-secondary hover:text-foreground " +
        "dark:bg-secondary dark:border-outline dark:text-foreground dark:hover:bg-secondary/75 dark:hover:text-foreground " +
        "focus:z-10 focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary";
    /// <summary>
    /// Gets the CSS classes for standard pagination links.
    /// Extends the base link style and adds rounded corners to first and last items.
    /// </summary>
    public override string Link => $"{BaseLinkStyle} first:rounded-l-theme last:rounded-r-theme";
    /// <summary>
    /// Gets the CSS classes for the current/active pagination link.
    /// Includes distinct styling to highlight the current page with primary colors.
    /// </summary>
    public override string LinkCurrent => 
        "flex items-center justify-center px-3 h-8 text-primary-foreground border border-primary bg-primary rounded no-underline " + // Added no-underline
        // "hover:bg-primary/90 hover:text-primary-foreground " + // Current should not have hover changes generally
        "dark:border-primary dark:bg-primary dark:text-primary-foreground " +
        "focus:z-10 focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary " +
        "aria-[current=page]:z-10 aria-[current=page]:ring-2 aria-[current=page]:ring-primary"; // Style for aria-current
    /// <summary>
    /// Gets the CSS classes for disabled pagination links (like Previous when on first page).
    /// Extends the base link style but adds reduced opacity and disabled cursor indicator.
    /// </summary>
    public override string LinkDisabled => 
        $"{BaseLinkStyle} cursor-not-allowed opacity-50 first:rounded-l-theme last:rounded-r-theme";
    /// <summary>
    /// Gets the CSS classes for ellipsis elements in the pagination.
    /// Styled similarly to links but without hover effects and with select-none to prevent text selection.
    /// </summary>
    public override string Ellipsis => 
        "flex items-center justify-center px-3 h-8 leading-tight " + 
        "text-foreground bg-background border border-outline " +
        "dark:bg-secondary dark:border-outline dark:text-foreground select-none"; // Added select-none
}
</file>

<file path="Components/DataTable/RzTable/RzTable.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent

<CascadingValue Value="this" Name="ParentRzTable" IsFixed="true">
    <HtmlElement Element="div" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
        <table class="@Theme.RzTable.Table" id="@TableId"> 
            @if (Header != null)
            {
                <thead class="@(FixedHeader ? $"{Theme.RzTable.Thead} {Theme.RzTable.FixedThead}" : Theme.RzTable.Thead)" id="@TableHeaderId">
                @Header(this)
                </thead>
            }
            
            @if (Body != null)
            {
                @Body!(this) @* RzTableBody will handle its own scrollable class based on FixedHeader *@
            }

            @if (Footer != null)
            {
                <tfoot class="@(FixedHeader ? $"{Theme.RzTable.Tfoot} {Theme.RzTable.FixedTfoot}" : Theme.RzTable.Tfoot)" id="@TableFooterId">
                @Footer(this)
                </tfoot>
            }
        </table>
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/DataTable/RzTable/RzTable.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
namespace RizzyUI;
/// <summary>
/// A highly configurable and HTMX-interactive table component.
/// It supports generic data types, templated headers, body, and footers,
/// and integrates with HTMX for dynamic operations like sorting, pagination, and filtering.
/// This component cascades itself to child components for easy access to table-wide properties.
/// </summary>
[CascadingTypeParameter(nameof(TItem))]
public partial class RzTable<TItem> : RzComponent
{
    private readonly List<ColumnDefinition<TItem>> _columnDefinitions = new();
    private string? _tableBodyIdInternal;
    private bool _hasRegisteredBody = false;
    /// <summary>
    /// Internal property to store the ID of the RzTableBody.
    /// This is set by RzTableBody upon its initialization.
    /// </summary>
    internal string? TableBodyIdInternal
    {
        get => _tableBodyIdInternal;
        private set => _tableBodyIdInternal = value;
    }
    /// <summary>
    /// Registers the ID of the RzTableBody component.
    /// Called by RzTableBody during its initialization.
    /// </summary>
    /// <param name="tableBodyId">The ID of the RzTableBody.</param>
    internal void RegisterTableBodyId(string tableBodyId)
    {
        if (_hasRegisteredBody && TableBodyIdInternal != tableBodyId)
        {
            // This situation should ideally not happen if RzTableBody is used correctly (only one instance).
        }
        if (_hasRegisteredBody && TableBodyIdInternal != tableBodyId)
        {
             throw new InvalidOperationException($"An RzTableBody with ID '{TableBodyIdInternal}' is already registered with this RzTable. Only one RzTableBody is allowed.");
        }
        TableBodyIdInternal = tableBodyId;
        _hasRegisteredBody = true; 
    }
    /// <summary>
    /// Gets the effectively resolved HTMX target selector for child components.
    /// Prioritizes HxTargetSelector parameter, then the registered TableBodyIdInternal,
    /// then falls back to a data-attribute selector convention linked to this RzTable's Id.
    /// </summary>
    public string EffectiveHxTargetSelector =>
        HxTargetSelector ??
        (!string.IsNullOrEmpty(TableBodyIdInternal) ? $"#{TableBodyIdInternal}" : $"[data-rztable-body-for='{Id}']");
    /// <summary>
    /// The collection of items to display in the table.
    /// For initial render or full Blazor re-renders.
    /// </summary>
    [Parameter, EditorRequired] public IEnumerable<TItem> Items { get; set; } = Enumerable.Empty<TItem>();
    /// <summary>
    /// The base URL for HTMX interactions (sorting, pagination, filtering).
    /// Child components like RzTableHeaderCell and RzPagination will use this
    /// to construct their HTMX request URLs.
    /// </summary>
    [Parameter, EditorRequired] public string HxControllerUrl { get; set; } = string.Empty;
    /// <summary>
    /// Represents the current request state of the table (e.g., sort order, page number, filters).
    /// This is typically bound from the parent component and updated based on server responses.
    /// </summary>
    [Parameter] public TableRequestModel CurrentTableRequest { get; set; } = new();
    /// <summary>
    /// Holds the current pagination state details (current page, total pages, etc.)
    /// received from the server.
    /// </summary>
    [Parameter] public PaginationState CurrentPaginationState { get; set; } = new(1, 0, 10, 0);
    /// <summary>
    /// Optional CSS selector for the default target of HTMX actions initiated by child components
    /// (e.g., sort headers, pagination links). If not set, it defaults to targeting the
    /// RzTableBody via its registered ID or a data-attribute fallback.
    /// </summary>
    [Parameter] public string? HxTargetSelector { get; set; }
    /// <summary>
    /// Optional default hx-swap mode for child-initiated HTMX actions (e.g., "innerHTML", "beforeend").
    /// Defaults to "innerHTML".
    /// </summary>
    [Parameter] public string HxSwapMode { get; set; } = "innerHTML";
    /// <summary>
    /// Optional default hx-indicator selector for child-initiated HTMX actions.
    /// If not set, RzTableBody will use its internal default spinner.
    /// </summary>
    [Parameter] public string? HxIndicatorSelector { get; set; }
    /// <summary>
    /// Defines the content for the table's header (&lt;thead&gt;).
    /// Typically contains one or more &lt;see cref="RzTableHeaderCell{TItem}"/&gt; components.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<RzTable<TItem>>? Header { get; set; }
    /// <summary>
    /// Defines the content for the table's body (&lt;tbody&gt;).
    /// This should be an &lt;see cref="RzTableBody{TItem}"/&gt; component.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<RzTable<TItem>>? Body { get; set; }
    /// <summary>
    /// Optional. Defines the content for the table's footer (&lt;tfoot&gt;).
    /// Often used for pagination controls or summary information.
    /// </summary>
    [Parameter] public RenderFragment<RzTable<TItem>>? Footer { get; set; }
    /// <summary>
    /// If true, applies alternating background colors to table rows. Defaults to false.
    /// </summary>
    [Parameter] public bool Striped { get; set; } = false;
    /// <summary>
    /// If true, applies hover styling to table rows. Defaults to true.
    /// </summary>
    [Parameter] public bool Hoverable { get; set; } = true;
    /// <summary>
    /// If true, applies borders to table cells (td and th). Defaults to false.
    /// </summary>
    [Parameter] public bool Border { get; set; } = false;
    /// <summary>
    /// [Future V2] Specifies the row selection mode. Defaults to None.
    /// </summary>
    [Parameter] public TableSelectionMode SelectionMode { get; set; } = TableSelectionMode.None;
    /// <summary>
    /// [Future V2] Callback for when row selection changes.
    /// </summary>
    [Parameter] public EventCallback<List<TItem>> SelectedItemsChanged { get; set; }
    /// <summary>
    /// [Future V2] The currently selected items if SelectionMode is not None.
    /// </summary>
    [Parameter] public List<TItem> SelectedItems { get; set; } = new();
    /// <summary>
    /// If true, the table header and footer (if present) will remain fixed while the table body scrolls.
    /// Defaults to false.
    /// </summary>
    [Parameter] public bool FixedHeader { get; set; } = false;
    /// <summary>
    /// The CSS class(es) to define the height of the scrollable table body when FixedHeader is true.
    /// Defaults to "h-96" (Tailwind class for height: 24rem).
    /// </summary>
    [Parameter] public string TableBodyHeightClass { get; set; } = "h-96";
    /// <summary>
    /// Id of the table element. This is used for HTMX interactions.
    /// </summary>
    public string TableId => $"{Id}-table";
    /// <summary>
    /// Id of the table head element. This is used for HTMX interactions.
    /// </summary>
    public string TableHeaderId => $"{Id}-table-head";
    /// <summary>
    /// Id of the table footer element. This is used for HTMX interactions.
    /// </summary>
    public string TableFooterId => $"{Id}-table-foot";
    /// <summary>
    /// Adds a column definition to the table's internal collection of columns.
    /// This is called by RzTableHeaderCell components during their initialization.
    /// </summary>
    /// <param name="columnDefinition">The column definition to add.</param>
    internal void AddColumnDefinition(ColumnDefinition<TItem> columnDefinition)
    {
        if (!_columnDefinitions.Any(cd => cd.Key == columnDefinition.Key))
        {
            _columnDefinitions.Add(columnDefinition);
            StateHasChanged(); 
        }
    }
    /// <summary>
    /// Returns a read-only list of all column definitions registered with this table.
    /// This allows other components to access column metadata without modifying the collection.
    /// </summary>
    /// <returns>A read-only list of column definitions.</returns>
    internal IReadOnlyList<ColumnDefinition<TItem>> GetColumnDefinitions() => _columnDefinitions.AsReadOnly();
    /// <summary>
    /// Gets the count of defined columns. Returns 1 if no columns are explicitly defined,
    /// to ensure colspans in templates like EmptyTemplate work correctly.
    /// </summary>
    public int ColumnCount => _columnDefinitions.Count > 0 ? _columnDefinitions.Count : 1;
    /// <summary>
    /// Determines the CSS classes to apply to the root container element by merging theme-based
    /// table container styles with any additional class attributes.
    /// </summary>
    /// <returns>A string containing the merged CSS classes.</returns>
    protected override string? RootClass()
    {
        var classes = new List<string> { Theme.RzTable.Container };
        if (FixedHeader)
        {
            // Apply the specific height class to the main container for fixed header scenarios
            classes.Add(Theme.RzTable.FixedHeaderContainer);
            classes.Add(TableBodyHeightClass); // User-defined or default height for the scrollable area
        }
        return TwMerge.Merge(AdditionalAttributes, classes.ToArray());
    }
}
</file>

<file path="Components/DataTable/RzTable/Styling/DefaultRzTableStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzTable component and its direct parts (table, thead, tfoot).
/// Styles for RzTableBody, RzTableHeaderCell, RzTableCell, and RzPagination will be in their respective files.
/// </summary>
public class DefaultRzTableStyles : RzStylesBase.RzTableStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzTableStyles"/> class with the specified theme.
    /// </summary>
    /// <param name="theme">The theme to use for styling.</param>
    public DefaultRzTableStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    /// Gets the CSS classes for the outer container wrapping the table.
    /// Provides overflow handling, width control, and rounded borders with appropriate colors.
    /// </summary>
    public override string Container => "overflow-hidden w-full overflow-x-auto rounded-theme border border-outline dark:border-outline";
    /// <summary>
    /// Gets the CSS classes for the table element itself.
    /// Sets width, text alignment, and appropriate text colors in both light and dark modes.
    /// </summary>
    public override string Table => "w-full text-left text-sm text-foreground dark:text-foreground";
    /// <summary>
    /// Gets the CSS classes for the table header (&lt;thead&gt;) element.
    /// Adds a bottom border, background color, and stronger text color for better contrast.
    /// </summary>
    public override string Thead => "border-b border-outline bg-secondary text-sm text-foreground dark:border-outline dark:bg-secondary dark:text-foreground";
    /// <summary>
    /// Gets the CSS classes for the table footer (&lt;tfoot&gt;) element.
    /// Adds a top border, background color, and appropriate text colors for consistent styling.
    /// </summary>
    public override string Tfoot => "border-t border-outline bg-secondary text-sm text-foreground dark:border-outline dark:bg-secondary dark:text-foreground";
    /// <summary>
    /// Gets the CSS classes for the container managing a table with a fixed header configuration.
    /// Ensures relative positioning and vertical overflow control for supporting fixed header behavior.
    /// </summary>
    public override string FixedHeaderContainer => "relative overflow-y-auto";
    /// <summary>
    /// Defines the CSS class for a table's fixed header row.
    /// Ensures the header remains visible by making it sticky at the top of the container
    /// with proper stacking context and positioning.
    /// </summary>
    public override string FixedThead => "sticky top-0 z-10";
    /// <summary>
    /// Gets the CSS classes for a fixed-position table footer (&lt;tfoot&gt;).
    /// Ensures the footer remains visible at the bottom edge of its container when scrolling vertically.
    /// Commonly used in tables with vertical overflow for improved accessibility and usability.
    /// </summary>
    public override string FixedTfoot => "sticky bottom-0 z-10";     
}
</file>

<file path="Components/DataTable/RzTableBody/RzTableBody.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()" hx-indicator="@EffectiveHxIndicatorSelector">
    @if (EffectiveItems.Any())
    {
        int rowIndex = (this.ParentRzTable?.CurrentPaginationState.CurrentPage-1) * this.ParentRzTable?.CurrentPaginationState.PageSize ?? 0;
        foreach (var item in EffectiveItems)
        {
            <CascadingValue Value="rowIndex" Name="RowIndex" IsFixed="false">
                @RowTemplate(item)
            </CascadingValue>
            rowIndex++;
        }
    }
    else if (EmptyTemplate != null)
    {
        <tr> 
            <RzTableCell TItem="@TItem" Colspan="@ColumnCount"> 
                @EmptyTemplate
            </RzTableCell>
        </tr>
    }
    else
    {
        <tr>
            <RzTableCell TItem="@TItem" Colspan="@ColumnCount">
                @Localizer["RzTable.DefaultEmptyMessage"]
            </RzTableCell>
        </tr>
    }
    <RzSpinner Id="@SpinnerId" Size="Size.Small" class="htmx-indicator absolute top-2.5 left-1/2 -translate-x-1/2"/>
</HtmlElement>
</file>

<file path="Components/DataTable/RzTableBody/RzTableBody.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using System.Collections.Generic;
using System.Linq;
namespace RizzyUI;
/// <summary>
/// Represents the body (&lt;tbody&gt;) of an RzTable. It's responsible for rendering rows based on the provided data
/// and templates. It infers its item type and data source from a parent RzTable if not explicitly provided.
/// It also registers its ID with the parent RzTable and adds a data-attribute for fallback targeting.
/// </summary>
public partial class RzTableBody<TItem> : RzComponent
{
    /// <summary>
    /// Cascaded parent RzTable instance.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Optional. The collection of items to display in the table body.
    /// If not provided, it will attempt to use the Items collection cascaded
    /// from the ParentRzTable.
    /// </summary>
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    /// <summary>
    /// Required. The template for rendering each row in the table body.
    /// The context of the RenderFragment is an instance of TItem.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<TItem> RowTemplate { get; set; } = default!;
    /// <summary>
    /// Optional. The template to display when there are no items to render in the table body.
    /// If not provided, a default message will be shown.
    /// </summary>
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    /// <summary>
    /// Gets the effective collection of items to display in the table body.
    /// Uses the Items parameter if provided, otherwise falls back to the parent RzTable's Items,
    /// or returns an empty collection if neither is available.
    /// </summary>
    protected IEnumerable<TItem> EffectiveItems => Items ?? ParentRzTable?.Items ?? Enumerable.Empty<TItem>();
    /// <summary>
    /// Gets the number of columns in the table.
    /// Uses the parent RzTable's ColumnCount if available, or defaults to 1.
    /// </summary>
    protected int ColumnCount => ParentRzTable?.ColumnCount ?? 1;
    /// <summary>
    /// Gets the ID to use for the loading spinner element.
    /// Constructed by appending "-spinner" to the component's ID.
    /// </summary>
    protected string SpinnerId => $"{Id}-spinner";
    /// <summary>
    /// Gets the effective HX indicator selector to use for HTMX loading indicators.
    /// Prioritizes any explicitly set "hx-indicator" in AdditionalAttributes,
    /// then falls back to ParentRzTable's HxIndicatorSelector,
    /// and finally uses a selector targeting this component's spinner by ID.
    /// </summary>
    protected string? EffectiveHxIndicatorSelector
    {
        get
        {
            if (AdditionalAttributes?.TryGetValue("hx-indicator", out var indicator) == true && indicator is string indicatorStr)
            {
                return indicatorStr;
            }
            return ParentRzTable?.HxIndicatorSelector ?? $"#{SpinnerId}";
        }
    }
    /// <summary>
    /// Initializes the component by setting the HTML element to "tbody",
    /// verifying it's within an RzTable parent, registering its ID with the parent,
    /// and adding data attributes for HTMX targeting.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "tbody"; 
        if (ParentRzTable == null)
        {
            throw new InvalidOperationException($"{GetType().Name} must be used within an RzTable.");
        }
        ParentRzTable.RegisterTableBodyId(Id);
        // Add data-attribute for fallback targeting
        AdditionalAttributes ??= new Dictionary<string, object>();
        AdditionalAttributes[$"data-rztable-body-for"] = ParentRzTable.Id;
    }
    /// <summary>
    /// Determines the CSS classes to apply to the root element by merging theme-based
    /// table body styles with any additional class attributes.
    /// </summary>
    /// <returns>A string containing the merged CSS classes.</returns>
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzTableBody.TableBody);
    }
}
</file>

<file path="Components/DataTable/RzTableBody/Styling/DefaultRzTableBodyStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzTableBody component.
/// Defines styling for the table body element and empty state display.
/// </summary>
public class DefaultRzTableBodyStyles : RzStylesBase.RzTableBodyStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzTableBodyStyles"/> class with the specified theme.
    /// </summary>
    /// <param name="theme">The theme to use for styling.</param>
    public DefaultRzTableBodyStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    /// Gets the CSS classes for the table body element.
    /// Provides divider styling between rows and establishes relative positioning
    /// for potential overlays or loading indicators.
    /// </summary>
    public override string TableBody => "divide-y divide-outline dark:divide-outline relative"; 
    /// <summary>
    /// Gets the CSS classes for cells in empty state rows.
    /// Styles include padding, centered text alignment, and muted text color
    /// to properly display the empty state message.
    /// </summary>
    public override string EmptyRowCell => "p-4 text-center text-muted-foreground dark:text-muted-foreground";
    /// <summary>
    /// Gets the CSS classes that enable and style the scrollable behavior of the table body.
    /// Defines overflow properties allowing vertical scrolling for content within the table body area.
    /// </summary>
    public override string ScrollableBody => "block overflow-y-auto";
}
</file>

<file path="Components/DataTable/RzTableCell/RzTableCell.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="CombinedAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/DataTable/RzTableCell/RzTableCell.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using System.Collections.Generic;
namespace RizzyUI;
/// <summary>
/// Represents a table data cell (&lt;td&gt;) within an RzTable.
/// Provides basic cell functionality including content, colspan, and styling.
/// Can conditionally render a border based on the parent RzTable's Border property.
/// </summary>
public partial class RzTableCell<TItem> : RzComponent 
{
    /// <summary>
    /// Cascaded parent RzTable instance. Available for context like the Border property.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Cascaded parent row containing this cell, if available.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTableRowParentRzTableRow")]
    protected RzTableRow<TItem>? ParentRzTableRow { get; set; }
    /// <summary>
    /// The content to be rendered inside the table cell.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Optional. Specifies the number of columns this cell should span.
    /// </summary>
    [Parameter] public int? Colspan { get; set; }
    /// <summary>
    /// Optional. A key to associate this cell with a specific column, primarily for clarity
    /// or potential future features like column-specific styling from the cell itself.
    /// </summary>
    [Parameter] public string? ColumnKey { get; set; }
    /// <summary>
    /// Gets combined attributes including any passed-in AdditionalAttributes and
    /// dynamically adds colspan attribute if the Colspan parameter has a value.
    /// </summary>
    protected Dictionary<string, object> CombinedAttributes
    {
        get
        {
            var attributes = new Dictionary<string, object>(AdditionalAttributes ?? new Dictionary<string, object>());
            if (Colspan.HasValue)
            {
                attributes["colspan"] = Colspan.Value.ToString();
            }
            return attributes;
        }
    }
    /// <summary>
    /// Initializes the component by setting the HTML element to "td" and preparing base attributes.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "td";
    }
    /// <summary>
    /// Determines the CSS classes to apply to the root element by merging theme-based
    /// table cell styles with any additional class attributes and conditional border styles.
    /// </summary>
    /// <returns>A string containing the merged CSS classes.</returns>
    protected override string? RootClass()
    {
        var styles = Theme.RzTableCell;
        var classBuilder = new List<string> { styles.TableCellBase };
        if (ParentRzTable is { Border: true })
        {
            classBuilder.Add(styles.TableCellBordered);
        }
        return TwMerge.Merge(AdditionalAttributes, classBuilder.ToArray());
    }
}
</file>

<file path="Components/DataTable/RzTableCell/Styling/DefaultRzTableCellStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzTableCell component.
/// </summary>
public class DefaultRzTableCellStyles : RzStylesBase.RzTableCellStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzTableCellStyles"/> class with the specified theme.
    /// </summary>
    /// <param name="theme">The theme to use for styling.</param>
    public DefaultRzTableCellStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    /// Gets the CSS classes for the base table cell element (padding).
    /// </summary>
    public override string TableCellBase => "p-4";
    /// <summary>
    /// Gets the CSS classes for a bordered table cell element.
    /// Default adds a right border. Use with CSS :last-child selectors for cleaner table appearance if needed.
    /// </summary>
    public override string TableCellBordered => "border-r border-outline dark:border-outline"; 
    // Consider if a full border "border border-outline" is better or if this should be more specific (e.g. border-x)
    // For now, just right border, assuming row handles bottom.
}
</file>

<file path="Components/DataTable/RzTableHeaderCell/RzTableHeaderCell.razor">
@namespace RizzyUI
@using Blazicons

@typeparam TItem
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()" aria-sort="@_ariaSortValue">
    @if (Sortable)
    {
        <button type="button"
                class="@Theme.RzTableHeaderCell.SortableButton"
                aria-label="@_sortButtonAriaLabel"
                @attributes="GetEffectiveHxAttributes()">
            <span class="@Theme.RzTableHeaderCell.TitleSpan">@ChildContent</span>
            @if (SortIndicatorIcon != null)
            {
                <div class="@SortIndicatorClass">
                    <Blazicon Svg="SortIndicatorIcon" />
                </div>
                
            }
        </button>
    }
    else
    {
        <span class="@Theme.RzTableHeaderCell.TitleSpan">@ChildContent</span>
    }
</HtmlElement>
</file>

<file path="Components/DataTable/RzTableHeaderCell/RzTableHeaderCell.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using Blazicons; 
using Rizzy.Utility;
namespace RizzyUI;
/// <summary>
/// Represents a header cell (&lt;th&gt;) in an RzTable.
/// It can define a column, enable sorting via HTMX, display sort direction indicators,
/// include ARIA attributes for accessibility, and conditionally render a border.
/// </summary>
public partial class RzTableHeaderCell<TItem> : RzComponent
{
    private string? _columnKeyInternal;
    private string? _effectiveHxGetUrl;
    private SortDirection _currentSortDirection = SortDirection.Unset;
    private SortDirection _nextSortDirection = SortDirection.Ascending;
    private string _ariaSortValue = "none";
    private string _sortButtonAriaLabel = string.Empty;
    /// <summary>
    /// Cascaded parent RzTable instance.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// An expression that identifies the property of TItem this header cell is associated with.
    /// Used to determine the column key for sorting if `ColumnKey` is not explicitly set.
    /// For nested properties (e.g., `p => p.Category.Name`), provide the full path via the `ColumnKey` parameter
    /// as automatic inference only supports direct members.
    /// </summary>
    [Parameter] public Expression<Func<TItem, object?>>? For { get; set; }
    /// <summary>
    /// Explicitly sets the key for this column (e.g., "Name", "Category.Name").
    /// If not provided, it's inferred from the `For` expression (for direct members only).
    /// This key is used in `TableRequestModel.SortBy`.
    /// </summary>
    [Parameter] public string? ColumnKey { get; set; }
    /// <summary>
    /// If true, this column header will be interactive for sorting. Defaults to false.
    /// </summary>
    [Parameter] public bool Sortable { get; set; }
    /// <summary>
    /// The initial sort direction for this column if it's the primary sort column on first load.
    /// This is primarily for visual indication; actual sorting is driven by `ParentRzTable.CurrentTableRequest`.
    /// </summary>
    [Parameter] public SortDirection InitialSortDirection { get; set; } = SortDirection.Unset;
    /// <summary>
    /// The content to be rendered inside the header cell (e.g., column title).
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment ChildContent { get; set; } = default!;
    /// <summary>
    /// Optional dictionary of HTMX attributes to apply to the sortable button.
    /// These will merge with or override the component's default HTMX attributes.
    /// </summary>
    [Parameter] public Dictionary<string, object>? HxAttributes { get; set; }
    /// <summary>
    /// Gets the effective column key, derived from `ColumnKey` or the `For` expression.
    /// </summary>
    public string EffectiveColumnKey => _columnKeyInternal ?? "unknown_column";
    /// <summary>
    /// Gets the current sort direction for this column.
    /// This is determined based on the parent table's CurrentTableRequest.
    /// </summary>
    protected SortDirection CurrentSortDirection => _currentSortDirection;
    /// <summary>
    /// Gets the next sort direction that would be applied when clicking the header.
    /// The sequence typically cycles: Unset -> Ascending -> Descending -> Unset.
    /// </summary>
    protected SortDirection NextSortDirection => _nextSortDirection;
    /// <summary>
    /// Gets the value for the aria-sort attribute, which helps screen readers announce the current sort state.
    /// Values can be "none", "ascending", or "descending".
    /// </summary>
    protected string AriaSortValue => _ariaSortValue;
    /// <summary>
    /// Gets the aria-label for the sort button, which provides accessible description of the column and its current sort state.
    /// </summary>
    protected string SortButtonAriaLabel => _sortButtonAriaLabel;
    /// <summary>
    /// Gets the CSS class string for the sort direction indicator icon.
    /// The styling changes based on current sort direction to provide visual cues.
    /// </summary>
    protected string SortIndicatorClass => Theme.RzTableHeaderCell.GetSortIndicatorCss(_currentSortDirection);
    /// <summary>
    /// Gets the appropriate icon to display based on the current sort direction.
    /// Returns different icons for ascending, descending, and unsorted states.
    /// </summary>
    protected SvgIcon? SortIndicatorIcon => Theme.RzTableHeaderCell.GetSortIndicatorIcon(_currentSortDirection);
    /// <summary>
    /// Called when the component is initialized.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentRzTable == null)
        {
            throw new InvalidOperationException($"{GetType().Name} must be used within an RzTable.");
        }
        if (string.IsNullOrEmpty(Element))
            Element = "th";
        AdditionalAttributes ??= new Dictionary<string, object>();
        AdditionalAttributes.TryAdd("scope", "col");
        ResolveColumnKeyAndRegister();
    }
    /// <summary>
    /// Called when component parameters are set.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        UpdateSortStateAndHxUrl();
    }
    /// <summary>
    /// Resolves the column key and registers the column definition with the parent table.
    /// </summary>
    private void ResolveColumnKeyAndRegister()
    {
        string resolvedKey;
        if (!string.IsNullOrWhiteSpace(ColumnKey))
        {
            resolvedKey = ColumnKey;
        }
        else if (For?.Body is MemberExpression memberExpression)
        {
            resolvedKey = memberExpression.Member.Name;
        }
        else if (For?.Body is UnaryExpression { Operand: MemberExpression unaryMemberExpression }) 
        {
            resolvedKey = unaryMemberExpression.Member.Name;
        }
        else
        {
            resolvedKey = ChildContent.AsMarkupString().Trim().Replace(" ", "_") + "_" + IdGenerator.UniqueId("col");
            if (string.IsNullOrWhiteSpace(resolvedKey) || resolvedKey.StartsWith("_"))
            {
                 resolvedKey = IdGenerator.UniqueId("col_anon_");
            }
        }
        _columnKeyInternal = resolvedKey;
        ParentRzTable!.AddColumnDefinition(new ColumnDefinition<TItem>(
            EffectiveColumnKey,
            ChildContent,
            Sortable,
            InitialSortDirection,
            For
        ));
    }
    /// <summary>
    /// Updates the sort state and the HTMX URL for sorting.
    /// </summary>
    private void UpdateSortStateAndHxUrl()
    {
        if (ParentRzTable == null) return;
        var currentRequest = ParentRzTable.CurrentTableRequest;
        _currentSortDirection = SortDirection.Unset;
        _nextSortDirection = Sortable ? (InitialSortDirection != SortDirection.Unset ? InitialSortDirection : SortDirection.Ascending) : SortDirection.Unset;
        _ariaSortValue = "none";
        _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionNone"]);
        if (Sortable && !string.IsNullOrWhiteSpace(_columnKeyInternal))
        {
            if (currentRequest.SortBy == _columnKeyInternal)
            {
                if (currentRequest.SortDir?.ToLowerInvariant() == "asc")
                {
                    _currentSortDirection = SortDirection.Ascending;
                    _nextSortDirection = SortDirection.Descending;
                    _ariaSortValue = "ascending";
                    _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionAscendingLong"]);
                }
                else if (currentRequest.SortDir?.ToLowerInvariant() == "desc")
                {
                    _currentSortDirection = SortDirection.Descending;
                    _nextSortDirection = SortDirection.Unset; 
                    _ariaSortValue = "descending";
                    _sortButtonAriaLabel = string.Format(Localizer["RzTable.SortButtonAriaLabelFormat"], ChildContent.AsMarkupString(), Localizer["RzTable.SortDirectionDescendingLong"]);
                }
            } else {
                if (InitialSortDirection != SortDirection.Unset && string.IsNullOrEmpty(currentRequest.SortBy))
                {
                     _currentSortDirection = InitialSortDirection;
                     _ariaSortValue = InitialSortDirection == SortDirection.Ascending ? "ascending" : "descending";
                }
            }
            TableRequestModel nextRequestParameters;
            if (_nextSortDirection == SortDirection.Unset)
            {
                nextRequestParameters = currentRequest with { SortBy = null, SortDir = null, Page = 1 };
            }
            else
            {
                nextRequestParameters = currentRequest with { 
                    SortBy = _columnKeyInternal, 
                    SortDir = _nextSortDirection == SortDirection.Ascending ? "asc" : "desc",
                    Page = 1 
                };
            }
            _effectiveHxGetUrl = $"{ParentRzTable.HxControllerUrl}{nextRequestParameters.ToQueryString()}";
        }
        else
        {
            _effectiveHxGetUrl = null;
        }
    }
    /// <summary>
    /// Gets the effective HTMX attributes for the sortable button.
    /// </summary>
    /// <returns>A dictionary of HTMX attributes.</returns>
    protected Dictionary<string, object> GetEffectiveHxAttributes()
    {
        var defaultAttributes = new Dictionary<string, object>();
        if (Sortable && !string.IsNullOrEmpty(_effectiveHxGetUrl) && ParentRzTable != null)
        {
            defaultAttributes["hx-get"] = _effectiveHxGetUrl;
            defaultAttributes["hx-target"] = ParentRzTable.EffectiveHxTargetSelector;
            defaultAttributes["hx-swap"] = ParentRzTable.HxSwapMode;
            if (!string.IsNullOrEmpty(ParentRzTable.HxIndicatorSelector))
            {
                 defaultAttributes["hx-indicator"] = ParentRzTable.HxIndicatorSelector;
            }
        }
        if (HxAttributes != null)
        {
            foreach (var attr in HxAttributes)
            {
                defaultAttributes[attr.Key] = attr.Value;
            }
        }
        return defaultAttributes;
    }
    /// <summary>
    /// Returns the CSS class for the root element of the header cell.
    /// </summary>
    /// <returns>The merged CSS class string.</returns>
    protected override string? RootClass()
    {
        var styles = Theme.RzTableHeaderCell;
        var classBuilder = new List<string> { styles.HeaderCellBase };
        if (Sortable)
        {
            classBuilder.Add(styles.SortableHeaderCell);
        }
        if (ParentRzTable is { Border: true })
        {
            classBuilder.Add(styles.HeaderCellBordered);
        }
        return TwMerge.Merge(AdditionalAttributes, classBuilder.ToArray());
    }
}
</file>

<file path="Components/DataTable/RzTableHeaderCell/Styling/DefaultRzTableHeaderCellStyles.cs">
using Blazicons;
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzTableHeaderCell component.
/// </summary>
public class DefaultRzTableHeaderCellStyles : RzStylesBase.RzTableHeaderCellStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzTableHeaderCellStyles"/> class with the specified theme.
    /// </summary>
    /// <param name="theme">The theme to use for styling.</param>
    public DefaultRzTableHeaderCellStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    /// Gets the CSS classes for the base header cell element.
    /// Default is "p-4" which provides consistent padding.
    /// </summary>
    public override string HeaderCellBase => "p-4";
    /// <summary>
    /// Gets the CSS classes for the sort button inside sortable header cells.
    /// Styles include spacing, alignment, and focus states for better accessibility.
    /// </summary>
    public override string SortableButton => "flex items-center justify-between gap-2 w-full text-left focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 dark:focus-visible:ring-offset-secondary rounded-sm";
    /// <summary>
    /// Gets the CSS classes for sortable header cells.
    /// Changes the cursor and adds hover states to provide visual feedback for interactive cells.
    /// </summary>
    public override string SortableHeaderCell => "cursor-pointer hover:bg-secondary/50 dark:hover:bg-secondary/50";
    /// <summary>
    /// Gets the CSS classes for the title span within header cells.
    /// Uses flex-grow to allow the sort indicator to be properly positioned.
    /// </summary>
    public override string TitleSpan => "flex-grow";
    /// <summary>
    /// Gets the CSS classes for a bordered header cell element.
    /// </summary>
    public override string HeaderCellBordered => "border-r border-outline dark:border-outline";
    /// <summary>
    /// Gets the CSS classes for the sort direction indicator based on the current sort direction.
    /// </summary>
    /// <param name="direction">The current sort direction.</param>
    /// <returns>CSS classes for styling the sort indicator appropriate to the sort direction.</returns>
    public override string GetSortIndicatorCss(SortDirection direction)
    {
        return direction switch
        {
            SortDirection.Ascending => "size-4 text-foreground dark:text-foreground",
            SortDirection.Descending => "size-4 text-foreground dark:text-foreground",
            SortDirection.Unset => "size-4 text-muted-foreground dark:text-muted-foreground opacity-60",
            _ => "size-4 opacity-0" 
        };
    }
    /// <summary>
    /// Gets the appropriate SVG icon for the sort direction indicator based on the current sort direction.
    /// </summary>
    /// <param name="direction">The current sort direction.</param>
    /// <returns>An SVG icon representing the sort direction, or null if no icon should be displayed.</returns>
    public override SvgIcon? GetSortIndicatorIcon(SortDirection direction)
    {
        return direction switch
        {
            SortDirection.Ascending => MdiIcon.ArrowUp,
            SortDirection.Descending => MdiIcon.ArrowDown,
            SortDirection.Unset => MdiIcon.ArrowUpDownBoldOutline,
            _ => null
        };
    }
}
</file>

<file path="Components/DataTable/RzTableRow/RzTableRow.razor">
@namespace RizzyUI
@typeparam TItem
@inherits RzComponent

<CascadingValue Value="this" Name="ParentRzTableRow" IsFixed="true">
	<tr @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
			@ChildContent
	</tr>	
</CascadingValue>
</file>

<file path="Components/DataTable/RzTableRow/RzTableRow.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using System.Collections.Generic;
using Rizzy.Utility; 
namespace RizzyUI;
/// <summary>
/// Represents a table row (&lt;tr&gt;) within an RzTable, typically used in Header, Body (RowTemplate), or Footer.
/// It primarily acts as a styled wrapper for its ChildContent, which should consist of RzTableHeaderCell or RzTableCell components.
/// Styling is determined by the active <see cref="RzTheme"/>, and can be influenced by parent RzTable properties like Striped and Hoverable.
/// </summary>
[CascadingTypeParameter(nameof(TItem))] // Allows TItem to be inferred from parent RzTable or RzTableBody
public partial class RzTableRow<TItem> : RzComponent
{
    /// <summary>
    /// Cascaded parent RzTable instance.
    /// </summary>
    [CascadingParameter(Name = "ParentRzTable")]
    protected RzTable<TItem>? ParentRzTable { get; set; }
    /// <summary>
    /// Cascaded row index from RzTableBody. Null if not in a body context or if striping is disabled.
    /// </summary>
    [CascadingParameter(Name = "RowIndex")]
    protected int? RowIndex { get; set; }
    /// <summary>
    /// The data item for the current row, typically provided by the RzTableBody's RowTemplate context.
    /// This can be used for conditional styling or row-specific attributes if needed in the future,
    /// though it's not directly used by the base &lt;tr&gt; styling itself currently.
    /// </summary>
    [Parameter] public TItem? Item { get; set; }
    /// <summary>
    /// The content to be rendered inside the table row, typically RzTableHeaderCell or RzTableCell components.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Called when the component is initialized.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "tr";
        if (ParentRzTable != null)
        {
            Id = $"{ParentRzTable.TableBodyIdInternal}-row";
            if (RowIndex != null)
                Id += "-" + RowIndex;
            else
            {
                Id = IdGenerator.UniqueId(Id);
            }
        }
    }
    /// <summary>
    /// Returns the CSS class for the root element of the row.
    /// </summary>
    /// <returns>The merged CSS class string.</returns>
    protected override string? RootClass()
    {
        var styles = Theme.RzTableRow;
        var classBuilder = new List<string> { styles.TableRowBase };
        if (ParentRzTable is { Hoverable: true })
        {
            classBuilder.Add(styles.TableRowHover);
        }
        if (ParentRzTable is { Striped: true } && RowIndex.HasValue)
        {
            // Apply theme-based surface colors for striping
            // These Tailwind classes will respect the theme's definitions
            classBuilder.Add(RowIndex.Value % 2 == 0 ? "bg-background" : "bg-secondary");
        }
        else if (ParentRzTable is { Striped: false })
        {
            // Ensure default row background if not striped
            classBuilder.Add("bg-background");
        }
        return TwMerge.Merge(AdditionalAttributes, classBuilder.ToArray());
    }
}
</file>

<file path="Components/DataTable/RzTableRow/Styling/DefaultRzTableRowStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzTableRow component.
/// </summary>
public class DefaultRzTableRowStyles : RzStylesBase.RzTableRowStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzTableRowStyles"/> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzTableRowStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string TableRowBase =>
        "border-b border-outline dark:border-outline transition-colors duration-150 ease-in-out";
    /// <inheritdoc />
    public override string TableRowHover =>
        "hover:bg-secondary/50 dark:hover:bg-secondary/50";
}
</file>

<file path="Components/Display/RzAvatar/RzAvatar.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()" role="img"
             aria-label="@AlternateText">
    @if (IndicatorVisible)
    {
        <div class="@Theme.RzAvatar.Indicator @Theme.RzAvatar.GetIndicatorSizeCss(Size) @Theme.RzAvatar.GetIndicatorColorCss(IndicatorColor)" aria-hidden="true"></div>
    }
    @if (!string.IsNullOrEmpty(ImageSource))
    {
        <img src="@ImageSource" alt="@AlternateText" class="@Theme.RzAvatar.Image @Theme.RzAvatar.GetSizeCss(Size) @Theme.RzAvatar.GetShapeCss(Shape)"/>
    }
    else if (!string.IsNullOrEmpty(Initials))
    {
        <div
            class="initialsContainer @Theme.RzAvatar.InitialsContainer @Theme.RzAvatar.GetSizeCss(Size) @Theme.RzAvatar.GetShapeCss(Shape) @Theme.RzAvatar.GetInitialsSizeCss(Size)">
            @Initials
        </div>
    }
    else
    {
        <div class="@Theme.RzAvatar.PlaceholderContainer @Theme.RzAvatar.GetSizeCss(Size) @Theme.RzAvatar.GetShapeCss(Shape)">
            <svg class="@Theme.RzAvatar.PlaceholderIcon @Theme.RzAvatar.GetPlaceholderSizeCss(Size)"
                 fill="currentColor"
                 viewBox="0 0 20 20"
                 xmlns="http://www.w3.org/2000/svg"
                 aria-hidden="true">
                <path
                    fill-rule="evenodd"
                    d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z"
                    clip-rule="evenodd"/>
            </svg>
        </div>
    }
</HtmlElement>
</file>

<file path="Components/Display/RzAvatar/RzAvatar.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a user avatar, supporting image sources, initials fallback, and optional status indicators.
///     Styling and dimensions are determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzAvatar : RzComponent
{
    private string _initials = string.Empty;
    /// <summary> Gets or sets the source URL of the avatar image. </summary>
    [Parameter]
    public string ImageSource { get; set; } = string.Empty;
    /// <summary> Gets or sets the display name associated with the avatar (used for alt text). </summary>
    [Parameter]
    public string DisplayName { get; set; } = string.Empty;
    /// <summary> Gets or sets the initials to display when no image is provided (max 2 chars, uppercase). </summary>
    [Parameter]
#pragma warning disable BL0007
    public string Initials
#pragma warning restore BL0007
    {
        get => _initials;
        set => _initials = value != null && value.Length > 2
            ? value.Substring(0, 2).ToUpperInvariant()
            : (value ?? string.Empty).ToUpperInvariant();
    }
    /// <summary> Gets or sets the shape of the avatar. Defaults to Circle. </summary>
    [Parameter]
    public AvatarShape Shape { get; set; } = AvatarShape.Circle;
    /// <summary> Gets or sets the size of the avatar. Defaults to Medium. </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <summary> Gets or sets a value indicating whether the status indicator is visible. </summary>
    [Parameter]
    public bool IndicatorVisible { get; set; }
    /// <summary> Gets or sets the accent color of the status indicator. Defaults to Emerald. </summary>
    [Parameter]
    public AccentColor IndicatorColor { get; set; } = AccentColor.Emerald;
    /// <summary>
    ///     Gets or sets a value indicating whether the avatar has a border (Currently not implemented in default
    ///     styles).
    /// </summary>
    [Parameter]
    public bool Border { get; set; } // Note: Border styling needs explicit addition if desired
    /// <summary> Gets the alternate text for the avatar image, used for accessibility. </summary>
    private string AlternateText => string.IsNullOrEmpty(DisplayName) ? "User Avatar" : $"{DisplayName}";
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAvatar.Container ?? string.Empty, Theme.RzAvatar.GetSizeCss(Size));
    }
}
</file>

<file path="Components/Display/RzAvatar/Styling/DefaultRzAvatarStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzAvatar component.
/// </summary>
public class DefaultRzAvatarStyles : RzStylesBase.RzAvatarStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzAvatarStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzAvatarStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container =>
        "relative inline-block aspect-square object-cover"; // Base container styles, size added separately
    /// <inheritdoc />
    public override string Indicator =>
        "border-2 absolute right-0 top-0 rounded-full border-surface"; // Base indicator styles, size and color added separately
    /// <inheritdoc />
    public override string Image => "inline-block aspect-square"; // Base image styles, size and shape added separately
    /// <inheritdoc />
    public override string InitialsContainer =>
        "inline-flex items-center justify-center bg-secondary text-muted-foreground dark:bg-secondary dark:text-muted-foreground"; // Base initials container styles, size and shape added separately
    /// <inheritdoc />
    public override string PlaceholderContainer =>
        "inline-flex items-center justify-center bg-secondary text-outline dark:bg-secondary dark:text-outline"; // Base placeholder styles, size and shape added separately
    /// <inheritdoc />
    public override string PlaceholderIcon => "inline-block"; // Base placeholder icon styles, size added separately
    /// <inheritdoc />
    public override string GetShapeCss(AvatarShape shape)
    {
        return shape switch
        {
            AvatarShape.Circle => "rounded-full", // Use theme token for full roundness
            AvatarShape.Square => "rounded-theme",
            _ => "rounded-full"
        };
    }
    /// <inheritdoc />
    public override string GetSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "size-6",
            Size.Small => "size-8",
            Size.Medium => "size-10",
            Size.Large => "size-14",
            Size.ExtraLarge => "size-20",
            _ => GetSizeCss(Size.Medium)
        };
    }
    /// <inheritdoc />
    public override string GetInitialsSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "text-xs", // Adjusted from original text-sm for better fit
            Size.Small => "text-sm",
            Size.Medium => "text-base", // Adjusted from original empty
            Size.Large => "text-2xl",
            Size.ExtraLarge => "text-4xl",
            _ => GetInitialsSizeCss(Size.Medium)
        };
    }
    /// <inheritdoc />
    public override string GetPlaceholderSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "size-4",
            Size.Small => "size-5",
            Size.Medium => "size-6",
            Size.Large => "size-8",
            Size.ExtraLarge => "size-10",
            _ => GetPlaceholderSizeCss(Size.Medium)
        };
    }
    /// <inheritdoc />
    public override string GetIndicatorSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "size-3",
            Size.Small => "size-3",
            Size.Medium => "size-3",
            Size.Large => "size-4",
            Size.ExtraLarge => "size-5",
            _ => GetIndicatorSizeCss(Size.Medium)
        };
    }
    /// <inheritdoc />
    public override string GetIndicatorColorCss(AccentColor color)
    {
        return color.ToLightBackgroundClass() + " " + color.ToDarkBackgroundClass();
    }
}
</file>

<file path="Components/Display/RzBadge/RzBadge.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
    <span class="@Theme.RzBadge.InnerSpan">
	    <span class="flex items-center gap-1"> 
		    @if (Icon != null)
		    {
			    <Blazicon Svg="Icon"/>
		    }
		    @ChildContent @Label
	    </span>
	</span>
</HtmlElement>
</file>

<file path="Components/Display/RzBadge/RzBadge.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A badge component for displaying labels with various styles and colors, determined by the active
///     <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzBadge : RzComponent
{
    /// <summary> The semantic color of the badge. Defaults to SurfaceAlt. </summary>
    [Parameter]
    public SemanticColor Color { get; set; } = SemanticColor.SurfaceAlt;
    /// <summary> When set to true, applies a softer styling to the badge. </summary>
    [Parameter]
    public bool Soft { get; set; }
    /// <summary> Optional icon to display within the badge. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Optional text label for the badge. Used if ChildContent is not provided. </summary>
    [Parameter]
    public string Label { get; set; } = string.Empty;
    /// <summary> Child content for the badge, allowing for text and additional elements. Overrides Label if set. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Initializes the component, setting the default element type if not specified.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "span"; // Default element for a badge
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzBadge;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Badge,
            Soft ? styles.GetVariantSoftCss(Color) : styles.GetVariantCss(Color));
    }
}
</file>

<file path="Components/Display/RzBadge/Styling/DefaultRzBadgeStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzBadge component.
/// </summary>
public class DefaultRzBadgeStyles : RzStylesBase.RzBadgeStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzBadgeStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzBadgeStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Badge =>
        "w-fit inline-flex overflow-hidden rounded-theme-2xl border text-xs font-medium"; // Use theme token
    /// <inheritdoc />
    public override string InnerSpan => "flex items-center gap-1 px-2 py-1";
    /// <inheritdoc />
    public override string GetVariantCss(SemanticColor color)
    {
        return color switch
        {
            SemanticColor.Surface => "border-outline bg-background text-foreground",
            SemanticColor.SurfaceAlt => "border-foreground bg-secondary text-foreground", // Corrected border
            SemanticColor.Primary => "border-primary bg-primary text-primary-foreground",
            SemanticColor.Secondary => "border-secondary bg-secondary text-secondary-foreground",
            SemanticColor.Info =>
                "border-info bg-info text-info-foreground dark:border-info dark:bg-info dark:text-info-foreground",
            SemanticColor.Success =>
                "border-success bg-success text-success-foreground dark:border-success dark:bg-success dark:text-success-foreground",
            SemanticColor.Warning =>
                "border-warning bg-warning text-warning-foreground dark:border-warning dark:bg-warning dark:text-warning-foreground",
            SemanticColor.Destructive =>
                "border-destructive bg-destructive text-destructive-foreground dark:border-destructive dark:bg-destructive dark:text-destructive-foreground",
            SemanticColor.Outline => "border-outline bg-transparent text-outline",
            SemanticColor.OnSurface => GetVariantCss(SemanticColor.Surface), // Map On variants to base
            SemanticColor.OnSurfaceStrong => GetVariantCss(SemanticColor.Surface),
            SemanticColor.OnPrimary => GetVariantCss(SemanticColor.Primary),
            SemanticColor.OnSecondary => GetVariantCss(SemanticColor.Secondary),
            SemanticColor.OnInfo => GetVariantCss(SemanticColor.Info),
            SemanticColor.OnSuccess => GetVariantCss(SemanticColor.Success),
            SemanticColor.OnWarning => GetVariantCss(SemanticColor.Warning),
            SemanticColor.DestructiveForeground => GetVariantCss(SemanticColor.Destructive),
            SemanticColor.OutlineStrong => GetVariantCss(SemanticColor.Outline),
            SemanticColor.None => "",
            _ => GetVariantCss(SemanticColor.SurfaceAlt) // Default
        };
    }
    /// <inheritdoc />
    public override string GetVariantSoftCss(SemanticColor color)
    {
        return color switch
        {
            SemanticColor.Surface => "border-outline bg-background text-foreground",
            SemanticColor.SurfaceAlt => "border-foreground bg-secondary text-foreground",
            SemanticColor.Primary => "border-primary bg-primary/10 text-primary",
            SemanticColor.Secondary => "border-secondary bg-secondary/10 text-secondary",
            SemanticColor.Info =>
                "border-info bg-info/10 dark:bg-info/10 text-info dark:border-info dark:text-info-foreground",
            SemanticColor.Success =>
                "border-success bg-success/10 dark:bg-success/10 text-success dark:border-success dark:text-success-foreground",
            SemanticColor.Warning =>
                "border-warning bg-warning/10 dark:bg-warning/10 text-warning dark:border-warning dark:text-warning-foreground",
            SemanticColor.Destructive =>
                "border-destructive bg-destructive/10 dark:bg-destructive/10 text-destructive dark:border-destructive dark:text-destructive-foreground",
            SemanticColor.Outline => "border-outline bg-outline/10 text-foreground",
            SemanticColor.OnSurface => GetVariantSoftCss(SemanticColor.Surface),
            SemanticColor.OnSurfaceStrong => GetVariantSoftCss(SemanticColor.Surface),
            SemanticColor.OnPrimary => GetVariantSoftCss(SemanticColor.Primary),
            SemanticColor.OnSecondary => GetVariantSoftCss(SemanticColor.Secondary),
            SemanticColor.OnInfo => GetVariantSoftCss(SemanticColor.Info),
            SemanticColor.OnSuccess => GetVariantSoftCss(SemanticColor.Success),
            SemanticColor.OnWarning => GetVariantSoftCss(SemanticColor.Warning),
            SemanticColor.DestructiveForeground => GetVariantSoftCss(SemanticColor.Destructive),
            SemanticColor.OutlineStrong => GetVariantSoftCss(SemanticColor.Outline),
            SemanticColor.None => "",
            _ => GetVariantSoftCss(SemanticColor.SurfaceAlt) // Default
        };
    }
}
</file>

<file path="Components/Display/RzDivider/RzDivider.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()" role="separator">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Display/RzDivider/RzDivider.razor.cs">
// src/RizzyUI/Components/RzDivider/RzDivider.razor.cs
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A component that renders a horizontal divider line, optionally with centered or aligned text/content.
///     Renders as an <c>&lt;hr></c> if no <see cref="ChildContent" /> is provided, otherwise renders as a <c>&lt;div></c>
///     using pseudo-elements for the lines. Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDivider : RzComponent
{
    // Used for Tailwind class discovery
#pragma warning disable CS0414 // Field is assigned but its value is never used
    private static readonly string TwDiscovery = "after:border-solid after:border-dashed after:border-dotted before:border-solid before:border-dashed before:border-dotted";
#pragma warning restore CS0414 // Field is assigned but its value is never used
    /// <summary> The style of the dividing line (Solid, Dashed, Dotted). Defaults to Solid. </summary>
    [Parameter] public DividerStyle Style { get; set; } = DividerStyle.Solid;
    /// <summary>
    ///     The alignment of the child content within the divider (Start, Center, End). Only used if
    ///     <see cref="ChildContent" /> is provided. Defaults to Center.
    /// </summary>
    [Parameter] public Align LabelAlignment { get; set; } = Align.Center;
    /// <summary>
    ///     Optional content to display within the divider (e.g., text or an icon). If null, a simple <c>&lt;hr></c> is
    ///     rendered.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzDivider;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Divider, // Base styles including text color, margins, base layout
            ChildContent is null
                ? styles.GetStyleCss(Style) // Style for <hr> (border-t, border-style)
                : styles.GetAlignmentCss(LabelAlignment,
                    Style) // Alignment/style for <div> with content (uses ::before/::after)
        );
    }
}
</file>

<file path="Components/Display/RzDivider/Styling/DefaultRzDividerStyles.cs">
namespace RizzyUI;
/// <summary>
///     Default implementation of <see cref="RzStylesBase.RzDividerStylesBase" /> that maps each
///     <see cref="RzDivider" /> visual variant to a Tailwind‑CSS utility string.
///     The class supplies:
///     <list type="bullet">
///         <item>
///             <description>Standard, thick, dotted, and dashed rules.</description>
///         </item>
///         <item>
///             <description>Inset variants (indented 2rem) of the above rules.</description>
///         </item>
///         <item>
///             <description>Base flex layout styles used when the divider carries a label or icon.</description>
///         </item>
///     </list>
/// </summary>
/// <remarks>
///     No string merging is performed here; component‑level merges occur inside
///     <see cref="RzDivider.RootClass" />.
/// </remarks>
public sealed class DefaultRzDividerStyles : RzStylesBase.RzDividerStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzDividerStyles" /> class.
    /// </summary>
    /// <param name="theme">
    ///     The active <see cref="RzTheme" />.  Present for future expansion—no theme tokens are
    ///     currently referenced by this class.
    /// </param>
    public DefaultRzDividerStyles(RzTheme theme) : base(theme)
    {
    }
    // ──────────────────────────────────────────────────────────────
    // Variant properties
    // ──────────────────────────────────────────────────────────────
    /// <inheritdoc />
    public override string Container => "my-4 border-t border-outline";
    /// <inheritdoc />
    public override string Thick => "my-4 h-px border-0 bg-outline";
    /// <inheritdoc />
    public override string Dotted => "my-4 border-t border-dotted border-outline";
    /// <inheritdoc />
    public override string Dashed => "my-4 border-t border-dashed  border-outline";
    /// <inheritdoc />
    public override string Inset => "ml-8 my-4 border-t border-outline";
    /// <inheritdoc />
    public override string InsetThick => "ml-8 my-4 h-px border-0 bg-outline";
    /// <inheritdoc />
    public override string InsetDotted => "ml-8 my-4 border-t border-dotted border-outline";
    /// <inheritdoc />
    public override string InsetDashed => "ml-8 my-4 border-t border-dashed  border-outline";
    /// <summary>
    ///     Base classes applied to the wrapper element when <see cref="RzDivider" /> contains
    ///     <c>ChildContent</c> (label, icon, etc.).
    /// </summary>
    public override string Divider => "flex items-center text-sm text-outline";
    // ──────────────────────────────────────────────────────────────
    // Helper methods
    // ──────────────────────────────────────────────────────────────
    /// <summary>
    ///     Returns the Tailwind class list for a plain <c>&lt;hr&gt;</c> rendered
    ///     in the requested <paramref name="style" />.
    /// </summary>
    /// <param name="style">The desired divider line style.</param>
    /// <returns>A class string defining border width, style, and color.</returns>
    public override string GetStyleCss(DividerStyle style)
    {
        return style switch
        {
            DividerStyle.Solid => $"{Container} border-solid",
            DividerStyle.Dashed => Dashed,
            DividerStyle.Dotted => Dotted,
            _ => $"{Container} border-solid"
        };
    }
    /// <summary>
    ///     Returns the class list for a divider rendered as a <c>&lt;div&gt;</c>
    ///     with <c>ChildContent</c>, including pseudo‑element definitions that draw
    ///     the left / right lines around the content.
    /// </summary>
    /// <param name="alignment">
    ///     The alignment of the label relative to the rule:
    ///     <see cref="Align.Start" />, <see cref="Align.Center" />, or <see cref="Align.End" />.
    /// </param>
    /// <param name="style">The visual style of the rule (solid, dashed, dotted).</param>
    /// <returns>A Tailwind class string describing flex layout and pseudo‑elements.</returns>
    public override string GetAlignmentCss(Align alignment, DividerStyle style)
    {
        // Determine the border-style part once.
        var lineStyle = style switch
        {
            DividerStyle.Solid => "border-solid",
            DividerStyle.Dashed => "border-dashed",
            DividerStyle.Dotted => "border-dotted",
            _ => "border-solid"
        };
        const string color = "border-outline dark:border-outline";
        return alignment switch
        {
            Align.Start => $"after:flex-1 after:border-t after:{lineStyle} after:{color} after:ms-6",
            Align.Center => $"before:flex-1 before:border-t before:{lineStyle} before:{color} before:me-6 " +
                            $"after:flex-1 after:border-t after:{lineStyle} after:{color} after:ms-6",
            Align.End => $"before:flex-1 before:border-t before:{lineStyle} before:{color} before:me-6",
            _ => string.Empty
        };
    }
}
</file>

<file path="Components/Display/RzProgress/RzProgress.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="div"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@RootClass()"
             >

	             <div x-data="rzProgress"
	                  data-alpine-root="@Id"
	                  data-label="@Label"
	                  data-current-val="@CurrentValue"
	                  data-min-val="@MinValue"
	                  data-max-val="@MaxValue"
	                  role="progressbar"
	                  aria-label="@AriaLabel"
	                  aria-valuenow="@CurrentValue"
	                  aria-valuemin="@MinValue"
	                  aria-valuemax="@MaxValue"
	                  data-progress="true">
		             
		             @if (LabelPosition == ProgressLabelPosition.Outside && !string.IsNullOrEmpty(Label))
		             {
			             <div class="@Theme.RzProgress.OutsideLabelContainer">
				             <div class="grow"></div>
				             <div class="@Theme.RzProgress.OutsideLabelText"><span x-text="buildLabel"></span></div>
			             </div>
		             }
		             <div class="@Theme.RzProgress.OuterBar @Theme.RzProgress.GetOuterBarHeightCss(LabelPosition)">
			             <div class="@InnerBarClass" x-ref="progressBar" nonce="@Nonce">
				             @if (LabelPosition == ProgressLabelPosition.Inside && !string.IsNullOrEmpty(Label))
				             {
					             <div class="@Theme.RzProgress.InsideLabelContainer" x-ref="progressBarLabel" :class="getLabelCss">
						             <span class="@Theme.RzProgress.InsideLabelText" x-ref="innerLabel"></span>
					             </div>
				             }
			             </div>
		             </div>

	             </div>
</HtmlElement>
</file>

<file path="Components/Display/RzProgress/RzProgress.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a Progress bar component that visually indicates the completion status of a task.
///     Supports labels inside or outside the bar and various status colors.
///     Styling and calculation logic is handled via the active <see cref="RzTheme" /> and Alpine.js.
/// </xmldoc>
public partial class RzProgress : RzComponent
{
    /// <summary> Gets or sets the current value of the progress bar. </summary>
    [Parameter]
    public int CurrentValue { get; set; }
    /// <summary> Gets or sets the minimum value of the progress bar. Defaults to 0. </summary>
    [Parameter]
    public int MinValue { get; set; }
    /// <summary> Gets or sets the maximum value of the progress bar. Defaults to 100. </summary>
    [Parameter]
    public int MaxValue { get; set; } = 100;
    /// <summary> Gets or sets the label text for the progress bar. Supports '{percent}' placeholder. </summary>
    [Parameter]
    public string? Label { get; set; }
    /// <summary> Gets or sets the position of the label (Inside or Outside). Defaults to Outside. </summary>
    [Parameter]
    public ProgressLabelPosition LabelPosition { get; set; } = ProgressLabelPosition.Outside;
    /// <summary> Gets or sets the status color variant of the progress bar. Defaults to Primary. </summary>
    [Parameter]
    public StatusColor Variant { get; set; } = StatusColor.Primary;
    /// <summary> Gets or sets the aria-label for accessibility. Defaults to "Progress Bar". </summary>
    [Parameter]
    public string AriaLabel { get; set; } = "Progress Bar";
    /// <summary> Gets the computed CSS classes for the inner bar (value), including base and variant styles. </summary>
    protected string InnerBarClass =>
        $"{Theme.RzProgress.InnerBarBase} {Theme.RzProgress.GetInnerBarVariantCss(Variant)}";
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzProgress.Container);
    }
    // Note: Percentage calculation logic moved to Alpine.js ('rzProgress' component)
}
</file>

<file path="Components/Display/RzProgress/Styling/DefaultRzProgressStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides default styles for the <see cref="RzProgress" /> component.
/// </summary>
public class DefaultRzProgressStyles : RzStylesBase.RzProgressStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzProgressStyles" /> class.
    /// </summary>
    /// <param name="theme">
    ///     The <see cref="RzTheme" /> instance that supplies color and sizing tokens.
    /// </param>
    public DefaultRzProgressStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "w-full";
    /// <inheritdoc />
    public override string OutsideLabelContainer => "mb-2 flex items-center";
    /// <inheritdoc />
    public override string OutsideLabelText => "text-foreground";
    /// <inheritdoc />
    public override string OuterBar =>
        "relative flex w-full overflow-hidden rounded-theme bg-outline";
    /// <inheritdoc />
    public override string InnerBarBase =>
        "p-0.5 text-center text-xs font-semibold leading-none transition-all";
    /// <inheritdoc />
    public override string InsideLabelContainer => "absolute";
    /// <inheritdoc />
    public override string InsideLabelText => string.Empty;
    /// <inheritdoc />
    public override string GetOuterBarHeightCss(ProgressLabelPosition position)
    {
        return position == ProgressLabelPosition.Inside ? "h-4" : "h-2.5";
    }
    /// <inheritdoc />
    public override string GetInnerBarVariantCss(StatusColor variant)
    {
        return variant switch
        {
            StatusColor.Primary => "h-full rounded-theme bg-primary text-primary-foreground",
            StatusColor.Secondary => "h-full rounded-theme bg-secondary text-secondary-foreground",
            StatusColor.Success =>
                "h-full rounded-theme bg-success dark:bg-success text-success-foreground dark:text-success-foreground",
            StatusColor.Info =>
                "h-full rounded-theme bg-info dark:bg-info text-info-foreground dark:text-info-foreground",
            StatusColor.Warning =>
                "h-full rounded-theme bg-warning dark:bg-warning text-warning-foreground dark:text-warning-foreground",
            StatusColor.Destructive =>
                "h-full rounded-theme bg-destructive dark:bg-destructive text-destructive-foreground dark:text-destructive-foreground",
            _ => GetInnerBarVariantCss(StatusColor.Primary)
        };
    }
    /// <inheritdoc />
    public override string GetInsideLabelColorCss(bool overflows)
    {
        return overflows ? "text-foreground dark:text-foreground" : string.Empty;
    }
}
</file>

<file path="Components/Document/Models/HeadingItem.cs">
namespace RizzyUI;
/// <summary>
///     Represents a heading item with level, title, and ID.
/// </summary>
public class HeadingItem
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="HeadingItem" /> class.
    /// </summary>
    /// <param name="level">The heading level.</param>
    /// <param name="title">The title of the heading.</param>
    /// <param name="id">The unique ID of the heading element.</param>
    public HeadingItem(HeadingLevel level, string title, string id)
    {
        Level = level;
        Title = title;
        Id = id;
    }
    /// <summary>
    ///     The heading level.
    /// </summary>
    public HeadingLevel Level { get; }
    /// <summary>
    ///     The title of the heading.
    /// </summary>
    public string Title { get; }
    /// <summary>
    ///     The unique ID of the heading element.
    /// </summary>
    public string Id { get; }
}
</file>

<file path="Components/Document/RzArticle/RzArticle.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    <div class="@Theme.RzArticle.InnerContainer">
        <article class="@Theme.RzArticle.Article @Theme.RzArticle.GetArticleProseCss(ProseWidth)">
            @MainContent
        </article>

        @if (SideContent != null)
        {
            <aside class="@Theme.RzArticle.GetAsideCss(ColumnWidth, IsSideFixed)" aria-label="@AsideAriaLabel">
                @SideContent
            </aside>
        }
    </div>
</HtmlElement>
</file>

<file path="Components/Document/RzArticle/RzArticle.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A layout component rendering a responsive two-column layout, typically for main article content
///     and a side navigation or information panel (<see cref="RzQuickReference" />).
///     Styling and layout details are determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzArticle : RzComponent
{
    /// <summary> Gets or sets the maximum character width of the main article content area. Defaults to Full. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Full;
    /// <summary> Gets or sets the width of the side column. Defaults to Large. </summary>
    [Parameter]
    public Size ColumnWidth { get; set; } = Size.Large;
    /// <summary> Gets or sets the content to render in the side column (e.g., QuickReference). </summary>
    [Parameter]
    public RenderFragment? SideContent { get; set; }
    /// <summary> Gets or sets the main content to render in the primary article area. Required. </summary>
    [Parameter]
    [EditorRequired]
    public required RenderFragment MainContent { get; set; }
    /// <summary>
    ///     Gets or sets a value indicating whether the side column should be fixed-positioned on larger screens.
    ///     Defaults to true.
    /// </summary>
    [Parameter]
    public bool IsSideFixed { get; set; } = true;
    /// <summary>
    /// Gets or sets the aria-label for the aside element, providing context for screen readers.
    /// If not set, defaults to a localized "Supplementary Content". Consider providing a more specific label based on the content
    /// (e.g., "On this page navigation", "Related links").
    /// </summary>
    [Parameter]
    public string? AsideAriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AsideAriaLabel ??= Localizer["RzArticle.DefaultAsideAriaLabel"];
    }
    /// <inheritdoc />
     protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Ensure default is applied if parameter becomes null after initialization
        AsideAriaLabel ??= Localizer["RzArticle.DefaultAsideAriaLabel"];
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzArticle.Container,
            Theme.RzArticle.GetContainerPaddingCss(ColumnWidth));
    }
}
</file>

<file path="Components/Document/RzArticle/Styling/DefaultRzArticleStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzArticle component.
/// </summary>
public class DefaultRzArticleStyles : RzStylesBase.RzArticleStylesBase
{
    /// <inheritdoc />
    public DefaultRzArticleStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container =>
        "flex w-full justify-between pr-0 text-foreground dark:text-foreground"; // Base container styles
    /// <inheritdoc />
    public override string InnerContainer => "mx-auto flex max-w-7xl grow flex-col overflow-x-auto overflow-y-hidden";
    /// <inheritdoc />
    public override string Article => ""; // Base article element, prose width added by method
    /// <inheritdoc />
    public override string Aside =>
        "hidden shrink-0 flex-col gap-2 overflow-y-auto p-8 pl-0 text-sm xl:flex"; // Base aside, fixed/width added by method
    /// <inheritdoc />
    public override string GetArticleProseCss(ProseWidth width)
    {
        return width switch
        {
            ProseWidth.Compact => "prose-compact",
            ProseWidth.Comfortable => "prose-comfortable",
            ProseWidth.Relaxed => "prose-relaxed",
            ProseWidth.Wide => "prose-wide",
            ProseWidth.UltraWide => "prose-ultrawide",
            ProseWidth.Full => "prose-full", // or "" if max-w-none is sufficient
            _ => GetArticleProseCss(ProseWidth.Comfortable)
        };
    }
    /// <inheritdoc />
    public override string GetAsideCss(Size columnWidth, bool isFixed)
    {
        var fixedCss =
            isFixed
                ? "h-fill fixed right-0 top-16 z-0"
                : ""; // Fixed positioning + top offset (adjust if navbar height changes)
        var widthCss = columnWidth switch
        {
            Size.ExtraSmall => "w-48",
            Size.Small => "w-56",
            Size.Medium => "w-64",
            Size.Large => "w-72",
            Size.ExtraLarge => "w-80",
            _ => GetAsideCss(Size.Large, isFixed) // Recalculate width based on default size
        };
        // Combine base, fixed, and width
        return $"{Aside} {fixedCss} {widthCss}";
    }
    /// <inheritdoc />
    public override string GetContainerPaddingCss(Size columnWidth)
    {
        return columnWidth switch // Adds right padding to main container to avoid overlap with fixed aside
        {
            Size.ExtraSmall => "xl:pr-48",
            Size.Small => "xl:pr-56",
            Size.Medium => "xl:pr-64",
            Size.Large => "xl:pr-72",
            Size.ExtraLarge => "xl:pr-80",
            _ => GetContainerPaddingCss(Size.Large)
        };
    }
}
</file>

<file path="Components/Document/RzBrowser/RzBrowser.razor">
@namespace RizzyUI
@inherits RzComponent

<div @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    <div x-data="rzBrowser" data-alpine-root="@Id">
        
        <div class="@Theme.RzBrowser.TopBar">
            <div class="@Theme.RzBrowser.TrafficLightsContainer" aria-hidden="true">
                <div class="@Theme.RzBrowser.TrafficLightRed"></div>
                <div class="@Theme.RzBrowser.TrafficLightYellow"></div>
                <div class="@Theme.RzBrowser.TrafficLightGreen"></div>
            </div>
            <div class="@Theme.RzBrowser.ScreenSizeControlsContainer">
                <div class="@Theme.RzBrowser.ScreenSizeButtonGroup" role="group" aria-label="@Localizer["RzBrowser.ScreenSizeGroupAriaLabel"]">
                    <button type="button" aria-label="@Localizer["RzBrowser.DesktopScreenTitle"]" title="@Localizer["RzBrowser.DesktopScreenTitle"]" x-on:click="setDesktopScreenSize" class="@Theme.RzBrowser.ScreenSizeButton">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getDesktopScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M0 4s0-2 2-2h12s2 0 2 2v6s0 2-2 2h-4c0 .667.083 1.167.25 1.5H11a.5.5 0 0 1 0 1H5a.5.5 0 0 1 0-1h.75c.167-.333.25-.833.25-1.5H2s-2 0-2-2V4zm1.398-.855a.758.758 0 0 0-.254.302A1.46 1.46 0 0 0 1 4.01V10c0 .325.078.502.145.602.07.105.17.188.302.254a1.464 1.464 0 0 0 .538.143L2.01 11H14c.325 0 .502-.078.602-.145a.758.758 0 0 0 .254-.302 1.464 1.464 0 0 0 .143-.538L15 9.99V4c0-.325-.078-.502-.145-.602a.757.757 0 0 0-.302-.254A1.46 1.46 0 0 0 13.99 3H2c-.325 0-.502.078-.602.145z"></path>
                        </svg>
                    </button>
                    <button type="button" x-on:click="setTabletScreenSize" aria-label="@Localizer["RzBrowser.TabletScreenTitle"]" title="@Localizer["RzBrowser.TabletScreenTitle"]" class="@Theme.RzBrowser.ScreenSizeButton">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getTabletScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M12 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h8zM4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4z"></path>
                            <path d="M8 14a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path>
                        </svg>
                    </button>
                    <button type="button" x-on:click="setPhoneScreenSize" aria-label="@Localizer["RzBrowser.PhoneScreenTitle"]" title="@Localizer["RzBrowser.PhoneScreenTitle"]" class="@Theme.RzBrowser.ScreenSizeButton">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                             :class="getPhoneScreenCss" viewBox="0 0 16 16" aria-hidden="true">
                            <path
                                d="M11 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h6zM5 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H5z"></path>
                            <path d="M8 14a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        <div class="@Theme.RzBrowser.ContentArea">
            <div class="@Theme.RzBrowser.PreviewContainer" :class="getBrowserBorderCss">
                @if (Layout != null)
                {
                    <RzEmbeddedPreview Layout="@Layout" IFrameTitle="@PreviewIFrameTitle">
                        @ChildContent
                    </RzEmbeddedPreview>
                }
                else
                {
                    @ChildContent
                }

            </div>
        </div>
    </div>    
</div>
</file>

<file path="Components/Document/RzBrowser/RzBrowser.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <summary>
///     A component that simulates a browser window, useful for previewing components or content.
/// </summary>
public partial class RzBrowser : RzComponent
{
    /// <summary>
    ///     The content to be displayed within the browser preview area.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Optional layout for rendering <see cref="ChildContent" /> inside an iframe via <see cref="RzEmbeddedPreview"/>.
    /// </summary>
    [Parameter] public Type? Layout { get; set; }
    /// <summary>
    /// Gets or sets the title attribute for the iframe when a layout is used.
    /// Defaults to "Component Preview". Provides context for screen reader users.
    /// </summary>
    [Parameter] public string PreviewIFrameTitle { get; set; } = "Component Preview";
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzBrowser.Container);
    }
}
</file>

<file path="Components/Document/RzBrowser/Styling/DefaultRzBrowserStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides default styles for the <see cref="RzBrowser" /> component.
/// </summary>
public class DefaultRzBrowserStyles : RzStylesBase.RzBrowserStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzBrowserStyles" /> class.
	/// </summary>
	/// <param name="theme">
	///     The <see cref="RzTheme" /> instance that supplies styles tokens.
	/// </param>
	public DefaultRzBrowserStyles(RzTheme theme) : base(theme)
    {
    }
	/// <inheritdoc />
	public override string Container => "overflow-hidden border border-outline rounded-theme";
	/// <inheritdoc />
	public override string TopBar =>
        "bg-secondary w-full px-4 py-3 lg:py-1.5 pr-0 flex items-center justify-between border-outline border-b";
	/// <inheritdoc />
	public override string TrafficLightsContainer => "flex gap-1.5";
	/// <inheritdoc />
	public override string TrafficLightRed => "size-3 rounded-full bg-red-500";
	/// <inheritdoc />
	public override string TrafficLightYellow => "size-3 rounded-full bg-yellow-500";
	/// <inheritdoc />
	public override string TrafficLightGreen => "size-3 rounded-full bg-green-500";
	/// <inheritdoc />
	public override string ScreenSizeControlsContainer =>
        "text-foreground hidden items-center justify-center gap-4 lg:flex";
	/// <inheritdoc />
	public override string ScreenSizeButton =>
        "rounded-full p-1 transition hover:bg-secondary/10 focus:outline-none focus-visible:bg-secondary/10 dark:hover-bg-background/10 dark:focus-visible-bg-background/10";
	/// <inheritdoc />
	public override string ScreenSizeButtonGroup =>
        "bg-secondary border-outline flex items-center gap-1 rounded-full px-4";
	/// <inheritdoc />
	public override string ContentArea => "grid-pattern bg-background flex justify-center";
	/// <inheritdoc />
	public override string PreviewContainer =>
        "bg-background border-outline relative w-full overflow-hidden transition-all";
}
</file>

<file path="Components/Document/RzCodeViewer/CodeLanguage.cs">
namespace RizzyUI;
/// <summary>
///     Provides constants for language aliases supported by Highlight.js.
/// </summary>
public static class CodeLanguage
{
    /// <summary>
    ///     1C Enterprise language.
    /// </summary>
    public const string OneC = "1c";
    /// <summary>
    ///     4D programming language.
    /// </summary>
    public const string FourD = "4d";
    /// <summary>
    ///     ABAP (Advanced Business Application Programming).
    /// </summary>
    public const string Abap = "sap-abap";
    /// <summary>
    ///     ABNF (Augmented Backus–Naur Form).
    /// </summary>
    public const string Abnf = "abnf";
    /// <summary>
    ///     Access logs.
    /// </summary>
    public const string AccessLog = "accesslog";
    /// <summary>
    ///     Ada programming language.
    /// </summary>
    public const string Ada = "ada";
    /// <summary>
    ///     Apex programming language.
    /// </summary>
    public const string Apex = "apex";
    /// <summary>
    ///     Arduino (C++ with Arduino libraries).
    /// </summary>
    public const string Arduino = "arduino";
    /// <summary>
    ///     ARM assembler.
    /// </summary>
    public const string ArmAsm = "armasm";
    /// <summary>
    ///     AVR assembler.
    /// </summary>
    public const string AvrAsm = "avrasm";
    /// <summary>
    ///     ActionScript language.
    /// </summary>
    public const string ActionScript = "actionscript";
    /// <summary>
    ///     Alan Interactive Fiction language.
    /// </summary>
    public const string AlanIf = "alan";
    /// <summary>
    ///     Alan programming language.
    /// </summary>
    public const string Alan = "ln";
    /// <summary>
    ///     AngelScript language.
    /// </summary>
    public const string AngelScript = "angelscript";
    /// <summary>
    ///     Apache configuration files.
    /// </summary>
    public const string Apache = "apache";
    /// <summary>
    ///     AppleScript language.
    /// </summary>
    public const string AppleScript = "applescript";
    /// <summary>
    ///     Esri Arcade scripting language.
    /// </summary>
    public const string Arcade = "arcade";
    /// <summary>
    ///     AsciiDoc markup language.
    /// </summary>
    public const string AsciiDoc = "asciidoc";
    /// <summary>
    ///     AspectJ programming language.
    /// </summary>
    public const string AspectJ = "aspectj";
    /// <summary>
    ///     AutoHotkey scripting language.
    /// </summary>
    public const string AutoHotkey = "autohotkey";
    /// <summary>
    ///     AutoIt scripting language.
    /// </summary>
    public const string AutoIt = "autoit";
    /// <summary>
    ///     AWK scripting language.
    /// </summary>
    public const string Awk = "awk";
    /// <summary>
    ///     Ballerina programming language.
    /// </summary>
    public const string Ballerina = "ballerina";
    /// <summary>
    ///     Bash shell scripting language.
    /// </summary>
    public const string Bash = "bash";
    /// <summary>
    ///     BASIC programming language.
    /// </summary>
    public const string Basic = "basic";
    /// <summary>
    ///     BBCode markup language.
    /// </summary>
    public const string BBCode = "bbcode";
    /// <summary>
    ///     Blade templating engine (Laravel).
    /// </summary>
    public const string Blade = "blade";
    /// <summary>
    ///     Backus–Naur Form grammar.
    /// </summary>
    public const string Bnf = "bnf";
    /// <summary>
    ///     BQN programming language.
    /// </summary>
    public const string Bqn = "bqn";
    /// <summary>
    ///     Brainfuck esoteric programming language.
    /// </summary>
    public const string Brainfuck = "brainfuck";
    /// <summary>
    ///     C# programming language.
    /// </summary>
    public const string CSharp = "csharp";
    /// <summary>
    ///     C programming language.
    /// </summary>
    public const string C = "c";
    /// <summary>
    ///     C++ programming language.
    /// </summary>
    public const string Cpp = "cpp";
    /// <summary>
    ///     C/AL language.
    /// </summary>
    public const string CAL = "cal";
    /// <summary>
    ///     C3 programming language.
    /// </summary>
    public const string C3 = "c3";
    /// <summary>
    ///     Caché Object Script.
    /// </summary>
    public const string CacheObjectScript = "cos";
    /// <summary>
    ///     Candid language.
    /// </summary>
    public const string Candid = "candid";
    /// <summary>
    ///     CMake scripting language.
    /// </summary>
    public const string CMake = "cmake";
    /// <summary>
    ///     COBOL programming language.
    /// </summary>
    public const string Cobol = "cobol";
    /// <summary>
    ///     CODEOWNERS file format.
    /// </summary>
    public const string Codeowners = "codeowners";
    /// <summary>
    ///     Coq proof assistant language.
    /// </summary>
    public const string Coq = "coq";
    /// <summary>
    ///     CSP (Communicating Sequential Processes).
    /// </summary>
    public const string Csp = "csp";
    /// <summary>
    ///     Cascading Style Sheets.
    /// </summary>
    public const string Css = "css";
    /// <summary>
    ///     Cap’n Proto serialization language.
    /// </summary>
    public const string CapnProto = "capnproto";
    /// <summary>
    ///     Chaos programming language.
    /// </summary>
    public const string Chaos = "chaos";
    /// <summary>
    ///     Chapel programming language.
    /// </summary>
    public const string Chapel = "chapel";
    /// <summary>
    ///     Cisco CLI configuration.
    /// </summary>
    public const string CiscoCli = "cisco";
    /// <summary>
    ///     Clojure programming language.
    /// </summary>
    public const string Clojure = "clojure";
    /// <summary>
    ///     CoffeeScript programming language.
    /// </summary>
    public const string CoffeeScript = "coffeescript";
    /// <summary>
    ///     CpcdosC+ programming language.
    /// </summary>
    public const string CpcdosCPlus = "cpc";
    /// <summary>
    ///     Crmsh (Cluster Resource Manager Shell).
    /// </summary>
    public const string Crmsh = "crmsh";
    /// <summary>
    ///     Crystal programming language.
    /// </summary>
    public const string Crystal = "crystal";
    /// <summary>
    ///     cURL command-line tool.
    /// </summary>
    public const string Curl = "curl";
    /// <summary>
    ///     Cypher query language (Neo4j).
    /// </summary>
    public const string Cypher = "cypher";
    /// <summary>
    ///     D programming language.
    /// </summary>
    public const string D = "d";
    /// <summary>
    ///     Dafny programming language.
    /// </summary>
    public const string Dafny = "dafny";
    /// <summary>
    ///     Dart programming language.
    /// </summary>
    public const string Dart = "dart";
    /// <summary>
    ///     Delphi programming language.
    /// </summary>
    public const string Delphi = "dpr";
    /// <summary>
    ///     Diff syntax for differences between files.
    /// </summary>
    public const string Diff = "diff";
    /// <summary>
    ///     Django templating language.
    /// </summary>
    public const string Django = "django";
    /// <summary>
    ///     DNS Zone file format.
    /// </summary>
    public const string DnsZoneFile = "dns";
    /// <summary>
    ///     Dockerfile format.
    /// </summary>
    public const string Dockerfile = "dockerfile";
    /// <summary>
    ///     DOS batch file scripting.
    /// </summary>
    public const string Dos = "dos";
    /// <summary>
    ///     dsconfig format.
    /// </summary>
    public const string Dsconfig = "dsconfig";
    /// <summary>
    ///     Device Tree Source.
    /// </summary>
    public const string Dts = "dts";
    /// <summary>
    ///     Dust templating language.
    /// </summary>
    public const string Dust = "dust";
    /// <summary>
    ///     Dylan programming language.
    /// </summary>
    public const string Dylan = "dylan";
    /// <summary>
    ///     EBNF (Extended Backus–Naur Form) grammar.
    /// </summary>
    public const string Ebnf = "ebnf";
    /// <summary>
    ///     Elixir programming language.
    /// </summary>
    public const string Elixir = "elixir";
    /// <summary>
    ///     Elm programming language.
    /// </summary>
    public const string Elm = "elm";
    /// <summary>
    ///     Erlang programming language.
    /// </summary>
    public const string Erlang = "erlang";
    /// <summary>
    ///     Excel formula language.
    /// </summary>
    public const string Excel = "excel";
    /// <summary>
    ///     Extempore programming language.
    /// </summary>
    public const string Extempore = "extempore";
    /// <summary>
    ///     F# programming language.
    /// </summary>
    public const string FSharp = "fsharp";
    /// <summary>
    ///     FIX (Financial Information Exchange) protocol.
    /// </summary>
    public const string Fix = "fix";
    /// <summary>
    ///     Flix programming language.
    /// </summary>
    public const string Flix = "flix";
    /// <summary>
    ///     Fortran programming language.
    /// </summary>
    public const string Fortran = "fortran";
    /// <summary>
    ///     FunC programming language.
    /// </summary>
    public const string FunC = "func";
    /// <summary>
    ///     G-code for CNC machines.
    /// </summary>
    public const string GCode = "gcode";
    /// <summary>
    ///     GAMS (General Algebraic Modeling System).
    /// </summary>
    public const string Gams = "gams";
    /// <summary>
    ///     GAUSS Mathematical and Statistical System.
    /// </summary>
    public const string Gauss = "gauss";
    /// <summary>
    ///     GDScript for Godot Engine.
    /// </summary>
    public const string GdScript = "godot";
    /// <summary>
    ///     Gherkin language for Cucumber testing.
    /// </summary>
    public const string Gherkin = "gherkin";
    /// <summary>
    ///     Glimmer and EmberJS templates.
    /// </summary>
    public const string Glimmer = "hbs";
    /// <summary>
    ///     GN meta-build system files.
    /// </summary>
    public const string Gn = "gn";
    /// <summary>
    ///     Go programming language.
    /// </summary>
    public const string Go = "go";
    /// <summary>
    ///     Grammatical Framework language.
    /// </summary>
    public const string GrammaticalFramework = "gf";
    /// <summary>
    ///     Golo programming language.
    /// </summary>
    public const string Golo = "golo";
    /// <summary>
    ///     Gradle build scripts.
    /// </summary>
    public const string Gradle = "gradle";
    /// <summary>
    ///     GraphQL query language.
    /// </summary>
    public const string GraphQL = "graphql";
    /// <summary>
    ///     Groovy programming language.
    /// </summary>
    public const string Groovy = "groovy";
    /// <summary>
    ///     GSQL query language.
    /// </summary>
    public const string GSQL = "gsql";
    /// <summary>
    ///     HTML, XML languages.
    /// </summary>
    public const string Html = "xml";
    /// <summary>
    ///     HTTP request and response messages.
    /// </summary>
    public const string Http = "http";
    /// <summary>
    ///     Haml templating language.
    /// </summary>
    public const string Haml = "haml";
    /// <summary>
    ///     Handlebars templating language.
    /// </summary>
    public const string Handlebars = "handlebars";
    /// <summary>
    ///     Haskell programming language.
    /// </summary>
    public const string Haskell = "haskell";
    /// <summary>
    ///     Haxe programming language.
    /// </summary>
    public const string Haxe = "haxe";
    /// <summary>
    ///     High-Level Shading Language.
    /// </summary>
    public const string Hlsl = "hlsl";
    /// <summary>
    ///     Hy programming language.
    /// </summary>
    public const string Hy = "hy";
    /// <summary>
    ///     INI configuration files.
    /// </summary>
    public const string Ini = "ini";
    /// <summary>
    ///     Inform 7 programming language.
    /// </summary>
    public const string Inform7 = "inform7";
    /// <summary>
    ///     IRPF90 language.
    /// </summary>
    public const string Irpf90 = "irpf90";
    /// <summary>
    ///     Iptables configuration.
    /// </summary>
    public const string Iptables = "iptables";
    /// <summary>
    ///     JSON (JavaScript Object Notation).
    /// </summary>
    public const string Json = "json";
    /// <summary>
    ///     JSONata query and transformation language.
    /// </summary>
    public const string Jsonata = "jsonata";
    /// <summary>
    ///     Java programming language.
    /// </summary>
    public const string Java = "java";
    /// <summary>
    ///     JavaScript programming language.
    /// </summary>
    public const string JavaScript = "javascript";
    /// <summary>
    ///     Jolie programming language.
    /// </summary>
    public const string Jolie = "jolie";
    /// <summary>
    ///     Julia programming language.
    /// </summary>
    public const string Julia = "julia";
    /// <summary>
    ///     Julia REPL sessions.
    /// </summary>
    public const string JuliaRepl = "julia-repl";
    /// <summary>
    ///     Kotlin programming language.
    /// </summary>
    public const string Kotlin = "kotlin";
    /// <summary>
    ///     LaTeX document preparation system.
    /// </summary>
    public const string Latex = "tex";
    /// <summary>
    ///     Leaf templating language.
    /// </summary>
    public const string Leaf = "leaf";
    /// <summary>
    ///     Lean theorem prover language.
    /// </summary>
    public const string Lean = "lean";
    /// <summary>
    ///     Lasso programming language.
    /// </summary>
    public const string Lasso = "lasso";
    /// <summary>
    ///     Less CSS preprocessor.
    /// </summary>
    public const string Less = "less";
    /// <summary>
    ///     LDIF (LDAP Data Interchange Format).
    /// </summary>
    public const string Ldif = "ldif";
    /// <summary>
    ///     Lisp programming language.
    /// </summary>
    public const string Lisp = "lisp";
    /// <summary>
    ///     LiveCode Server scripting language.
    /// </summary>
    public const string LiveCodeServer = "livecodeserver";
    /// <summary>
    ///     LiveScript programming language.
    /// </summary>
    public const string LiveScript = "livescript";
    /// <summary>
    ///     LookML (Looker Modeling Language).
    /// </summary>
    public const string LookMl = "lookml";
    /// <summary>
    ///     Lua programming language.
    /// </summary>
    public const string Lua = "lua";
    /// <summary>
    ///     Luau programming language.
    /// </summary>
    public const string Luau = "luau";
    /// <summary>
    ///     Macaulay2 algebra system language.
    /// </summary>
    public const string Macaulay2 = "macaulay2";
    /// <summary>
    ///     Makefile build automation tool.
    /// </summary>
    public const string Makefile = "makefile";
    /// <summary>
    ///     Markdown markup language.
    /// </summary>
    public const string Markdown = "markdown";
    /// <summary>
    ///     Mathematica symbolic computation language.
    /// </summary>
    public const string Mathematica = "mathematica";
    /// <summary>
    ///     MATLAB programming language.
    /// </summary>
    public const string Matlab = "matlab";
    /// <summary>
    ///     Maxima computer algebra system.
    /// </summary>
    public const string Maxima = "maxima";
    /// <summary>
    ///     Maya Embedded Language.
    /// </summary>
    public const string MayaEmbeddedLanguage = "mel";
    /// <summary>
    ///     Mercury programming language.
    /// </summary>
    public const string Mercury = "mercury";
    /// <summary>
    ///     MetaPost language.
    /// </summary>
    public const string MetaPost = "metapost";
    /// <summary>
    ///     MIPS assembler.
    /// </summary>
    public const string MipsAsm = "mips";
    /// <summary>
    ///     Mint programming language.
    /// </summary>
    public const string Mint = "mint";
    /// <summary>
    ///     Mirth scripting language.
    /// </summary>
    public const string Mirth = "mirth";
    /// <summary>
    ///     mIRC scripting language.
    /// </summary>
    public const string Mirc = "mirc";
    /// <summary>
    ///     Mizar language.
    /// </summary>
    public const string Mizar = "mizar";
    /// <summary>
    ///     MKB (Makefiles and Builders).
    /// </summary>
    public const string Mkb = "mkb";
    /// <summary>
    ///     MLIR (Multi-Level Intermediate Representation).
    /// </summary>
    public const string Mlir = "mlir";
    /// <summary>
    ///     Mojolicious Perl framework.
    /// </summary>
    public const string Mojolicious = "mojolicious";
    /// <summary>
    ///     Monkey programming language.
    /// </summary>
    public const string Monkey = "monkey";
    /// <summary>
    ///     MoonScript programming language.
    /// </summary>
    public const string MoonScript = "moonscript";
    /// <summary>
    ///     Motoko programming language.
    /// </summary>
    public const string Motoko = "motoko";
    /// <summary>
    ///     N1QL query language.
    /// </summary>
    public const string N1ql = "n1ql";
    /// <summary>
    ///     NSIS (Nullsoft Scriptable Install System).
    /// </summary>
    public const string Nsis = "nsis";
    /// <summary>
    ///     Never programming language.
    /// </summary>
    public const string Never = "never";
    /// <summary>
    ///     Nginx configuration files.
    /// </summary>
    public const string Nginx = "nginx";
    /// <summary>
    ///     Nim programming language.
    /// </summary>
    public const string Nim = "nim";
    /// <summary>
    ///     Nix programming language.
    /// </summary>
    public const string Nix = "nix";
    /// <summary>
    ///     Oak programming language.
    /// </summary>
    public const string Oak = "oak";
    /// <summary>
    ///     Object Constraint Language.
    /// </summary>
    public const string Ocl = "ocl";
    /// <summary>
    ///     OCaml programming language.
    /// </summary>
    public const string OCaml = "ocaml";
    /// <summary>
    ///     Objective-C programming language.
    /// </summary>
    public const string ObjectiveC = "objectivec";
    /// <summary>
    ///     Odin programming language.
    /// </summary>
    public const string Odin = "odin";
    /// <summary>
    ///     OpenGL Shading Language.
    /// </summary>
    public const string OpenGLShadingLanguage = "glsl";
    /// <summary>
    ///     OpenSCAD scripting language.
    /// </summary>
    public const string OpenScad = "openscad";
    /// <summary>
    ///     Oracle Rules Language.
    /// </summary>
    public const string OracleRulesLanguage = "ruleslanguage";
    /// <summary>
    ///     Oxygene programming language.
    /// </summary>
    public const string Oxygene = "oxygene";
    /// <summary>
    ///     PF firewall configuration files.
    /// </summary>
    public const string Pf = "pf";
    /// <summary>
    ///     PHP scripting language.
    /// </summary>
    public const string Php = "php";
    /// <summary>
    ///     Papyrus scripting language.
    /// </summary>
    public const string Papyrus = "papyrus";
    /// <summary>
    ///     Parser3 scripting language.
    /// </summary>
    public const string Parser3 = "parser3";
    /// <summary>
    ///     Perl programming language.
    /// </summary>
    public const string Perl = "perl";
    /// <summary>
    ///     Phix programming language.
    /// </summary>
    public const string Phix = "phix";
    /// <summary>
    ///     Pine Script for financial analysis.
    /// </summary>
    public const string PineScript = "pine";
    /// <summary>
    ///     Plaintext format.
    /// </summary>
    public const string Plaintext = "plaintext";
    /// <summary>
    ///     Pony programming language.
    /// </summary>
    public const string Pony = "pony";
    /// <summary>
    ///     PostgreSQL and PL/pgSQL.
    /// </summary>
    public const string PostgreSQL = "pgsql";
    /// <summary>
    ///     PowerOn programming language.
    /// </summary>
    public const string PowerOn = "poweron";
    /// <summary>
    ///     PowerShell scripting language.
    /// </summary>
    public const string PowerShell = "powershell";
    /// <summary>
    ///     Processing programming language.
    /// </summary>
    public const string Processing = "processing";
    /// <summary>
    ///     Prolog programming language.
    /// </summary>
    public const string Prolog = "prolog";
    /// <summary>
    ///     Properties file format.
    /// </summary>
    public const string Properties = "properties";
    /// <summary>
    ///     Protocol Buffers.
    /// </summary>
    public const string ProtocolBuffers = "proto";
    /// <summary>
    ///     Puppet configuration management language.
    /// </summary>
    public const string Puppet = "puppet";
    /// <summary>
    ///     Python programming language.
    /// </summary>
    public const string Python = "python";
    /// <summary>
    ///     Python REPL sessions.
    /// </summary>
    public const string PythonRepl = "python-repl";
    /// <summary>
    ///     Q# programming language.
    /// </summary>
    public const string QSharp = "qsharp";
    /// <summary>
    ///     Q/K programming language.
    /// </summary>
    public const string Q = "k";
    /// <summary>
    ///     QML language.
    /// </summary>
    public const string Qml = "qml";
    /// <summary>
    ///     R programming language.
    /// </summary>
    public const string R = "r";
    /// <summary>
    ///     Raku programming language.
    /// </summary>
    public const string Raku = "raku";
    /// <summary>
    ///     RakuDoc documentation format.
    /// </summary>
    public const string RakuDoc = "pod6";
    /// <summary>
    ///     Raku quoting constructs.
    /// </summary>
    public const string RakuQuoting = "rakuquoting";
    /// <summary>
    ///     Raku regexes.
    /// </summary>
    public const string RakuRegexe = "rakuregexe";
    /// <summary>
    ///     Razor (cshtml-razor) for ASP.NET web pages.
    /// </summary>
    public const string Razor = "cshtml-razor";
    /// <summary>
    ///     ReasonML programming language.
    /// </summary>
    public const string Reasonml = "reasonml";
    /// <summary>
    ///     Rebol and Red programming languages.
    /// </summary>
    public const string RebolAndRed = "redbol";
    /// <summary>
    ///     RenderMan RIB file format.
    /// </summary>
    public const string RenderManRib = "rib";
    /// <summary>
    ///     RenderMan RSL shader language.
    /// </summary>
    public const string RenderManRsl = "rsl";
    /// <summary>
    ///     ReScript programming language.
    /// </summary>
    public const string Rescript = "rescript";
    /// <summary>
    ///     RiScript language.
    /// </summary>
    public const string RiScript = "risc";
    /// <summary>
    ///     RISC-V Assembly language.
    /// </summary>
    public const string RiscVAssembly = "riscv";
    /// <summary>
    ///     Roboconf graph files.
    /// </summary>
    public const string Roboconf = "graph";
    /// <summary>
    ///     Robot Framework test data.
    /// </summary>
    public const string RobotFramework = "robot";
    /// <summary>
    ///     RPM spec files.
    /// </summary>
    public const string RpmSpecfile = "rpm-specfile";
    /// <summary>
    ///     Ruby programming language.
    /// </summary>
    public const string Ruby = "ruby";
    /// <summary>
    ///     Rust programming language.
    /// </summary>
    public const string Rust = "rust";
    /// <summary>
    ///     RVT Script language.
    /// </summary>
    public const string RvtScript = "rvt";
    /// <summary>
    ///     SAS programming language.
    /// </summary>
    public const string SAS = "SAS";
    /// <summary>
    ///     SCSS (Sassy CSS) language.
    /// </summary>
    public const string Scss = "scss";
    /// <summary>
    ///     SQL (Structured Query Language).
    /// </summary>
    public const string Sql = "sql";
    /// <summary>
    ///     STEP Part 21 files.
    /// </summary>
    public const string StepPart21 = "p21";
    /// <summary>
    ///     Scala programming language.
    /// </summary>
    public const string Scala = "scala";
    /// <summary>
    ///     Scheme programming language.
    /// </summary>
    public const string Scheme = "scheme";
    /// <summary>
    ///     Scilab programming language.
    /// </summary>
    public const string Scilab = "scilab";
    /// <summary>
    ///     SFZ format.
    /// </summary>
    public const string Sfz = "sfz";
    /// <summary>
    ///     Shape Expressions (ShExC).
    /// </summary>
    public const string ShapeExpressions = "shexc";
    /// <summary>
    ///     Shell scripting language.
    /// </summary>
    public const string Shell = "shell";
    /// <summary>
    ///     Smali assembly language for Dalvik VM.
    /// </summary>
    public const string Smali = "smali";
    /// <summary>
    ///     Smalltalk programming language.
    /// </summary>
    public const string Smalltalk = "smalltalk";
    /// <summary>
    ///     Standard ML programming language.
    /// </summary>
    public const string Sml = "sml";
    /// <summary>
    ///     Solidity programming language.
    /// </summary>
    public const string Solidity = "solidity";
    /// <summary>
    ///     Splunk SPL (Search Processing Language).
    /// </summary>
    public const string SplunkSpl = "spl";
    /// <summary>
    ///     Stan programming language.
    /// </summary>
    public const string Stan = "stan";
    /// <summary>
    ///     Stata statistical software.
    /// </summary>
    public const string Stata = "stata";
    /// <summary>
    ///     Structured Text (IEC 61131-3).
    /// </summary>
    public const string StructuredText = "iecst";
    /// <summary>
    ///     Stylus CSS preprocessor.
    /// </summary>
    public const string Stylus = "stylus";
    /// <summary>
    ///     SubUnit test result format.
    /// </summary>
    public const string SubUnit = "subunit";
    /// <summary>
    ///     SuperCollider programming language.
    /// </summary>
    public const string Supercollider = "supercollider";
    /// <summary>
    ///     Svelte component framework.
    /// </summary>
    public const string Svelte = "svelte";
    /// <summary>
    ///     Swift programming language.
    /// </summary>
    public const string Swift = "swift";
    /// <summary>
    ///     Tcl scripting language.
    /// </summary>
    public const string Tcl = "tcl";
    /// <summary>
    ///     Terraform (HCL) configuration language.
    /// </summary>
    public const string Terraform = "terraform";
    /// <summary>
    ///     Test Anything Protocol.
    /// </summary>
    public const string Tap = "tap";
    /// <summary>
    ///     Thrift interface definition language.
    /// </summary>
    public const string Thrift = "thrift";
    /// <summary>
    ///     Toit programming language.
    /// </summary>
    public const string Toit = "toit";
    /// <summary>
    ///     TP language.
    /// </summary>
    public const string Tp = "tp";
    /// <summary>
    ///     Transact-SQL language.
    /// </summary>
    public const string TransactSql = "tsql";
    /// <summary>
    ///     TTCN-3 testing language.
    /// </summary>
    public const string TtcnThree = "ttcn";
    /// <summary>
    ///     Twig templating language.
    /// </summary>
    public const string Twig = "twig";
    /// <summary>
    ///     TypeScript programming language.
    /// </summary>
    public const string TypeScript = "typescript";
    /// <summary>
    ///     Unicorn Rails log files.
    /// </summary>
    public const string UnicornRailsLog = "unicorn-rails-log";
    /// <summary>
    ///     Unison programming language.
    /// </summary>
    public const string Unison = "unison";
    /// <summary>
    ///     VB.NET programming language.
    /// </summary>
    public const string VbNet = "vbnet";
    /// <summary>
    ///     VBA (Visual Basic for Applications).
    /// </summary>
    public const string Vba = "vba";
    /// <summary>
    ///     VBScript scripting language.
    /// </summary>
    public const string VbScript = "vbscript";
    /// <summary>
    ///     VHDL hardware description language.
    /// </summary>
    public const string Vhdl = "vhdl";
    /// <summary>
    ///     Vala programming language.
    /// </summary>
    public const string Vala = "vala";
    /// <summary>
    ///     Verilog hardware description language.
    /// </summary>
    public const string Verilog = "verilog";
    /// <summary>
    ///     Vim script.
    /// </summary>
    public const string VimScript = "vim";
    /// <summary>
    ///     WebGPU Shading Language (WGSL).
    /// </summary>
    public const string Wgsl = "wgsl";
    /// <summary>
    ///     X# programming language.
    /// </summary>
    public const string XSharp = "xsharp";
    /// <summary>
    ///     X++ programming language (Axapta).
    /// </summary>
    public const string Axapta = "axapta";
    /// <summary>
    ///     x86 Assembly language.
    /// </summary>
    public const string X86Asm = "x86asm";
    /// <summary>
    ///     x86 Assembly (AT&amp;T syntax).
    /// </summary>
    public const string X86AsmAtt = "x86asmatt";
    /// <summary>
    ///     XL programming language.
    /// </summary>
    public const string Xl = "xl";
    /// <summary>
    ///     XQuery and XPath.
    /// </summary>
    public const string XQuery = "xquery";
    /// <summary>
    ///     YAML Ain't Markup Language.
    /// </summary>
    public const string Yaml = "yml";
    /// <summary>
    ///     ZenScript scripting language.
    /// </summary>
    public const string ZenScript = "zenscript";
    /// <summary>
    ///     Zephir programming language.
    /// </summary>
    public const string Zephir = "zephir";
    /// <summary>
    ///     Zig programming language.
    /// </summary>
    public const string Zig = "zig";
    /// <summary>
    ///     Gets the full language class with the "language-" prefix.
    /// </summary>
    /// <param name="language">The language alias to append.</param>
    /// <returns>A string representing the full language class for Highlight.js.</returns>
    public static string GetLanguageClass(string language)
    {
        return $"language-{language}";
    }
}
</file>

<file path="Components/Document/RzCodeViewer/RzCodeViewer.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">

    <div data-alpine-root="@Id" data-assets="@_assets"
         data-codeid="@CodeId"
         data-nonce="@Nonce"
         data-copy-title="@CopyButtonTitle"
         data-copied-title="@CopiedButtonTitle"
         x-data="rzCodeViewer">
    
        <div class="@Theme.RzCodeViewer.Header">
            <span class="@Theme.RzCodeViewer.HeaderTitle">@ViewerTitle</span>
        </div>

        <div class="@Theme.RzCodeViewer.CodeContainer">
            <div class="@Theme.RzCodeViewer.CopyButtonContainer">
                <button type="button" aria-label="@Localizer["RzCodeViewer.CopyButtonAriaLabel"]" role="button" :title="getCopiedTitle" x-on:click="copyHTML"
                        class="@Theme.RzCodeViewer.CopyButton" :class="getCopiedCss" x-on:click.away="disableCopied"
                        data-target="cardDefault">
                    <svg x-show="notCopied" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"
                         stroke-width="1.5" stroke="currentColor" class="@Theme.RzCodeViewer.CopyIconDefault"
                         x-transition:enter="transition duration-200 ease-out motion-reduce:transition-none" x-transition:enter-start="opacity-0"
                         x-transition:enter-end="opacity-100"
                         aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184"></path>
                    </svg>
                    <svg x-show="copied" x-transition:enter="transition duration-200 ease-out motion-reduce:transition-none"
                         x-transition:enter-start="translate-y-2 opacity-0"
                         x-transition:enter-end="translate-y-0 opacity-100" xmlns="http://www.w3.org/2000/svg" fill="none"
                         viewBox="0 0 24 24" stroke-width="1.3" stroke="currentColor" class="@Theme.RzCodeViewer.CopyIconCopied"
                         aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round"
                              d="M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75"></path>
                    </svg>
                </button>
            </div>

            <div class="@Theme.RzCodeViewer.PreWrapper" :class="getExpandCss">
                <pre x-ref="codeBlock" class="@Theme.RzCodeViewer.PreElement" tabindex="0">
                    <code class="@LanguageClass" id="@CodeId">@CodeContent</code>
                </pre>
            </div>
        </div>

        <button type="button" aria-label="@Localizer["RzCodeViewer.ExpandButtonAriaLabel"]" class="@Theme.RzCodeViewer.ExpandButton" x-on:click="toggleExpand">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"
                class="@Theme.RzCodeViewer.ExpandIcon" :class="getExpandButtonCss" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"></path>
            </svg>
        </button>
    </div>
</HtmlElement>
</file>

<file path="Components/Document/RzCodeViewer/RzCodeViewer.razor.cs">
using System.Text.Json;
using System.Web;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
// For HttpUtility
namespace RizzyUI;
/// <xmldoc>
///     Displays code snippets with syntax highlighting (using Highlight.js), copy-to-clipboard functionality,
///     and an expand/collapse feature. Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCodeViewer : RzComponent
{
    /// <summary> Default assets loaded for RzCodeViewer (Highlight.js core and Razor plugin). </summary>
    public static string[] DefaultAssets =
    [
        Constants.ContentUrl("vendor/highlightjs/highlight.js"),
        Constants.ContentUrl("js/lib/highlightjs-plugin/cshtml-razor.min.js")
    ];
    private string _assets = string.Empty;
    // Theme is inherited from RzComponent
    private string CodeId { get; } = IdGenerator.UniqueId("rzcode");
    private string CodeContent { get; set; } = string.Empty;
    /// <summary>
    ///     Optional array of asset URLs (JS/CSS) to load, primarily for Highlight.js and themes. Defaults to
    ///     <see cref="DefaultAssets" />.
    /// </summary>
    [Parameter] public string[] ComponentAssets { get; set; } = DefaultAssets;
    /// <summary>
    ///     The language alias for Highlight.js syntax highlighting (e.g., "csharp", "html", "css"). See
    ///     <see cref="CodeLanguage" /> constants. Defaults to "html".
    /// </summary>
    [Parameter] public string Language { get; set; } = CodeLanguage.Html;
    /// <summary> The code content provided as a RenderFragment. Used if <see cref="Source" /> is null or empty. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary> The code content provided as a string. Takes precedence over <see cref="ChildContent" />. </summary>
    [Parameter] public string? Source { get; set; }
    /// <summary> The title displayed in the header of the code viewer card. Defaults to localized "Source". </summary>
    [Parameter] public string? ViewerTitle { get; set; }
    /// <summary> Gets the title text for the copy button before copying. </summary>
    protected string CopyButtonTitle => Localizer["RzCodeViewer.CopyButtonTitleCopy"];
    /// <summary> Gets the title text for the copy button after copying. </summary>
    protected string CopiedButtonTitle => Localizer["RzCodeViewer.CopyButtonTitleCopied"];
    /// <summary> Gets the full language class name for Highlight.js. </summary>
    protected string LanguageClass => CodeLanguage.GetLanguageClass(Language);
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        // Base class handles Theme initialization
        base.OnInitialized();
        _assets = JsonSerializer.Serialize(ComponentAssets);
        ViewerTitle ??= Localizer["RzCodeViewer.DefaultViewerTitle"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        ViewerTitle ??= Localizer["RzCodeViewer.DefaultViewerTitle"]; // Ensure default if becomes null
        SetCodeContent();
    }
    private void SetCodeContent()
    {
        string rawContent;
        if (!string.IsNullOrEmpty(Source))
        {
            rawContent = Source;
        }
        else if (ChildContent != null)
        {
            rawContent = ChildContent.AsMarkupString(); // Assumes AsMarkupString extension exists
            rawContent = HttpUtility.HtmlDecode(rawContent); // Decode entities
        }
        else
        {
            rawContent = string.Empty;
        }
        CodeContent = rawContent.TrimEmptyLines().Outdent(); // Trim and outdent
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzCodeViewer.Container);
    }
}
</file>

<file path="Components/Document/RzCodeViewer/Styling/DefaultRzCodeViewerStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzCodeViewer. </summary>
public class DefaultRzCodeViewerStyles : RzStylesBase.RzCodeViewerStylesBase
{
    /// <inheritdoc />
    public DefaultRzCodeViewerStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "mt-2 overflow-auto";
    /// <inheritdoc />
    public override string Header =>
        "border-b-0 border-outline bg-secondary flex flex-col items-start justify-between gap-4 rounded-theme rounded-b-none border p-4 text-sm text-slate-400 md:flex-row md:items-center md:gap-2"; // Use semantic names
    /// <inheritdoc />
    public override string HeaderTitle => "text-foreground"; // Use semantic names
    /// <inheritdoc />
    public override string CodeContainer =>
        "border-outline w-full overflow-y-auto transition-all !rounded-b-none rounded-b-xl border"; // Use semantic names
    /// <inheritdoc />
    public override string CopyButtonContainer =>
        "border-surface-tertiary/70 bg-accent text-foreground-tertiary flex h-11 items-center justify-between border-b"; // Use semantic names
    /// <inheritdoc />
    public override string CopyButton =>
        "my-auto ml-auto mr-2 overflow-hidden rounded-full p-1 hover:bg-background/10 focus:outline-none focus:outline-offset-0 focus-visible:outline-2 active:-outline-offset-2"; // Use semantic names
    /// <inheritdoc />
    public override string CopyIconDefault =>
        "text-foreground size-6 cursor-pointer"; // Use semantic names (adjusted for likely contrast)
    /// <inheritdoc />
    public override string CopyIconCopied => "size-6 text-emerald-500"; // Keep specific color for success state
    /// <inheritdoc />
    public override string PreWrapper => "relative overflow-y-auto";
    /// <inheritdoc />
    public override string PreElement =>
        "text-foreground/60 overflow-x-auto text-sm p-8 border-none"; // Use semantic names
    /// <inheritdoc />
    public override string ExpandButton =>
        "border-t-0 border-outline bg-secondary text-foreground flex w-full items-center justify-center gap-2 rounded-theme rounded-t-none border p-2 focus:outline-none focus-visible:rounded-t-none focus-visible:border-2 focus-visible:border-primary dark:focus-visible:border-primary"; // Use semantic names
    /// <inheritdoc />
    public override string ExpandIcon => "rotate-0 h-5 w-5 transition";
    /// <inheritdoc />
    public override string GetExpandContentCss(bool isExpanded)
    {
        return isExpanded ? "" : "max-h-60";
    }
    /// <inheritdoc />
    public override string GetExpandButtonIconCss(bool isExpanded)
    {
        return isExpanded ? "rotate-180" : "rotate-0";
    }
    /// <inheritdoc />
    public override string GetCopyButtonStateCss(bool isCopied)
    {
        return isCopied ? "focus-visible:outline-success" : "focus-visible:outline-foreground";
        // Use semantic names
    }
}
</file>

<file path="Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" class="@Theme.RzEmbeddedPreview.Container">
	<iframe x-data="rzEmbeddedPreview"
	        id="@Id"
	        data-alpine-root="@Id"
	        class="@Theme.RzEmbeddedPreview.IFrame"
	        srcdoc="@_content"
	        x-ref="iframe"
			title="@IFrameTitle">
	</iframe>
</HtmlElement>
</file>

<file path="Components/Document/RzEmbeddedPreview/RzEmbeddedPreview.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
// For Task
namespace RizzyUI;
/// <xmldoc>
///     Renders child content within an isolated iframe, optionally applying a specified Blazor layout component.
///     Useful for previewing components or content in a sandboxed environment. Includes Alpine.js logic
///     for dynamic iframe resizing and dark mode synchronization.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzEmbeddedPreview : RzComponent
{
    private string? _content;
    /// <summary> ServiceProvider reference needed to render components to string correctly. </summary>
    [Inject] private IServiceProvider ServiceProvider { get; set; } = default!;
    /// <summary> The content (markup or components) to render inside the iframe. Required. </summary>
    [Parameter] [EditorRequired] public required RenderFragment ChildContent { get; set; }
    /// <summary> An optional Blazor layout component type to wrap the <see cref="ChildContent" /> within the iframe. </summary>
    [Parameter] public Type? Layout { get; set; }
    /// <summary>
    /// Gets or sets the title attribute for the iframe, providing context for screen readers.
    /// If not set, defaults to a localized "Embedded Content Preview".
    /// </summary>
    [Parameter] public string? IFrameTitle { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set default localized value if parameter is not provided
        IFrameTitle ??= Localizer["RzEmbeddedPreview.DefaultIFrameTitle"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
         // Ensure default is applied if parameter becomes null after initialization
        IFrameTitle ??= Localizer["RzEmbeddedPreview.DefaultIFrameTitle"];
    }
    /// <inheritdoc />
    protected override async Task OnParametersSetAsync() // Use async version for RenderHtmlAsync
    {
        await base.OnParametersSetAsync(); // Ensure base class logic runs
        // Wrap the ChildContent inside the Layout if specified
        RenderFragment fragment = builder =>
        {
            if (Layout != null)
            {
                builder.OpenComponent(0, Layout);
                builder.AddAttribute(1, nameof(LayoutComponentBase.Body), ChildContent);
                builder.CloseComponent();
            }
            else
            {
                builder.AddContent(2, ChildContent);
            }
        };
        // Use the async RenderHtml extension method to render the fragment
        // Be mindful of potential deadlocks if not done correctly in all scenarios.
        // Consider making this truly async if rendering becomes complex.
        _content = await fragment.RenderHtmlAsync(ServiceProvider);
    }
}
</file>

<file path="Components/Document/RzEmbeddedPreview/Styling/DefaultRzEmbeddedPreviewStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzEmbeddedPreview. </summary>
public class DefaultRzEmbeddedPreviewStyles : RzStylesBase.RzEmbeddedPreviewStylesBase
{
    /// <inheritdoc />
    public DefaultRzEmbeddedPreviewStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "w-full";
    /// <inheritdoc />
    public override string IFrame => "w-full transition-all min-h-28";
}
</file>

<file path="Components/Document/RzMarkdown/RzMarkdown.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="div" @attributes="@AdditionalAttributes" class="@RootClass()" id="@Id">
	<div data-alpine-root="@Id" data-assets="@_assets" data-nonce="@Nonce" x-data="rzMarkdown">
	@OutputHtml
	</div>
</HtmlElement>
</file>

<file path="Components/Document/RzMarkdown/RzMarkdown.razor.cs">
using System.Text;
using System.Text.Json;
using System.Web;
using Markdig;
using Markdig.Renderers.Html;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A component that converts Markdown text (provided as ChildContent or Content parameter) into HTML using Markdig.
///     It supports GitHub Flavored Markdown extensions and integrates with Highlight.js for syntax highlighting.
///     Styling is determined by the active <see cref="RzTheme" /> and Tailwind Typography plugin.
/// </xmldoc>
public partial class RzMarkdown : RzComponent
{
    /// <summary> Default assets loaded for RzMarkdown (Highlight.js and Razor plugin). </summary>
    public static string[] DefaultAssets = [ /* Unchanged */];
    private string _assets = string.Empty;
    /// <summary> Reference to the QuickReferenceContainer for heading registration. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <summary>
    ///     The Markdig pipeline used for conversion. Defaults to a pipeline with advanced extensions and custom code
    ///     block rendering.
    /// </summary>
    [Parameter]
    public MarkdownPipeline? Pipeline { get; set; }
    /// <summary> The Markdown content provided as a RenderFragment. Used if <see cref="Content" /> is null or empty. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The Markdown content provided as a string. Takes precedence over <see cref="ChildContent" />. </summary>
    [Parameter]
    public string? Content { get; set; } = string.Empty;
    /// <summary> Controls the maximum width of the rendered prose content. Defaults to Comfortable. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Comfortable;
    /// <summary>
    ///     Optional array of asset URLs (JS/CSS) to load, primarily for syntax highlighting. Defaults to
    ///     <see cref="DefaultAssets" />.
    /// </summary>
    [Parameter]
    public string[] ComponentAssets { get; set; } = DefaultAssets;
    /// <summary> Gets the HTML markup generated by converting the markdown content. </summary>
    protected MarkupString? OutputHtml { get; private set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Setup default pipeline if none provided
        Pipeline ??= new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseRizzySyntaxHighlighting() // Assumes this extension exists and is correctly implemented
            .Build();
        // Serialize assets only once if they don't change
        _assets = JsonSerializer.Serialize(ComponentAssets);
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-render HTML only if content changes
        if (OutputHtml is null)
            RenderMarkdownContent();
    }
    private void RenderMarkdownContent()
    {
        string markdownText;
        if (!string.IsNullOrEmpty(Content))
        {
            markdownText = Content;
        }
        else if (ChildContent != null)
        {
            markdownText = ChildContent.AsMarkupString().Outdent();
            markdownText = HttpUtility.HtmlDecode(markdownText); // Decode potential HTML entities
        }
        else
        {
            markdownText = string.Empty;
        }
        var html = RenderOutput(markdownText);
        OutputHtml = new MarkupString(html);
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzMarkdown.Container,
            Theme.RzMarkdown.GetProseWidthCss(ProseWidth));
    }
    // RenderOutput and ExtractPlainText methods remain the same, but ensure they use the correct
    // QuickReferenceContainer type (RzQuickReferenceContainer) if needed.
    private string RenderOutput(string markdownText)
    {
        var document = Markdown.Parse(markdownText, Pipeline);
        // Iterate through heading blocks and register them.
        if (QuickReferenceContainer != null)
            foreach (var block in document)
                if (block is HeadingBlock heading)
                {
                    var level = heading.Level;
                    var headingText = ExtractPlainText(heading.Inline);
                    var attributes = heading.GetAttributes();
                    attributes.Id ??= IdGenerator.UniqueId("heading"); // Ensure ID exists
                    attributes.AddProperty("x-data", "rzHeading"); // Add Alpine data if needed
                    var headingLevel = level switch
                    {
                        1 => HeadingLevel.H1, 2 => HeadingLevel.H2, 3 => HeadingLevel.H3, _ => HeadingLevel.H4
                    };
                    // Ensure QuickReferenceContainer parameter type matches RzQuickReferenceContainer
                    QuickReferenceContainer.RegisterHeading(headingLevel, headingText, attributes.Id);
                }
        return document.ToHtml(Pipeline);
    }
    private string ExtractPlainText(ContainerInline? inline)
    {
        // (Implementation remains the same)
        if (inline == null) return string.Empty;
        var sb = new StringBuilder();
        foreach (var child in inline)
            if (child is LiteralInline literal)
                sb.Append(literal.Content.Text.Substring(literal.Content.Start, literal.Content.Length));
            else if (child is ContainerInline container) sb.Append(ExtractPlainText(container));
        return sb.ToString().Trim();
    }
}
</file>

<file path="Components/Document/RzMarkdown/Styling/DefaultRzMarkdownStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzMarkdown component.
/// </summary>
public class DefaultRzMarkdownStyles : RzStylesBase.RzMarkdownStylesBase
{
    /// <inheritdoc />
    public DefaultRzMarkdownStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    // Includes base prose, dark mode inversion, and theme text color
    public override string Container => "prose dark:prose-invert text-foreground max-w-none";
    /// <inheritdoc />
    public override string GetProseWidthCss(ProseWidth width)
    {
        return width switch
        {
            ProseWidth.Compact => "prose-compact",
            ProseWidth.Comfortable => "prose-comfortable",
            ProseWidth.Relaxed => "prose-relaxed",
            ProseWidth.Wide => "prose-wide",
            ProseWidth.UltraWide => "prose-ultrawide", // Corrected class name if needed
            ProseWidth.Full => "prose-full", // Ensure this utility exists or remove if max-w-none covers it
            _ => GetProseWidthCss(ProseWidth.Comfortable) // Default to comfortable
        };
    }
}
</file>

<file path="Components/Document/RzQuickReference/RzQuickReference.razor">
@namespace RizzyUI
@inherits RzComponent

<nav @attributes="@AdditionalAttributes" class="@RootClass()" id="@Id" aria-label="@AriaLabel">
    <p class="@Theme.RzQuickReference.Title">
        @Title
    </p>
    <ul class="@Theme.RzQuickReference.List">
        @foreach (var heading in _headings)
        {
            <li class="@Theme.RzQuickReference.ListItem @GetIndentationClass(heading.Level)">
                <a href="#@heading.Id"
                   class="@Theme.RzQuickReference.Link"
                   data-headingid="@heading.Id"
                   :class="getSelectedCss"
                   :aria-current="getSelectedAriaCurrent"
                   x-on:click="handleHeadingClick">
                    @heading.Title
                </a>
            </li>
        }
    </ul>
</nav>
</file>

<file path="Components/Document/RzQuickReference/RzQuickReference.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders an "on this page" style navigation outline based on headings registered
///     with the parent <see cref="RzQuickReferenceContainer" />. Interacts with Alpine.js
///     to highlight the currently visible heading and set `aria-current`.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzQuickReference : RzComponent
{
    private IReadOnlyList<HeadingItem> _headings = new List<HeadingItem>().AsReadOnly();
    /// <summary> Gets the parent container which holds the heading data. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <summary> The title displayed above the quick reference list. Defaults to localized "On this page". </summary>
    [Parameter]
    public string? Title { get; set; }
    /// <summary>
    /// The aria-label for the navigation element. Defaults to localized "On this page navigation".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (QuickReferenceContainer == null)
            throw new InvalidOperationException(
                $"{GetType()} must be placed within an {nameof(RzQuickReferenceContainer)}.");
        // Get initial headings
        _headings = QuickReferenceContainer.GetHeadingItems();
        // Set default localized values if parameters are null
        Title ??= Localizer["RzQuickReference.DefaultTitle"];
        AriaLabel ??= Localizer["RzQuickReference.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Update headings if the container might have changed (less common, but possible)
        if (QuickReferenceContainer != null) _headings = QuickReferenceContainer.GetHeadingItems();
         // Ensure defaults are applied if parameters become null after initialization
        Title ??= Localizer["RzQuickReference.DefaultTitle"];
        AriaLabel ??= Localizer["RzQuickReference.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzQuickReference.Container);
    }
    /// <summary> Gets the CSS class for indentation based on the heading level. </summary>
    /// <param name="level">The heading level.</param>
    /// <returns>A string containing the Tailwind CSS class for margin-left.</returns>
    protected string GetIndentationClass(HeadingLevel level)
    {
        return Theme.RzQuickReference.GetIndentationCss(level, QuickReferenceContainer!.MinimumHeadingLevel);
        // Use parent's min level
    }
}
</file>

<file path="Components/Document/RzQuickReference/RzQuickReferenceContainer.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	<div data-alpine-root="@Id" data-headings="@_headingItemsSerialized"
	     data-currentheadingid="@(_currentHeadingId)"
	     x-data="rzQuickReferenceContainer">
		<CascadingValue Value="this" IsFixed="true">
			@ChildContent
		</CascadingValue>		
	</div>
</HtmlElement>
</file>

<file path="Components/Document/RzQuickReference/RzQuickReferenceContainer.razor.cs">
using System.Text.Json;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container component that collects heading information from child components (like <see cref="RzHeading" />)
///     and makes it available to <see cref="RzQuickReference" /> for building an "on this page" navigation.
///     Interacts with Alpine.js to manage the currently highlighted heading.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzQuickReferenceContainer : RzComponent
{
    private readonly List<HeadingItem> _headingItems = new();
    private string _currentHeadingId = string.Empty; // Store initial heading ID
    private string _headingItemsSerialized = "[]";
    /// <summary> The lowest heading level (e.g., H2) to include in the quick reference outline. Defaults to H2. </summary>
    [Parameter]
    public HeadingLevel MinimumHeadingLevel { get; set; } = HeadingLevel.H2;
    /// <summary> The highest heading level (e.g., H4) to include in the quick reference outline. Defaults to H4. </summary>
    [Parameter]
    public HeadingLevel MaximumHeadingLevel { get; set; } = HeadingLevel.H4;
    /// <summary>
    ///     The child content of the container, which should include headings and potentially an
    ///     <see cref="RzQuickReference" /> component.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Registers a heading with this container. Called by child <see cref="RzHeading" /> components. </summary>
    /// <param name="level">The heading level.</param>
    /// <param name="title">The title of the heading.</param>
    /// <param name="id">The unique ID of the heading element.</param>
    internal void RegisterHeading(HeadingLevel level, string title, string id)
    {
        if (level >= MinimumHeadingLevel && level <= MaximumHeadingLevel)
            _headingItems.Add(new HeadingItem(level, title, id));
        UpdateSerializedHeadings();
        StateHasChanged();
    }
    private void UpdateSerializedHeadings()
    {
        _headingItemsSerialized =
            JsonSerializer.Serialize(_headingItems.Select(x => x.Id).ToList()); // Serialize the IDs
        _currentHeadingId = _headingItems.FirstOrDefault()?.Id ?? string.Empty; // Set initial ID for Alpine
    }
    /// <summary> Gets the list of registered heading items. </summary>
    /// <returns>A read-only list of <see cref="HeadingItem" />.</returns>
    public IReadOnlyList<HeadingItem> GetHeadingItems()
    {
        return _headingItems.AsReadOnly();
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzQuickReferenceContainer.Container);
    }
}
</file>

<file path="Components/Document/RzQuickReference/Styling/DefaultRzQuickReferenceStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzQuickReference. </summary>
public class DefaultRzQuickReferenceStyles : RzStylesBase.RzQuickReferenceStylesBase
{
    /// <inheritdoc />
    public DefaultRzQuickReferenceStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "text-foreground"; // Base text color
    /// <inheritdoc />
    public override string Title => "mb-4 font-bold";
    /// <inheritdoc />
    public override string List => "flex flex-col gap-2";
    /// <inheritdoc />
    public override string ListItem => ""; // Base LI, indentation added dynamically
    /// <inheritdoc />
    public override string Link => ""; // Base link, selected state handled by Alpine :class
    /// <inheritdoc />
    public override string LinkSelected => "font-bold"; // Class added by Alpine when selected
    /// <inheritdoc />
    public override string GetIndentationCss(HeadingLevel level, HeadingLevel minLevel)
    {
        // Calculate relative level (0 = minLevel, 1 = minLevel+1, etc.)
        var relativeLevel = (int)level - (int)minLevel;
        return relativeLevel switch
        {
            0 => "ml-0",
            1 => "ml-4",
            2 => "ml-8",
            3 => "ml-12", // H4 if min is H1, or H5 if min is H2
            _ => "ml-0" // Default or levels beyond H4/H5
        };
    }
}
/// <summary> Provides default styles for RzQuickReferenceContainer. </summary>
public class DefaultRzQuickReferenceContainerStyles : RzStylesBase.RzQuickReferenceContainerStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzQuickReferenceContainerStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzQuickReferenceContainerStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // No base styles for the container usually
}
</file>

<file path="Components/Feedback/RzAlert/RzAlert.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<CascadingValue Value="this" IsFixed="true">
    <HtmlElement Element="@EffectiveElement"
                 @attributes="@AdditionalAttributes"
                 id="@Id"
                 class="@RootClass()"
                 role="alert"
                 aria-live="assertive"
                 >
                     
             <div data-alpine-root="@Id" class="@Theme.RzAlert.InnerContainer @(_bgLight)"
                  x-cloak
                  x-data="rzAlert" x-show="showAlert"
                  x-transition:enter="transition ease-out duration-200 motion-reduce:transition-none"
                  x-transition:enter-start="opacity-0"
                  x-transition:enter-end="opacity-100"
                  x-transition:leave="transition ease-in duration-100 motion-reduce:transition-none"
                  x-transition:leave-start="opacity-100"
                  x-transition:leave-end="opacity-0">
            @if (Icon != null)
            {
                <div class="@Theme.RzAlert.IconContainer @(_iconColor)" aria-hidden="true">
                    @if (Pulse)
                    {
                        <div class="@Theme.RzAlert.IconPulse @_bgLighter"></div>
                    }
                    <Blazicon Svg="Icon"></Blazicon>
                </div>
            }
            <div class="@Theme.RzAlert.ContentContainer">
                @ChildContent
            </div>

            @if (Dismissable)
            {
                <button
                    type="button"
                    x-on:click="dismiss"
                    aria-label="@Localizer["RzAlert.CloseButtonAriaLabel"]"
                    class="@Theme.RzAlert.CloseButton">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" stroke="currentColor"
                         fill="none" stroke-width="2.5" class="@Theme.RzAlert.CloseButtonIcon">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            }
        </div>
    </HtmlElement>
</CascadingValue>
</file>

<file path="Components/Feedback/RzAlert/RzAlert.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents an alert component that displays a message with optional icon, variant, and dismiss functionality.
///     Styling is handled by the active theme. Content within the alert is implicitly announced by assistive technologies
///     due to the `role="alert"` attribute on the container.
/// </xmldoc>
public partial class RzAlert : RzComponent
{
    private string _bgLight = string.Empty;
    private string _bgLighter = string.Empty;
    private string _iconColor = string.Empty;
    /// <summary> Gets or sets the variant of the alert. </summary>
    [Parameter]
    public AlertVariant Variant { get; set; } = AlertVariant.Information;
    /// <summary> Gets or sets the icon displayed in the alert. If null, a default icon based on the variant may be shown. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Gets or sets a value indicating whether the alert can be dismissed via a close button. </summary>
    [Parameter]
    public bool Dismissable { get; set; }
    /// <summary> Gets or sets the content to be displayed inside the alert, typically including <see cref="RzAlertTitle"/> and <see cref="RzAlertDescription"/>. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets whether to display a pulsing animation behind the icon for emphasis. Requires `Pulse` to be true in the theme. </summary>
    [Parameter]
    public bool Pulse { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        SetVariantStyles(); // Set styles after Theme is confirmed
        SetDefaultIcon(); // Set default icon after variant styles are known
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        // Re-apply styles if parameters change AFTER initialization
        if (Theme != null) // Ensure theme is available
        {
            SetVariantStyles();
            SetDefaultIcon(); // Re-evaluate default icon if variant changed and Icon is null
        }
        base.OnParametersSet();
    }
    private void SetVariantStyles()
    {
        var styles = Theme.RzAlert;
        _bgLight = styles.GetVariantBackgroundLightCss(Variant);
        _bgLighter = styles.GetVariantBackgroundLighterCss(Variant);
        _iconColor = styles.GetVariantIconColorCss(Variant);
    }
    private void SetDefaultIcon()
    {
        if (Icon == null) // Only set if user hasn't provided one
            Icon = Variant switch
            {
                AlertVariant.Information => MdiIcon.InformationSlabCircle,
                AlertVariant.Success => MdiIcon.CheckCircle,
                AlertVariant.Warning => MdiIcon.AlertCircle,
                AlertVariant.Destructive => MdiIcon.CloseCircle,
                AlertVariant.Alternate => null, // No default for alternate
                _ => MdiIcon.InformationSlabCircle
            };
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAlert.Container, Theme.RzAlert.GetVariantCss(Variant));
    }
}
</file>

<file path="Components/Feedback/RzAlert/RzAlertDescription.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Feedback/RzAlert/RzAlertDescription.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the descriptive content (<c>p</c> tag by default) within an <see cref="RzAlert" /> component.
///     Provides supplementary information to the <see cref="RzAlertTitle" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzAlertDescription : RzComponent
{
    /// <summary> The descriptive content to be rendered. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p"; // Default to paragraph element
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAlertDescription.Description);
    }
}
</file>

<file path="Components/Feedback/RzAlert/RzAlertTitle.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">@ChildContent</HtmlElement>
</file>

<file path="Components/Feedback/RzAlert/RzAlertTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the title section (defaults to <c>h3</c>) for an <see cref="RzAlert" /> component.
///     Its text color is determined by the parent alert's variant and the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzAlertTitle : RzComponent
{
    private string _variantTextClass = string.Empty;
    /// <summary> Gets the parent <see cref="RzAlert" /> component to determine the variant. </summary>
    [CascadingParameter] public RzAlert? AlertParent { get; set; }
    /// <summary> The content to be rendered inside the alert title (typically text). </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "h3"; // Default semantic level for an alert title within its context
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Get variant color class after AlertParent should be available
        _variantTextClass = Theme.RzAlertTitle.GetVariantTextColorCss(AlertParent?.Variant);
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAlertTitle.Title, _variantTextClass);
    }
}
</file>

<file path="Components/Feedback/RzAlert/Styling/DefaultRzAlertStyles.cs">
namespace RizzyUI;
/// <inheritdoc />
public class DefaultRzAlertStyles : RzStylesBase.RzAlertStylesBase
{
    /// <inheritdoc />
    public DefaultRzAlertStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "relative w-full overflow-hidden rounded-theme border";
    /// <inheritdoc />
    public override string InnerContainer => "flex w-full items-center gap-2 p-4";
    /// <inheritdoc />
    public override string IconContainer => "relative flex rounded-full p-1 text-2xl justify-center";
    /// <inheritdoc />
    public override string IconPulse =>
        "absolute animate-ping motion-reduce:animate-none size-6 aspect-square rounded-full";
    /// <inheritdoc />
    public override string ContentContainer => "ml-2 flex-grow"; // Added flex-grow
    /// <inheritdoc />
    public override string CloseButton => "ml-auto self-start p-1 rounded-full focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-primary dark:focus-visible:ring-offset-surface-dark"; // Added focus styles
    /// <inheritdoc />
    public override string CloseButtonIcon => "shrink-0 h-4 w-4";
    /// <inheritdoc />
    public override string GetVariantCss(AlertVariant variant)
    {
        return variant switch
        {
            AlertVariant.Alternate => "border-outline bg-background text-foreground",
            AlertVariant.Information =>
                "border-info bg-background text-foreground",
            AlertVariant.Success =>
                "border-success bg-background text-foreground",
            AlertVariant.Warning =>
                "border-warning bg-background text-foreground",
            AlertVariant.Destructive =>
                "border-destructive bg-background text-foreground",
            _ => GetVariantCss(AlertVariant.Information) // Default
        };
    }
    /// <inheritdoc />
    public override string GetVariantBackgroundLightCss(AlertVariant variant)
    {
        return variant switch
        {
            AlertVariant.Alternate => "bg-secondary/10",
            AlertVariant.Information => "bg-info/10",
            AlertVariant.Success => "bg-success/10",
            AlertVariant.Warning => "bg-warning/10",
            AlertVariant.Destructive => "bg-destructive/10",
            _ => GetVariantBackgroundLightCss(AlertVariant.Information)
        };
    }
    /// <inheritdoc />
    public override string GetVariantBackgroundLighterCss(AlertVariant variant)
    {
        return variant switch
        {
            AlertVariant.Alternate => "bg-secondary/15",
            AlertVariant.Information => "bg-info/15",
            AlertVariant.Success => "bg-success/15",
            AlertVariant.Warning => "bg-warning/15",
            AlertVariant.Destructive => "bg-destructive/15",
            _ => GetVariantBackgroundLighterCss(AlertVariant.Information)
        };
    }
    /// <inheritdoc />
    public override string GetVariantIconColorCss(AlertVariant variant)
    {
        return variant switch
        {
            AlertVariant.Alternate => "text-foreground",
            AlertVariant.Information => "text-info",
            AlertVariant.Success => "text-success",
            AlertVariant.Warning => "text-warning",
            AlertVariant.Destructive => "text-destructive",
            _ => GetVariantIconColorCss(AlertVariant.Information)
        };
    }
}
/// <inheritdoc />
public class DefaultRzAlertTitleStyles : RzStylesBase.RzAlertTitleStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzAlertTitleStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzAlertTitleStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    ///     Gets the base CSS classes for the alert title element.
    /// </summary>
    public override string Title => "text-sm font-semibold pb-1";
    /// <summary>
    ///     Gets the CSS classes for the text color based on the alert variant.
    /// </summary>
    /// <param name="variant">The alert variant.</param>
    /// <returns>A string of CSS classes.</returns>
    public override string GetVariantTextColorCss(AlertVariant? variant)
    {
        return variant switch
        {
            AlertVariant.Alternate =>
                "text-foreground", // Example: maybe stronger for alternate
            AlertVariant.Information => "text-info",
            AlertVariant.Success => "text-success",
            AlertVariant.Warning => "text-warning",
            AlertVariant.Destructive => "text-destructive",
            _ => "text-info" // Default
        };
    }
}
/// <inheritdoc />
public class DefaultRzAlertDescriptionStyles : RzStylesBase.RzAlertDescriptionStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzAlertDescriptionStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzAlertDescriptionStyles(RzTheme theme) : base(theme)
    {
    }
    /// <summary>
    ///     Gets the base CSS classes for the alert description element.
    /// </summary>
    public override string Description => "text-xs font-medium sm:text-sm";
}
</file>

<file path="Components/Feedback/RzModal/RzModal.razor">
@namespace RizzyUI
@inherits RzComponent
@using Blazicons

<template x-teleport="body">
    <div x-data="rzModal"
         id="@Id"
         data-alpine-root="@Id"
         data-modal-id="@Id"
         data-body-id="@BodyId"
         data-footer-id="@FooterId"
         data-nonce="@Nonce"
         data-event-trigger-name="@EventTriggerName"
         data-close-event-name="@CloseEventName"
         data-close-on-escape="@CloseOnEscape.ToString().ToLowerInvariant()"
         data-close-on-click-outside="@CloseOnClickOutside.ToString().ToLowerInvariant()"
         class="contents">

        <div x-cloak
             x-show="modalOpen"
             x-transition:enter="transition ease-out duration-200 motion-reduce:transition-none"
             x-transition:enter-start="opacity-0"
             x-transition:enter-end="opacity-100"
             x-transition:leave="transition ease-in duration-100 motion-reduce:transition-none"
             x-transition:leave-start="opacity-100"
             x-transition:leave-end="opacity-0"
             x-bind:aria-hidden="notModalOpen"
             tabindex="-1"
             role="dialog"
             aria-modal="true"
             aria-labelledby="@AriaLabelId"
             class="@Theme.RzModal.Backdrop">

            <HtmlElement Element="div" @attributes="AdditionalAttributes"
                 x-cloak
                 x-show="modalOpen"
                 x-transition:enter="transition ease-out duration-200 motion-reduce:transition-none"
                 x-transition:enter-start="opacity-0 scale-125"
                 x-transition:enter-end="opacity-100 scale-100"
                 x-transition:leave="transition ease-in duration-100 motion-reduce:transition-none"
                 x-transition:leave-start="opacity-100 scale-100"
                 x-transition:leave-end="opacity-0 scale-125"
                 x-trap.inert="modalOpen"
                 x-on:click.outside="handleClickOutside"
                 role="document"
                 class="@RootClass()">

                @if (ShowHeader)
                {
                    <div class="@Theme.RzModal.Header">
                        @if (TitleContent is not null)
                        {
                            <div id="@AriaLabelId" class="@Theme.RzModal.TitleContainer">
                                @TitleContent
                            </div>
                        }
                        else if (!string.IsNullOrEmpty(Title))
                        {
                            <h3 id="@AriaLabelId" class="@Theme.RzModal.Title">
                                @Title
                            </h3>
                        }
                        else
                        {
                             <div id="@AriaLabelId" class="@Theme.RzModal.TitleContainer"></div>
                        }

                        @if(ShowCloseButton)
                        {
                            <div class="@Theme.RzModal.CloseButtonContainer">
                                <button x-on:click="closeModal"
                                        type="button"
                                        aria-label="@Localizer["RzModal.CloseButtonAriaLabel"]"
                                        class="@Theme.RzModal.CloseButton">
                                    <Blazicon Svg="MdiIcon.Close" class="@Theme.RzModal.CloseButtonIcon"/>
                                </button>
                            </div>
                        }
                    </div>
                }

                <div id="@BodyId" class="@Theme.RzModal.Body">
                    @ChildContent
                </div>

                @if (FooterContent is not null)
                {
                     <div id="@FooterId" class="@Theme.RzModal.Footer">
                        @FooterContent
                    </div>
                }

            </HtmlElement>
        </div>
    </div>
</template>
</file>

<file path="Components/Feedback/RzModal/RzModal.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
using Blazicons;
namespace RizzyUI;
/// <xmldoc>
/// Renders a modal dialog component that can be triggered by a specified event name or opened programmatically.
/// Supports dynamic content loading/swapping within its body or footer using HTMX by targeting the BodyId or FooterId.
/// Includes backdrop, transitions, focus trapping, and configurable closing behavior (Escape, backdrop click, close event).
/// Styling is controlled by the active <see cref="RzTheme"/>. Interactivity is managed by the 'rzModal' Alpine.js component.
/// Dispatches lifecycle events: rz:modal-initialized, rz:modal-before-open, rz:modal-after-open, rz:modal-before-close, rz:modal-after-close.
/// </xmldoc>
public partial class RzModal : RzComponent
{
    /// <summary>
    /// Gets the unique identifier used for the `aria-labelledby` attribute, linking the dialog to its title.
    /// </summary>
    protected string AriaLabelId { get; } = IdGenerator.UniqueId("rzmdlttl");
    /// <summary>
    /// Gets the unique identifier for the modal body container, usable as an HTMX target ID.
    /// Passed to Alpine for the initialized event detail.
    /// </summary>
    public string BodyId { get; } = IdGenerator.UniqueId("rzmdlbody");
    /// <summary>
    /// Gets the unique identifier for the modal footer container, usable as an HTMX target ID.
    /// Passed to Alpine for the initialized event detail.
    /// </summary>
    public string FooterId { get; } = IdGenerator.UniqueId("rzmdlfoot");
    /// <summary>
    /// Gets or sets the name of the window event that will trigger this modal to open.
    /// If empty, the modal must be opened programmatically (e.g., via Alpine.js $dispatch or direct JS).
    /// </summary>
    [Parameter]
    public string EventTriggerName { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets the name of the window event that will trigger this modal to close (e.g., from an HTMX response header).
    /// Defaults to the value defined in <see cref="Constants.Events.ModalClose"/>.
    /// </summary>
    [Parameter]
    public string CloseEventName { get; set; } = Constants.Events.ModalClose;
    /// <summary>
    /// Gets or sets the title text displayed in the modal header. Used if <see cref="TitleContent"/> is null.
    /// </summary>
    [Parameter]
    public string? Title { get; set; }
    /// <summary>
    /// Gets or sets the size variant of the modal dialog, controlling its maximum width.
    /// Defaults to <see cref="ModalSize.Medium"/>.
    /// </summary>
    [Parameter]
    public ModalSize Size { get; set; } = ModalSize.Medium;
    /// <summary>
    /// Gets or sets custom content to be rendered in the modal's title area, overriding the <see cref="Title"/> parameter.
    /// Allows for more complex title structures.
    /// </summary>
    [Parameter]
    public RenderFragment? TitleContent { get; set; }
    /// <summary>
    /// Gets or sets the main content to be displayed within the modal body. Can be targeted by HTMX.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets or sets optional content to be displayed in a distinct footer section. Can be targeted by HTMX.
    /// </summary>
    [Parameter]
    public RenderFragment? FooterContent { get; set; }
    /// <summary>
    /// Gets or sets whether the modal should close when the Escape key is pressed.
    /// Passed to the Alpine component. Defaults to true.
    /// </summary>
    [Parameter]
    public bool CloseOnEscape { get; set; } = true;
    /// <summary>
    /// Gets or sets whether the modal should close when a click occurs on the backdrop outside the dialog.
    /// Passed to the Alpine component. Defaults to true.
    /// </summary>
    [Parameter]
    public bool CloseOnClickOutside { get; set; } = true;
    /// <summary>
    /// Gets or sets whether to display the header section (including title and close button).
    /// Defaults to true.
    /// </summary>
    [Parameter]
    public bool ShowHeader { get; set; } = true;
    /// <summary>
    /// Gets or sets whether to display the default close ('X') button in the header.
    /// Only relevant if ShowHeader is true. Defaults to true.
    /// </summary>
    [Parameter]
    public bool ShowCloseButton { get; set; } = true;
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzModal;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Dialog,
            styles.GetSizeCss(Size)
        );
    }
}
</file>

<file path="Components/Feedback/RzModal/Styling/DefaultRzModalStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzModal component.
/// </summary>
public class DefaultRzModalStyles : RzStylesBase.RzModalStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzModalStyles"/> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzModalStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Backdrop =>
        "z-[10004] fixed inset-0 overflow-y-auto overflow-x-hidden bg-background/75 backdrop-brightness-75 backdrop-blur-xs p-4 lg:p-8";
    /// <inheritdoc />
    public override string Dialog =>
        "mx-auto flex w-full flex-col rounded-theme bg-background shadow-lg border-outline dark:text-foreground";
    /// <inheritdoc />
    public override string Header =>
        "flex items-center justify-between bg-secondary px-5 py-4 dark:bg-secondary rounded-t-theme";
    /// <inheritdoc />
    public override string TitleContainer => "flex flex-grow flex-row items-center";
    /// <inheritdoc />
    public override string Title => "font-medium text-foreground";
    /// <inheritdoc />
    public override string CloseButtonContainer => "-my-4";
    /// <inheritdoc />
    public override string CloseButton =>
         "leading-5 inline-flex items-center justify-center space-x-2 rounded-lg border border-transparent px-3 py-2 text-sm font-semibold text-foreground hover:border-outline hover:text-foreground hover:shadow-sm focus:ring focus:ring-primary/25 active:border-outline active:shadow-none dark:border-transparent dark:text-foreground dark:hover:border-outline dark:hover:text-foreground dark:focus:ring-primary/40 dark:active:border-outline";
    /// <inheritdoc />
    public override string CloseButtonIcon => "size-4 -mx-1 inline-block";
    /// <inheritdoc />
    public override string Body => "p-5";
    /// <inheritdoc />
    public override string Footer => "px-5 py-4 bg-secondary dark:bg-secondary rounded-b-theme border-t border-outline";
    /// <inheritdoc />
    public override string GetSizeCss(ModalSize size)
    {
        return size switch
        {
            ModalSize.ExtraSmall => "max-w-xs",
            ModalSize.Small => "max-w-sm",
            ModalSize.Medium => "max-w-md",
            ModalSize.Large => "max-w-lg",
            ModalSize.ExtraLarge => "max-w-xl",
            ModalSize.TwoXL => "max-w-2xl",
            ModalSize.ThreeXL => "max-w-3xl",
            ModalSize.FourXL => "max-w-4xl",
            ModalSize.FiveXL => "max-w-5xl",
            ModalSize.SixXL => "max-w-6xl",
            ModalSize.SevenXL => "max-w-7xl",
            _ => "max-w-md"
        };
    }
}
</file>

<file path="Components/Feedback/RzSpinner/RzSpinner.razor">
@namespace RizzyUI
@inherits RzComponent

<div @attributes="AdditionalAttributes" id="@Id">
	<svg xmlns="http://www.w3.org/2000/svg"
	     viewBox="0 0 24 24"
	     aria-hidden="true"
	     role="status"
	     aria-label="@AriaLabel"
	     @attributes="AdditionalAttributes"
	     class="@RootClass()">
		<path d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25" />
		<path d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z" />
	</svg>	
</div>
</file>

<file path="Components/Feedback/RzSpinner/RzSpinner.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
/// Renders an SVG spinning animation to indicate loading or processing.
/// Styling (size and color) is determined by parameters and the active <see cref="RzTheme"/>.
/// </xmldoc>
public partial class RzSpinner : RzComponent
{
    /// <summary>
    /// Gets or sets the size of the spinner.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets the semantic color of the spinner.
    /// Defaults to <see cref="SemanticColor.None"/>, which results in the theme's default 'OnSurface' fill color being used.
    /// </summary>
    [Parameter]
    public SemanticColor Color { get; set; } = SemanticColor.None;
    /// <summary>
    /// Gets or sets the accessible label for the spinner, describing what is loading.
    /// Defaults to a localized "Loading...".
    /// </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set default localized value if parameter is not provided
        AriaLabel ??= Localizer["RzSpinner.DefaultAriaLabel"]; // Assuming key exists in resx
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Ensure default is applied if parameter becomes null after initialization
        AriaLabel ??= Localizer["RzSpinner.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzSpinner;
        return TwMerge.Merge(AdditionalAttributes,
            styles.SpinnerBase,          // Includes animation and default fill
            styles.GetSizeCss(Size),     // Applies size class
            styles.GetColorCss(Color)    // Applies fill color override if Color != None
        );
    }
}
</file>

<file path="Components/Feedback/RzSpinner/Styling/DefaultRzSpinnerStyles.cs">
namespace RizzyUI;
/// <summary>
/// Provides the default styles for the RzSpinner component.
/// </summary>
public class DefaultRzSpinnerStyles : RzStylesBase.RzSpinnerStylesBase
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DefaultRzSpinnerStyles"/> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzSpinnerStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string SpinnerBase => "motion-safe:animate-spin fill-foreground"; // Default fill and animation
    /// <inheritdoc />
    public override string GetSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "size-4",
            Size.Small => "size-5",
            Size.Medium => "size-6", // Default size
            Size.Large => "size-7",
            Size.ExtraLarge => "size-8",
            _ => GetSizeCss(Size.Medium) // Fallback to default
        };
    }
    /// <inheritdoc />
    public override string GetColorCss(SemanticColor color)
    {
        // Return fill class based on SemanticColor, defaulting to empty if None
        // The base class already provides fill-foreground
        return color != SemanticColor.None ? ColorUtilExtensions.ToFillClass(color) : "";
    }
}
/// <summary>
/// Supports conversion of SemanticColor to CSS fill class strings.
/// </summary>
public static partial class ColorUtilExtensions
{
    /// <summary>
    /// Converts a SemanticColor to a fill class string.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS fill class.</returns>
    public static string ToFillClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "", // Uses SpinnerBase default (fill-foreground)
            SemanticColor.Surface => "fill-surface",
            SemanticColor.OnSurface => "fill-foreground",
            SemanticColor.OnSurfaceStrong => "fill-foreground",
            SemanticColor.SurfaceAlt => "fill-secondary",
            SemanticColor.Primary => "fill-primary",
            SemanticColor.OnPrimary => "fill-primary-foreground",
            SemanticColor.Secondary => "fill-secondary",
            SemanticColor.OnSecondary => "fill-secondary-foreground",
            SemanticColor.Outline => "fill-outline",
            SemanticColor.OutlineStrong => "fill-outline-strong",
            SemanticColor.Destructive => "fill-destructive",
            SemanticColor.DestructiveForeground => "fill-destructive-foreground",
            SemanticColor.Info => "fill-info",
            SemanticColor.OnInfo => "fill-info-foreground", // Check if onInfo fill exists or adjust
            SemanticColor.Warning => "fill-warning",
            SemanticColor.OnWarning => "fill-warning-foreground",
            SemanticColor.Success => "fill-success",
            SemanticColor.OnSuccess => "fill-success-foreground",
            _ => "" // Fallback to SpinnerBase default
        };
    }
}
</file>

<file path="Components/Form/_Imports.razor">
@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using Rizzy.Configuration;
@using Rizzy.Components
</file>

<file path="Components/Form/Enum/Orientation.cs">
namespace RizzyUI;
/// <summary>
///     Specifies the layout orientation for components or form fields.
///     This enum is used to define whether elements should be arranged horizontally or vertically.
/// </summary>
public enum Orientation
{
	/// <summary>
	///     Indicates that elements should be arranged in a horizontal layout.
	/// </summary>
	Horizontal,
	/// <summary>
	///     Indicates that elements should be arranged in a vertical layout.
	/// </summary>
	Vertical
}
</file>

<file path="Components/Form/Enum/SectionLayout.cs">
namespace RizzyUI;
/// <summary>
///     Layout for section
/// </summary>
public enum SectionLayout
{
    /// <summary>
    ///     Title and description appear in a format stacked on top of form
    /// </summary>
    Stacked,
    /// <summary>
    ///     Title and description appear in a left column with form on right
    /// </summary>
    TwoColumn
}
</file>

<file path="Components/Form/Enum/TextRole.cs">
namespace RizzyUI;
/// <summary>
///     Specifies the semantic role of a text input field within a form. This enumeration determines the behavior and
///     styling
///     applied to text inputs, such as standard text, password, email, URL, search, or telephone inputs.
/// </summary>
public enum TextRole
{
	/// <summary>
	///     Represents a standard text input field.
	/// </summary>
	Text,
	/// <summary>
	///     Represents a password input field, which obscures user input for privacy.
	/// </summary>
	Password,
	/// <summary>
	///     Represents an email input field, optimized for entering email addresses.
	/// </summary>
	Email,
	/// <summary>
	///     Represents a URL input field, optimized for entering web addresses.
	/// </summary>
	Url,
	/// <summary>
	///     Represents a search input field, typically styled for search functionality.
	/// </summary>
	Search,
	/// <summary>
	///     Represents a telephone input field, optimized for entering phone numbers.
	/// </summary>
	Tel
}
</file>

<file path="Components/Form/InputBase.cs">
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <summary>
///     Base class for input components, handling value binding and additional attributes.
/// </summary>
/// <typeparam name="TValue">Type of the bound value.</typeparam>
public class InputBase<TValue> : RzComponent
{
    /// <summary>
    ///     Expression identifying the model property to bind.
    /// </summary>
    [Parameter]
    [EditorRequired]
    public required Expression<Func<TValue>> For { get; set; }
    /// <summary>
    ///     Retrieves a parameter value from additional attributes with type safety.
    /// </summary>
    /// <param name="parameterName">The attribute key.</param>
    /// <param name="defaultValue">Default value if not found or type mismatch.</param>
    /// <returns>
    ///     The attribute value cast to <typeparamref name="TValue" />, or <paramref name="defaultValue" />.
    /// </returns>
    protected TValue GetParameterValue(string parameterName, TValue defaultValue)
    {
        if (AdditionalAttributes is not null &&
            AdditionalAttributes.TryGetValue(parameterName, out var attributeValue) &&
            attributeValue is TValue typedValue)
            return typedValue;
        return defaultValue;
    }
}
</file>

<file path="Components/Form/Models/FlatpickrOptions.cs">
using System.Text.Json.Serialization;
using Jalex.UI.Components.Form.Converters;
namespace RizzyUI;
/// <summary>
///     Specifies the selection mode for the date picker.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum Mode
{
    /// <summary>
    ///     Single date selection mode.
    /// </summary>
    Single,
    /// <summary>
    ///     Multiple date selection mode.
    /// </summary>
    Multiple,
    /// <summary>
    ///     Range selection mode, allowing a start and end date.
    /// </summary>
    Range,
    /// <summary>
    ///     Time-only selection mode, hiding the calendar.
    /// </summary>
    Time
}
/// <summary>
///     Defines how the month selector in the calendar is displayed.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MonthSelectorType
{
    /// <summary>
    ///     Displays the month selector as a dropdown.
    /// </summary>
    Dropdown,
    /// <summary>
    ///     Displays the month selector as a static list.
    /// </summary>
    Static
}
/// <summary>
///     Specifies the positioning strategy for the Flatpickr calendar.
/// </summary>
[JsonConverter(typeof(CalendarPositionConverter))]
public enum CalendarPosition
{
    /// <summary>
    ///     Automatic positioning based on available space.
    /// </summary>
    Auto,
    /// <summary>
    ///     Force the calendar to appear above the input.
    /// </summary>
    Above,
    /// <summary>
    ///     Force the calendar to appear below the input.
    /// </summary>
    Below,
    /// <summary>
    ///     Automatic placement with left alignment.
    /// </summary>
    AutoLeft,
    /// <summary>
    ///     Automatic placement with center alignment.
    /// </summary>
    AutoCenter,
    /// <summary>
    ///     Automatic placement with right alignment.
    /// </summary>
    AutoRight,
    /// <summary>
    ///     Force the calendar above and aligned to the left.
    /// </summary>
    AboveLeft,
    /// <summary>
    ///     Force the calendar above and centered horizontally.
    /// </summary>
    AboveCenter,
    /// <summary>
    ///     Force the calendar above and aligned to the right.
    /// </summary>
    AboveRight,
    /// <summary>
    ///     Force the calendar below and aligned to the left.
    /// </summary>
    BelowLeft,
    /// <summary>
    ///     Force the calendar below and centered horizontally.
    /// </summary>
    BelowCenter,
    /// <summary>
    ///     Force the calendar below and aligned to the right.
    /// </summary>
    BelowRight
}
/// <summary>
///     Represents a date range used to enable or disable selection in the date picker.
/// </summary>
public class CalendarDateRange
{
    /// <summary>
    ///     Gets or sets the starting date for this range.
    /// </summary>
    public DateTime From { get; set; }
    /// <summary>
    ///     Gets or sets the ending date for this range. May be null if only a single date is used.
    /// </summary>
    public DateTime? To { get; set; }
}
/// <summary>
///     Configuration options for Flatpickr date/time picker.
/// </summary>
public class FlatpickrOptions
{
    /// <summary>
    ///     Allows the user to enter a date directly into the input field. By default, direct entry is disabled.
    /// </summary>
    [JsonPropertyName("allowInput")]
    public bool? AllowInput { get; set; }
    /// <summary>
    ///     Allows preloading of an invalid date. Useful when you're using date strings as default values, or if the input
    ///     element is optional.
    /// </summary>
    [JsonPropertyName("allowInvalidPreload")]
    public bool? AllowInvalidPreload { get; set; }
    /// <summary>
    ///     Exactly the same as date format, but for the altInput field.
    /// </summary>
    [JsonPropertyName("altFormat")]
    public string? AltFormat { get; set; }
    /// <summary>
    ///     Show the user a readable date (as per altFormat), but return something totally different to the server.
    /// </summary>
    [JsonPropertyName("altInput")]
    public bool? AltInput { get; set; }
    /// <summary>
    ///     This class will be added to the input element created by the altInput option. Note that altInput already inherits
    ///     classes from the original input.
    /// </summary>
    [JsonPropertyName("altInputClass")]
    public string? AltInputClass { get; set; }
    /// <summary>
    ///     Whether to enable animations, such as month transitions.
    /// </summary>
    [JsonPropertyName("animate")]
    public bool? Animate { get; set; }
    /// <summary>
    ///     Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat.
    ///     Defaults to "F j, Y".
    /// </summary>
    [JsonPropertyName("ariaDateFormat")]
    public string? AriaDateFormat { get; set; }
    /// <summary>
    ///     Whether the default time should be auto-filled when the input is empty and gains or loses focus. Defaults to true.
    /// </summary>
    [JsonPropertyName("autoFillDefaultTime")]
    public bool? AutoFillDefaultTime { get; set; }
    /// <summary>
    ///     Whether clicking on the input should open the picker. Set it to false if you only want to open the calendar
    ///     programmatically.
    /// </summary>
    [JsonPropertyName("clickOpens")]
    public bool? ClickOpens { get; set; }
    /// <summary>
    ///     Whether calendar should close after date selection. By default, the calendar stays open unless the user clicks
    ///     outside of it.
    /// </summary>
    [JsonPropertyName("closeOnSelect")]
    public bool? CloseOnSelect { get; set; }
    /// <summary>
    ///     If "mode" is "multiple", this string will be used to join selected dates together for the date input value.
    /// </summary>
    [JsonPropertyName("conjunction")]
    public string? Conjunction { get; set; }
    /// <summary>
    ///     A string of characters which are used to define how the date will be displayed in the input box.
    /// </summary>
    [JsonPropertyName("dateFormat")]
    public string? DateFormat { get; set; }
    /// <summary>
    ///     The initial selected date(s).
    /// </summary>
    [JsonPropertyName("defaultDate")]
    public string? DefaultDate { get; set; }
    /// <summary>
    ///     Initial value of the hour element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultHour")]
    public int? DefaultHour { get; set; }
    /// <summary>
    ///     Initial value of the minute element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultMinute")]
    public int? DefaultMinute { get; set; }
    /// <summary>
    ///     Initial value of the seconds element, when no date is selected.
    /// </summary>
    [JsonPropertyName("defaultSeconds")]
    public int? DefaultSeconds { get; set; }
    /// <summary>
    ///     Disables certain dates, preventing them from being selected.
    /// </summary>
    [JsonPropertyName("disable")]
    public List<CalendarDateRange>? Disable { get; set; }
    /// <summary>
    ///     Set this to true to always use the non-native picker on mobile devices.
    ///     By default, Flatpickr utilizes native datetime widgets unless certain options (e.g., disable) are used.
    /// </summary>
    [JsonPropertyName("disableMobile")]
    public bool? DisableMobile { get; set; }
    /// <summary>
    ///     Disables all dates except for those specified.
    /// </summary>
    [JsonPropertyName("enable")]
    public List<CalendarDateRange>? Enable { get; set; }
    /// <summary>
    ///     Enables seconds selection in the time picker.
    /// </summary>
    [JsonPropertyName("enableSeconds")]
    public bool? EnableSeconds { get; set; }
    /// <summary>
    ///     Enables the time picker.
    /// </summary>
    [JsonPropertyName("enableTime")]
    public bool? EnableTime { get; set; }
    /// <summary>
    ///     Adjusts the step for the hour input (incl. scrolling).
    /// </summary>
    [JsonPropertyName("hourIncrement")]
    public int? HourIncrement { get; set; }
    /// <summary>
    ///     Displays the calendar inline.
    /// </summary>
    [JsonPropertyName("inline")]
    public bool? Inline { get; set; }
    /// <summary>
    ///     The locale, either as a string (e.g., "ru", "en") or as an object.
    /// </summary>
    [JsonPropertyName("locale")]
    public string? Locale { get; set; }
    /// <summary>
    ///     The maximum date that a user can pick to (inclusive).
    /// </summary>
    [JsonPropertyName("maxDate")]
    public DateTime? MaxDate { get; set; }
    /// <summary>
    ///     The maximum time that a user can pick to (inclusive).
    /// </summary>
    [JsonPropertyName("maxTime")]
    public DateTime? MaxTime { get; set; }
    /// <summary>
    ///     The minimum date that a user can start picking from (inclusive).
    /// </summary>
    [JsonPropertyName("minDate")]
    public DateTime? MinDate { get; set; }
    /// <summary>
    ///     The minimum time that a user can start picking from (inclusive).
    /// </summary>
    [JsonPropertyName("minTime")]
    public DateTime? MinTime { get; set; }
    /// <summary>
    ///     Adjusts the step for the minute input (incl. scrolling). Defaults to 5.
    /// </summary>
    [JsonPropertyName("minuteIncrement")]
    public int? MinuteIncrement { get; set; }
    /// <summary>
    ///     Date selection mode, defaults to "single".
    /// </summary>
    [JsonPropertyName("mode")]
    public Mode? Mode { get; set; }
    /// <summary>
    ///     How the month selector in the calendar should be shown. Can be set to "dropdown" to display a dropdown
    ///     menu for month selection, or "static" to display the months as a static list.
    /// </summary>
    [JsonPropertyName("monthSelectorType")]
    public MonthSelectorType? MonthSelectorType { get; set; }
    /// <summary>
    ///     HTML for the right arrow icon, used to switch months.
    /// </summary>
    [JsonPropertyName("nextArrow")]
    public string? NextArrow { get; set; }
    /// <summary>
    ///     Hides the day selection in the calendar. Use it along with "enableTime" to create a time picker.
    /// </summary>
    [JsonPropertyName("noCalendar")]
    public bool? NoCalendar { get; set; }
    /// <summary>
    ///     How the calendar should be positioned with regards to the input. Can accept multiple positioning options like
    ///     "auto", "above", "below", "auto left", "auto right", etc.
    /// </summary>
    [JsonPropertyName("position")]
    public CalendarPosition? CalendarPosition { get; set; }
    /// <summary>
    ///     HTML for the left arrow icon, used to switch months.
    /// </summary>
    [JsonPropertyName("prevArrow")]
    public string? PrevArrow { get; set; }
    /// <summary>
    ///     Whether to display the current month name in shorthand mode, e.g., "Sep" instead of "September".
    /// </summary>
    [JsonPropertyName("shorthandCurrentMonth")]
    public bool? ShorthandCurrentMonth { get; set; }
    /// <summary>
    ///     Creates a wrapper to position the calendar. Useful if the input is inside a scrollable element or you need the
    ///     calendar to be positioned in a specific way relative to the input.
    /// </summary>
    [JsonPropertyName("static")]
    public bool? Static { get; set; }
    /// <summary>
    ///     Sets the number of months to show in the calendar. Useful for displaying multiple months at once.
    /// </summary>
    [JsonPropertyName("showMonths")]
    public int? ShowMonths { get; set; }
    /// <summary>
    ///     Displays time picker in 24-hour mode without AM/PM selection when enabled.
    /// </summary>
    [JsonPropertyName("time_24hr")]
    public bool? Time24Hr { get; set; }
    /// <summary>
    ///     Display week numbers to the left of the calendar.
    /// </summary>
    [JsonPropertyName("weekNumbers")]
    public bool? WeekNumbers { get; set; }
    /// <summary>
    ///     See https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements. Allows the flatpickr calendar to wrap
    ///     around a custom input and open/close the calendar when this input is focused or clicked.
    /// </summary>
    [JsonPropertyName("wrap")]
    public bool? Wrap { get; set; }
}
</file>

<file path="Components/Form/RzButton/RzButton.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()" aria-label="@EffectiveAssistiveLabel">

    @if (ChildContent != null)
    {
        @ChildContent
    }
    else
    {
        @Label
    }
</HtmlElement>
</file>

<file path="Components/Form/RzButton/RzButton.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <summary>
/// Represents a clickable button with customizable styling, variant, and size. Styling is handled by the active theme.
/// </summary>
public partial class RzButton : RzComponent
{
    /// <summary>
    /// Gets or sets the parent <see cref="RzButtonGroup"/> this component belongs to, if any.
    /// This is provided via a cascading parameter.
    /// </summary>
    [CascadingParameter]
    public RzButtonGroup? Group { get; set; }
    /// <summary>
    /// Gets or sets the accessible label for the button, used for screen readers.
    /// If not provided, it defaults to a localized value obtained from <see cref="RzComponent.Localizer"/>
    /// using the key "RzButton.AssistiveLabelDefault".
    /// </summary>
    [Parameter]
    public string? AssistiveLabel { get; set; }
    /// <summary>
    /// Gets or sets the visual style variant of the button (e.g., Primary, Secondary).
    /// Defaults to <see cref="ButtonVariant.Primary"/>.
    /// </summary>
    [Parameter]
    public ButtonVariant Variant { get; set; } = ButtonVariant.Primary;
    /// <summary>
    /// Gets or sets the size of the button.
    /// Defaults to <see cref="Size.Medium"/>.
    /// </summary>
    [Parameter]
    public Size Size { get; set; } = Size.Medium;
    /// <summary>
    /// Gets or sets a value indicating whether the button should have an outline style
    /// instead of a solid background. Defaults to false.
    /// </summary>
    [Parameter]
    public bool Outline { get; set; }
    /// <summary>
    /// Gets or sets the text label displayed on the button. This is used only if
    /// the <see cref="ChildContent"/> parameter is not provided. Defaults to an empty string.
    /// </summary>
    [Parameter]
    public string Label { get; set; } = string.Empty;
    /// <summary>
    /// Gets or sets a value indicating whether to enable the button's click animation
    /// (e.g., scaling effect on press). Defaults to true.
    /// </summary>
    [Parameter]
    public bool Animate { get; set; } = true;
    /// <summary>
    /// Gets or sets the optional content to be rendered inside the button element.
    /// If provided, this overrides the <see cref="Label"/> property.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Gets the effective assistive label to be used for the `aria-label` attribute.
    /// It returns the value of the <see cref="AssistiveLabel"/> parameter if provided,
    /// otherwise it falls back to the localized default string identified by the key "RzButton.AssistiveLabelDefault".
    /// </summary>
    protected string EffectiveAssistiveLabel => AssistiveLabel ?? Localizer["RzButton.AssistiveLabelDefault"];
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set the root HTML element for this component to 'button'.
        if (string.IsNullOrEmpty(Element))
            Element = "button";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzButton;
        var groupStyles = Theme.RzButtonGroup;
        string groupSpecificClass = string.Empty;
        // Determine if this button is part of a group and apply specific styles
        if (Group != null)
        {
            var index = Group.Buttons.IndexOf(this);
            if (index == 0) // First button in the group
                groupSpecificClass = groupStyles.GroupFirst;
            else if (index == Group.Buttons.Count - 1) // Last button in the group
                groupSpecificClass = groupStyles.GroupLast;
            else // Middle button in the group
                groupSpecificClass = groupStyles.GroupMiddle;
        }
        // Merge all applicable CSS classes using Tailwind Merge
        return TwMerge.Merge(AdditionalAttributes, // Start with user-provided classes
            styles.Button,                        // Base button styles
            Outline ? styles.GetVariantOutlineCss(Variant) : styles.GetVariantCss(Variant), // Apply variant (solid or outline)
            Animate ? styles.Animated : "",       // Apply animation class if enabled
            styles.GetSizeCss(Size),              // Apply size class
            groupSpecificClass);                  // Apply group-specific class if applicable
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Register this button with its parent group, if it exists.
        Group?.AddButton(this);
    }
}
</file>

<file path="Components/Form/RzButton/RzButtonGroup.razor">
@namespace RizzyUI
@inherits RzComponent


<CascadingValue Value="this" IsFixed="true">
	<div @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
		@ChildContent
	</div>
</CascadingValue>
</file>

<file path="Components/Form/RzButton/RzButtonGroup.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a group of <see cref="RzButton" /> components displayed together,
///     often with adjusted styling for adjacent borders and corners.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzButtonGroup : RzComponent
{
    /// <summary> Internal list that holds the buttons added to the group. </summary>
    private readonly List<RzButton> _buttons = new();
    /// <summary> Gets the read-only list of buttons contained in this button group. </summary>
    public List<RzButton> Buttons => _buttons;
    /// <summary>
    ///     The child content to be rendered inside the button group. Typically includes <see cref="RzButton" />
    ///     components.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzButtonGroup.Container);
    }
    /// <summary>
    ///     Adds an <see cref="RzButton" /> to the button group if it is not already present.
    ///     Called internally by child buttons.
    /// </summary>
    /// <param name="button">The <see cref="RzButton" /> instance to add to the group.</param>
    internal void AddButton(RzButton button)
    {
        if (!_buttons.Contains(button)) _buttons.Add(button);
        // No need to call StateHasChanged here as the button rendering itself will handle its classes based on index
    }
}
</file>

<file path="Components/Form/RzButton/Styling/DefaultRzButtonGroupStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzButtonGroup component.
/// </summary>
public class DefaultRzButtonGroupStyles : RzStylesBase.RzButtonGroupStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzButtonGroupStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzButtonGroupStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "inline-flex";
    /// <inheritdoc />
    public override string GroupFirst => "rounded-none rounded-l-borderRadius"; // Use theme token
    /// <inheritdoc />
    public override string GroupLast => "rounded-none rounded-r-borderRadius border-l-0"; // Use theme token
    /// <inheritdoc />
    public override string GroupMiddle => "rounded-none border-l-0";
}
</file>

<file path="Components/Form/RzButton/Styling/DefaultRzButtonStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzButton component.
/// </summary>
public class DefaultRzButtonStyles : RzStylesBase.RzButtonStylesBase
{
    /// <inheritdoc />
    public DefaultRzButtonStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Button =>
        "inline-flex items-center justify-center gap-2 cursor-pointer whitespace-nowrap rounded-theme font-medium tracking-wide text-center transition hover:opacity-75 active:opacity-100 hover:shadow-sm disabled:opacity-75 disabled:cursor-not-allowed";
    /// <inheritdoc />
    public override string Animated => "transform active:scale-90 motion-reduce:transition-none transition-transform";
    /// <inheritdoc />
    public override string GetVariantCss(ButtonVariant variant)
    {
        return variant switch
        {
            ButtonVariant.Primary =>
                "bg-primary text-primary-foreground focus-visible:outline-primary dark:focus-visible:outline-primary",
            ButtonVariant.Secondary =>
                "bg-secondary text-secondary-foreground focus-visible:outline-secondary dark:focus-visible:outline-secondary",
            ButtonVariant.Alternate =>
                "bg-secondary text-foreground focus-visible:outline-secondary dark:focus-visible:outline-secondary",
            ButtonVariant.Inverse =>
                "bg-background text-foreground focus-visible:outline-surface dark:bg-background dark:text-foreground dark:focus-visible:outline-surface", // Corrected Inverse
            ButtonVariant.Information =>
                "bg-info text-info-foreground focus-visible:outline-info dark:bg-info dark:text-info-foreground dark:focus-visible:outline-info",
            ButtonVariant.Destructive =>
                "bg-destructive text-destructive-foreground focus-visible:outline-destructive dark:bg-destructive dark:text-destructive-foreground dark:focus-visible:outline-destructive",
            ButtonVariant.Warning =>
                "bg-warning text-warning-foreground focus-visible:outline-warning dark:bg-warning dark:text-warning-foreground dark:focus-visible:outline-warning",
            ButtonVariant.Success =>
                "bg-success text-success-foreground focus-visible:outline-success dark:bg-success dark:text-success-foreground dark:focus-visible:outline-success",
            ButtonVariant.Ghost => "bg-transparent text-foreground focus-visible:outline-none",
            _ => GetVariantCss(ButtonVariant.Primary) // Default
        };
    }
    /// <inheritdoc />
    public override string GetVariantOutlineCss(ButtonVariant variant)
    {
        return variant switch
        {
            ButtonVariant.Primary =>
                "bg-transparent border border-primary text-primary focus-visible:outline-primary dark:focus-visible:outline-primary",
            ButtonVariant.Secondary =>
                "bg-transparent border border-secondary text-secondary focus-visible:outline-secondary dark:focus-visible:outline-secondary",
            ButtonVariant.Alternate =>
                "bg-transparent border border-outline text-outline focus-visible:outline-outline dark:focus-visible:outline-outline",
            ButtonVariant.Inverse =>
                "bg-transparent border border-foreground text-foreground focus-visible:outline-foreground dark:focus-visible:outline-foreground",
            ButtonVariant.Information =>
                "bg-transparent border border-info text-info focus-visible:outline-info dark:border-info dark:text-info dark:focus-visible:outline-info",
            ButtonVariant.Destructive =>
                "bg-transparent border border-destructive text-destructive focus-visible:outline-destructive dark:border-destructive dark:text-destructive dark:focus-visible:outline-destructive",
            ButtonVariant.Warning =>
                "bg-transparent border border-warning text-warning focus-visible:outline-warning dark:border-warning dark:text-warning dark:focus-visible:outline-warning",
            ButtonVariant.Success =>
                "bg-transparent border border-success text-success focus-visible:outline-success dark:border-success dark:text-success dark:focus-visible:outline-success",
            ButtonVariant.Ghost => "bg-transparent border text-foreground hover:opacity-75 focus-visible:outline-none",
            _ => GetVariantOutlineCss(ButtonVariant.Primary) // Default
        };
    }
    /// <inheritdoc />
    public override string GetSizeCss(Size size)
    {
        return size switch
        {
            Size.ExtraSmall => "px-2 py-1 text-sm",
            Size.Small => "px-3 py-2 text-sm",
            Size.Medium => "px-4 py-2 text-md", // Assuming text-md exists or adjust as needed
            Size.Large => "px-6 py-3 text-md",
            Size.ExtraLarge => "px-8 py-4 text-md",
            _ => GetSizeCss(Size.Medium)
        };
    }
}
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroup.razor">
@namespace RizzyUI
@typeparam TValue
@inherits RzComponent

<CascadingValue Value="this" IsFixed="true">
	<HtmlElement Element="div" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
		@ChildContent
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroup.razor.cs">
using System.Linq.Expressions;
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a group of checkbox items (<see cref="RzCheckboxGroupItem{TValue}" />) that support multiple selection.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCheckboxGroup<TValue> : RzComponent
{
    /// <summary> Gets or sets the selected values in the checkbox group. </summary>
    [Parameter]
    public IList<TValue> Values { get; set; } = new List<TValue>();
    /// <summary> Gets or sets the event callback when the selected values change. </summary>
    [Parameter]
    public EventCallback<IList<TValue>> ValuesChanged { get; set; }
    /// <summary> Gets or sets the expression for the bound value, used for validation. </summary>
    [Parameter]
    public Expression<Func<IList<TValue>>>? For { get; set; }
    /// <summary> Gets or sets the orientation of the checkbox group (Vertical or Horizontal). Defaults to Vertical. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary> Gets or sets the child content, expected to be <see cref="RzCheckboxGroupItem{TValue}" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Gets or sets the custom Blazicon SVG icon to display when a checkbox is checked. Defaults to
    ///     MdiIcon.CheckBold.
    /// </summary>
    [Parameter]
    public SvgIcon CheckedIcon { get; set; } = MdiIcon.CheckBold;
    /// <summary> Determines whether the specified value is currently selected in the group. </summary>
    /// <param name="value">The value to check.</param>
    /// <returns>True if the value is selected; otherwise, false.</returns>
    public bool IsSelected(TValue value)
    {
        return Values.Any(x => EqualityComparer<TValue>.Default.Equals(x, value));
    }
    /// <summary> Toggles the selection state of the specified value within the group. </summary>
    /// <param name="value">The value to toggle.</param>
    /// <param name="isChecked">The desired state (true to select, false to deselect).</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public async Task ToggleValueAsync(TValue value, bool isChecked)
    {
        var changed = false;
        if (isChecked)
        {
            if (!Values.Any(x => EqualityComparer<TValue>.Default.Equals(x, value)))
            {
                Values.Add(value);
                changed = true;
            }
        }
        else
        {
            var existing = Values.FirstOrDefault(x => EqualityComparer<TValue>.Default.Equals(x, value));
            // Ensure existing is not null before checking Contains and removing
            if (existing != null && Values.Contains(existing))
            {
                var removed = Values.Remove(existing);
                if (removed) changed = true;
            }
        }
        if (changed && ValuesChanged.HasDelegate) await ValuesChanged.InvokeAsync(Values);
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzCheckboxGroup;
        return TwMerge.Merge(AdditionalAttributes, styles.Container, styles.GetOrientationCss(Orientation));
    }
}
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroupField.razor">
@namespace RizzyUI
@typeparam TValue
@using Rizzy
@inherits RzComponent

<RzField @attributes="AdditionalAttributes" Id="@Id" class="@RootClass()">
	<RzFieldLabel DisplayName="@DisplayName" For="@For"/>
	@if (FieldHelp != null)
	{
		<RzFieldHelp>@FieldHelp</RzFieldHelp>
	}
	<RzCheckboxGroup TValue="TValue" For="@For" @Values="CurrentValues" Orientation="@Orientation"
	                 class="@Theme.RzCheckboxGroupField.GroupWithinField">
		@CheckboxGroupContent
	</RzCheckboxGroup>
	<RzValidationMessage For="@For"/>
</RzField>
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroupField.razor.cs">
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a form field component that wraps a group of checkbox items (<see cref="RzCheckboxGroup{TValue}" />)
///     with a label, help text, and validation message integration. It leverages the <see cref="RzField" /> component for
///     base structure.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCheckboxGroupField<TValue> : RzComponent
{
    private IList<TValue> _currentValues = new List<TValue>();
    private FieldIdentifier _fieldIdentifier;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the display name for the field label. If not set, it's inferred from the `For` expression. </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <summary> Specifies the field the checkbox group is bound to. Required. </summary>
    [Parameter]
    [EditorRequired]
    public Expression<Func<IList<TValue>>>? For { get; set; }
    /// <summary> Gets or sets the list of selected values in the checkbox group. </summary>
    [Parameter]
    public IList<TValue>? Values { get; set; }
    /// <summary> Event callback invoked when the selected values change. </summary>
    [Parameter]
    public EventCallback<IList<TValue>> ValuesChanged { get; set; }
    /// <summary> Gets or sets the orientation of the checkbox group (Vertical or Horizontal). Defaults to Vertical. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary> Child content containing the <see cref="RzCheckboxGroupItem{TValue}" /> components. </summary>
    [Parameter]
    public RenderFragment? CheckboxGroupContent { get; set; }
    /// <summary> Optional content displayed below the group to provide help or context. </summary>
    [Parameter]
    public RenderFragment? FieldHelp { get; set; }
    /// <summary> Internal property to bind the RzCheckboxGroup's Values. </summary>
    protected IList<TValue> CurrentValues
    {
        get => _currentValues;
        set
        {
            if (!EqualityComparer<IList<TValue>>.Default.Equals(_currentValues, value))
            {
                _currentValues = value;
                // Notify EditContext about the change
                EditContext?.NotifyFieldChanged(_fieldIdentifier);
                // Invoke the ValuesChanged callback
                InvokeAsync(() => ValuesChanged.InvokeAsync(_currentValues));
            }
        }
    }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        // Initialize CurrentValues from the parameter or the model
        _currentValues = Values ??
                         _fieldIdentifier.Model.GetType()?.GetProperty(_fieldIdentifier.FieldName)
                             ?.GetValue(_fieldIdentifier.Model) as IList<TValue> ?? new List<TValue>();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // If the Values parameter changes externally, update internal state
        if (Values != null && !ReferenceEquals(Values, _currentValues) && !Values.SequenceEqual(_currentValues))
            _currentValues = new List<TValue>(Values); // Create a copy to avoid mutation issues if needed
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes);
    }
}
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroupItem.razor">
@namespace RizzyUI
@typeparam TValue
@using Blazicons
@using Rizzy
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id">
	<div x-data="rzCheckboxGroupItem" data-alpine-root="@Id" class="@Theme.RzCheckboxGroupItem.Label">
		<div class="@Theme.RzCheckboxGroupItem.CheckboxWrapper">
			<RzInputCheckbox @bind-Value="IsChecked" class="@Theme.RzCheckboxGroupItem.CheckboxInput" x-on:change="toggleCheckbox" x-ref="chk"/>
			<div class="@Theme.RzCheckboxGroupItem.IconContainer" :class="getIconCss">
				<Blazicon Svg="EffectiveCheckedIcon"/>
			</div>
		</div>
		<span class="@Theme.RzCheckboxGroupItem.TitleSpan">@Title</span>
		@ChildContent
	</div>
</HtmlElement>
</file>

<file path="Components/Form/RzCheckbox/RzCheckboxGroupItem.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a single checkbox item within a <see cref="RzCheckboxGroup{TValue}" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCheckboxGroupItem<TValue> : RzComponent
{
    /// <summary> Gets the parent checkbox group context. </summary>
    [CascadingParameter]
    public RzCheckboxGroup<TValue>? Parent { get; set; }
    /// <summary> Gets or sets the value associated with this checkbox item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public TValue? Value { get; set; }
    /// <summary> Gets or sets the display title for this checkbox item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Title { get; set; } = string.Empty;
    /// <summary> Gets or sets optional child content displayed alongside the title. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets the custom Blazicon SVG icon to display when checked. Overrides the parent group's icon if set. </summary>
    [Parameter]
    public SvgIcon? CheckedIcon { get; set; }
    /// <summary> The actual icon to use, considering the parameter and the parent group's setting. </summary>
    protected SvgIcon EffectiveCheckedIcon { get; private set; } = default!;
    /// <summary> Gets or sets the checked state, bound to the parent group's selection. </summary>
    private bool IsChecked
    {
        get => Parent != null && Parent.IsSelected(Value!);
        set
        {
            if (Parent != null)
                // Invoke the parent's toggle method asynchronously
                InvokeAsync(() => Parent.ToggleValueAsync(Value!, value));
        }
    }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Parent == null)
            throw new InvalidOperationException($"{GetType()} must be placed within an RzCheckboxGroup.");
        if (string.IsNullOrEmpty(Element))
            Element = "label";
        SetEffectiveIcon();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Update icon if parameter changes
        if (Theme != null) // Ensure theme is set before accessing Parent
            SetEffectiveIcon();
    }
    private void SetEffectiveIcon()
    {
        EffectiveCheckedIcon = CheckedIcon ?? Parent?.CheckedIcon ?? MdiIcon.CheckBold; // Fallback chain
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzCheckboxGroupItem.Label);
    }
    /// <summary> Gets the CSS class for icon visibility based on the checked state. </summary>
    /// <param name="isChecked">Current checked state.</param>
    /// <returns>CSS class string.</returns>
    protected string GetIconVisibilityCss(bool isChecked)
    {
        return Theme.RzCheckboxGroupItem.GetIconVisibilityCss(isChecked);
    }
}
</file>

<file path="Components/Form/RzCheckbox/Styling/DefaultRzCheckboxStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzCheckboxGroup. </summary>
public class DefaultRzCheckboxGroupStyles : RzStylesBase.RzCheckboxGroupStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCheckboxGroupStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCheckboxGroupStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "flex flex-wrap gap-4"; // Base container
    /// <inheritdoc />
    public override string GetOrientationCss(Orientation orientation)
    {
        return orientation switch
        {
            Orientation.Horizontal => "flex-row items-center", // Keep gap-4 from Container
            Orientation.Vertical => "flex-col", // Keep gap-4 from Container, but vertical
            _ => GetOrientationCss(Orientation.Vertical)
        };
    }
}
/// <summary> Provides default styles for RzCheckboxGroupItem. </summary>
public class DefaultRzCheckboxGroupItemStyles : RzStylesBase.RzCheckboxGroupItemStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCheckboxGroupItemStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCheckboxGroupItemStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Label => "inline-flex items-center cursor-pointer"; // Added cursor-pointer
    /// <inheritdoc />
    public override string CheckboxWrapper => "relative";
    /// <inheritdoc />
    // Note: text-primary-500 is hardcoded here, ideally map to theme.Primary or similar if needed for specific check color
    public override string CheckboxInput =>
        "size-4 rounded-theme-sm border border-outline text-primary-500 focus:border-primary-500 focus:ring-3 focus:ring-primary/50 dark:bg-secondary dark:ring-offset-surface dark:checked:border-transparent dark:checked:bg-primary dark:focus:border-primary";
    /// <inheritdoc />
    public override string IconContainer =>
        "absolute inset-0 flex items-center justify-center text-primary-foreground"; // Text color for icon on checked bg
    /// <inheritdoc />
    public override string TitleSpan => "ml-2";
    /// <inheritdoc />
    public override string GetIconVisibilityCss(bool isChecked)
    {
        return isChecked ? "" : "hidden";
    }
}
/// <summary> Provides default styles for RzCheckboxGroupField. </summary>
public class DefaultRzCheckboxGroupFieldStyles : RzStylesBase.RzCheckboxGroupFieldStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCheckboxGroupFieldStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCheckboxGroupFieldStyles(RzTheme theme) : base(theme)
    {
    }
    // This field usually relies on the RzField component for its structure.
    /// <inheritdoc />
    public override string Field => ""; // Handled by RzFieldStylesBase
    /// <inheritdoc />
    public override string GroupWithinField => "my-3"; // Default margin for the group inside the field
}
</file>

<file path="Components/Form/RzDateEdit/RzDateEdit.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="div"
             @attributes="AdditionalAttributes"
             id="@Id"
             class="@Theme.RzDateEdit.Container"
             role="group" aria-label="Date picker">
	
	<div x-data="rzDateEdit"
	     data-alpine-root="@Id"
	     data-config="@_serializedConfig"
	     data-uid="@_uid"
	     data-assets="@_assets"
	     data-nonce="@Nonce">

		<div class="@Theme.RzDateEdit.InputWrapper" x-data="rzPrependInput" x-ref="pickerWrapper">
			@if (!string.IsNullOrEmpty(PrependText) || PrependIcon != null)
			{
				<div x-ref="prependContainer" class="@Theme.RzDateEdit.PrependElement">
					@if (!string.IsNullOrEmpty(PrependText))
					{
						@PrependText
					}
					else if (PrependIcon != null)
					{
						<div class="@Theme.RzDateEdit.PrependIconContainer">
							<Blazicon Svg="PrependIcon"/>
						</div>
					}
				</div>
			}

			<input x-ref="textInput"
			       id="@_uidInputId"
			       type="text"
			       @bind="CurrentValue"
			       placeholder="@Placeholder"
			       class="@Theme.RzDateEdit.Input"
			       data-input
			       aria-label="Select date"/>
		</div>
	</div>	
</HtmlElement>
</file>

<file path="Components/Form/RzDateEdit/RzDateEdit.razor.cs">
using System.Globalization;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Rizzy.Utility;
using RizzyUI.Extensions;
// For EditContext, FieldIdentifier
namespace RizzyUI;
/// <xmldoc>
///     A date input component enhanced with the Flatpickr JavaScript library for a calendar popup.
///     Supports binding to nullable DateTime and configuration via <see cref="FlatpickrOptions" />.
///     Styling is determined by the active <see cref="RzTheme" />. Should be used within an EditForm.
/// </xmldoc>
public sealed partial class RzDateEdit : RzComponent
{
    private static readonly string[] DefaultAssets =
    [
        // Flatpickr JS - CSS is often included via CDN link or build process
        "https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.js"
    ];
    private readonly string _uid = IdGenerator.UniqueId("rzdate");
    private string _assets = "[]";
    private DateTime? _currentValue;
    private FieldIdentifier _fieldIdentifier;
    private string _inputValue = string.Empty; // Value for the input element itself
    private string _serializedConfig = "{}";
    // Theme is inherited from RzComponent
    [CascadingParameter] private EditContext? EditContext { get; set; }
    /// <summary> Gets the unique ID for the input element. </summary>
    private string _uidInputId => $"{_uid}-input";
    /// <summary> Gets or sets the expression identifying the DateTime? field to bind to. Required. </summary>
    [Parameter] [EditorRequired] public Expression<Func<DateTime?>>? For { get; set; }
    /// <summary> Gets or sets the Flatpickr configuration options. </summary>
    [Parameter] public FlatpickrOptions Options { get; set; } = new() { Locale = "en" }; // Ensure default locale
    /// <summary> Gets or sets the placeholder text for the date input. </summary>
    [Parameter] public string Placeholder { get; set; } = string.Empty;
    /// <summary> Gets or sets optional text to prepend inside the input's visual container. </summary>
    [Parameter] public string? PrependText { get; set; }
    /// <summary> Gets or sets an optional Blazicon SVG icon to prepend inside the input's visual container. </summary>
    [Parameter] public SvgIcon? PrependIcon { get; set; }
    /// <summary> Optional array of asset URLs (JS/CSS) for Flatpickr. Defaults to Flatpickr CDN JS. </summary>
    [Parameter] public string[] ComponentAssets { get; set; } = DefaultAssets;
    /// <summary> Internal property for binding the input value. </summary>
    private string CurrentValue
    {
        get => _inputValue;
        set
        {
            // This setter might be called by Flatpickr changing the input value.
            // We need to parse it back to DateTime? and update the model.
            if (_inputValue == value) return;
            _inputValue = value;
            if (DateTime.TryParseExact(value, GetFlatpickrFormat(), CultureInfo.InvariantCulture, DateTimeStyles.None,
                    out var parsedDate))
                UpdateValue(parsedDate);
            else if (string.IsNullOrEmpty(value)) UpdateValue(null); // Handle clearing the input
            // If parsing fails, we might want to keep _currentValue as is, or set to null,
            // depending on desired behavior for invalid manual input.
            // For now, we only update if parsing succeeds or input is cleared.
        }
    }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized(); // Initializes Theme
        if (For == null) throw new InvalidOperationException($"{GetType()} requires a 'For' parameter.");
        if (EditContext == null) throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        _currentValue = For.Compile().Invoke(); // Get initial value from model
        FormatInputValue(); // Format initial value for display
        SerializeConfigAndAssets(); // Prepare data for Alpine
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // If the bound value changes externally, update our internal state
        var modelValue = For?.Compile().Invoke();
        if (_currentValue != modelValue)
        {
            _currentValue = modelValue;
            FormatInputValue(); // Reformat display value
            // Reserializing might be needed if Options changed, but can be costly.
            // Consider if Options are likely to change dynamically. If not, only do this in OnInitialized.
            // SerializeConfigAndAssets();
        }
        // Re-serialize if options or assets change
        SerializeConfigAndAssets();
    }
    private void UpdateValue(DateTime? newValue)
    {
        var valueChanged = _currentValue != newValue;
        _currentValue = newValue;
        if (valueChanged) EditContext?.NotifyFieldChanged(_fieldIdentifier);
        // Note: We don't invoke a ValueChanged event here as binding is handled by RzInput* components usually.
        // If direct binding support without RzInput* is needed, add [Parameter] Value/ValueChanged.
    }
    private void FormatInputValue()
    {
        // Format the DateTime? value into the string format expected by Flatpickr/the input
        if (_currentValue.HasValue)
            _inputValue = _currentValue.Value.ToString(GetFlatpickrFormat(), CultureInfo.InvariantCulture);
        else
            _inputValue = string.Empty;
    }
    private string GetFlatpickrFormat()
    {
        // Determine the format string based on Flatpickr options
        // This needs to match how Flatpickr parses/formats dates.
        // Defaulting to ISO 8601 date format. Adjust if Options.DateFormat is different.
        return Options.DateFormat ?? "Y-m-d";
    }
    private void SerializeConfigAndAssets()
    {
        // Store default date based on current value if not explicitly set in Options
        if (string.IsNullOrEmpty(Options.DefaultDate) && _currentValue.HasValue)
            // Use a format Flatpickr understands by default
            Options.DefaultDate = _currentValue.Value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
        // Prepare data object for Alpine
        var alpineData = new
            { options = Options, placeholder = Placeholder, prependText = PrependText ?? string.Empty };
        _serializedConfig = JsonSerializer.Serialize(alpineData,
            new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull });
        _assets = JsonSerializer.Serialize(ComponentAssets);
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzDateEdit.Container);
    }
}
</file>

<file path="Components/Form/RzDateEdit/Styling/DefaultRzDateEditStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzDateEdit. </summary>
public class DefaultRzDateEditStyles : RzStylesBase.RzDateEditStylesBase
{
	/// <inheritdoc />
	public DefaultRzDateEditStyles(RzTheme theme) : base(theme)
    {
    }
	/// <inheritdoc />
	public override string Container => "w-full";
	/// <inheritdoc />
	public override string InputWrapper => "relative";
	/// <inheritdoc />
	public override string PrependElement =>
        "pointer-events-none absolute inset-y-0 left-0 my-px ml-px flex items-center rounded-l-theme border-r border-outline bg-secondary px-3 text-foreground dark:border-outline dark:bg-secondary dark:text-foreground"; // Use semantic names
	/// <inheritdoc />
	public override string PrependIconContainer => "text-xl";
	/// <inheritdoc />
	public override string Input =>
        "block w-full rounded-theme border border-outline px-3 py-2 leading-6 placeholder-muted-foreground focus:border-primary focus:ring focus:ring-primary/50 dark:border-outline dark:bg-secondary dark:placeholder-muted-foreground dark:focus:border-primary flatpickr-input"; // Use semantic names, adjusted focus ring
}
</file>

<file path="Components/Form/RzField/RzField.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Form/RzField/RzField.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container component for form fields, typically grouping a label, input, help text, and validation message.
///     Provides consistent spacing. Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzField : RzComponent
{
    /// <summary> The content to be rendered inside the field container (label, input, etc.). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzField.Field);
    }
}
</file>

<file path="Components/Form/RzField/RzFieldHelp.razor">
@namespace RizzyUI
@inherits RzComponent

<p @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</p>
</file>

<file path="Components/Form/RzField/RzFieldHelp.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a paragraph (<c>p</c>) element typically used to provide help text or descriptions
///     for a form field within an <see cref="RzField" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzFieldHelp : RzComponent
{
    /// <summary> The help text or other content to be rendered. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzFieldHelp.HelpText);
    }
}
</file>

<file path="Components/Form/RzField/RzFieldLabel.razor">
@namespace RizzyUI
@inherits RzComponent
@typeparam TValue


@if (!string.IsNullOrEmpty(_effectiveDisplayName))
{
    <label for="@_for" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
        @_effectiveDisplayName
        @ChildContent
    </label>
}
else
{
    @ChildContent
}
</file>

<file path="Components/Form/RzField/RzFieldLabel.razor.cs">
using System.ComponentModel.DataAnnotations;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.AspNetCore.Http;
using Rizzy.Htmx;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a <c>label</c> element typically associated with a form input within an <see cref="RzField" />.
///     Automatically determines the 'for' attribute and infers the display name from the bound field if not explicitly
///     set.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
[CascadingTypeParameter(nameof(TValue))] // Hint for type inference if used generically
public partial class RzFieldLabel<TValue> : RzComponent
{
    private string? _effectiveDisplayName; // Store the calculated display name
    private string _for = string.Empty;
    [CascadingParameter] private HttpContext? HttpContext { get; set; }
    [CascadingParameter] private EditContext? EditContext { get; set; }
    /// <summary> Optional child content, often used for required indicators or icons. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Specifies the field the label is associated with. Used to determine the 'for' attribute and infer
    ///     DisplayName.
    /// </summary>
    [Parameter]
    public Expression<Func<TValue>>? For { get; set; }
    /// <summary>
    ///     Explicitly sets the text content of the label. If not set, it's inferred from the 'For' expression's display
    ///     attributes or member name.
    /// </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        if (EditContext is null) return; // Should have been caught in OnInitialized, but defensive check
        SetEffectiveDisplayName(); // Calculate display name
        SetForAttribute(); // Calculate 'for' attribute
        base.OnParametersSet();
    }
    private void SetEffectiveDisplayName()
    {
        // If DisplayName is explicitly set, use it.
        if (!string.IsNullOrEmpty(DisplayName))
        {
            _effectiveDisplayName = DisplayName;
            return;
        }
        // If For is not provided, we can't infer, leave it null/empty.
        if (For == null)
        {
            _effectiveDisplayName = null;
            return;
        }
        // Try to infer from DisplayAttribute or member name
        if (For.Body is MemberExpression memberExpression)
        {
            var displayAttribute = memberExpression.Member.GetCustomAttribute<DisplayAttribute>(true);
            _effectiveDisplayName =
                displayAttribute?.GetName() ?? memberExpression.Member.Name; // GetName handles resources
        }
        else
        {
            // Fallback if For is not a simple MemberExpression (less likely for labels)
            _effectiveDisplayName = For.ToString(); // Or some other default
        }
    }
    private void SetForAttribute()
    {
        _for = string.Empty; // Reset
        if (For != null && HttpContext != null && EditContext != null)
            try
            {
                var field = FieldIdentifier.Create(For);
                var fieldMap = HttpContext.GetOrAddFieldMapping(EditContext); // Use extension method
                if (fieldMap != null && fieldMap.TryGetValue(field, out var map) && map != null)
                    _for = map.Id;
            }
            catch (ArgumentException)
            {
                // Handle cases where For expression is not suitable for FieldIdentifier (e.g., complex expressions)
                // In this case, _for remains empty, and the label won't have a 'for' attribute.
            }
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzFieldLabel.Label);
    }
}
</file>

<file path="Components/Form/RzField/Styling/DefaultRzFieldStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzField. </summary>
public class DefaultRzFieldStyles : RzStylesBase.RzFieldStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzFieldStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzFieldStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Field => "space-y-1";
}
/// <summary> Provides default styles for RzFieldLabel. </summary>
public class DefaultRzFieldLabelStyles : RzStylesBase.RzFieldLabelStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzFieldLabelStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzFieldLabelStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Label => "font-medium";
    /// <inheritdoc />
    public override string RequiredIndicator =>
        "text-sm text-destructive dark:text-destructive"; // Assuming Destructive has dark variant or is same
}
/// <summary> Provides default styles for RzFieldHelp. </summary>
public class DefaultRzFieldHelpStyles : RzStylesBase.RzFieldHelpStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzFieldHelpStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzFieldHelpStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string HelpText => "text-sm text-foreground";
}
</file>

<file path="Components/Form/RzFormSection/RzFormSection.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" class="@RootClass()" @attributes="AdditionalAttributes" id="@Id">
	<div class="@Theme.RzFormSection.GetDescriptionLayoutCss(Layout)">
		@if (!string.IsNullOrEmpty(Title))
		{
			<h2 class="@Theme.RzFormSection.Title">@Title</h2>
		}
		@if (Description != null)
		{
			<p class="@Theme.RzFormSection.Description">
				@Description
			</p>
		}
	</div>
	<div class="@Theme.RzFormSection.GetContentLayoutCss(Layout)">
		@Content
	</div>
</HtmlElement>
</file>

<file path="Components/Form/RzFormSection/RzFormSection.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Organizes form content into sections with an optional title and description, supporting different layouts.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzFormSection : RzComponent
{
    /// <summary> The title of the form section. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Title { get; set; } = string.Empty;
    /// <summary> Optional descriptive content for the section. </summary>
    [Parameter]
    public RenderFragment? Description { get; set; }
    /// <summary> The main content of the form section (e.g., input fields). </summary>
    [Parameter]
    public RenderFragment? Content { get; set; }
    /// <summary> The layout style for the section (Stacked or TwoColumn). Defaults to TwoColumn. </summary>
    [Parameter]
    public SectionLayout Layout { get; set; } = SectionLayout.TwoColumn;
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzFormSection.Container,
            Theme.RzFormSection.GetLayoutCss(Layout));
    }
}
</file>

<file path="Components/Form/RzFormSection/Styling/DefaultRzFormSectionStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzFormSection. </summary>
public class DefaultRzFormSectionStyles : RzStylesBase.RzFormSectionStylesBase
{
    /// <inheritdoc />
    public DefaultRzFormSectionStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // Base container style is determined by layout method
    /// <inheritdoc />
    public override string DescriptionContainer => ""; // Determined by layout method
    /// <inheritdoc />
    public override string Title =>
        "text-base/7 font-semibold text-foreground"; // Adjusted line height
    /// <inheritdoc />
    public override string Description => "text-sm text-foreground";
    /// <inheritdoc />
    public override string ContentContainer => ""; // Determined by layout method
    /// <inheritdoc />
    public override string GetLayoutCss(SectionLayout layout)
    {
        return layout switch
        {
            SectionLayout.TwoColumn => "md:flex md:space-x-5",
            SectionLayout.Stacked => "mb-5",
            _ => GetLayoutCss(SectionLayout.TwoColumn)
        };
    }
    /// <inheritdoc />
    public override string GetDescriptionLayoutCss(SectionLayout layout)
    {
        return layout switch
        {
            SectionLayout.TwoColumn => "md:w-1/3 md:flex-none",
            SectionLayout.Stacked => "pb-5 mb-10 border-b border-outline", // Use theme border
            _ => GetDescriptionLayoutCss(SectionLayout.TwoColumn)
        };
    }
    /// <inheritdoc />
    public override string GetContentLayoutCss(SectionLayout layout)
    {
        return layout switch
        {
            SectionLayout.TwoColumn => "space-y-6 md:w-1/2", // space-y might need review depending on RzField margins
            SectionLayout.Stacked => "",
            _ => GetContentLayoutCss(SectionLayout.TwoColumn)
        };
    }
}
</file>

<file path="Components/Form/RzNumber/RzNumberEdit.razor">
@typeparam TValue
@namespace RizzyUI
@using Blazicons
@using Rizzy
@inherits InputBase<TValue>

<HtmlElement Element="@EffectiveElement" id="@Id" class="@Theme.RzNumberEdit.InputWrapper">
	<div x-data="rzPrependInput" alpine-data-root="@Id">
		@if (!string.IsNullOrEmpty(PrependText) || PrependIcon != null)
		{
			<div x-ref="prependContainer" class="@Theme.RzNumberEdit.PrependElement">
				@if (!string.IsNullOrEmpty(PrependText))
				{
					@PrependText
				}
				else if (PrependIcon != null)
				{
					<div class="@Theme.RzNumberEdit.PrependIconContainer">
						<Blazicon Svg="PrependIcon"/>
					</div>
				}
			</div>
		}
		<RzInputNumber x-ref="textInput" TValue="TValue" @ref="_elem" Value="@_value" ValueExpression="For"
		               placeholder="@_placeholder" @attributes="AdditionalAttributes" class="@Theme.RzNumberEdit.Input"/>
	</div>
</HtmlElement>
</file>

<file path="Components/Form/RzNumber/RzNumberEdit.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For RzInputNumber
// For EditContext
namespace RizzyUI;
/// <xmldoc>
///     Represents a customizable number input component, potentially used within an <see cref="RzNumberField{TValue}" />.
///     Supports prepended text or icons and binding to numeric types. Styling is determined by the active
///     <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzNumberEdit<TValue> : InputBase<TValue> // Inherits InputBase<TValue>
{
    private RzInputNumber<TValue>? _elem; // Reference to the underlying RzInputNumber
    private string _placeholder = string.Empty;
    private TValue _value = default!;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    public EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the placeholder text for the input field. </summary>
    [Parameter]
    public string Placeholder { get; set; } = string.Empty;
    /// <summary> Gets or sets optional text to prepend inside the input field's visual container. </summary>
    [Parameter]
    public string? PrependText { get; set; }
    /// <summary>
    ///     Gets or sets an optional Blazicon SVG icon to prepend inside the input field's visual container. Use either
    ///     this or PrependText.
    /// </summary>
    [Parameter]
    public SvgIcon? PrependIcon { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized(); // Call base for InputBase logic
        if (For == null) // For is required by InputBase
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null) // RzInputNumber requires EditContext
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet(); // Call base for InputBase logic
        _placeholder = Placeholder;
        if (AdditionalAttributes is not null && AdditionalAttributes.TryGetValue("placeholder", out var ph) &&
            ph is string phStr) _placeholder = phStr;
        // Compile the field expression to get the initial value.
        _value = For!.Compile().Invoke(); // For is guaranteed non-null by base/OnInitialized
        if (!string.IsNullOrEmpty(PrependText) && PrependIcon != null)
            throw new InvalidOperationException(
                $"{nameof(PrependText)} and {nameof(PrependIcon)} cannot both be set at the same time.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzNumberEdit.Input);
        // RzInputNumber handles merging its own class
    }
}
</file>

<file path="Components/Form/RzNumber/RzNumberField.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@inherits RzComponent


<RzField @attributes="AdditionalAttributes" Id="@Id" class="@RootClass()">
	<RzFieldLabel DisplayName="@DisplayName" For="@For" Required="Required"/>

	<RzNumberEdit TValue="TValue"
	              For="@For"
	              Placeholder="@Placeholder"
	              PrependIcon="@PrependIcon"
	              PrependText="@PrependText"
	              @attributes="InputAttributes"/>
	@if (FieldHelp != null)
	{
		<RzFieldHelp>@FieldHelp</RzFieldHelp>
	}
	<RzValidationMessage For="@For"/>
</RzField>
</file>

<file path="Components/Form/RzNumber/RzNumberField.razor.cs">
using System.Linq.Expressions;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a complete form field for number input, including a label, the input itself (
///     <see cref="RzNumberEdit{TValue}" />),
///     optional help text, and validation message integration. Leverages <see cref="RzField" /> for structure.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzNumberField<TValue> : RzComponent
{
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Specifies the field the number input is bound to. Required. </summary>
    [Parameter]
    [EditorRequired]
    public Expression<Func<TValue>>? For { get; set; }
    /// <summary> Gets or sets optional text to prepend inside the input's visual container. </summary>
    [Parameter]
    public string? PrependText { get; set; }
    /// <summary> Gets or sets an optional Blazicon SVG icon to prepend inside the input's visual container. </summary>
    [Parameter]
    public SvgIcon? PrependIcon { get; set; }
    /// <summary> Gets or sets the placeholder text displayed in the input field. </summary>
    [Parameter]
    public string Placeholder { get; set; } = string.Empty;
    /// <summary> Gets or sets the display name for the field label. If not set, it's inferred from the 'For' expression. </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <summary> Gets or sets a value indicating whether the field is marked as required. Defaults to false. </summary>
    [Parameter]
    public bool Required { get; set; }
    /// <summary> Gets or sets optional content displayed below the input as help text. </summary>
    [Parameter]
    public RenderFragment? FieldHelp { get; set; }
    /// <summary> Separates AdditionalAttributes intended for RzNumberEdit. </summary>
    protected Dictionary<string, object> InputAttributes => AdditionalAttributes?
        .Where(kvp => kvp.Key.ToLowerInvariant() != "class") // Exclude class from being passed down directly
        .ToDictionary(kvp => kvp.Key, kvp => kvp.Value) ?? new Dictionary<string, object>();
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        // Merge class attribute specifically for the RzField container
        return TwMerge.Merge(AdditionalAttributes, Theme.RzNumberField.Field);
    }
}
</file>

<file path="Components/Form/RzNumber/Styling/DefaultRzNumberStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzNumberEdit. </summary>
public class DefaultRzNumberEditStyles : RzStylesBase.RzNumberEditStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzNumberEditStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzNumberEditStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string InputWrapper => "relative";
    /// <inheritdoc />
    public override string PrependElement =>
        "pointer-events-none absolute inset-y-0 left-0 my-px ml-px flex items-center rounded-l-borderRadius border-r border-outline bg-secondary pl-3 pr-1 text-foreground dark:border-outline dark:bg-secondary dark:text-foreground";
    /// <inheritdoc />
    public override string PrependIconContainer => "text-xl";
    /// <inheritdoc />
    public override string Input =>
        "block w-full rounded-theme border border-outline px-3 py-2 leading-6 placeholder-muted-foreground focus:border-primary focus:ring focus:ring-primary/50 transition-opacity text-transparent dark:border-outline dark:bg-secondary dark:placeholder-muted-foreground dark:focus:border-primary";
}
/// <summary> Provides default styles for RzNumberField. </summary>
public class DefaultRzNumberFieldStyles : RzStylesBase.RzNumberFieldStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzNumberFieldStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzNumberFieldStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Field => ""; // Handled by RzField component
}
</file>

<file path="Components/Form/RzRadio/RzRadioGroup.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@inherits RzComponent

<CascadingValue Value="this" IsFixed="true">

    <RzInputRadioGroup TValue="TValue" ValueExpression="@For" Value="CurrentValue" Id="@Id" Name="@Name">
        <div @attributes="AdditionalAttributes" class="@RootClass()">
            @ChildContent
        </div>
    </RzInputRadioGroup>
</CascadingValue>
</file>

<file path="Components/Form/RzRadio/RzRadioGroup.razor.cs">
using System.Linq.Expressions;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a group of radio buttons (<see cref="RzRadioGroupItem{TValue}" />) where only one option can be selected
///     at a time.
///     It integrates with Blazor's EditForm for validation and model binding.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzRadioGroup<TValue> : RzComponent
{
    private TValue? _currentValue = default!;
    private FieldIdentifier _fieldIdentifier;
    private List<RzRadioGroupItem<TValue>> _items = new();
    /// <summary> Gets the current edit context. Required as RzInputRadioGroup needs it. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the display name (often used by label components, though not directly here). </summary>
    [Parameter]
    public string? DisplayName { get; set; } = string.Empty;
    /// <summary> Gets or sets the orientation of the radio items (Vertical or Horizontal). Defaults to Vertical. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary>
    ///     Specifies the field for which validation messages should be displayed.
    /// </summary>
    [Parameter] [EditorRequired]
    public Expression<Func<TValue>>? For { get; set; }
    /// <summary> Gets or sets the 'name' attribute shared by all radio buttons in the group. If empty, one is generated. </summary>
    [Parameter]
    public string Name { get; set; } = string.Empty;
    /// <summary>
    ///     Gets or sets the Blazicon SVG icon displayed inside the selected radio button circle. Defaults to
    ///     CheckboxMarkedCircle.
    /// </summary>
    [Parameter]
    public SvgIcon CheckboxIcon { get; set; } = MdiIcon.CheckboxMarkedCircle;
    /// <summary> Gets or sets the currently selected value in the radio group. </summary>
    [Parameter]
    public TValue? Value { get; set; } = default!;
    /// <summary> Event callback invoked when the selected value changes. </summary>
    [Parameter]
    public EventCallback<TValue> ValueChanged { get; set; }
    /// <summary> Gets or sets the child content, expected to be <see cref="RzRadioGroupItem{TValue}" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Internal property for two-way binding with RzInputRadioGroup. </summary>
    protected TValue? CurrentValue
    {
        get => _currentValue;
        set
        {
            if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, value))
            {
                _currentValue = value;
                // Update the original parameter and invoke the callback
                InvokeAsync(async () =>
                {
                    Value = _currentValue; // Update the parameter bound property
                    await ValueChanged.InvokeAsync(_currentValue);
                    // RzInputRadioGroup handles EditContext notification
                });
            }
        }
    }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        _currentValue = Value ?? For.Compile().Invoke(); // Initialize from parameter or model
        // Generate a name if not provided
        if (string.IsNullOrEmpty(Name)) Name = _fieldIdentifier.FieldName;
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Update internal value if the parameter changes externally
        if (For != null && Value == null)
        {
            var newValue = Value ?? For.Compile().Invoke();
            if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, newValue)) _currentValue = newValue;
        }
        // Regenerate name if 'For' changes and Name was auto-generated
        if (For == null) return;
        var newFieldIdentifier = FieldIdentifier.Create(For);
        if (string.IsNullOrEmpty(Name) || Name == _fieldIdentifier.FieldName)
            Name = newFieldIdentifier.FieldName;
        _fieldIdentifier = newFieldIdentifier;
    }
    /// <summary> Adds an <see cref="RzRadioGroupItem{TValue}" /> to this group. Called by child items. </summary>
    /// <param name="item">The radio group item to add.</param>
    public void AddRadioItem(RzRadioGroupItem<TValue> item)
    {
        if (!_items.Contains(item))
        {
            _items.Add(item);
            StateHasChanged(); // Need to re-render to update grid column count
        }
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzRadioGroup;
        return TwMerge.Merge(AdditionalAttributes, styles.Container,
            styles.GetGridColumnsCss(Orientation, _items.Count));
    }
}
</file>

<file path="Components/Form/RzRadio/RzRadioGroupField.razor">
@typeparam TValue
@namespace RizzyUI
@using Rizzy
@inherits RzComponent

<RzField @attributes="AdditionalAttributes" Id="@Id" class="@RootClass()">
    <RzFieldLabel DisplayName="@DisplayName" For="@For" Required="Required"/>
    @if (FieldHelp != null)
    {
        <RzFieldHelp>@FieldHelp</RzFieldHelp>
    }
    <RzRadioGroup TValue="TValue"
                  @bind-Value="CurrentValue"
                  DisplayName="@DisplayName"
                  Name="@ResolvedName"
                  For="@For"
                  Orientation="@Orientation"
                  CheckboxIcon="@CheckboxIcon"
                  class="@Theme.RzRadioGroupField.GroupWithinField">
        @RadioGroupContent
    </RzRadioGroup>
    <RzValidationMessage For="@For"/>
</RzField>
</file>

<file path="Components/Form/RzRadio/RzRadioGroupField.razor.cs">
using System.Linq.Expressions;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For EditContext, FieldIdentifier
namespace RizzyUI;
/// <xmldoc>
///     Represents a form field containing a group of radio buttons (<see cref="RzRadioGroup{TValue}" />),
///     along with a label, optional help text, and validation message integration.
///     Leverages <see cref="RzField" /> for structure. Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzRadioGroupField<TValue> : RzComponent
{
    private TValue? _currentValue;
    private FieldIdentifier _fieldIdentifier;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the display name for the field label. If not set, it's inferred from the 'For' expression. </summary>
    [Parameter]
    public string? DisplayName { get; set; } = string.Empty;
    /// <summary> Gets or sets the orientation of the radio group (Vertical or Horizontal). Defaults to Vertical. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Vertical;
    /// <summary>
    ///     Gets or sets the Blazicon SVG icon displayed inside the selected radio button circle. Defaults to
    ///     CheckboxMarkedCircle.
    /// </summary>
    [Parameter]
    public SvgIcon CheckboxIcon { get; set; } = MdiIcon.CheckboxMarkedCircle;
    /// <summary> Specifies the field the radio group is bound to. Required. </summary>
    [Parameter]
    [EditorRequired]
    public required Expression<Func<TValue>>? For { get; set; }
    /// <summary> Gets or sets the current selected value of the radio group. </summary>
    [Parameter]
    public TValue? Value { get; set; }
    /// <summary> Event callback invoked when the selected value changes. </summary>
    [Parameter]
    public EventCallback<TValue> ValueChanged { get; set; }
    /// <summary> Gets or sets the 'name' attribute for the radio group. If empty, it's derived from the 'For' expression. </summary>
    [Parameter]
    public string Name { get; set; } = string.Empty;
    /// <summary> Gets or sets the child content containing the <see cref="RzRadioGroupItem{TValue}" /> components. </summary>
    [Parameter]
    public RenderFragment? RadioGroupContent { get; set; } // Renamed from ChildContent for clarity
    /// <summary> Optional content displayed below the group as help text. </summary>
    [Parameter]
    public RenderFragment? FieldHelp { get; set; }
    /// <summary> Gets or sets a value indicating whether the field is marked as required. Defaults to false. </summary>
    [Parameter]
    public bool Required { get; set; }
    /// <summary> Internal property for two-way binding with RzRadioGroup. </summary>
    protected TValue? CurrentValue
    {
        get => _currentValue;
        set
        {
            if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, value))
            {
                _currentValue = value;
                // Update the original parameter and invoke the callback
                InvokeAsync(async () =>
                {
                    Value = _currentValue; // Update the parameter bound property
                    await ValueChanged.InvokeAsync(_currentValue);
                    EditContext?.NotifyFieldChanged(_fieldIdentifier); // Notify EditContext
                });
            }
        }
    }
    /// <summary> The resolved name attribute for the radio group. </summary>
    protected string ResolvedName { get; private set; } = string.Empty;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        _currentValue = Value ?? For.Compile().Invoke(); // Initialize from parameter or model
        ResolvedName = string.IsNullOrEmpty(Name) ? _fieldIdentifier.FieldName : Name; // Resolve name
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Update internal value if the parameter changes externally
        var newValue = Value ?? For!.Compile().Invoke();
        if (!EqualityComparer<TValue?>.Default.Equals(_currentValue, newValue)) _currentValue = newValue;
        // Update resolved name if 'For' or 'Name' parameter changes
        if (For != null)
        {
            var newFieldIdentifier = FieldIdentifier.Create(For);
            ResolvedName = string.IsNullOrEmpty(Name) ? newFieldIdentifier.FieldName : Name;
            _fieldIdentifier = newFieldIdentifier; // Update field identifier if 'For' changed
        }
        else if (!string.IsNullOrEmpty(Name))
        {
            ResolvedName = Name; // Use explicit name if 'For' is somehow null now
        }
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes);
        // Styling handled by RzField
    }
}
</file>

<file path="Components/Form/RzRadio/RzRadioGroupItem.razor">
@typeparam TValue
@namespace RizzyUI
@using Blazicons
@using Rizzy
@inherits RzComponent

<label @attributes="AdditionalAttributes" id="@Id" class="@Theme.RzRadioGroupItem.LabelWrapper">
    <RzInputRadio @ref="_radioRef" TValue="TValue" class="@Theme.RzRadioGroupItem.RadioInput" Name="@ParentRadioGroup?.Name" Id="@RadioInputId" Value="@Value"/>
    <span class="@Theme.RzRadioGroupItem.IconContainer">
	    <Blazicon Svg="EffectiveCheckboxIcon"/>
    </span>
    <span class="@Theme.RzRadioGroupItem.ClickableContainer">
        <div class="@Theme.RzRadioGroupItem.ContentWrapper">
            @if (Icon != null)
            {
                <div class="@Theme.RzRadioGroupItem.LeadingIconContainer">
	                <Blazicon Svg="Icon"/>
                </div>
            }
            <span class="@Theme.RzRadioGroupItem.TextContainer">
                <span class="@Theme.RzRadioGroupItem.LabelText">@Label</span>
                @if (Description != null)
                {
                    <span class="@Theme.RzRadioGroupItem.DescriptionText">@Description</span>
                }
                @ChildContent
            </span>
        </div>
    </span>
</label>
</file>

<file path="Components/Form/RzRadio/RzRadioGroupItem.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
// For RzInputRadio
// For IdGenerator
namespace RizzyUI;
/// <xmldoc>
///     Represents a single radio button item within an <see cref="RzRadioGroup{TValue}" />.
///     Includes support for labels, descriptions, and icons.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzRadioGroupItem<TValue> : RzComponent
{
    private RzInputRadio<TValue>? _radioRef;
    /// <summary> Gets the parent radio group. </summary>
    [CascadingParameter]
    public RzRadioGroup<TValue>? ParentRadioGroup { get; set; }
    /// <summary> Gets or sets the Blazicon SVG icon displayed next to the label (optional). </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Gets or sets the main text label for the radio item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Label { get; set; } = string.Empty;
    /// <summary> Gets or sets the value associated with this radio item. </summary>
    [Parameter]
    public TValue? Value { get; set; }
    /// <summary> Gets or sets optional descriptive text displayed below the label. </summary>
    [Parameter]
    public RenderFragment? Description { get; set; }
    /// <summary> Gets or sets the unique ID for the radio input element. Defaults to a generated ID. </summary>
    [Parameter]
    public string RadioInputId { get; set; } = IdGenerator.UniqueId("rzrd");
    /// <summary> Optional child content rendered within the text container. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Provides a reference to the underlying <see cref="RzInputRadio{TValue}"/> component. </summary>
    public RzInputRadio<TValue> InputRadioRef => _radioRef ?? throw new InvalidOperationException("RzInputRadio reference is not set.");
    /// <summary> The effective icon used for the checkmark, determined by the parent group. </summary>
    protected SvgIcon EffectiveCheckboxIcon { get; set; } = default!;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentRadioGroup == null)
            throw new InvalidOperationException($"{GetType()} must be used within an RzRadioGroup.");
        EffectiveCheckboxIcon = ParentRadioGroup.CheckboxIcon; // Get icon from parent
        ParentRadioGroup.AddRadioItem(this); // Register with parent
    }
    // No RootClass needed as the root is the label with styles applied directly
}
</file>

<file path="Components/Form/RzRadio/Styling/DefaultRzRadioStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzRadioGroup. </summary>
public class DefaultRzRadioGroupStyles : RzStylesBase.RzRadioGroupStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzRadioGroupStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzRadioGroupStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "grid gap-2 pt-3"; // Base grid layout
    /// <inheritdoc />
    public override string GetGridColumnsCss(Orientation orientation, int itemCount)
    {
        return orientation switch
        {
            Orientation.Horizontal => $"grid-cols-{itemCount}", // Dynamic columns for horizontal
            Orientation.Vertical => "grid-cols-1", // Single column for vertical
            _ => GetGridColumnsCss(Orientation.Vertical, itemCount)
        };
    }
}
/// <summary> Provides default styles for RzRadioGroupItem. </summary>
public class DefaultRzRadioGroupItemStyles : RzStylesBase.RzRadioGroupItemStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzRadioGroupItemStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzRadioGroupItemStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string LabelWrapper => "group relative flex";
    /// <inheritdoc />
    public override string RadioInput => "opacity-0 peer absolute left-0 top-0 appearance-none"; // Hidden input
    /// <inheritdoc />
    // Styling for the checkmark circle indicator
    public override string IconContainer =>
        "z-1 text-primary text-xl opacity-0 absolute bottom-0 right-0 top-0 flex scale-50 cursor-pointer items-center px-4 transition peer-checked:scale-100 peer-checked:opacity-100";
    /// <inheritdoc />
    // Styling for the main visible container that gets border/bg on check/focus
    public override string ClickableContainer =>
        "group-hover:border-primary relative flex grow cursor-pointer rounded-theme border border-outline p-4 peer-checked:bg-secondary peer-checked:border-primary dark:peer-checked:border-primary dark:peer-checked:bg-secondary dark:peer-checked:bg-opacity-10 peer-focus:ring peer-focus:ring-primary";
    /// <inheritdoc />
    public override string ContentWrapper => "flex";
    /// <inheritdoc />
    public override string LeadingIconContainer => "mr-2 text-2xl content-center";
    /// <inheritdoc />
    public override string TextContainer => "grow pr-8 text-sm"; // Padding right to avoid overlap with check icon
    /// <inheritdoc />
    public override string LabelText => "mb-1 block font-bold";
    /// <inheritdoc />
    public override string DescriptionText => "block text-foreground";
}
/// <summary> Provides default styles for RzRadioGroupField. </summary>
public class DefaultRzRadioGroupFieldStyles : RzStylesBase.RzRadioGroupFieldStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzRadioGroupFieldStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzRadioGroupFieldStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Field => ""; // Handled by RzField component
    /// <inheritdoc />
    public override string GroupWithinField => ""; // No extra styling needed for the group within the field by default
}
</file>

<file path="Components/Form/RzText/RzTextEdit.razor">
@namespace RizzyUI
@using Blazicons
@using Rizzy
@inherits InputBase<string>

<div class="@Theme.RzTextEdit.InputWrapper" id="@Id">
    <div x-data="rzPrependInput" data-alpine-root="@Id">
        @if (!string.IsNullOrEmpty(PrependText) || PrependIcon != null)
        {
            <div x-ref="prependContainer" class="@Theme.RzTextEdit.PrependElement">
                @if (!string.IsNullOrEmpty(PrependText))
                {
                    @PrependText
                }
                else if (PrependIcon != null) // Ensure PrependIcon is not null before rendering
                {
                    <div class="@Theme.RzTextEdit.PrependIconContainer">
                        <Blazicon Svg="PrependIcon"/>
                    </div>
                }
            </div>
        }
        <RzInputText x-ref="textInput" @ref="_elem" type="@_role" Value="@_value" ValueExpression="For"
                     placeholder="@_placeholder" @attributes="AdditionalAttributes" class="@Theme.RzTextEdit.Input"/>
    </div>
</div>
</file>

<file path="Components/Form/RzText/RzTextEdit.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For RzInputText
// For EditContext
namespace RizzyUI;
/// <xmldoc>
///     Represents a customizable text input component, potentially used within an <see cref="RzTextField" />.
///     Supports prepended text or icons. Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTextEdit : InputBase<string> // Inherits from InputBase<string>
{
    private RzInputText? _elem; // Reference to the underlying RzInputText
    private string _placeholder = string.Empty;
    private string _role = "text";
    private string _value = string.Empty;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    public EditContext? EditContext { get; set; } // Cascaded EditContext
    /// <summary> Gets or sets the semantic role of the text input (e.g., Text, Password, Email). Defaults to Text. </summary>
    [Parameter]
    public TextRole Role { get; set; } = TextRole.Text;
    /// <summary> Gets or sets the placeholder text for the input field. </summary>
    [Parameter]
    public string Placeholder { get; set; } = string.Empty;
    /// <summary> Gets or sets optional text to prepend inside the input field's visual container. </summary>
    [Parameter]
    public string? PrependText { get; set; }
    /// <summary>
    ///     Gets or sets an optional Blazicon SVG icon to prepend inside the input field's visual container. Use either
    ///     this or PrependText.
    /// </summary>
    [Parameter]
    public SvgIcon? PrependIcon { get; set; }
    /// <summary>
    /// Provides a reference to the underlying <see cref="RzInputText"/> component.
    /// </summary>
    /// <exception cref="InvalidOperationException"></exception>
    public RzInputText InputTextRef => _elem ?? throw new InvalidOperationException("RzInputText reference is not set.");
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null) // RzInputText requires EditContext
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _role = GetParameterValue("type", Role.ToString().ToLowerInvariant()); // Get type from attributes or Role prop
        _placeholder =
            GetParameterValue("placeholder", Placeholder); // Get placeholder from attributes or Placeholder prop
        _value = For!.Compile().Invoke(); // Get initial value from expression (For is required by base)
        if (!string.IsNullOrEmpty(PrependText) && PrependIcon != null)
            throw new InvalidOperationException(
                $"{nameof(PrependText)} and {nameof(PrependIcon)} cannot both be set at the same time.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzTextEdit.Input);
        // RzInputText handles merging its class
    }
}
</file>

<file path="Components/Form/RzText/RzTextField.razor">
@namespace RizzyUI
@using Rizzy
@inherits RzComponent


<RzField class="@RootClass()" Id="@Id">
	<RzFieldLabel DisplayName="@DisplayName" For="@For" Required="Required"/>

	<RzTextEdit For="@For"
	            Role="@Role"
	            Placeholder="@Placeholder"
	            PrependIcon="@PrependIcon"
	            PrependText="@PrependText"
	            @attributes="AdditionalAttributes"/>
	@if (FieldHelp != null)
	{
		<RzFieldHelp>@FieldHelp</RzFieldHelp>
	}
	<RzValidationMessage For="@For"/>
</RzField>
</file>

<file path="Components/Form/RzText/RzTextField.razor.cs">
using System.Linq.Expressions;
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For EditContext
namespace RizzyUI;
/// <xmldoc>
///     Represents a complete form field for text input, including a label, the input itself (<see cref="RzTextEdit" />),
///     optional help text, and validation message integration. Leverages <see cref="RzField" /> for structure.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTextField : RzComponent
{
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the semantic role of the text input (e.g., Text, Password). Defaults to Text. </summary>
    [Parameter]
    public TextRole Role { get; set; } = TextRole.Text;
    /// <summary> Gets or sets the placeholder text displayed in the input field. </summary>
    [Parameter]
    public string Placeholder { get; set; } = string.Empty;
    /// <summary> Gets or sets the display name for the field label. If not set, it's inferred from the 'For' expression. </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <summary>
    ///     Gets or sets a value indicating whether the field is marked as required (adds an indicator to the label).
    ///     Defaults to false.
    /// </summary>
    [Parameter]
    public bool Required { get; set; }
    /// <summary> Gets or sets optional content displayed below the input field as help text. </summary>
    [Parameter]
    public RenderFragment? FieldHelp { get; set; }
    /// <summary> Specifies the field the input is bound to. Required. Used for binding, validation, and label inference. </summary>
    [Parameter]
    [EditorRequired]
    public Expression<Func<string>>? For { get; set; }
    /// <summary> Gets or sets optional text to prepend inside the input field's visual container. </summary>
    [Parameter]
    public string? PrependText { get; set; }
    /// <summary>
    ///     Gets or sets an optional Blazicon SVG icon to prepend inside the input field's visual container. Use either
    ///     this or PrependText.
    /// </summary>
    [Parameter]
    public SvgIcon? PrependIcon { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes);
        // Styling is primarily handled by the nested RzField component
    }
}
</file>

<file path="Components/Form/RzText/Styling/DefaultRzTextStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzTextEdit. </summary>
public class DefaultRzTextEditStyles : RzStylesBase.RzTextEditStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzTextEditStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzTextEditStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string InputWrapper => "relative";
    /// <inheritdoc />
    public override string PrependElement =>
        "pointer-events-none absolute inset-y-0 left-0 my-px ml-px flex items-center rounded-l-borderRadius border-r border-outline bg-secondary px-3 text-foreground dark:border-outline dark:bg-secondary dark:text-foreground"; // Adjusted padding slightly, used theme tokens
    /// <inheritdoc />
    public override string PrependIconContainer => "text-xl";
    /// <inheritdoc />
    public override string Input =>
        "block w-full rounded-theme border border-outline px-3 py-2 leading-6 placeholder-muted-foreground focus:border-primary focus:ring focus:ring-primary/50 dark:border-outline dark:bg-secondary dark:placeholder-muted-foreground dark:focus:border-primary transition-opacity text-transparent"; // text-transparent initially for rzPrependInput
}
/// <summary> Provides default styles for RzTextField. </summary>
public class DefaultRzTextFieldStyles : RzStylesBase.RzTextFieldStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzTextFieldStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzTextFieldStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Field => ""; // Handled by RzField component
}
</file>

<file path="Components/Form/RzToggle/RzToggle.razor">
@namespace RizzyUI
@using Rizzy
@inherits RzComponent

<RzInputCheckbox ValueExpression="@For"
                 Value="CurrentValue"
                 @attributes="AdditionalAttributes"
                 class="@RootClass()"
                 role="switch"
                 tabindex="0"
                 aria-checked="@AriaCheckedValue"/>
</file>

<file path="Components/Form/RzToggle/RzToggle.razor.cs">
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For RzInputCheckbox
// For EditContext
namespace RizzyUI;
/// <xmldoc>
///     Renders a toggle switch (styled checkbox) component.
///     Styling is determined by the active <see cref="RzTheme" />. It should be used within an EditForm context.
/// </xmldoc>
public partial class RzToggle : RzComponent
{
    private bool _currentValue;
    private FieldIdentifier _fieldIdentifier;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the current boolean value of the toggle. </summary>
    [Parameter]
    public bool? Value { get; set; }
    /// <summary> Event callback for when the value changes. </summary>
    [Parameter]
    public EventCallback<bool> ValueChanged { get; set; }
    /// <summary> Specifies the field the toggle is bound to. Required. </summary>
    [Parameter]
    [EditorRequired]
    public Expression<Func<bool>>? For { get; set; }
    /// <summary> Internal property for two-way binding with RzInputCheckbox. </summary>
    protected bool CurrentValue
    {
        get => _currentValue;
        set
        {
            if (_currentValue != value)
            {
                _currentValue = value;
                // Update the original parameter and invoke the callback
                InvokeAsync(async () =>
                {
                    Value = _currentValue; // Update the parameter bound property
                    await ValueChanged.InvokeAsync(_currentValue);
                    EditContext?.NotifyFieldChanged(_fieldIdentifier); // Notify EditContext
                });
            }
        }
    }
    /// <summary> Gets the string representation for the aria-checked attribute. </summary>
    protected string AriaCheckedValue => CurrentValue ? "true" : "false";
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        // Initialize _currentValue from Value parameter or model
        _currentValue = Value ?? For.Compile().Invoke();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Update internal value if the parameter changes externally
        var newValue = Value ?? For?.Compile().Invoke() ?? false;
        if (_currentValue != newValue) _currentValue = newValue;
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzToggle.Toggle);
    }
}
</file>

<file path="Components/Form/RzToggle/RzToggleField.razor">
@namespace RizzyUI
@using Rizzy
@inherits RzComponent

<RzField Id="@Id" class="@RootClass()">
	<div class="@Theme.RzToggleField.ContentWrapper">
		<div class="@Theme.RzToggleField.InnerWrapper">
			<RzFieldLabel DisplayName="@DisplayName" For="@For" class="@Theme.RzToggleField.LabelInField">
				@if (Description != null)
				{
					<span class="@Theme.RzToggleField.DescriptionInLabel">
						@Description
					</span>
				}
			</RzFieldLabel>


			<RzToggle For="@For" @bind-Value="CurrentValue" class="@Theme.RzToggleField.ToggleInField"
			          @attributes="AdditionalAttributes"/>
		</div>
	</div>

	<RzValidationMessage For="@For"/>
</RzField>
</file>

<file path="Components/Form/RzToggle/RzToggleField.razor.cs">
using System.Linq.Expressions;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Forms;
using RizzyUI.Extensions;
// For IdGenerator if needed, though base RzComponent might handle ID now
// For EditContext
namespace RizzyUI;
/// <xmldoc>
///     Represents a form field containing a toggle switch (<see cref="RzToggle" />), along with a label,
///     optional description, and validation message integration. Leverages <see cref="RzField" /> for structure.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzToggleField : RzComponent
{
    private bool _currentValue;
    private FieldIdentifier _fieldIdentifier;
    /// <summary> Gets the current edit context. </summary>
    [CascadingParameter]
    private EditContext? EditContext { get; set; }
    /// <summary> Gets or sets the display name for the field label. If not set, it's inferred from the 'For' expression. </summary>
    [Parameter]
    public string? DisplayName { get; set; }
    /// <summary> Gets or sets optional descriptive text displayed below the label. </summary>
    [Parameter]
    public RenderFragment? Description { get; set; }
    /// <summary> Specifies the field the toggle switch is bound to. Required. </summary>
    [Parameter]
    [EditorRequired]
    public Expression<Func<bool>>? For { get; set; }
    /// <summary> Gets or sets the current boolean value of the toggle switch. </summary>
    [Parameter]
    public bool? Value { get; set; }
    /// <summary> Event callback invoked when the toggle's value changes. </summary>
    [Parameter]
    public EventCallback<bool> ValueChanged { get; set; }
    /// <summary> Internal property for two-way binding with RzToggle. </summary>
    protected bool CurrentValue
    {
        get => _currentValue;
        set
        {
            if (_currentValue != value)
            {
                _currentValue = value;
                // Update the original parameter and invoke the callback
                InvokeAsync(async () =>
                {
                    Value = _currentValue; // Update the parameter bound property
                    await ValueChanged.InvokeAsync(_currentValue);
                    EditContext?.NotifyFieldChanged(_fieldIdentifier); // Notify EditContext
                });
            }
        }
    }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (For == null)
            throw new InvalidOperationException($"{GetType()} requires a value for the 'For' parameter.");
        if (EditContext == null)
            throw new InvalidOperationException($"{GetType()} must be used within an EditForm.");
        _fieldIdentifier = FieldIdentifier.Create(For);
        // Initialize _currentValue from Value parameter or model
        _currentValue = Value ?? For.Compile().Invoke();
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // If the Value parameter changes externally, update internal state
        var newValue = Value ?? For?.Compile().Invoke() ?? false;
        if (_currentValue != newValue) _currentValue = newValue;
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes);
        // Styling handled by RzField
    }
}
</file>

<file path="Components/Form/RzToggle/Styling/DefaultRzToggleStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzToggle. </summary>
public class DefaultRzToggleStyles : RzStylesBase.RzToggleStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzToggleStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzToggleStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    // Note: Colors like text-primary, checked:bg-primary should ideally map to theme tokens if possible,
    // but Tailwind's checked: variant often relies on direct color classes.
    public override string Toggle =>
        "relative w-[3.25rem] h-7 p-px bg-outline border-transparent text-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:ring-primary disabled:opacity-50 disabled:pointer-events-none checked:bg-none checked:bg-primary checked:text-primary checked:border-primary focus:checked:border-primary dark:checked:bg-primary dark:checked:border-primary dark:focus:ring-offset-surface before:inline-block before:size-6 before:bg-primary-foreground checked:before:bg-primary-foreground before:translate-x-0 checked:before:translate-x-full before:rounded-full before:shadow before:transform before:ring-0 before:transition before:ease-in-out before:duration-200 dark:before:bg-primary-foreground dark:checked:before:bg-primary-foreground";
}
/// <summary> Provides default styles for RzToggleField. </summary>
public class DefaultRzToggleFieldStyles : RzStylesBase.RzToggleFieldStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzToggleFieldStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzToggleFieldStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Field => ""; // Handled by RzField
    /// <inheritdoc />
    public override string ContentWrapper => "space-x-2";
    /// <inheritdoc />
    public override string InnerWrapper => "flex items-center justify-between space-x-3";
    /// <inheritdoc />
    public override string LabelInField =>
        "font-medium leading-relaxed"; // Specific style for label within toggle field
    /// <inheritdoc />
    public override string ToggleInField => ""; // No specific adjustment needed for the toggle itself usually
    /// <inheritdoc />
    public override string DescriptionInLabel => "block text-sm text-foreground";
}
</file>

<file path="Components/FragmentComponent.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <summary>
///     Component that encapsulates a RenderFragment for use as a partial or child component.
/// </summary>
public class FragmentComponent : ComponentBase
{
    /// <summary>
    ///     Fragment to render
    /// </summary>
    [Parameter]
    public RenderFragment? Fragment { get; set; }
    /// <summary>
    ///     Construct a component from a fragment
    /// </summary>
    /// <param name="builder"></param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        if (Fragment != null) builder.AddContent(0, Fragment);
    }
}
</file>

<file path="Components/HtmlElement.cs">
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <summary>
///     A generic Blazor component that renders a specified HTML element with optional content and attributes.
/// </summary>
public sealed class HtmlElement : ComponentBase
{
    /// <summary>
    ///     Specifies the root HTML element to render (e.g., "div", "a", "button").
    ///     If not set, defaults to "div".
    /// </summary>
    [Parameter]
    public string Element { get; set; } = "div";
    /// <summary>
    ///     Represents the content to be rendered inside the HTML element.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     A collection of additional attributes to apply to the HTML element.
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public IDictionary<string, object>? AdditionalAttributes { get; set; }
    /// <summary>
    ///     Builds the component's render tree.
    /// </summary>
    /// <param name="builder">An instance of <see cref="RenderTreeBuilder" /> used to build the render tree.</param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        var elementName = Element ?? "div";
        builder.OpenElement(0, elementName);
        builder.AddMultipleAttributes(1, AdditionalAttributes);
        builder.AddContent(3, ChildContent);
        builder.CloseElement();
    }
}
</file>

<file path="Components/Layout/RzAccordion/RzAccordion.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="div"
             @attributes="@AdditionalAttributes"
             class="@RootClass()">
	<div x-data="rzAccordion" data-alpine-root="@Id" data-multiple="@AllowMultipleOpen.ToString().ToLowerInvariant()">
		@ChildContent
	</div>
</HtmlElement>
</file>

<file path="Components/Layout/RzAccordion/RzAccordion.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents an accordion component that allows for collapsible sections. Styling is handled by the active theme.
///     Interactivity is managed by the 'rzAccordion' Alpine.js component.
/// </xmldoc>
public partial class RzAccordion : RzComponent
{
    /// <summary> When true, multiple sections may be open simultaneously. </summary>
    [Parameter]
    public bool AllowMultipleOpen { get; set; }
    /// <summary> Child content containing one or more RzAccordionSection components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAccordion.Container);
    }
}
</file>

<file path="Components/Layout/RzAccordion/RzAccordionSection.razor">
@namespace RizzyUI
@inherits RzComponent

<div x-data="rzAccordionSection" x-ref="@SectionId" data-is-open="@((!Collapsed).ToString().ToLowerInvariant())"
     data-section-id="@SectionId"
     data-expanded-class="@Theme.RzAccordionSection.ChevronIconExpanded"
     class="@Theme.RzAccordionSection.Container">
	<button id="@ButtonId" type="button" class="@RootClass()" aria-controls="@ContentId"
	        x-on:click="toggle" :aria-expanded="getAriaExpanded">
		@Title
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke-width="2"
		     stroke="currentColor" class="@Theme.RzAccordionSection.ChevronIcon motion-safe:transition-transform" aria-hidden="true"
		     :class="getExpandedCss">
			<path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5"/>
		</svg>
	</button>
	<div id="@ContentId" role="region" aria-labelledby="@ButtonId"
	     x-cloak x-show="open" x-collapse
         class="@Theme.RzAccordionSection.ContentContainerWrapper">
		<div class="@Theme.RzAccordionSection.ContentContainer">
			@ChildContent
		</div>
	</div>
</div>
</file>

<file path="Components/Layout/RzAccordion/RzAccordionSection.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
// Required for RzTheme
namespace RizzyUI;
/// <xmldoc>
///     Represents a section of an accordion component (<see cref="RzAccordion" />) that can be expanded or collapsed
///     to show or hide its content. Styling is managed by the active <see cref="RzTheme" />.
///     Interactivity is managed by the 'rzAccordionSection' Alpine.js component.
/// </xmldoc>
public partial class RzAccordionSection : RzComponent
{
    // Generate a unique ID for this section.
    private string SectionId { get; } = IdGenerator.UniqueId("rzaccsec");
    /// <summary> Gets the unique ID for the button element. </summary>
    protected string ButtonId => $"rzaccordion-button-{SectionId}";
    /// <summary> Gets the unique ID for the content container element. </summary>
    protected string ContentId => $"rzaccordion-content-{SectionId}";
    /// <summary> The title displayed in the clickable header of the accordion section. </summary>
    [Parameter]
    public string Title { get; set; } = string.Empty;
    /// <summary> Determines if the section is initially collapsed (true) or expanded (false). Defaults to true. </summary>
    [Parameter]
    public bool Collapsed { get; set; } = true;
    /// <summary> The content to be displayed inside the section when it is expanded. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzAccordionSection.Button);
    }
}
</file>

<file path="Components/Layout/RzAccordion/Styling/DefaultRzAccordionSectionStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzAccordionSection component.
/// </summary>
public class DefaultRzAccordionSectionStyles : RzStylesBase.RzAccordionSectionStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzAccordionSectionStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzAccordionSectionStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // Container div has no specific base style
    /// <inheritdoc />
    public override string Button =>
        "flex w-full items-center justify-between gap-4 bg-secondary p-4 text-left underline-offset-2 hover:bg-secondary/75 focus-visible:bg-secondary/75 focus-visible:underline focus-visible:outline-none dark:hover:bg-secondary/75 dark:focus-visible:bg-secondary/75 text-foreground font-medium"; // Removed focus-visible:outline-hidden for better accessibility
    /// <inheritdoc />
    public override string ContentContainerWrapper => ""; // Wrapper for x-collapse has no base style
    /// <inheritdoc />
    public override string ContentContainer => "p-4 text-sm sm:text-base text-pretty text-foreground"; // Added text color
    /// <inheritdoc />
    public override string ChevronIcon => "size-5 shrink-0 motion-safe:transition-transform"; // Added motion-safe
    /// <inheritdoc />
    public override string ChevronIconExpanded => "rotate-180"; // Class applied when expanded
}
</file>

<file path="Components/Layout/RzAccordion/Styling/DefaultRzAccordionStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzAccordion component.
/// </summary>
public class DefaultRzAccordionStyles : RzStylesBase.RzAccordionStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzAccordionStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzAccordionStyles(RzTheme theme) : base(theme)
    {
    }
	/// <summary>
	///     Gets the base CSS classes for the main RzAccordion container div.
	/// </summary>
	public override string Container =>
        "w-full divide-y divide-outline overflow-hidden rounded-theme border border-outline bg-secondary/40 text-foreground dark:divide-outline";
}
</file>

<file path="Components/Layout/RzCard/RzCard.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCard.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A flexible container component for displaying content in a card format.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCard : RzComponent
{
    /// <summary> The content to be rendered inside the card. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The background color for the card. Defaults to Surface. </summary>
    [Parameter]
    public SemanticColor BackgroundColor { get; set; } = SemanticColor.Surface;
    /// <summary> The text color for the card content. Defaults to OnSurface. </summary>
    [Parameter]
    public SemanticColor TextColor { get; set; } = SemanticColor.OnSurface;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var bgColorClass = BackgroundColor != SemanticColor.None
            ? BackgroundColor.ToBackgroundClass()
            : Theme.Light.Surface.ToCssClassString("bg"); // Use theme default if None
        var textColorClass = TextColor != SemanticColor.None
            ? TextColor.ToTextClass()
            : Theme.Light.OnSurface.ToCssClassString("text"); // Use theme default if None
        return TwMerge.Merge(AdditionalAttributes,
            Theme.RzCard.Container,
            bgColorClass,
            textColorClass);
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardBody.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardBody.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the main content area of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardBody : RzComponent
{
    /// <summary> The content to be rendered inside the card body. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The background color for the card body. Defaults to None (inherits from card). </summary>
    [Parameter]
    public SemanticColor BackgroundColor { get; set; } = SemanticColor.None;
    /// <summary> The text color for the card body content. Defaults to None (inherits from card). </summary>
    [Parameter]
    public SemanticColor TextColor { get; set; } = SemanticColor.None;
    /// <inheritdoc />
     protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes,
            Theme.RzCardBody.Body,
            BackgroundColor != SemanticColor.None ? BackgroundColor.ToBackgroundClass() : "", // Only apply if set
            TextColor != SemanticColor.None ? TextColor.ToTextClass() : ""); // Only apply if set
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardButtons.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardButtons.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container specifically for placing buttons within an <see cref="RzCardHeader" /> or <see cref="RzCardFooter" />.
///     Provides appropriate layout styling based on the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardButtons : RzComponent
{
    /// <summary> The buttons or other action elements to be rendered within this container. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
     protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzCardButtons.ButtonsContainer);
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardFooter.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    @ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardFooter.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the footer section of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardFooter : RzComponent
{
    /// <summary> The content to be rendered inside the card footer. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The background color for the card footer. Defaults to SurfaceAlt. </summary>
    [Parameter]
    public SemanticColor BackgroundColor { get; set; } = SemanticColor.SurfaceAlt;
    /// <summary> The text color for the card footer content. Defaults to OnSurface. </summary>
    [Parameter]
    public SemanticColor TextColor { get; set; } = SemanticColor.OnSurface;
    /// <inheritdoc />
     protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
         var bgColorClass = BackgroundColor != SemanticColor.None
            ? BackgroundColor.ToBackgroundClass()
            : Theme.Light.SurfaceAlt.ToCssClassString("bg"); // Use theme default if None
        var textColorClass = TextColor != SemanticColor.None
            ? TextColor.ToTextClass()
            : Theme.Light.OnSurface.ToCssClassString("text"); // Use theme default if None
        return TwMerge.Merge(AdditionalAttributes,
            Theme.RzCardFooter.Footer,
            bgColorClass,
            textColorClass);
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardHeader.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardHeader.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the header section of an <see cref="RzCard" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardHeader : RzComponent
{
    /// <summary> The content to be rendered inside the card header. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The background color for the card header. Defaults to SurfaceAlt. </summary>
    [Parameter]
    public SemanticColor BackgroundColor { get; set; } = SemanticColor.SurfaceAlt;
    /// <summary> The text color for the card header content. Defaults to OnSurface. </summary>
    [Parameter]
    public SemanticColor TextColor { get; set; } = SemanticColor.OnSurface;
    /// <inheritdoc />
     protected override void OnInitialized()
    {
        base.OnInitialized();
        Element = "div"; // Often a div, but could be header semantically
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var bgColorClass = BackgroundColor != SemanticColor.None
            ? BackgroundColor.ToBackgroundClass()
            : Theme.Light.SurfaceAlt.ToCssClassString("bg"); // Use theme default if None
        var textColorClass = TextColor != SemanticColor.None
            ? TextColor.ToTextClass()
            : Theme.Light.OnSurface.ToCssClassString("text"); // Use theme default if None
        return TwMerge.Merge(AdditionalAttributes,
            Theme.RzCardHeader.Header,
            bgColorClass,
            textColorClass);
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardSubtitle.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardSubtitle.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a subtitle within an <see cref="RzCardHeader" />. Typically renders as an H4 element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardSubtitle : RzComponent
{
    /// <summary> The text or content to be rendered as the card subtitle. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "h4"; // Default element for a subtitle
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzCardSubtitle.Subtitle);
    }
}
</file>

<file path="Components/Layout/RzCard/RzCardTitle.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Layout/RzCard/RzCardTitle.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the main title within an <see cref="RzCardHeader" />. Typically renders as an H3 element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzCardTitle : RzComponent
{
    /// <summary> The text or content to be rendered as the card title. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "h3"; // Default element for a title
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzCardTitle.Title);
    }
}
</file>

<file path="Components/Layout/RzCard/Styling/DefaultRzCardStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzCard. </summary>
public class DefaultRzCardStyles : RzStylesBase.RzCardStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container =>
        "flex flex-col rounded-theme overflow-hidden shadow-sm border border-outline";
}
/// <summary> Provides default styles for RzCardHeader. </summary>
public class DefaultRzCardHeaderStyles : RzStylesBase.RzCardHeaderStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardHeaderStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardHeaderStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Header =>
        "flex flex-col gap-3 px-5 py-4 text-center sm:flex-row sm:items-center sm:justify-between sm:text-left";
}
/// <summary> Provides default styles for RzCardBody. </summary>
public class DefaultRzCardBodyStyles : RzStylesBase.RzCardBodyStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardBodyStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardBodyStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Body => "grow p-5";
}
/// <summary> Provides default styles for RzCardFooter. </summary>
public class DefaultRzCardFooterStyles : RzStylesBase.RzCardFooterStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardFooterStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardFooterStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Footer => "px-5 py-4 text-sm last:rounded-b-borderRadius";
}
/// <summary> Provides default styles for RzCardTitle. </summary>
public class DefaultRzCardTitleStyles : RzStylesBase.RzCardTitleStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardTitleStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardTitleStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Title =>
        "flex items-center mb-1 text-lg font-semibold text-foreground";
}
/// <summary> Provides default styles for RzCardSubtitle. </summary>
public class DefaultRzCardSubtitleStyles : RzStylesBase.RzCardSubtitleStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardSubtitleStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardSubtitleStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Subtitle => "text-sm font-medium text-foreground";
}
/// <summary> Provides default styles for RzCardButtons. </summary>
public class DefaultRzCardButtonsStyles : RzStylesBase.RzCardButtonsStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzCardButtonsStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzCardButtonsStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string ButtonsContainer => "md:flex items-center gap-2 md:-my-4";
}
</file>

<file path="Components/Layout/RzSearchButton/RzSearchButton.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="@EffectiveElement"
             type="button"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@RootClass()"
             aria-label="@Label">
	<div class="@Theme.RzSearchButton.InnerContainer">
		<span class="@Theme.RzSearchButton.IconSpan" aria-hidden="true">
			<Blazicon Svg="MdiIcon.Magnify"/>
		</span>
		@Label
	</div>
</HtmlElement>
</file>

<file path="Components/Layout/RzSearchButton/RzSearchButton.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a search button styled consistently with the application's theme,
///     displaying a search icon and a configurable text label.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSearchButton : RzComponent
{
    // Theme is inherited from RzComponent
    /// <summary>
    /// Gets or sets the text label displayed on the button and used for the aria-label.
    /// Defaults to a localized "Search" value.
    /// </summary>
    [Parameter] public string? Label { get; set; }
     /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Label ??= Localizer["RzSearchButton.DefaultLabel"];
        if (string.IsNullOrEmpty(Element))
            Element = "button"; // Set the root element tag
    }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Ensure default is applied if parameter becomes null after initialization
        Label ??= Localizer["RzSearchButton.DefaultLabel"];
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzSearchButton.Button);
    }
}
</file>

<file path="Components/Layout/RzSearchButton/Styling/DefaultRzSearchButtonStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzSearchButton. </summary>
public class DefaultRzSearchButtonStyles : RzStylesBase.RzSearchButtonStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzSearchButtonStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzSearchButtonStyles(RzTheme theme) : base(theme)
    {
    }
	/// <inheritdoc />
	public override string Button =>
        "flex h-10 w-full cursor-pointer items-center justify-between border-outline bg-secondary p-2 px-4 font-light transition-all duration-200 rounded-theme border"; // Use semantic names & rounded-theme
	/// <inheritdoc />
	public override string InnerContainer => "flex items-center gap-2";
	/// <inheritdoc />
	public override string IconSpan => "text-xl";
}
</file>

<file path="Components/Layout/RzStep/RzStep.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
namespace RizzyUI;
/// <xmldoc>
///     Represents the data definition for a single step within an <see cref="RzSteps" /> component.
///     This component registers its parameters with the parent <see cref="RzSteps" /> component during initialization.
///     It does not render any HTML directly; the parent <see cref="RzSteps" /> component is responsible for rendering
///     based on the collected data.
/// </xmldoc>
public class RzStep : ComponentBase // Doesn't need RzComponent base as it renders nothing itself
{
    /// <summary> Gets or sets the main text label describing the step. Required. </summary>
    [Parameter] [EditorRequired] public string Label { get; set; } = string.Empty;
    /// <summary> Gets or sets the current status of the step (Completed, Current, or Upcoming). Required. </summary>
    [Parameter] [EditorRequired] public StepStatus Status { get; set; } = StepStatus.Upcoming;
    /// <summary>
    ///     Gets or sets an optional ARIA label for the step, providing more context for accessibility. If not provided,
    ///     the <see cref="Label" /> is typically used by the parent component.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }
    /// <summary>
    ///     Gets or sets optional caption text displayed below the step label (rendered by the parent
    ///     <see cref="RzSteps" /> component).
    /// </summary>
    [Parameter] public string? Caption { get; set; }
    /// <summary>
    ///     Gets or sets an optional Blazicon SVG icon to display within the step indicator instead of a number or
    ///     checkmark.
    /// </summary>
    [Parameter] public SvgIcon? Icon { get; set; }
    /// <summary> Gets the parent <see cref="RzSteps" /> component via cascading parameter. </summary>
    [CascadingParameter] private RzSteps? ParentSteps { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentSteps is not null)
            // Create the StepData record from parameters and register it with the parent
            ParentSteps.RegisterStep(new StepData(Label, Status, AriaLabel, Caption, Icon));
        else
            // Ensure the component is used correctly within the hierarchy
            throw new InvalidOperationException(
                $"{nameof(RzStep)} must be used as a child of an {nameof(RzSteps)} component.");
    }
}
</file>

<file path="Components/Layout/RzStep/RzSteps.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()" aria-label="@AriaLabel">

	<CascadingValue Value="this" IsFixed="true">
		@ChildContent
	</CascadingValue>

	@for (var i = 0; i < Items.Count; i++)
	{
		var step = Items[i];
		var isFirst = i == 0;
		var prevStep = isFirst ? null : Items[i - 1];
		var effectiveAriaLabel = string.IsNullOrEmpty(step.AriaLabel) ? step.Label : step.AriaLabel;
        var isCurrent = step.Status == StepStatus.Current;

		<li class="@GetStepItemCss(isFirst)" aria-label="@effectiveAriaLabel" aria-current="@(isCurrent ? "step" : null)">

			@if (!isFirst && prevStep != null)
			{
				<span class="@Theme.RzSteps.GetConnectorCss(Orientation, prevStep.Status, ActiveColor)" aria-hidden="true"></span>
			}

			<div class="@Theme.RzSteps.StepContentContainer">
				@if (step.Status == StepStatus.Completed)
				{
					<span class="@Theme.RzSteps.CircleCompletedBase @Theme.RzSteps.GetCircleCompletedCss(ActiveColor)">
						@if (step.Icon is not null)
						{
							<Blazicon Svg="step.Icon" class="@Theme.RzSteps.CircleCompletedIcon" aria-hidden="true"/>
						}
						else
						{
							<svg class="@Theme.RzSteps.CircleCompletedIcon" xmlns="http://www.w3.org/2000/svg" fill="none"
							     viewBox="0 0 24 24" stroke-width="3" stroke="currentColor" aria-hidden="true">
								<path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5"/>
							</svg>
						}
                        <span class="@Theme.RzSteps.CircleCompletedSrText">@Localizer["RzSteps.CompletedStepSrText"]</span>
					</span>
				}
				else
				{
					<span class="@Theme.RzSteps.CircleDefaultBase @Theme.RzSteps.GetCircleDefaultCss(step.Status, ActiveColor)">
						@if (step.Icon is not null)
						{
							<Blazicon Svg="step.Icon" class="@Theme.RzSteps.CircleDefaultIcon" aria-hidden="true"/>
						}
						else
						{
							@(i + 1)
						}
					</span>
				}
				@if (ShowLabels && !string.IsNullOrEmpty(step.Label))
				{
					<span class="@Theme.RzSteps.LabelBase @Theme.RzSteps.GetLabelStatusCss(step.Status, ActiveColor)">@step.Label</span>
				}
			</div>

			@if (!string.IsNullOrEmpty(step.Caption))
           {
               <span class="@Theme.RzSteps.Caption">@step.Caption</span>
           }
		</li>
	}
</HtmlElement>
</file>

<file path="Components/Layout/RzStep/RzSteps.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A component that displays a sequence of steps, visually indicating progress through a process.
///     Child <see cref="RzStep" /> components automatically register their data.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSteps : RzComponent
{
    /// <summary>
    ///     Gets the list of step data to display. Populated by child <see cref="RzStep" /> components or directly via
    ///     parameter.
    /// </summary>
    [Parameter]
    public List<StepData> Items { get; set; } = new();
    /// <summary> Gets or sets the orientation (Horizontal or Vertical). Defaults to Horizontal. </summary>
    [Parameter]
    public Orientation Orientation { get; set; } = Orientation.Horizontal;
    /// <summary> Gets or sets a value indicating whether step labels are shown. Defaults to true. </summary>
    [Parameter]
    public bool ShowLabels { get; set; } = true;
    /// <summary> Gets or sets the ARIA label for the steps container. Defaults to localized "Steps progress indicator". </summary>
    [Parameter]
    public string? AriaLabel { get; set; }
    /// <summary> Gets or sets the active color used for completed and current steps. Defaults to Primary. </summary>
    [Parameter]
    public StatusColor ActiveColor { get; set; } = StatusColor.Primary;
    /// <summary> The child content, expected to be <see cref="RzStep" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        AriaLabel ??= Localizer["RzSteps.DefaultAriaLabel"];
        if (string.IsNullOrEmpty(Element))
            Element = "ol";
    }
     /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        AriaLabel ??= Localizer["RzSteps.DefaultAriaLabel"];
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzSteps.Container,
            Theme.RzSteps.GetOrientationCss(Orientation));
    }
    /// <summary> Registers step data. Called by child <see cref="RzStep" /> components. </summary>
    internal void RegisterStep(StepData data)
    {
        // Avoid adding if already present during potential re-renders
        if (!Items.Exists(i => i.Label == data.Label && i.Caption == data.Caption)) // Check more fields for uniqueness
        {
            Items.Add(data);
            InvokeAsync(StateHasChanged); // Update UI after adding
        }
    }
    /// <summary> Gets the combined CSS classes for a step list item, considering if it's the first item. </summary>
    /// <param name="isFirst">Indicates if the item is the first in the list.</param>
    /// <returns>A string of CSS classes.</returns>
    protected string GetStepItemCss(bool isFirst)
    {
        return $"{Theme.RzSteps.StepItem} {Theme.RzSteps.GetStepItemWidthCss(isFirst)}";
    }
}
</file>

<file path="Components/Layout/RzStep/StepData.cs">
using Blazicons;
namespace RizzyUI;
/// <xmldoc>
///     Represents the data for a single step.
/// </xmldoc>
public record StepData
{
	/// <summary>
	///     Initializes a new instance of the <see cref="StepData" /> record.
	/// </summary>
	/// <param name="label">The label text for the step.</param>
	/// <param name="status">The status of the step.</param>
	/// <param name="ariaLabel">The optional ARIA label for accessibility.</param>
	/// <param name="caption">The optional caption displayed under the step.</param>
	/// <param name="icon">The optional icon to display in place of the step number.</param>
	public StepData(string label, StepStatus status, string? ariaLabel, string? caption, SvgIcon? icon)
    {
        Label = label;
        Status = status;
        AriaLabel = ariaLabel;
        Caption = caption;
        Icon = icon;
    }
	/// <summary>
	///     Gets the label text for the step.
	/// </summary>
	public string Label { get; init; }
	/// <summary>
	///     Gets the status of the step (Completed, Current, or Upcoming).
	/// </summary>
	public StepStatus Status { get; init; }
	/// <summary>
	///     Gets the optional ARIA label for accessibility. If not provided, the Label is used.
	/// </summary>
	public string? AriaLabel { get; init; }
	/// <summary>
	///     Gets the optional caption text (a small muted text displayed under the step).
	/// </summary>
	public string? Caption { get; init; }
	/// <summary>
	///     Gets the optional icon to display instead of the step number.
	/// </summary>
	public SvgIcon? Icon { get; init; }
}
</file>

<file path="Components/Layout/RzStep/StepStatus.cs">
namespace RizzyUI;
/// <xmldoc>
///     Specifies the status of a step in the Steps component.
/// </xmldoc>
public enum StepStatus
{
    /// <summary>Step is complete.</summary>
    Completed,
    /// <summary>Step is the current active step.</summary>
    Current,
    /// <summary>Step is upcoming.</summary>
    Upcoming
}
</file>

<file path="Components/Layout/RzStep/Styling/DefaultRzStepsStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzSteps. </summary>
public class DefaultRzStepsStyles : RzStylesBase.RzStepsStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzStepsStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzStepsStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "flex gap-2"; // Base flex container
    /// <inheritdoc />
    public override string StepItem => "flex items-center relative text-sm"; // Styles for each <li>
    /// <inheritdoc />
    public override string ConnectorBase => ""; // Base connector, specific styles added by GetConnectorCss
    /// <inheritdoc />
    public override string StepContentContainer => "flex items-center gap-2"; // Container for circle + label
    /// <inheritdoc />
    public override string CircleCompletedBase =>
        "flex size-6 items-center justify-center rounded-full border"; // Base completed circle
    /// <inheritdoc />
    public override string CircleCompletedIcon => "size-4";
    /// <inheritdoc />
    public override string CircleCompletedSrText => "sr-only";
    /// <inheritdoc />
    public override string CircleDefaultBase =>
        "flex size-6 shrink-0 items-center justify-center rounded-full border"; // Base default circle
    /// <inheritdoc />
    public override string CircleDefaultIcon => "size-4"; // Size for the default icon within the circle
    /// <inheritdoc />
    public override string LabelBase => "hidden w-max sm:inline"; // Base label style (hidden on small screens)
    /// <inheritdoc />
    public override string Caption =>
        "text-xs text-muted-foreground mt-1"; // Style for caption, added top margin
    /// <inheritdoc />
    public override string GetOrientationCss(Orientation orientation)
    {
        return orientation switch
        {
            Orientation.Horizontal => "w-full items-start", // Horizontal layout adjustments, align items start
            Orientation.Vertical => "w-min flex-col gap-14", // Vertical layout adjustments
            _ => GetOrientationCss(Orientation.Horizontal)
        };
    }
    /// <inheritdoc />
    public override string GetStepItemWidthCss(bool isFirst)
    {
        return isFirst ? "" : "w-full";
        // Make non-first items take full width in horizontal
    }
    /// <inheritdoc />
    public override string GetConnectorCss(Orientation orientation, StepStatus previousStatus, StatusColor activeColor)
    {
        var isActive = previousStatus == StepStatus.Completed || previousStatus == StepStatus.Current;
        var colorClass = isActive ? GetActiveBackgroundClass(activeColor) : "bg-outline dark:bg-outline";
        var positionAndSize = orientation == Orientation.Vertical
            ? "absolute bottom-8 left-3 h-10 w-0.5" // Vertical positioning
            : "h-0.5 flex-1 mx-2"; // Horizontal positioning, added margin
        return $"{positionAndSize} {colorClass}";
    }
    /// <inheritdoc />
    public override string GetCircleCompletedCss(StatusColor activeColor)
    {
        return
            $"{GetActiveBorderClass(activeColor)} {GetActiveBackgroundClass(activeColor)} {GetActiveTextClass(activeColor)}";
    }
    /// <inheritdoc />
    public override string GetCircleDefaultCss(StepStatus status, StatusColor activeColor)
    {
        // Use theme variables for focus ring color if possible, otherwise fallback
        string focusRingColorClass = activeColor switch
        {
            StatusColor.Primary => "focus-visible:ring-primary dark:focus-visible:ring-primary",
            StatusColor.Secondary => "focus-visible:ring-secondary dark:focus-visible:ring-secondary",
            StatusColor.Success => "focus-visible:ring-success dark:focus-visible:ring-success",
            StatusColor.Info => "focus-visible:ring-info dark:focus-visible:ring-info",
            StatusColor.Warning => "focus-visible:ring-warning dark:focus-visible:ring-warning",
            StatusColor.Destructive => "focus-visible:ring-destructive dark:focus-visible:ring-destructive",
            _ => "focus-visible:ring-primary dark:focus-visible:ring-primary"
        };
        return status switch
        {
            StepStatus.Current =>
                $"border {GetActiveBorderClass(activeColor)} {GetActiveBackgroundClass(activeColor)} font-bold {GetActiveTextClass(activeColor)} focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 {focusRingColorClass}",
            StepStatus.Upcoming => "border border-outline bg-secondary font-medium text-foreground focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-primary dark:focus-visible:ring-offset-surface-dark",
            _ => GetCircleDefaultCss(StepStatus.Upcoming, activeColor) // Default to upcoming style
        };
    }
    /// <inheritdoc />
    public override string GetLabelStatusCss(StepStatus status, StatusColor activeColor)
    {
        return status switch
        {
             // Use theme colors for text, potentially different for dark mode
            StepStatus.Completed => GetActiveTextColorClass(activeColor),
            StepStatus.Current => $"font-bold {GetActiveTextColorClass(activeColor)}",
            StepStatus.Upcoming => "text-foreground dark:text-foreground",
            _ => GetLabelStatusCss(StepStatus.Upcoming, activeColor)
        };
    }
    // Helper methods to get active color classes based on StatusColor
    private string GetActiveBackgroundClass(StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "bg-primary",
            StatusColor.Secondary => "bg-secondary",
            StatusColor.Success => "bg-success dark:bg-success", // Assume dark bg exists
            StatusColor.Info => "bg-info dark:bg-info",       // Assume dark bg exists
            StatusColor.Warning => "bg-warning dark:bg-warning", // Assume dark bg exists
            StatusColor.Destructive => "bg-destructive dark:bg-destructive",   // Assume dark bg exists
            _ => GetActiveBackgroundClass(StatusColor.Primary)
        };
    }
    private string GetActiveBorderClass(StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "border-primary",
            StatusColor.Secondary => "border-secondary",
            StatusColor.Success => "border-success dark:border-success",
            StatusColor.Info => "border-info dark:border-info",
            StatusColor.Warning => "border-warning dark:border-warning",
            StatusColor.Destructive => "border-destructive dark:border-destructive",
            _ => GetActiveBorderClass(StatusColor.Primary)
        };
    }
    private string GetActiveTextClass(StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "text-primary-foreground",
            StatusColor.Secondary => "text-secondary-foreground",
            StatusColor.Success => "text-success-foreground dark:text-success-foreground", // Assume dark text exists
            StatusColor.Info => "text-info-foreground dark:text-info-foreground",          // Assume dark text exists
            StatusColor.Warning => "text-warning-foreground dark:text-warning-foreground", // Assume dark text exists
            StatusColor.Destructive => "text-destructive-foreground dark:text-destructive-foreground",     // Assume dark text exists
            _ => GetActiveTextClass(StatusColor.Primary)
        };
    }
     private string GetActiveTextColorClass(StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "text-primary dark:text-primary",
            StatusColor.Secondary => "text-secondary dark:text-secondary",
            StatusColor.Success => "text-success dark:text-success",
            StatusColor.Info => "text-info dark:text-info",
            StatusColor.Warning => "text-warning dark:text-warning",
            StatusColor.Destructive => "text-destructive dark:text-destructive",
            _ => GetActiveTextColorClass(StatusColor.Primary)
        };
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<CascadingValue Value="this">
	<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()" aria-label="breadcrumb">

		@ChildContent
		<ol class="@Theme.RzBreadcrumb.List">
			@foreach (var item in Items)
			{
				<li class="@Theme.RzBreadcrumbItem.ListItem">

					@item.Content
					@if (item != Items.Last())
					{
						<Blazicon Svg="Separator"/>
					}
				</li>
			}
		</ol>
	</HtmlElement>
</CascadingValue>
</file>

<file path="Components/Navigation/RzBreadcrumb/RzBreadcrumb.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a breadcrumb navigation component that displays a list of navigation links.
///     Styling is determined by the active <see cref="RzTheme" />. Child <see cref="RzBreadcrumbItem" />
///     components register themselves with this parent.
/// </xmldoc>
public partial class RzBreadcrumb : RzComponent
{
    /// <summary> Gets the list of breadcrumb items registered with this breadcrumb component. </summary>
    protected readonly List<RzBreadcrumbItem> Items = new();
    /// <summary> Specifies the Blazicon SVG icon to use as a separator between items. Defaults to ChevronRight. </summary>
    [Parameter]
    public SvgIcon Separator { get; set; } = MdiIcon.ChevronRight;
    /// <summary> Child content for the breadcrumb component, should contain <see cref="RzBreadcrumbItem" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> The HTML element to render this component as. Defaults to "nav". </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav"; // Default element for a breadcrumb
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzBreadcrumb.Container);
    }
    /// <summary>
    ///     Registers a breadcrumb item with this breadcrumb component. Called by child items.
    /// </summary>
    /// <param name="item">The breadcrumb item to register.</param>
    internal void RegisterItem(RzBreadcrumbItem item)
    {
        if (!Items.Contains(item)) // Prevent duplicate registration
        {
            Items.Add(item);
            InvokeAsync(StateHasChanged); // Update UI when items are added
        }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/RzBreadcrumbItem.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
namespace RizzyUI;
/// <xmldoc>
///     Represents an individual item within a <see cref="RzBreadcrumb" /> navigation component.
///     It renders either a link or a span depending on its `IsActive` state.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public class RzBreadcrumbItem : RzComponent // Inherit RzComponent for potential future use, though no root element here
{
    /// <summary> Gets or sets the parent <see cref="RzBreadcrumb" /> component. </summary>
    [CascadingParameter]
    private RzBreadcrumb? ParentBreadcrumb { get; set; }
    /// <summary> The URL that the breadcrumb item links to (ignored if IsActive is true). Defaults to "#". </summary>
    [Parameter]
    public string Href { get; set; } = "#";
    /// <summary> The display text of the breadcrumb item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Label { get; set; } = string.Empty;
    /// <summary>
    ///     Indicates whether this breadcrumb item represents the current page. If true, renders as a span; otherwise,
    ///     renders as a link.
    /// </summary>
    [Parameter]
    public bool IsActive { get; set; }
    /// <summary> An optional Blazicon SVG icon to display instead of the text label. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary>
    ///     Gets the RenderFragment content to be rendered by the parent <see cref="RzBreadcrumb" />.
    ///     This dynamically creates either an anchor or a span based on the IsActive state.
    /// </summary>
    internal RenderFragment Content => builder =>
    {
        var styles = Theme.RzBreadcrumbItem; // Access styles via Theme
        if (!IsActive)
        {
            builder.OpenElement(0, "a");
            builder.AddAttribute(1, "href", Href);
            builder.AddMultipleAttributes(2, AdditionalAttributes); // Apply extra attributes to the link
            builder.AddAttribute(3, "class", styles.Link); // Apply link styles
            RenderInnerContent(builder, styles);
            builder.CloseElement(); // a
        }
        else
        {
            builder.OpenElement(0, "span");
            builder.AddAttribute(1, "class", styles.ActiveSpan); // Apply active span styles
            builder.AddAttribute(2, "aria-current", "page");
            builder.AddMultipleAttributes(3, AdditionalAttributes); // Apply extra attributes to the span
            RenderInnerContent(builder, styles);
            builder.CloseElement(); // span
        }
    };
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (ParentBreadcrumb == null)
            throw new InvalidOperationException(
                $"{nameof(RzBreadcrumbItem)} must be used within an {nameof(RzBreadcrumb)} component.");
        ParentBreadcrumb.RegisterItem(this);
    }
    /// <summary>
    ///     Helper method to render the icon or label content.
    /// </summary>
    private void RenderInnerContent(RenderTreeBuilder builder, RzStylesBase.RzBreadcrumbItemStylesBase styles)
    {
        if (Icon != null)
        {
            builder.OpenElement(4, "span");
            builder.AddAttribute(5, "class", styles.IconSpan); // Apply icon span styles
            builder.OpenComponent<Blazicon>(6);
            builder.AddAttribute(7, "Svg", Icon);
            builder.CloseComponent(); // Blazicon
            builder.CloseElement(); // span
        }
        else
        {
            builder.AddContent(8, Label);
        }
    }
}
</file>

<file path="Components/Navigation/RzBreadcrumb/Styling/DefaultRzBreadcrumbStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzBreadcrumb component.
/// </summary>
public class DefaultRzBreadcrumbStyles : RzStylesBase.RzBreadcrumbStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzBreadcrumbStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzBreadcrumbStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => "text-sm font-medium text-primary-foreground mb-4"; // Adjusted color
    /// <inheritdoc />
    public override string List => "flex flex-wrap items-center gap-1";
}
/// <summary>
///     Provides the default styles for the RzBreadcrumbItem component.
/// </summary>
public class DefaultRzBreadcrumbItemStyles : RzStylesBase.RzBreadcrumbItemStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzBreadcrumbItemStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzBreadcrumbItemStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string ListItem => "flex items-center gap-1 text-foreground";
    /// <inheritdoc />
    public override string Link =>
        "text-foreground hover:text-foreground dark:hover:text-foreground";
    /// <inheritdoc />
    public override string ActiveSpan => "font-bold text-foreground";
    /// <inheritdoc />
    public override string IconSpan => "text-xl";
}
</file>

<file path="Components/Navigation/RzDropdown/RzDropdown.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="div" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	<div x-data="rzDropdown" data-alpine-root="@Id" data-anchor="@Anchor.ToString().ToLowerInvariant()" class="@Theme.RzDropdown.RelativeWrapper">
		<div
			class="@Theme.RzDropdown.TriggerWrapper"
			aria-haspopup="true"
			x-bind:aria-expanded="dropdownOpen"
			x-on:click="toggleDropdown"
			x-on:keydown.space.prevent="openWithKeyboard"
			x-on:keydown.enter.prevent="openWithKeyboard"
			x-on:keydown.down.prevent="openWithKeyboard"
			x-on:keydown.esc.window="closeDropdown">
			<div>@Trigger</div>
		</div>
		<div x-cloak
		     x-show="dropdownOpen"
		     x-transition:enter="transition ease-out duration-100"
		     x-transition:enter-start="opacity-0 scale-90"
		     x-transition:enter-end="opacity-100 scale-100"
		     x-transition:leave="transition ease-in duration-75"
		     x-transition:leave-start="opacity-100 scale-100"
		     x-transition:leave-end="opacity-0 scale-90"
		     x-on:click.outside="closeDropdown"
		     x-trap="openedWithKeyboard"
		     x-on:keydown.down.prevent="focusWrapNext" x-on:keydown.up.prevent="focusWrapPrevious"
		     role="menu"
		     aria-labelledby="rz-dropdown-trigger"
		     class="@Theme.RzDropdown.MenuContainer"
		     x-bind:class="anchorCss">
			<div class="@Theme.RzDropdown.MenuInnerContainer">
				@Content
			</div>
		</div>
	</div>
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/RzDropdown.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a dropdown component with a customizable trigger and content area.
///     It manages its open/close state and keyboard navigation via Alpine.js.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDropdown : RzComponent
{
    /// <summary> Gets or sets the render fragment that defines the dropdown trigger. Required. </summary>
    [Parameter]
    [EditorRequired]
    public RenderFragment? Trigger { get; set; }
    /// <summary> Gets or sets the render fragment that defines the dropdown content. Required. </summary>
    [Parameter]
    [EditorRequired]
    public RenderFragment? Content { get; set; }
    /// <summary> Gets or sets the point on the trigger where the dropdown menu attaches. Defaults to BottomCenter. </summary>
    [Parameter]
    public AnchorPoint Anchor { get; set; } = AnchorPoint.BottomCenter;
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzDropdown.Container);
        // Apply base style from theme
    }
}
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownMenuItem.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<a role="menuitem" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()" x-on:click="closeDropdown" tabindex="0">
	@if (Icon != null)
	{
		<span class="@Theme.RzDropdownMenuItem.IconSpan"><Blazicon Svg="@Icon" class="@Theme.RzDropdownMenuItem.Icon"/></span>
	}
	<span class="@Theme.RzDropdownMenuItem.TitleSpan">@Title</span>
	@if (Count != null)
	{
		<div class="@Theme.RzDropdownMenuItem.CountDiv">
			@Count
		</div>
	}
</a>
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownMenuItem.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a clickable menu item within an <see cref="RzDropdownSection" />.
///     Clicking this item typically closes the parent dropdown via Alpine.js.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDropdownMenuItem : RzComponent
{
    /// <summary> Gets or sets the optional Blazicon SVG icon to display before the title. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Gets or sets the title text of the menu item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Title { get; set; } = "Untitled";
    /// <summary> Gets or sets an optional numeric count to display as a badge alongside the title. </summary>
    [Parameter]
    public int? Count { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzDropdownMenuItem.MenuItem);
    }
}
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownSection.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzDropdown/RzDropdownSection.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container component used to group related <see cref="RzDropdownMenuItem" /> components within an
///     <see cref="RzDropdown" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDropdownSection : RzComponent
{
    /// <summary> Gets or sets the child content for this dropdown section, typically <see cref="RzDropdownMenuItem" />s. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzDropdownSection.Section);
    }
}
</file>

<file path="Components/Navigation/RzDropdown/Styling/DefaultRzDropdownStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzDropdown. </summary>
public class DefaultRzDropdownStyles : RzStylesBase.RzDropdownStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzDropdownStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzDropdownStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // Root container has no specific style by default
    /// <inheritdoc />
    public override string RelativeWrapper => "relative inline-block";
    /// <inheritdoc />
    public override string TriggerWrapper => "inline-flex items-center justify-center space-x-2";
    /// <inheritdoc />
    public override string MenuContainer => "z-60 absolute w-64 rounded-theme shadow-xl dark:shadow-gray-900";
    /// <inheritdoc />
    public override string MenuInnerContainer =>
        "border border-outline divide-y divide-outline rounded-theme bg-background ring-black dark:divide-outline"; // Simplified ring
}
/// <summary> Provides default styles for RzDropdownSection. </summary>
public class DefaultRzDropdownSectionStyles : RzStylesBase.RzDropdownSectionStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzDropdownSectionStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzDropdownSectionStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Section => "space-y-1 p-2.5";
}
/// <summary> Provides default styles for RzDropdownMenuItem. </summary>
public class DefaultRzDropdownMenuItemStyles : RzStylesBase.RzDropdownMenuItemStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzDropdownMenuItemStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzDropdownMenuItemStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string MenuItem =>
        "group flex items-center justify-between space-x-2 rounded-theme cursor-pointer border border-transparent px-2.5 py-2 text-sm font-medium text-foreground hover:bg-primary/10 hover:text-primary focus-visible:bg-primary/10 focus-visible:text-foreground focus-visible:outline-hidden dark:hover:bg-secondary dark:focus-visible:bg-primary/10 dark:focus-visible:text-foreground";
    /// <inheritdoc />
    public override string IconSpan => "text-xl";
    /// <inheritdoc />
    public override string Icon => "size-5 flex-none opacity-25 group-hover:opacity-50";
    /// <inheritdoc />
    public override string TitleSpan => "grow";
    /// <inheritdoc />
    public override string CountDiv =>
        "inline-flex rounded-full border px-1.5 py-0.5 text-xs font-semibold border-outline"; // Added border color
}
</file>

<file path="Components/Navigation/RzLink/RzLink.razor">
@namespace RizzyUI
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="AdditionalAttributes" href="@Href" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Navigation/RzLink/RzLink.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
// For Dictionary
namespace RizzyUI;
/// <xmldoc>
///     Represents a styled link component that renders an anchor (<c>a</c>) element.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzLink : RzComponent
{
    /// <summary> Gets or sets the URL to which the link navigates. If null or empty, defaults to "#". </summary>
    [Parameter]
    public string? Href { get; set; } 
    /// <summary> Gets or sets whether the link should be underlined on hover and focus. Defaults to true. </summary>
    [Parameter]
    public bool Underline { get; set; } = true;
    /// <summary> Gets or sets the content to be displayed inside the link (e.g., text or icons). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    /// Sets default element to <c>a</c> for the link component.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "a"; // Set the root element tag to <a> for links
    }
    /// <summary>
    /// Invoked when a component's parameters have been set or updated.
    /// Updates the <c>Href</c> parameter to a default value if it has not been specified.
    /// </summary>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Href ??= "#";
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzLink;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Link,
            Underline ? styles.UnderlineEnabled : "");
    }
}
</file>

<file path="Components/Navigation/RzLink/Styling/DefaultRzLinkStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzLink component.
/// </summary>
public class DefaultRzLinkStyles : RzStylesBase.RzLinkStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzLinkStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzLinkStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    // Use theme primary color for link, adjust dark mode as needed by theme
    public override string Link => "font-medium text-primary underline-offset-2 focus:outline-hidden dark:text-primary";
    /// <inheritdoc />
    public override string UnderlineEnabled => "hover:underline focus:underline";
}
</file>

<file path="Components/Navigation/RzNavbar/RzNavbar.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    <!-- Navbar Toggle Button (conditionally rendered based on screen size by CSS) -->
    <button type="button" class="@Theme.RzNavbar.ToggleButton" x-on:click="toggleSidebar">
        <div class="@Theme.RzNavbar.ToggleButtonIconContainer">
            <Blazicon Svg="MdiIcon.Menu"/>
        </div>
        <span class="@Theme.RzNavbar.ToggleButtonSrText">@ScreenReaderText</span>
    </button>

    <div class="@Theme.RzNavbar.ContentContainer">
        @ChildContent
    </div>
</HtmlElement>
</file>

<file path="Components/Navigation/RzNavbar/RzNavbar.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a fixed top navigation bar component. Includes a responsive toggle button for mobile sidebars.
///     Styling is determined by the active <see cref="RzTheme" />. Typically used within an <see cref="RzSidebar" />
///     layout.
/// </xmldoc>
public partial class RzNavbar : RzComponent
{
    /// <summary> The content to be displayed inside the navbar (e.g., brand logo, navigation links, user controls). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Screen reader text for the mobile toggle button. Defaults to "Toggle side navigation". </summary>
    [Parameter]
    public string ScreenReaderText { get; set; } = "Toggle side navigation";
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "nav"; // Set the root element tag
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzNavbar.Navbar);
    }
}
</file>

<file path="Components/Navigation/RzNavbar/Styling/DefaultRzNavbarStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzNavbar component.
/// </summary>
public class DefaultRzNavbarStyles : RzStylesBase.RzNavbarStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzNavbarStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzNavbarStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Navbar =>
        "fixed top-0 z-50 h-16 w-screen items-center justify-between border-outline bg-secondary/75 px-4 py-2 backdrop-blur-xl flex border-b";
    /// <inheritdoc />
    public override string ToggleButton => "md:hidden inline-block text-foreground";
    /// <inheritdoc />
    public override string ToggleButtonIconContainer => "text-xl";
    /// <inheritdoc />
    public override string ToggleButtonSrText => "sr-only";
    /// <inheritdoc />
    public override string ContentContainer => "h-full w-full flex items-center justify-between";
}
</file>

<file path="Components/Navigation/RzSidebar/RzSidebar.razor">
@namespace RizzyUI
@inherits RzComponent

<div id="@Id" class="@RootClass()">
    <div x-data="rzSidebar" data-alpine-root="@Id">
        @if (NavbarContent != null)
        {
            @NavbarContent
        }

        <div class="@Theme.RzSidebar.LayoutContainer @Theme.RzSidebar.GetLayoutContainerTopCss(HasNavbar)">
            <div class="@LayoutInnerContainerClass">
                <!-- Skip Link -->
                <a class="@Theme.RzSidebar.SkipLink" href="#@MainContentId">skip to the main content</a>

                <!-- Mobile Overlay -->
                <div x-cloak x-show="showSidebar" class="@Theme.RzSidebar.Overlay" aria-hidden="true" x-on:click="hideSidebar"
                     x-transition.opacity></div>

                <!-- Sidebar -->
                <aside x-cloak class="@Theme.RzSidebar.Sidebar @Theme.RzSidebar.GetSidebarTopCss(HasNavbar)" :class="getSidebarTranslation"
                       aria-label="sidebar navigation">
                    @MenuContent
                </aside>

                <!-- Main Content -->
                <section id="@MainContentId" class="@Theme.RzSidebar.MainContentContainer">
                    <div class="@Theme.RzSidebar.MainContentPadding">
                        @MainContent
                    </div>
                </section>
            </div>
        </div>

        @if (NavbarContent == null)
        {
            <!-- Floating Toggle Button (only if no navbar) -->
            <button class="@Theme.RzSidebar.FloatingToggleButton" x-on:click="toggleSidebar">

                <svg x-show="showSidebar" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"
                     class="size-5" aria-hidden="true">
                    <path
                        d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/>
                </svg>
                <svg x-show="isSidebarHidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"
                     class="size-5" aria-hidden="true">
                    <path
                        d="M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2zm5-1v12h9a1 1 0 0 0 1-1V3a1 1 0 0 0-1-1zM4 2H2a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2z"/>
                </svg>
                <span class="sr-only">sidebar toggle</span>
            </button>
        }
    </div>
</div>
</file>

<file path="Components/Navigation/RzSidebar/RzSidebar.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a responsive layout component with a collapsible sidebar and main content area.
///     Includes a toggle mechanism (via Alpine.js) for small screens and accessibility features.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSidebar : RzComponent
{
    /// <summary> Gets or sets the identifier for the main content area, used for the skip link. Defaults to "main-content". </summary>
    [Parameter]
    public string MainContentId { get; set; } = "main-content";
    /// <summary>
    ///     Optional content for the <see cref="RzNavbar" /> component, rendered above the sidebar/main content. If set,
    ///     adjusts layout spacing.
    /// </summary>
    [Parameter]
    public RenderFragment? NavbarContent { get; set; }
    /// <summary> Content to be rendered inside the sidebar navigation area (typically <see cref="RzSidebarLinks" />). </summary>
    [Parameter]
    public RenderFragment? MenuContent { get; set; }
    /// <summary> The main content to be displayed in the primary content area. </summary>
    [Parameter]
    public RenderFragment? MainContent { get; set; }
    /// <summary> Determines if a Navbar is present. </summary>
    protected bool HasNavbar => NavbarContent != null;
    /// <summary> Gets computed CSS classes for the inner layout container. </summary>
    protected string LayoutInnerContainerClass => "relative flex w-full flex-col md:flex-row"; // Added this wrapper
    /// <summary>
    ///     Gets the root CSS class for the component, merging base styles with additional attributes.
    /// </summary>
    /// <returns>A string representing the CSS classes for the root element.</returns>
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzSidebar.Container);
    }
}
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarLinkItem.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent


@if (Collapsible)
{
    <li class="@Theme.RzSidebarLinkItem.CollapsibleListItem" id="@Id">
        <div data-expanded="@((!Collapsed).ToString().ToLowerInvariant())" x-data="rzSidebarLinkItem"
             data-chevron-expanded-class="@Theme.RzSidebarLinkItem.GetChevronRotationCss(true)"
             data-chevron-collapsed-class="@Theme.RzSidebarLinkItem.GetChevronRotationCss(false)"
             class="@Theme.RzSidebarLinkItem.CollapsibleInnerDiv">
            <button type="button" x-on:click="toggleExpanded" id="@ButtonId" aria-controls="@CollapseId"
                    x-bind:aria-expanded="isExpanded" class="@Theme.RzSidebarLinkItem.CollapsibleButton">
                @if (Icon != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.CollapsibleButtonIconContainer" aria-hidden="true">
                        <Blazicon Svg="@Icon"/>
                    </div>
                }
                <span class="@Theme.RzSidebarLinkItem.CollapsibleButtonTitle">@Title</span>
                @if (TrailerContent != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.CollapsibleButtonTrailer">@TrailerContent</div>
                }
                <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="@Theme.RzSidebarLinkItem.CollapsibleButtonChevron"
                     x-bind:class="getExpandedClass" aria-hidden="true">
                    <path fill-rule="evenodd"
                          d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z"
                          clip-rule="evenodd"/>
                </svg>
            </button>
            <ul x-cloak x-collapse x-show="isExpanded" aria-labelledby="@ButtonId" id="@CollapseId"
                class="@Theme.RzSidebarLinkItem.CollapsibleNestedList">
                <CascadingValue Value="this" IsFixed="true">
                    @ChildContent
                </CascadingValue>
            </ul>
        </div>
    </li>
}
else if (Parent is { HasChildren: true, Collapsible: false }) // Sub-item under non-collapsible parent
{
    <li class="@Theme.RzSidebarLinkItem.SubListItem" id="@Id">
        @if (HasChildren) // Sub-item that itself has children (render as div)
        {
            <div @attributes="AdditionalAttributes" class="@Theme.RzSidebarLinkItem.SubLinkOrDiv">
                @if (Icon != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemIconContainer" aria-hidden="true">
                        <Blazicon Svg="@Icon"/>
                    </div>
                }
                <span class="@Theme.RzSidebarLinkItem.ItemTitle">@Title</span>
                @if (TrailerContent != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemTrailer">@TrailerContent</div>
                }
            </div>
        }
        else // Leaf sub-item (render as link)
        {
            <a @attributes="AdditionalAttributes" href="@Href" target="@Target" class="@Theme.RzSidebarLinkItem.SubLinkOrDiv">
                @if (Icon != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemIconContainer" aria-hidden="true">
                        <Blazicon Svg="@Icon"/>
                    </div>
                }
                <span class="@Theme.RzSidebarLinkItem.ItemTitle">@Title</span>
                @if (TrailerContent != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemTrailer">@TrailerContent</div>
                }
            </a>
        }
        @if (ChildContent != null)
        {
            <ul class="@Theme.RzSidebarLinkItem.NonCollapsibleNestedList">
                <CascadingValue Value="this" IsFixed="true">
                    @ChildContent
                </CascadingValue>
            </ul>
        }
    </li>
}
else // Top-level non-collapsible item
{
    <li class="@Theme.RzSidebarLinkItem.TopLevelListItem" id="@Id">
        @if (HasChildren) // Top-level item with children (render as div)
        {
            <div @attributes="AdditionalAttributes" class="@Theme.RzSidebarLinkItem.TopLevelNonCollapsibleDiv">
                @if (Icon != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemIconContainer" aria-hidden="true">
                        <Blazicon Svg="@Icon"/>
                    </div>
                }
                <span class="@Theme.RzSidebarLinkItem.ItemTitle">@Title</span>
                @if (TrailerContent != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemTrailer">@TrailerContent</div>
                }
            </div>
        }
        else // Top-level leaf item (render as link)
        {
            <a @attributes="AdditionalAttributes" href="@Href" target="@Target" class="@Theme.RzSidebarLinkItem.TopLevelLink">
                @if (Icon != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemIconContainer" aria-hidden="true">
                        <Blazicon Svg="@Icon"/>
                    </div>
                }
                <span class="@Theme.RzSidebarLinkItem.ItemTitle">@Title</span>
                @if (TrailerContent != null)
                {
                    <div class="@Theme.RzSidebarLinkItem.ItemTrailer">@TrailerContent</div>
                }
            </a>
        }
        @if (ChildContent != null)
        {
            <ul class="@Theme.RzSidebarLinkItem.NonCollapsibleNestedList">
                <CascadingValue Value="this" IsFixed="true">
                    @ChildContent
                </CascadingValue>
            </ul>
        }
    </li>
}
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarLinkItem.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
namespace RizzyUI;
/// <xmldoc>
///     Represents a single link item within an <see cref="RzSidebarLinks" /> list. Can be a simple link,
///     a collapsible section header, or a non-collapsible header with nested items.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSidebarLinkItem : RzComponent
{
    private bool _hasChildren;
    /// <summary> Gets the parent <see cref="RzSidebarLinkItem" /> in a hierarchy, if any. </summary>
    [CascadingParameter]
    public RzSidebarLinkItem? Parent { get; set; }
    /// <summary> Gets or sets the Blazicon SVG icon to display for the link item. </summary>
    [Parameter]
    public SvgIcon? Icon { get; set; }
    /// <summary> Gets or sets the title text of the link item. Required. </summary>
    [Parameter]
    [EditorRequired]
    public string Title { get; set; } = string.Empty;
    /// <summary> Gets or sets the URL to navigate to (used if not collapsible and not a header-only item). Defaults to "#". </summary>
    [Parameter]
    public string Href { get; set; } = "#";
    /// <summary> Gets or sets the target attribute for the link (_self, _blank, etc.). </summary>
    [Parameter]
    public string Target { get; set; } = "_self";
    /// <summary> Gets or sets the child content, typically nested <see cref="RzSidebarLinkItem" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets additional content to display after the title (e.g., badges). </summary>
    [Parameter]
    public RenderFragment? TrailerContent { get; set; }
    /// <summary>
    ///     Gets or sets a value indicating whether the link item acts as a collapsible section header. Defaults to
    ///     false.
    /// </summary>
    [Parameter]
    public bool Collapsible { get; set; }
    /// <summary> Gets or sets the initial collapsed state if <see cref="Collapsible" /> is true. Defaults to true. </summary>
    [Parameter]
    public bool Collapsed { get; set; } = true;
    /// <summary> Gets or sets a value indicating whether this link item contains child items. Set automatically by children. </summary>
    protected internal bool HasChildren
    {
        get => _hasChildren;
        set
        {
            if (_hasChildren != value)
            {
                _hasChildren = value;
                StateHasChanged();
            }
        }
    }
    /// <summary> Gets the unique ID for the collapsible button element. </summary>
    protected string ButtonId { get; private set; } = string.Empty;
    /// <summary> Gets the unique ID for the collapsible content element. </summary>
    protected string CollapseId { get; private set; } = string.Empty;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Collapsible)
        {
            var guid = IdGenerator.UniqueId("rzsb"); // Use new prefix
            ButtonId = $"rzbtn-{guid}";
            CollapseId = $"rzclps-{guid}";
        }
        Parent?.NotifyChildAdded(this); // Notify parent
    }
    /// <summary>
    ///     Called by child components to notify the parent that a child has been added.
    /// </summary>
    /// <param name="child">The child <see cref="RzSidebarLinkItem" /> being added.</param>
    internal void NotifyChildAdded(RzSidebarLinkItem child)
    {
        if (!HasChildren) HasChildren = true;
    }
}
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarLinks.razor">
@namespace RizzyUI
@inherits RzComponent

<ul id="@Id" class="@RootClass()">
    @ChildContent
</ul>
</file>

<file path="Components/Navigation/RzSidebar/RzSidebarLinks.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container component for a list of <see cref="RzSidebarLinkItem" />s within an <see cref="RzSidebar" />.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzSidebarLinks : RzComponent
{
    /// <summary> The child content, expected to be <see cref="RzSidebarLinkItem" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzSidebarLinks.List);
    }
}
</file>

<file path="Components/Navigation/RzSidebar/Styling/DefaultRzSidebarStyles.cs">
namespace RizzyUI;
/// <summary>
///     Provides the default styles for the RzSidebar component.
/// </summary>
public class DefaultRzSidebarStyles : RzStylesBase.RzSidebarStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzSidebarStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance to use for styling.</param>
    public DefaultRzSidebarStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // x-data container usually has no specific style
    /// <inheritdoc />
    public override string LayoutContainer => "relative flex w-full flex-col md:flex-row";
    /// <inheritdoc />
    public override string SkipLink => "sr-only";
    /// <inheritdoc />
    // Use semantic surface color with alpha for overlay
    public override string Overlay => "z-30 bg-background/10 fixed inset-0 backdrop-blur-sm md:hidden dark:bg-background/10";
    /// <inheritdoc />
    // Use semantic names for background and border
    public override string Sidebar =>
        "fixed left-0 bottom-0 w-60 overflow-y-auto scrollbar-hover bg-secondary border-r border-outline z-40 p-4 transition-transform duration-300 md:w-60 md:translate-x-0";
    /// <inheritdoc />
    // Use semantic name for background
    public override string MainContentContainer => "md:pl-60 w-full bg-background"; // pl matches sidebar width
    /// <inheritdoc />
    public override string MainContentPadding => "p-4 md:p-6 lg:p-8";
    /// <inheritdoc />
    // Use semantic names for background and text
    public override string FloatingToggleButton =>
        "z-50 fixed right-4 top-4 rounded-full bg-primary p-4 text-primary-foreground md:hidden";
    /// <inheritdoc />
    public override string GetSidebarTopCss(bool hasNavbar)
    {
        return hasNavbar ? "top-16" : "top-0";
        // Adjust based on standard navbar height (h-16)
    }
    /// <inheritdoc />
    public override string GetLayoutContainerTopCss(bool hasNavbar)
    {
        return hasNavbar ? "mt-16" : "";
        // Adjust based on standard navbar height (h-16)
    }
    /// <inheritdoc />
    // Use fixed width value corresponding to 'w-60'
    public override string GetSidebarTranslationCss(bool isVisible)
    {
        return isVisible ? "translate-x-0" : "-translate-x-60";
    }
}
/// <summary> Provides default styles for RzSidebarLinkItem. </summary>
public class DefaultRzSidebarLinkItemStyles : RzStylesBase.RzSidebarLinkItemStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzSidebarLinkItemStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzSidebarLinkItemStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string CollapsibleListItem => ""; // No specific style on the LI itself usually
    /// <inheritdoc />
    public override string CollapsibleInnerDiv => "flex flex-col";
    /// <inheritdoc />
    public override string CollapsibleButton =>
        "flex items-center justify-between rounded-theme gap-2 px-2 py-1.5 text-sm font-medium underline-offset-2 focus:outline-none focus-visible:underline text-foreground hover:bg-primary/5 hover:text-foreground dark:hover:text-foreground dark:hover:bg-primary/5";
    /// <inheritdoc />
    public override string CollapsibleButtonIconContainer => "text-xl";
    /// <inheritdoc />
    public override string CollapsibleButtonTitle => "mr-auto text-left";
    /// <inheritdoc />
    public override string CollapsibleButtonTrailer => "ml-auto";
    /// <inheritdoc />
    public override string CollapsibleButtonChevron => "size-5 transition-transform shrink-0";
    /// <inheritdoc />
    public override string CollapsibleNestedList => ""; // No base style needed, relies on children LI styles
    /// <inheritdoc />
    public override string SubListItem =>
        "border-l px-2 py-0.5 border-outline dark:border-outline transition duration-200 hover:border-l-2 hover:border-outline-strong hover:text-foreground dark:hover:border-outline-strong dark:hover:text-foreground";
    /// <inheritdoc />
    public override string SubLinkOrDiv =>
        "flex items-center gap-2 px-2 py-1.5 text-sm rounded-theme text-foreground underline-offset-2 hover:bg-primary/5 hover:text-foreground focus-visible:underline focus:outline-none dark:hover:bg-primary/5 dark:hover:text-foreground";
    /// <inheritdoc />
    public override string TopLevelListItem => "px-1 py-0.5 first:mt-2";
    /// <inheritdoc />
    public override string TopLevelNonCollapsibleDiv =>
        "flex items-center gap-2 px-2 py-1.5 text-sm font-medium text-foreground underline-offset-2 rounded-theme"; // Similar to link but not a link
    /// <inheritdoc />
    public override string TopLevelLink =>
        "flex items-center gap-2 px-2 py-1.5 text-sm font-medium text-foreground underline-offset-2 hover:bg-primary/5 hover:text-foreground focus-visible:underline focus:outline-none dark:hover:bg-primary/5 dark:hover:text-foreground rounded-theme";
    /// <inheritdoc />
    public override string ItemIconContainer => "text-lg";
    /// <inheritdoc />
    public override string ItemTitle => ""; // Just a span
    /// <inheritdoc />
    public override string ItemTrailer => "ml-auto";
    /// <inheritdoc />
    public override string NonCollapsibleNestedList => "pl-4";
    /// <inheritdoc />
    public override string GetChevronRotationCss(bool isExpanded)
    {
        return isExpanded ? "rotate-180" : "rotate-0";
    }
}
/// <summary> Provides default styles for RzSidebarLinks. </summary>
public class DefaultRzSidebarLinksStyles : RzStylesBase.RzSidebarLinksStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzSidebarLinksStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzSidebarLinksStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string List => "flex flex-col gap-2 pb-6";
}
</file>

<file path="Components/Navigation/RzTab/RzTab.razor">
@inherits RzComponent
@namespace RizzyUI

<button
    id="@TabId"
    data-name="@NameLower"
    data-selectedtextcolor="@SelectedTextColorClass"
    @attributes="AdditionalAttributes"
    x-on:click="tabButtonClicked"
    x-on:keydown="handleKeyDown"
    type="button"
    role="tab"
    :aria-selected="getTabButtonAriaSelected"
    tabindex="0"
    aria-controls="@PanelId"
    class="@RootClass()"
    :class="getSelectedTabTextColorCss">
    @ChildContent
</button>
</file>

<file path="Components/Navigation/RzTab/RzTab.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents a single clickable tab button within an <see cref="RzTabStrip" />.
///     Interacts with the parent <see cref="RzTabs" /> component and Alpine.js to manage selection state.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTab : RzComponent
{
    /// <summary> Gets the parent Tabs component context. </summary>
    [CascadingParameter]
    private RzTabs? Parent { get; set; }
    /// <summary> Gets the parent TabStrip component context. </summary>
    [CascadingParameter]
    private RzTabStrip? TabStrip { get; set; }
    /// <summary>
    ///     The unique name identifier for this tab. Must match the Name of the corresponding <see cref="RzTabPanel" />.
    ///     Required.
    /// </summary>
    [Parameter]
    [EditorRequired]
    public required string Name { get; set; } = default!;
    /// <summary> The content to be displayed inside the tab button (e.g., text, icon). </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets the lowercase name used for data attributes and IDs. </summary>
    protected string NameLower => Name?.ToLowerInvariant() ?? string.Empty;
    /// <summary> Gets the ID for the tab button element. </summary>
    protected string TabId => $"{NameLower}-tab";
    /// <summary> Gets the ID for the corresponding tab panel element. </summary>
    protected string PanelId => $"{NameLower}-panel";
    /// <summary> Gets the CSS class for the selected text color from the parent Tabs. </summary>
    protected string SelectedTextColorClass =>
        Parent?.SelectedTabTextColor.ToTextClass() ?? Theme.Light.Primary.ToCssClassString("text");
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Parent == null)
            throw new InvalidOperationException($"{GetType()} must exist within an RzTabs component.");
        if (TabStrip == null)
            throw new InvalidOperationException($"{GetType()} must exist within an RzTabStrip component.");
        Parent.AddTab(this); // Register with Tabs
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzTab;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Button,
            styles.GetBackgroundColorCss(Parent?.TabBackgroundColor ?? SemanticColor.Surface), // Use parent's BG color
            styles.GetTextColorCss(Parent?.TabTextColor ?? SemanticColor.OnSurface), // Use parent's default text color
            styles.GetJustifyCss(TabStrip?.Justify ?? Justify.Center) // Use strip's justify
        );
    }
}
</file>

<file path="Components/Navigation/RzTab/RzTabPanel.razor">
@inherits RzComponent
@namespace RizzyUI

<div
    id="@PanelId"
    data-name="@NameLower"
    x-show="tabContentActive"
    role="tabpanel"
    aria-labelledby="@TabId"
    tabindex="0"
    class="@Theme.RzTabPanel.OuterContainer"
    x-cloak
>
    <div @attributes="AdditionalAttributes" class="@RootClass()">
        @ChildContent
    </div>
</div>
</file>

<file path="Components/Navigation/RzTab/RzTabPanel.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Represents the content panel associated with a specific <see cref="RzTab" />.
///     It becomes visible when its corresponding tab is selected. Controlled via Alpine.js.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTabPanel : RzComponent
{
    /// <summary> Gets the parent Tabs component context. </summary>
    [CascadingParameter]
    private RzTabs? Parent { get; set; }
    /// <summary>
    ///     The unique name identifier for this panel. Must match the Name of the corresponding <see cref="RzTab" />.
    ///     Required.
    /// </summary>
    [Parameter]
    [EditorRequired]
    public string Name { get; set; } = default!;
    /// <summary> The content to be displayed inside the tab panel when active. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets the lowercase name used for data attributes and IDs. </summary>
    protected string NameLower => Name?.ToLowerInvariant() ?? string.Empty;
    /// <summary> Gets the ID for the corresponding tab button element. </summary>
    protected string TabId => $"{NameLower}-tab";
    /// <summary> Gets the ID for this panel element. </summary>
    protected string PanelId => $"{NameLower}-panel";
    /// <summary> Gets the computed CSS classes for the text color, inheriting from the parent Tabs component. </summary>
    protected string TextColorClass =>
        Theme.RzTabPanel.GetTextColorCss(Parent?.TabTextColor ?? SemanticColor.OnSurface);
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Parent == null)
            throw new InvalidOperationException($"{GetType()} must exist within an RzTabs component.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        // RootClass is now applied to the inner div via the markup
        return TwMerge.Merge(AdditionalAttributes, Theme.RzTabPanel.InnerContainer, TextColorClass);
    }
}
</file>

<file path="Components/Navigation/RzTab/RzTabs.razor">
@inherits RzComponent
@namespace RizzyUI

<CascadingValue Value="this" IsFixed="true">
	<div @attributes="AdditionalAttributes"
	     id="@Id"
         class="@RootClass()">
	    <div
		    data-tabselected="@ActiveTabNameLower"
		    data-buttonref="@ButtonRefId"
		    data-alpine-root="@Id"
		    x-data="rzTabs"
		    x-on:resize.window="handleResize">
		    @Menu

		    <div class="@Theme.RzTabs.PanelsContainer">
			    @TabPanels
		    </div>
	    </div>        
    </div>
</CascadingValue>
</file>

<file path="Components/Navigation/RzTab/RzTabs.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     A container component for managing a set of tabs (<see cref="RzTab" />) and their corresponding content panels (
///     <see cref="RzTabPanel" />).
///     Handles tab selection state and interaction via Alpine.js.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTabs : RzComponent
{
    /// <summary> Internal list holding registered Tab components. </summary>
    internal List<RzTab> _tabs = new();
    /// <summary> The unique ID reference for the tab button container element (<see cref="RzTabStrip" />). </summary>
    internal string ButtonRefId { get; } = IdGenerator.UniqueId("rztabBtns");
    /// <summary> Gets or sets the name of the tab that should be initially selected. If empty, the first tab is selected. </summary>
    [Parameter]
    public string SelectedTabName { get; set; } = string.Empty;
    /// <summary> Gets or sets the text color for non-selected tabs. Defaults to OnSurface. </summary>
    [Parameter]
    public SemanticColor TabTextColor { get; set; } = SemanticColor.OnSurface;
    /// <summary> Gets or sets the text color for the selected tab. Defaults to Primary. </summary>
    [Parameter]
    public SemanticColor SelectedTabTextColor { get; set; } = SemanticColor.Primary;
    /// <summary> Gets or sets the color for the underline marker of the selected tab. Defaults to Primary. </summary>
    [Parameter]
    public SemanticColor SelectedTabUnderlineColor { get; set; } = SemanticColor.Primary;
    /// <summary> Gets or sets the background color for the tabs (applied to individual tabs). Defaults to Surface. </summary>
    [Parameter]
    public SemanticColor TabBackgroundColor { get; set; } = SemanticColor.Surface;
    /// <summary> The required RenderFragment containing the tab menu structure (usually includes <see cref="RzTabStrip" />). </summary>
    [Parameter]
    [EditorRequired]
    public required RenderFragment Menu { get; set; } = default!;
    /// <summary> The required RenderFragment containing the <see cref="RzTabPanel" /> components. </summary>
    [Parameter]
    [EditorRequired]
    public required RenderFragment TabPanels { get; set; } = default!;
    /// <summary> Gets the currently active/selected Tab component. </summary>
    public RzTab? ActiveTab { get; private set; }
    /// <summary> Gets the lowercase name of the active tab for data binding. </summary>
    protected string ActiveTabNameLower => ActiveTab?.Name?.ToLowerInvariant() ?? string.Empty;
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzTabs.Container);
    }
    /// <summary> Registers an <see cref="RzTab" /> component with this container. Called by child tabs. </summary>
    /// <param name="tab">The tab component to register.</param>
    internal void AddTab(RzTab tab)
    {
        if (!_tabs.Contains(tab))
        {
            _tabs.Add(tab);
            // Determine initial active tab
            if (ActiveTab == null && (_tabs.Count == 1 || string.IsNullOrEmpty(SelectedTabName)))
                ActiveTab = tab;
            else if (!string.IsNullOrEmpty(SelectedTabName) &&
                     tab.Name.Equals(SelectedTabName, StringComparison.OrdinalIgnoreCase)) ActiveTab = tab;
            StateHasChanged(); // Update if active tab might have changed
        }
    }
}
</file>

<file path="Components/Navigation/RzTab/RzTabStrip.razor">
@inherits RzComponent
@namespace RizzyUI

<CascadingValue Value="this" IsFixed="true">
    <div id="@Parent?.ButtonRefId"
         role="tablist"
         @attributes="AdditionalAttributes"
         class="@RootClass()">
        @ChildContent

        <div x-ref="tabMarker" class="@Theme.RzTabStrip.Marker @MarkerAfterBackgroundClass" x-cloak>
            <div class="@Theme.RzTabStrip.MarkerInner"></div>
        </div>
    </div>
</CascadingValue>
</file>

<file path="Components/Navigation/RzTab/RzTabStrip.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
// For Count()
namespace RizzyUI;
/// <xmldoc>
///     Represents the container for the clickable tab buttons within an <see cref="RzTabs" /> component.
///     It manages the layout (grid columns, gap) and the visual selection marker.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzTabStrip : RzComponent
{
    /// <summary> Gets the parent Tabs component context. </summary>
    [CascadingParameter]
    private RzTabs? Parent { get; set; }
    /// <summary> Horizontal alignment of tab content within the strip. Defaults to Center. </summary>
    [Parameter]
    public Justify Justify { get; set; } = Justify.Center;
    /// <summary> Gap spacing between tabs. Defaults to Medium. </summary>
    [Parameter]
    public Size SpaceBetween { get; set; } = Size.Medium;
    /// <summary> The child content, expected to be <see cref="RzTab" /> components. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets the computed CSS classes for the marker's ::after background color. </summary>
    protected string MarkerAfterBackgroundClass => Parent != null
        ? Theme.RzTabStrip.GetMarkerAfterBackgroundCss(Parent.SelectedTabUnderlineColor)
        : "";
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (Parent == null)
            throw new InvalidOperationException($"{GetType()} must exist within an RzTabs component.");
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzTabStrip;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Strip,
            Parent?._tabs != null ? styles.GetColumnsCss(Parent._tabs.Count) : "grid-cols-1", // Handle null case
            styles.GetGapCss(SpaceBetween),
            Parent?.TabTextColor.ToTextClass() ?? "" // Inherit text color from Tabs
        );
    }
}
</file>

<file path="Components/Navigation/RzTab/Styling/DefaultRzTabStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzTabs. </summary>
public class DefaultRzTabsStyles : RzStylesBase.RzTabsStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzTabsStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzTabsStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Container => ""; // Base container usually has no style
    /// <inheritdoc />
    public override string PanelsContainer => ""; // Container for panels usually has no specific style
}
/// <summary> Provides default styles for RzTabStrip. </summary>
public class DefaultRzTabStripStyles : RzStylesBase.RzTabStripStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzTabStripStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzTabStripStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Strip => "relative inline-grid select-none items-center";
    /// <inheritdoc />
    public override string Marker =>
        "z-20 opacity-0 absolute pointer-events-none left-0 h-full w-1/2 duration-300 ease-out after:absolute after:left-0 after:bottom-0 after:h-0.5 after:w-full";
    /// <inheritdoc />
    public override string MarkerInner => "h-full w-full"; // Inner div might not need styles
    /// <inheritdoc />
    public override string GetColumnsCss(int tabCount)
    {
        return tabCount switch
        {
            1 => "grid-cols-1", 2 => "grid-cols-2", 3 => "grid-cols-3", 4 => "grid-cols-4",
            5 => "grid-cols-5", 6 => "grid-cols-6", 7 => "grid-cols-7", 8 => "grid-cols-8",
            9 => "grid-cols-9", 10 => "grid-cols-10", 11 => "grid-cols-11", 12 => "grid-cols-12",
            _ => "grid-cols-1" // Fallback or handle more if needed
        };
    }
    /// <inheritdoc />
    public override string GetGapCss(Size spaceBetween)
    {
        return spaceBetween switch
        {
            Size.ExtraSmall => "gap-0", Size.Small => "gap-1", Size.Medium => "gap-2",
            Size.Large => "gap-3", Size.ExtraLarge => "gap-4",
            _ => GetGapCss(Size.Medium)
        };
    }
    /// <inheritdoc />
    public override string GetMarkerAfterBackgroundCss(SemanticColor color)
    {
        return color.ToBackgroundClass("after");
        // Use ColorUtil extension
    }
}
/// <summary> Provides default styles for RzTab. </summary>
public class DefaultRzTabStyles : RzStylesBase.RzTabStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzTabStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzTabStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Button =>
        "z-10 relative inline-flex h-8 px-2 w-full cursor-pointer items-center whitespace-nowrap rounded-theme rounded-b-none font-medium transition-all mr-1";
    /// <inheritdoc />
    public override string GetJustifyCss(Justify justify)
    {
        return justify switch
        {
            Justify.Start => "justify-start", Justify.Center => "justify-center", Justify.End => "justify-end",
            _ => GetJustifyCss(Justify.Center)
        };
    }
    /// <inheritdoc />
    public override string GetTextColorCss(SemanticColor color)
    {
        return color.ToTextClass();
    }
    /// <inheritdoc />
    public override string GetBackgroundColorCss(SemanticColor color)
    {
        return color.ToBackgroundClass();
    }
}
/// <summary> Provides default styles for RzTabPanel. </summary>
public class DefaultRzTabPanelStyles : RzStylesBase.RzTabPanelStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzTabPanelStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzTabPanelStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string OuterContainer => "relative"; // For positioning if needed
    /// <inheritdoc />
    public override string InnerContainer => ""; // Base inner container, padding/bg added via attributes usually
    /// <inheritdoc />
    public override string GetTextColorCss(SemanticColor color)
    {
        return color.ToTextClass();
    }
}
</file>

<file path="Components/Theme/RzDarkMode/RzDarkModeToggle.razor">
@namespace RizzyUI
@using Blazicons
@inherits RzComponent

<HtmlElement Element="@EffectiveElement"
             @attributes="@AdditionalAttributes"
             id="@Id"
             class="@RootClass()"
             type="button"
             aria-label="@Localizer["RzDarkModeToggle.AriaLabel"]">
    <div x-data="rzDarkModeToggle"
         x-on:click="toggle"
         alpine-data-root="@Id"
         :aria-pressed="isDark">
        <div x-show="isLight" x-cloak>
            <Blazicon Svg="@DarkIcon" class="@Theme.RzDarkmodeToggle.Icon"/>
        </div>
        <div x-show="isDark" x-cloak>
            <Blazicon Svg="@LightIcon" class="@Theme.RzDarkmodeToggle.Icon"/>
        </div>
    </div>
</HtmlElement>
</file>

<file path="Components/Theme/RzDarkMode/RzDarkModeToggle.razor.cs">
using Blazicons;
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a button that toggles between light and dark color themes for the application.
///     Interactivity (state management and class toggling on `&lt;html>`) is handled via the `rzDarkModeToggle` Alpine.js
///     component.
///     Styling is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzDarkModeToggle : RzComponent
{
    /// <summary> Icon shown when light mode is active (clicking enables dark mode). Defaults to MoonOutline. </summary>
    [Parameter] public SvgIcon DarkIcon { get; set; } = Ionicon.MoonOutline;
    /// <summary> Icon shown when dark mode is active (clicking enables light mode). Defaults to SunnyOutline. </summary>
    [Parameter] public SvgIcon LightIcon { get; set; } = Ionicon.SunnyOutline;
    /// <summary> Defaults Element to "button" </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "button"; // Set the root element tag
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzDarkmodeToggle.Button);
    }
}
</file>

<file path="Components/Theme/RzDarkMode/Styling/RzDarkModeToggleStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for RzDarkmodeToggle. </summary>
public class DefaultRzDarkmodeToggleStyles : RzStylesBase.RzDarkmodeToggleStylesBase
{
	/// <summary>
	///     Initializes a new instance of the <see cref="DefaultRzDarkmodeToggleStyles" /> class.
	/// </summary>
	/// <param name="theme">The theme instance providing styling context.</param>
	public DefaultRzDarkmodeToggleStyles(RzTheme theme) : base(theme)
    {
    }
	/// <inheritdoc />
	public override string Button =>
        "inline-flex text-xl items-center justify-center p-2 mr-2 rounded-theme transition-colors ease-in-out duration-300 focus:outline-none text-foreground bg-background hover:bg-secondary/75 dark:hover:bg-secondary/75"; // Use semantic names, adjusted hover slightly
	/// <inheritdoc />
	public override string Icon => "transition-transform duration-300 ease-out";
}
</file>

<file path="Components/Theme/RzThemeProvider.cs">
using System.Text;
using Microsoft.AspNetCore.Components;
using Microsoft.AspNetCore.Components.Rendering;
using Microsoft.AspNetCore.Components.Web;
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
// Required for HeadContent
namespace RizzyUI;
/// <summary>
///     A Blazor component that provides the current theme's CSS variables and initial dark mode script
///     into the document head via <see cref="HeadOutlet" />. It also cascades the resolved theme
///     to its child content. If no theme parameter is provided, it uses the default theme specified
///     in <see cref="RizzyUIConfig" /> or falls back to <see cref="RzTheme.Default" />.
/// </summary>
public class RzThemeProvider : ComponentBase
{
    [Inject] private IOptions<RizzyUIConfig>? RizzyConfig { get; set; }
    /// <summary>
    ///     NonceProvider service that provides scoped per-request nonce values to RizzyUI components.
    /// </summary>
    [Inject]
    protected IRizzyNonceProvider RizzyNonceProvider { get; set; } = default!;
    /// <summary>
    ///     Gets or sets the theme to apply. If null, defaults to the theme configured in
    ///     <see cref="RizzyUIConfig.DefaultTheme" /> or <see cref="RzTheme.Default" />.
    /// </summary>
    [Parameter]
    public RzTheme? Theme { get; set; }
    /// <summary>
    ///     Gets or sets the child content to render within the theme provider context.
    ///     The resolved theme will be cascaded to this content.
    /// </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     Builds the render tree for the component, injecting a &lt;style> tag with CSS variables
    ///     and an initial dark mode script into the head via <see cref="HeadContent" />. It also
    ///     renders the <see cref="ChildContent" /> wrapped in a <see cref="CascadingValue{TValue}" />
    ///     providing the resolved <see cref="RzTheme" />.
    /// </summary>
    /// <param name="builder">The <see cref="RenderTreeBuilder" /> used to build the component's output.</param>
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
        // Determine the theme to use based on priority: Parameter > Config > Default
        var actualTheme = Theme ?? RizzyConfig?.Value.DefaultTheme ?? RzTheme.Default;
        // Generate the CSS variables string
        var css = GenerateRootVariables(actualTheme);
        var nonce = RizzyNonceProvider.GetNonce(); // Get nonce once for efficiency
        // Render HeadContent to inject style and script into <head>
        builder.OpenComponent<RzHeadContent>(0);
        builder.AddAttribute(1, "ChildContent", (RenderFragment)(headBuilder =>
        {
            // Inject the style tag with theme variables
            headBuilder.AddMarkupContent(2, $"<style nonce=\"{nonce}\">{css}</style>");
            // Inject the initial dark mode script
            headBuilder.AddMarkupContent(3, $@"<script nonce=""{nonce}"">
                const storedMode = localStorage.getItem('darkMode') ?? 'auto';
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                document.documentElement.classList.toggle('dark', storedMode === 'dark' || (storedMode === 'auto' && prefersDark));
            </script>");
        }));
        builder.CloseComponent(); // Close HeadContent
        // Render ChildContent wrapped in a CascadingValue to provide the theme
        builder.OpenComponent<CascadingValue<RzTheme>>(4); // Use specific type RzTheme
        builder.AddAttribute(5, "Value", actualTheme);
        builder.AddAttribute(6, "IsFixed", true); // Theme instance is fixed for this provider's scope
        builder.AddAttribute(7, "ChildContent", (RenderFragment)(cascadeBuilder =>
        {
            cascadeBuilder.AddContent(8, ChildContent); // Render the actual child content
        }));
        builder.CloseComponent(); // Close CascadingValue<RzTheme>
    }
    /// <summary>
    ///     Generates the CSS variable definitions for the given theme.
    /// </summary>
    /// <param name="theme">The theme to generate variables from.</param>
    /// <returns>A string containing a :root CSS block with the theme variables.</returns>
    private string GenerateRootVariables(RzTheme theme)
    {
        var sb = new StringBuilder();
        sb.AppendLine(":root {");
        // --- Base (Light) Variables ---
        sb.AppendLine($"--color-surface: {theme.Light.Surface.ToCssColorString()};");
        sb.AppendLine($"--color-foreground: {theme.Light.OnSurface.ToCssColorString()};");
        sb.AppendLine($"--color-foreground: {theme.Light.OnSurfaceStrong.ToCssColorString()};");
        sb.AppendLine($"--color-muted-foreground: {theme.Light.OnSurfaceMuted.ToCssColorString()};");
        sb.AppendLine($"--color-secondary: {theme.Light.SurfaceAlt.ToCssColorString()};");
        sb.AppendLine($"--color-surface-tertiary: {theme.Light.SurfaceTertiary.ToCssColorString()};");
        sb.AppendLine($"--color-accent-foreground: {theme.Light.OnSurfaceTertiary.ToCssColorString()};");
        sb.AppendLine($"--color-primary: {theme.Light.Primary.ToCssColorString()};");
        sb.AppendLine($"--color-primary-foreground: {theme.Light.OnPrimary.ToCssColorString()};");
        sb.AppendLine($"--color-secondary: {theme.Light.Secondary.ToCssColorString()};");
        sb.AppendLine($"--color-secondary-foreground: {theme.Light.OnSecondary.ToCssColorString()};");
        sb.AppendLine($"--color-outline: {theme.Light.Outline.ToCssColorString()};");
        sb.AppendLine($"--color-outline-strong: {theme.Light.OutlineStrong.ToCssColorString()};");
        // --- Status Colors (Same for Light/Dark in current definition) ---
        sb.AppendLine($"--color-destructive: {theme.Destructive.ToCssColorString()};");
        sb.AppendLine($"--color-destructive-foreground: {theme.DestructiveForeground.ToCssColorString()};");
        sb.AppendLine($"--color-info: {theme.Info.ToCssColorString()};");
        sb.AppendLine($"--color-info-foreground: {theme.OnInfo.ToCssColorString()};"); // Consistent naming needed
        sb.AppendLine($"--color-warning: {theme.Warning.ToCssColorString()};");
        sb.AppendLine($"--color-warning-foreground: {theme.OnWarning.ToCssColorString()};");
        sb.AppendLine($"--color-success: {theme.Success.ToCssColorString()};");
        sb.AppendLine($"--color-success-foreground: {theme.OnSuccess.ToCssColorString()};");
        // --- Border Variables ---
        sb.AppendLine($"--borderWidth: {theme.BorderWidth};");
        sb.AppendLine($"--borderRadius: {theme.BorderRadius};");
        // --- Highlight.js (Light) Variables ---
        sb.AppendLine($"--highlight-bg: {theme.Light.Code.Background.ToCssColorString()};");
        sb.AppendLine($"--highlight-color: {theme.Light.Code.Color.ToCssColorString()};");
        sb.AppendLine($"--highlight-comment: {theme.Light.Code.Comment.ToCssColorString()};");
        sb.AppendLine($"--highlight-keyword: {theme.Light.Code.Keyword.ToCssColorString()};");
        sb.AppendLine($"--highlight-attribute: {theme.Light.Code.Attribute.ToCssColorString()};");
        sb.AppendLine($"--highlight-symbol: {theme.Light.Code.Symbol.ToCssColorString()};");
        sb.AppendLine($"--highlight-namespace: {theme.Light.Code.Namespace.ToCssColorString()};");
        sb.AppendLine($"--highlight-variable: {theme.Light.Code.Variable.ToCssColorString()};");
        sb.AppendLine($"--highlight-literal: {theme.Light.Code.Literal.ToCssColorString()};");
        sb.AppendLine($"--highlight-punctuation: {theme.Light.Code.Punctuation.ToCssColorString()};");
        sb.AppendLine($"--highlight-deletion: {theme.Light.Code.Deletion.ToCssColorString()};");
        sb.AppendLine($"--highlight-addition: {theme.Light.Code.Addition.ToCssColorString()};");
        // Link highlight variables to Tailwind Prose variables
        sb.AppendLine(".prose {");
        sb.AppendLine("  --tw-prose-code: var(--highlight-color);");
        sb.AppendLine("  --tw-prose-pre-code: var(--highlight-color);"); // Ensure pre code also uses it
        sb.AppendLine("  --tw-prose-pre-bg: var(--highlight-bg);");
        sb.AppendLine("}");
        // --- Dark Mode Overrides
        sb.AppendLine("&:where(.dark, .dark *) {");
        sb.AppendLine($"  --color-surface: {theme.Dark.Surface.ToCssColorString()};");
        sb.AppendLine($"  --color-foreground: {theme.Dark.OnSurface.ToCssColorString()};");
        sb.AppendLine($"  --color-foreground: {theme.Dark.OnSurfaceStrong.ToCssColorString()};");
        sb.AppendLine($"  --color-muted-foreground: {theme.Dark.OnSurfaceMuted.ToCssColorString()};");
        sb.AppendLine($"  --color-secondary: {theme.Dark.SurfaceAlt.ToCssColorString()};");
        sb.AppendLine($"  --color-surface-tertiary: {theme.Dark.SurfaceTertiary.ToCssColorString()};");
        sb.AppendLine($"  --color-accent-foreground: {theme.Dark.OnSurfaceTertiary.ToCssColorString()};");
        sb.AppendLine($"  --color-primary: {theme.Dark.Primary.ToCssColorString()};");
        sb.AppendLine($"  --color-primary-foreground: {theme.Dark.OnPrimary.ToCssColorString()};");
        sb.AppendLine($"  --color-secondary: {theme.Dark.Secondary.ToCssColorString()};");
        sb.AppendLine($"  --color-secondary-foreground: {theme.Dark.OnSecondary.ToCssColorString()};");
        sb.AppendLine($"  --color-outline: {theme.Dark.Outline.ToCssColorString()};");
        sb.AppendLine($"  --color-outline-strong: {theme.Dark.OutlineStrong.ToCssColorString()};");
        // Highlight.js (Dark) Variables
        sb.AppendLine($"  --highlight-bg: {theme.Dark.Code.Background.ToCssColorString()};");
        sb.AppendLine($"  --highlight-color: {theme.Dark.Code.Color.ToCssColorString()};");
        sb.AppendLine($"  --highlight-comment: {theme.Dark.Code.Comment.ToCssColorString()};");
        sb.AppendLine($"  --highlight-keyword: {theme.Dark.Code.Keyword.ToCssColorString()};");
        sb.AppendLine($"  --highlight-attribute: {theme.Dark.Code.Attribute.ToCssColorString()};");
        sb.AppendLine($"  --highlight-symbol: {theme.Dark.Code.Symbol.ToCssColorString()};");
        sb.AppendLine($"  --highlight-namespace: {theme.Dark.Code.Namespace.ToCssColorString()};");
        sb.AppendLine($"  --highlight-variable: {theme.Dark.Code.Variable.ToCssColorString()};");
        sb.AppendLine($"  --highlight-literal: {theme.Dark.Code.Literal.ToCssColorString()};");
        sb.AppendLine($"  --highlight-punctuation: {theme.Dark.Code.Punctuation.ToCssColorString()};");
        sb.AppendLine($"  --highlight-deletion: {theme.Dark.Code.Deletion.ToCssColorString()};");
        sb.AppendLine($"  --highlight-addition: {theme.Dark.Code.Addition.ToCssColorString()};");
        // Note: Status colors (Destructive, Info, etc.) don't have dark overrides in RzTheme current definition
        sb.AppendLine("}"); // Close &:where(...)
        sb.AppendLine("}"); // Close :root
        return sb.ToString();
    }
}
</file>

<file path="Components/Theme/Themes/ArcticTheme.cs">
namespace RizzyUI;
/// <summary>
///     The default theme used for the application, inheriting from <see cref="RzTheme" />.
///     Initializes the theme using the Tailwind color palette via the <see cref="Colors" /> class.
/// </summary>
public class ArcticTheme : RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="RzTheme" /> class with predefined values.
    /// </summary>
    public ArcticTheme() : base("Arctic", "arctic")
    {
        // Light mode colors
        Light = new RzThemeVariant
        {
            Surface = Colors.White, // White
            OnSurface = Colors.Slate.L700, // #334155 (51,65,85)
            OnSurfaceStrong = Colors.Black, // Black
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Slate.L100, // #F1F5F9 (241,245,249)
            SurfaceTertiary = Colors.Slate.L200,
            OnSurfaceTertiary = Colors.Slate.L600,
            Primary = Colors.Blue.L700, // #1D4ED8 (29,78,216)
            OnPrimary = Colors.Slate.L100, // #F1F5F9
            Secondary = Colors.Indigo.L700, // #4338CA (67,56,202)
            OnSecondary = Colors.Slate.L100, // #F1F5F9
            Outline = Colors.Slate.L300, // #CBD5E1 (203,213,225)
            OutlineStrong = Colors.Slate.L800, // #1E293B (30,41,59)
            Code = CodeThemes.Github
        };
        // Dark mode colors
        Dark = new RzThemeVariant
        {
            Surface = Colors.Slate.L900, // #0F172A (15,23,42)
            OnSurface = Colors.Slate.L300, // #CBD5E1 (203,213,225)
            OnSurfaceStrong = Colors.White, // White
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Slate.L800,
            SurfaceTertiary = Colors.Slate.L700,
            OnSurfaceTertiary = Colors.Slate.L300,
            Primary = Colors.Blue.L600, // #2563EB (37,99,235)
            OnPrimary = Colors.Slate.L100, // #F1F5F9
            Secondary = Colors.Indigo.L600, // #4F46E5 (79,70,229)
            OnSecondary = Colors.Slate.L100, // #F1F5F9
            Outline = Colors.Slate.L700, // #334155 (51,65,85)
            OutlineStrong = Colors.Slate.L300, // #CBD5E1 (203,213,225)
            Code = CodeThemes.DefaultDark
        };
        // Status colors
        Destructive = Colors.Red.L600; // #DC2626 (220,38,38)
        DestructiveForeground = Colors.White; // white
        Info = Colors.Sky.L600; // #0284C7 (2,132,199)
        OnInfo = Colors.White; // white
        Warning = Colors.Amber.L500; // #F59E0B (245,158,11)
        OnWarning = Colors.White; // #FFFFFF
        Success = Colors.Green.L600; // #16A34A (22,163,74)
        OnSuccess = Colors.White; // #FFFFFF
        // Borders and radius
        BorderWidth = "1px";
        BorderRadius = "6px";
    }
}
</file>

<file path="Components/Theme/Themes/Code/CodeThemes.cs">
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
namespace RizzyUI;
/// <summary>
///     Provides static RizzyCodeTheme instances for each theme in your JSON.
/// </summary>
public static class CodeThemes
{
    public static RizzyCodeTheme Apathy { get; } = new("#031A16", "#81B5AC", "#2B685E", "#4C963E", "#3E7996", "#96883E",
        "#3E9688", "#883E96", "#963E4C", "#81B5AC", "#3E9688", "#883E96");
    public static RizzyCodeTheme Ashes { get; } = new("#1C2023", "#C7CCD1", "#747C84", "#C795AE", "#C7C795", "#AE95C7",
        "#C7AE95", "#95C7AE", "#95AEC7", "#C7CCD1", "#C7AE95", "#95C7AE");
    public static RizzyCodeTheme AtelierCaveLight { get; } = new("#efecf4", "#585260", "#7e7887", "#955ae7", "#aa573c",
        "#576ddb", "#be4678", "#2a9292", "#398bc6", "#585260", "#be4678", "#2a9292");
    public static RizzyCodeTheme AtelierCave { get; } = new("#19171c", "#8b8792", "#655f6d", "#955ae7", "#aa573c",
        "#576ddb", "#be4678", "#2a9292", "#398bc6", "#8b8792", "#be4678", "#2a9292");
    public static RizzyCodeTheme AtelierDuneLight { get; } = new("#fefbec", "#6e6b5e", "#999580", "#b854d4", "#b65611",
        "#6684e1", "#d73737", "#60ac39", "#1fad83", "#6e6b5e", "#d73737", "#60ac39");
    public static RizzyCodeTheme AtelierDune { get; } = new("#20201d", "#a6a28c", "#7d7a68", "#b854d4", "#b65611",
        "#6684e1", "#d73737", "#60ac39", "#1fad83", "#a6a28c", "#d73737", "#60ac39");
    public static RizzyCodeTheme AtelierEstuaryLight { get; } = new("#f4f3ec", "#5f5e4e", "#878573", "#5f9182",
        "#ae7313", "#36a166", "#ba6236", "#7d9726", "#5b9d48", "#5f5e4e", "#ba6236", "#7d9726");
    public static RizzyCodeTheme AtelierEstuary { get; } = new("#22221b", "#929181", "#6c6b5a", "#5f9182", "#ae7313",
        "#36a166", "#ba6236", "#7d9726", "#5b9d48", "#929181", "#ba6236", "#7d9726");
    public static RizzyCodeTheme AtelierForestLight { get; } = new("#f1efee", "#68615e", "#9c9491", "#6666ea",
        "#df5320", "#407ee7", "#f22c40", "#7b9726", "#3d97b8", "#68615e", "#f22c40", "#7b9726");
    public static RizzyCodeTheme AtelierForest { get; } = new("#1b1918", "#a8a19f", "#766e6b", "#6666ea", "#df5320",
        "#407ee7", "#f22c40", "#7b9726", "#3d97b8", "#a8a19f", "#f22c40", "#7b9726");
    public static RizzyCodeTheme AtelierHeathLight { get; } = new("#f7f3f7", "#695d69", "#9e8f9e", "#7b59c0", "#a65926",
        "#516aec", "#ca402b", "#918b3b", "#159393", "#695d69", "#ca402b", "#918b3b");
    public static RizzyCodeTheme AtelierHeath { get; } = new("#1b181b", "#ab9bab", "#776977", "#7b59c0", "#a65926",
        "#516aec", "#ca402b", "#918b3b", "#159393", "#ab9bab", "#ca402b", "#918b3b");
    public static RizzyCodeTheme AtelierLakesideLight { get; } = new("#ebf8ff", "#516d7b", "#7195a8", "#6b6bb8",
        "#935c25", "#257fad", "#d22d72", "#568c3b", "#2d8f6f", "#516d7b", "#d22d72", "#568c3b");
    public static RizzyCodeTheme AtelierLakeside { get; } = new("#161b1d", "#7ea2b4", "#5a7b8c", "#6b6bb8", "#935c25",
        "#257fad", "#d22d72", "#568c3b", "#2d8f6f", "#7ea2b4", "#d22d72", "#568c3b");
    public static RizzyCodeTheme AtelierPlateauLight { get; } = new("#f4ecec", "#585050", "#7e7777", "#8464c4",
        "#b45a3c", "#7272ca", "#ca4949", "#4b8b8b", "#5485b6", "#585050", "#ca4949", "#4b8b8b");
    public static RizzyCodeTheme AtelierPlateau { get; } = new("#1b1818", "#8a8585", "#655d5d", "#8464c4", "#b45a3c",
        "#7272ca", "#ca4949", "#4b8b8b", "#5485b6", "#8a8585", "#ca4949", "#4b8b8b");
    public static RizzyCodeTheme AtelierSavannaLight { get; } = new("#ecf4ee", "#526057", "#78877d", "#55859b",
        "#9f713c", "#478c90", "#b16139", "#489963", "#1c9aa0", "#526057", "#b16139", "#489963");
    public static RizzyCodeTheme AtelierSavanna { get; } = new("#171c19", "#87928a", "#5f6d64", "#55859b", "#9f713c",
        "#478c90", "#b16139", "#489963", "#1c9aa0", "#87928a", "#b16139", "#489963");
    public static RizzyCodeTheme AtelierSeasideLight { get; } = new("#f4fbf4", "#5e6e5e", "#809980", "#ad2bee",
        "#87711d", "#3d62f5", "#e6193c", "#29a329", "#1999b3", "#5e6e5e", "#e6193c", "#29a329");
    public static RizzyCodeTheme AtelierSeaside { get; } = new("#131513", "#8ca68c", "#687d68", "#ad2bee", "#87711d",
        "#3d62f5", "#e6193c", "#29a329", "#1999b3", "#8ca68c", "#e6193c", "#29a329");
    public static RizzyCodeTheme AtelierSulphurpoolLight { get; } = new("#f5f7ff", "#5e6687", "#898ea4", "#6679cc",
        "#c76b29", "#3d8fd1", "#c94922", "#ac9739", "#22a2c9", "#5e6687", "#c94922", "#ac9739");
    public static RizzyCodeTheme AtelierSulphurpool { get; } = new("#202746", "#979db4", "#6b7394", "#6679cc",
        "#c76b29", "#3d8fd1", "#c94922", "#ac9739", "#22a2c9", "#979db4", "#c94922", "#ac9739");
    public static RizzyCodeTheme Bespin { get; } = new("#28211c", "#8a8986", "#666666", "#9b859d", "#cf7d34", "#5ea6ea",
        "#cf6a4c", "#54be0d", "#afc4db", "#8a8986", "#cf6a4c", "#54be0d");
    public static RizzyCodeTheme Brewer { get; } = new("#0c0d0e", "#b7b8b9", "#737475", "#756bb1", "#e6550d", "#3182bd",
        "#e31a1c", "#31a354", "#80b1d3", "#b7b8b9", "#e31a1c", "#31a354");
    public static RizzyCodeTheme Bright { get; } = new("#000000", "#e0e0e0", "#b0b0b0", "#d381c3", "#fc6d24", "#6fb3d2",
        "#fb0120", "#a1c659", "#76c7b7", "#e0e0e0", "#fb0120", "#a1c659");
    public static RizzyCodeTheme BrushtreesDark { get; } = new("#485867", "#B0C5C8", "#8299A1", "#b386b2", "#d8bba2",
        "#868cb3", "#b38686", "#87b386", "#86b3b3", "#B0C5C8", "#b38686", "#87b386");
    public static RizzyCodeTheme Brushtrees { get; } = new("#E3EFEF", "#6D828E", "#98AFB5", "#b386b2", "#d8bba2",
        "#868cb3", "#b38686", "#87b386", "#86b3b3", "#6D828E", "#b38686", "#87b386");
    public static RizzyCodeTheme Chalk { get; } = new("#151515", "#d0d0d0", "#505050", "#e1a3ee", "#eda987", "#6fc2ef",
        "#fb9fb1", "#acc267", "#12cfc0", "#d0d0d0", "#fb9fb1", "#acc267");
    public static RizzyCodeTheme Circus { get; } = new("#191919", "#a7a7a7", "#5f5a60", "#b888e2", "#4bb1a7", "#639ee4",
        "#dc657d", "#84b97c", "#4bb1a7", "#a7a7a7", "#dc657d", "#84b97c");
    public static RizzyCodeTheme ClassicDark { get; } = new("#151515", "#D0D0D0", "#505050", "#AA759F", "#D28445",
        "#6A9FB5", "#AC4142", "#90A959", "#75B5AA", "#D0D0D0", "#AC4142", "#90A959");
    public static RizzyCodeTheme ClassicLight { get; } = new("#F5F5F5", "#303030", "#B0B0B0", "#AA759F", "#D28445",
        "#6A9FB5", "#AC4142", "#90A959", "#75B5AA", "#303030", "#AC4142", "#90A959");
    public static RizzyCodeTheme Codeschool { get; } = new("#232c31", "#9ea7a6", "#3f4944", "#c59820", "#43820d",
        "#484d79", "#2a5491", "#237986", "#b02f30", "#9ea7a6", "#2a5491", "#237986");
    public static RizzyCodeTheme Cupcake { get; } = new("#fbf1f2", "#8b8198", "#bfb9c6", "#BB99B4", "#EBB790",
        "#7297B9", "#D57E85", "#A3B367", "#69A9A7", "#8b8198", "#D57E85", "#A3B367");
    public static RizzyCodeTheme Cupertino { get; } = new("#5e5e5e", "#c0c0c0", "#808080", "#a90d91", "#eb8500",
        "#0000ff", "#c41a15", "#007400", "#318495", "#c0c0c0", "#c41a15", "#007400");
    public static RizzyCodeTheme Darktooth { get; } = new("#1D2021", "#A89984", "#665C54", "#8F4673", "#FE8625",
        "#0D6678", "#FB543F", "#95C085", "#8BA59B", "#A89984", "#FB543F", "#95C085");
    public static RizzyCodeTheme DefaultDark { get; } = new("#181818", "#d8d8d8", "#585858", "#ba8baf", "#dc9656",
        "#7cafc2", "#ab4642", "#a1b56c", "#86c1b9", "#d8d8d8", "#ab4642", "#a1b56c");
    public static RizzyCodeTheme DefaultLight { get; } = new("#f8f8f8", "#383838", "#b8b8b8", "#ba8baf", "#dc9656",
        "#7cafc2", "#ab4642", "#a1b56c", "#86c1b9", "#383838", "#ab4642", "#a1b56c");
    public static RizzyCodeTheme Dracula { get; } = new("#282936", "#e9e9f4", "#4d4f68", "#b45bcf", "#b45bcf",
        "#62d6e8", "#ea51b2", "#00f769", "#a1efe4", "#e9e9f4", "#ea51b2", "#00f769");
    public static RizzyCodeTheme Eighties { get; } = new("#2d2d2d", "#d3d0c8", "#747369", "#cc99cc", "#f99157",
        "#6699cc", "#f2777a", "#99cc99", "#66cccc", "#d3d0c8", "#f2777a", "#99cc99");
    public static RizzyCodeTheme Embers { get; } = new("#16130F", "#A39A90", "#5A5047", "#82576D", "#828257", "#6D5782",
        "#826D57", "#57826D", "#576D82", "#A39A90", "#826D57", "#57826D");
    public static RizzyCodeTheme Flat { get; } = new("#2C3E50", "#e0e0e0", "#95A5A6", "#9B59B6", "#E67E22", "#3498DB",
        "#E74C3C", "#2ECC71", "#1ABC9C", "#e0e0e0", "#E74C3C", "#2ECC71");
    public static RizzyCodeTheme Github { get; } = new("#ffffff", "#333333", "#969896", "#a71d5d", "#0086b3", "#795da3",
        "#ed6a43", "#183691", "#183691", "#333333", "#ed6a43", "#183691");
    public static RizzyCodeTheme GoogleDark { get; } = new("#1d1f21", "#c5c8c6", "#969896", "#A36AC7", "#F96A38",
        "#3971ED", "#CC342B", "#198844", "#3971ED", "#c5c8c6", "#CC342B", "#198844");
    public static RizzyCodeTheme GoogleLight { get; } = new("#ffffff", "#373b41", "#b4b7b4", "#A36AC7", "#F96A38",
        "#3971ED", "#CC342B", "#198844", "#3971ED", "#373b41", "#CC342B", "#198844");
    public static RizzyCodeTheme GrayscaleDark { get; } = new("#101010", "#b9b9b9", "#525252", "#747474", "#999999",
        "#686868", "#7c7c7c", "#8e8e8e", "#868686", "#b9b9b9", "#7c7c7c", "#8e8e8e");
    public static RizzyCodeTheme GrayscaleLight { get; } = new("#f7f7f7", "#464646", "#ababab", "#747474", "#999999",
        "#686868", "#7c7c7c", "#8e8e8e", "#868686", "#464646", "#7c7c7c", "#8e8e8e");
    public static RizzyCodeTheme Greenscreen { get; } = new("#001100", "#00bb00", "#007700", "#00bb00", "#009900",
        "#009900", "#007700", "#00bb00", "#005500", "#00bb00", "#007700", "#00bb00");
    public static RizzyCodeTheme GruvboxDarkHard { get; } = new("#1d2021", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    public static RizzyCodeTheme GruvboxDarkMedium { get; } = new("#282828", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    public static RizzyCodeTheme GruvboxDarkPale { get; } = new("#262626", "#dab997", "#8a8a8a", "#d485ad", "#ff8700",
        "#83adad", "#d75f5f", "#afaf00", "#85ad85", "#dab997", "#d75f5f", "#afaf00");
    public static RizzyCodeTheme GruvboxDarkSoft { get; } = new("#32302f", "#d5c4a1", "#665c54", "#d3869b", "#fe8019",
        "#83a598", "#fb4934", "#b8bb26", "#8ec07c", "#d5c4a1", "#fb4934", "#b8bb26");
    public static RizzyCodeTheme GruvboxLightHard { get; } = new("#f9f5d7", "#504945", "#bdae93", "#8f3f71", "#af3a03",
        "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    public static RizzyCodeTheme GruvboxLightMedium { get; } = new("#fbf1c7", "#504945", "#bdae93", "#8f3f71",
        "#af3a03", "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    public static RizzyCodeTheme GruvboxLightSoft { get; } = new("#f2e5bc", "#504945", "#bdae93", "#8f3f71", "#af3a03",
        "#076678", "#9d0006", "#79740e", "#427b58", "#504945", "#9d0006", "#79740e");
    public static RizzyCodeTheme HarmonicDark { get; } = new("#0b1c2c", "#cbd6e2", "#627e99", "#bf568b", "#bfbf56",
        "#8b56bf", "#bf8b56", "#56bf8b", "#568bbf", "#cbd6e2", "#bf8b56", "#56bf8b");
    public static RizzyCodeTheme HarmonicLight { get; } = new("#f7f9fb", "#405c79", "#aabcce", "#bf568b", "#bfbf56",
        "#8b56bf", "#bf8b56", "#56bf8b", "#568bbf", "#405c79", "#bf8b56", "#56bf8b");
    public static RizzyCodeTheme Hopscotch { get; } = new("#322931", "#b9b5b8", "#797379", "#c85e7c", "#fd8b19",
        "#1290bf", "#dd464c", "#8fc13e", "#149b93", "#b9b5b8", "#dd464c", "#8fc13e");
    public static RizzyCodeTheme IaDark { get; } = new("#1a1a1a", "#cccccc", "#767676", "#b98eb2", "#d86868", "#8eccdd",
        "#d88568", "#83a471", "#7c9cae", "#cccccc", "#d88568", "#83a471");
    public static RizzyCodeTheme IaLight { get; } = new("#f6f6f6", "#181818", "#898989", "#a94598", "#c43e18",
        "#48bac2", "#9c5a02", "#38781c", "#2d6bb1", "#181818", "#9c5a02", "#38781c");
    public static RizzyCodeTheme Icy { get; } = new("#021012", "#095b67", "#052e34", "#00acc1", "#b3ebf2", "#00bcd4",
        "#16c1d9", "#4dd0e1", "#26c6da", "#095b67", "#16c1d9", "#4dd0e1");
    public static RizzyCodeTheme Irblack { get; } = new("#000000", "#b5b3aa", "#6c6c66", "#ff73fd", "#e9c062",
        "#96cbfe", "#ff6c60", "#a8ff60", "#c6c5fe", "#b5b3aa", "#ff6c60", "#a8ff60");
    public static RizzyCodeTheme Isotope { get; } = new("#000000", "#d0d0d0", "#808080", "#cc00ff", "#ff9900",
        "#0066ff", "#ff0000", "#33ff00", "#00ffff", "#d0d0d0", "#ff0000", "#33ff00");
    public static RizzyCodeTheme Macintosh { get; } = new("#000000", "#c0c0c0", "#808080", "#4700a5", "#ff6403",
        "#0000d3", "#dd0907", "#1fb714", "#02abea", "#c0c0c0", "#dd0907", "#1fb714");
    public static RizzyCodeTheme Marrakesh { get; } = new("#201602", "#948e48", "#6c6823", "#8868b3", "#b36144",
        "#477ca1", "#c35359", "#18974e", "#75a738", "#948e48", "#c35359", "#18974e");
    public static RizzyCodeTheme Materia { get; } = new("#263238", "#CDD3DE", "#707880", "#82AAFF", "#EA9560",
        "#89DDFF", "#EC5F67", "#8BD649", "#80CBC4", "#CDD3DE", "#EC5F67", "#8BD649");
    public static RizzyCodeTheme MaterialDarker { get; } = new("#212121", "#EEFFFF", "#4A4A4A", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#EEFFFF", "#F07178", "#C3E88D");
    public static RizzyCodeTheme MaterialLighter { get; } = new("#FAFAFA", "#80CBC4", "#CCD7DA", "#7C4DFF", "#F76D47",
        "#6182B8", "#FF5370", "#91B859", "#39ADB5", "#80CBC4", "#FF5370", "#91B859");
    public static RizzyCodeTheme MaterialPalenight { get; } = new("#292D3E", "#959DCB", "#676E95", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#959DCB", "#F07178", "#C3E88D");
    public static RizzyCodeTheme MaterialVivid { get; } = new("#263238", "#B0BEC5", "#546E7A", "#651FFF", "#FF9100",
        "#2979FF", "#FF1744", "#00E676", "#00B0FF", "#B0BEC5", "#FF1744", "#00E676");
    public static RizzyCodeTheme Material { get; } = new("#263238", "#EEFFFF", "#546E7A", "#C792EA", "#F78C6C",
        "#82AAFF", "#F07178", "#C3E88D", "#89DDFF", "#EEFFFF", "#F07178", "#C3E88D");
    public static RizzyCodeTheme MellowPurple { get; } = new("#1e0528", "#ffeeff", "#320f55", "#8991bb", "#aa00a3",
        "#550068", "#00d9e9", "#05cb0d", "#b900b1", "#ffeeff", "#00d9e9", "#05cb0d");
    public static RizzyCodeTheme MexicoLight { get; } = new("#f8f8f8", "#383838", "#b8b8b8", "#96609e", "#dc9656",
        "#7cafc2", "#ab4642", "#538947", "#4b8093", "#383838", "#ab4642", "#538947");
    public static RizzyCodeTheme Mocha { get; } = new("#3B3228", "#d0c8c6", "#7e705a", "#a89bb9", "#d28b71", "#8ab3b5",
        "#cb6077", "#beb55b", "#7bbda4", "#d0c8c6", "#cb6077", "#beb55b");
    public static RizzyCodeTheme Monokai { get; } = new("#272822", "#f8f8f2", "#75715e", "#ae81ff", "#fd971f",
        "#66d9ef", "#f92672", "#a6e22e", "#a1efe4", "#f8f8f2", "#f92672", "#a6e22e");
    public static RizzyCodeTheme Nord { get; } = new("#2E3440", "#E5E9F0", "#4C566A", "#A3BE8C", "#81A1C1", "#EBCB8B",
        "#88C0D0", "#BF616A", "#D08770", "#E5E9F0", "#88C0D0", "#BF616A");
    public static RizzyCodeTheme Ocean { get; } = new("#2b303b", "#c0c5ce", "#65737e", "#b48ead", "#d08770", "#8fa1b3",
        "#bf616a", "#a3be8c", "#96b5b4", "#c0c5ce", "#bf616a", "#a3be8c");
    public static RizzyCodeTheme OceanicNext { get; } = new("#1B2B34", "#C0C5CE", "#65737E", "#C594C5", "#F99157",
        "#6699CC", "#EC5f67", "#99C794", "#5FB3B3", "#C0C5CE", "#EC5f67", "#99C794");
    public static RizzyCodeTheme OneLight { get; } = new("#fafafa", "#383a42", "#a0a1a7", "#a626a4", "#d75f00",
        "#4078f2", "#ca1243", "#50a14f", "#0184bc", "#383a42", "#ca1243", "#50a14f");
    public static RizzyCodeTheme Onedark { get; } = new("#282c34", "#abb2bf", "#545862", "#c678dd", "#d19a66",
        "#61afef", "#e06c75", "#98c379", "#56b6c2", "#abb2bf", "#e06c75", "#98c379");
    public static RizzyCodeTheme OutrunDark { get; } = new("#00002A", "#D0D0FA", "#50507A", "#F10596", "#FC8D28",
        "#66B0FF", "#FF4242", "#59F176", "#0EF0F0", "#D0D0FA", "#FF4242", "#59F176");
    public static RizzyCodeTheme Paraiso { get; } = new("#2f1e2e", "#a39e9b", "#776e71", "#815ba4", "#f99b15",
        "#06b6ef", "#ef6155", "#48b685", "#5bc4bf", "#a39e9b", "#ef6155", "#48b685");
    public static RizzyCodeTheme Phd { get; } = new("#061229", "#b8bbc2", "#717885", "#9989cc", "#f0a000", "#5299bf",
        "#d07346", "#99bf52", "#72b9bf", "#b8bbc2", "#d07346", "#99bf52");
    public static RizzyCodeTheme Pico { get; } = new("#000000", "#5f574f", "#008751", "#ff77a8", "#ffa300", "#83769c",
        "#ff004d", "#00e756", "#29adff", "#5f574f", "#ff004d", "#00e756");
    public static RizzyCodeTheme Pop { get; } = new("#000000", "#d0d0d0", "#505050", "#b31e8d", "#f29333", "#0e5a94",
        "#eb008a", "#37b349", "#00aabb", "#d0d0d0", "#eb008a", "#37b349");
    public static RizzyCodeTheme Porple { get; } = new("#292c36", "#d8d8d8", "#65568a", "#b74989", "#d28e5d", "#8485ce",
        "#f84547", "#95c76f", "#64878f", "#d8d8d8", "#f84547", "#95c76f");
    public static RizzyCodeTheme Railscasts { get; } = new("#2b2b2b", "#e6e1dc", "#5a647e", "#b6b3eb", "#cc7833",
        "#6d9cbe", "#da4939", "#a5c261", "#519f50", "#e6e1dc", "#da4939", "#a5c261");
    public static RizzyCodeTheme Rebecca { get; } = new("#292a44", "#f1eff8", "#666699", "#7aa5ff", "#efe4a1",
        "#2de0a7", "#a0a0c5", "#6dfedf", "#8eaee0", "#f1eff8", "#a0a0c5", "#6dfedf");
    public static RizzyCodeTheme Seti { get; } = new("#151718", "#d6d6d6", "#41535B", "#a074c4", "#db7b55", "#55b5db",
        "#Cd3f45", "#9fca56", "#55dbbe", "#d6d6d6", "#Cd3f45", "#9fca56");
    public static RizzyCodeTheme Shapeshifter { get; } = new("#f9f9f9", "#102015", "#555555", "#f996e2", "#e09448",
        "#3b48e3", "#e92f2f", "#0ed839", "#23edda", "#102015", "#e92f2f", "#0ed839");
    public static RizzyCodeTheme Snazzy { get; } = new("#1e1f29", "#eff0eb", "#78787e", "#ff6ac1", "#ff9f43", "#57c7ff",
        "#ff5c57", "#5af78e", "#9aedfe", "#eff0eb", "#ff5c57", "#5af78e");
    public static RizzyCodeTheme Solarflare { get; } = new("#18262F", "#A6AFB8", "#667581", "#A363D5", "#E66B2B",
        "#33B5E1", "#EF5253", "#7CC844", "#52CBB0", "#A6AFB8", "#EF5253", "#7CC844");
    public static RizzyCodeTheme SolarizedDark { get; } = new("#002b36", "#93a1a1", "#657b83", "#6c71c4", "#cb4b16",
        "#268bd2", "#dc322f", "#859900", "#2aa198", "#93a1a1", "#dc322f", "#859900");
    public static RizzyCodeTheme SolarizedLight { get; } = new("#fdf6e3", "#586e75", "#839496", "#6c71c4", "#cb4b16",
        "#268bd2", "#dc322f", "#859900", "#2aa198", "#586e75", "#dc322f", "#859900");
    public static RizzyCodeTheme Spacemacs { get; } = new("#1f2022", "#a3a3a3", "#585858", "#a31db1", "#ffa500",
        "#4f97d7", "#f2241f", "#67b11d", "#2d9574", "#a3a3a3", "#f2241f", "#67b11d");
    public static RizzyCodeTheme SummerfruitDark { get; } = new("#151515", "#D0D0D0", "#505050", "#AD00A1", "#FD8900",
        "#3777E6", "#FF0086", "#00C918", "#1FAAAA", "#D0D0D0", "#FF0086", "#00C918");
    public static RizzyCodeTheme SummerfruitLight { get; } = new("#FFFFFF", "#101010", "#B0B0B0", "#AD00A1", "#FD8900",
        "#3777E6", "#FF0086", "#00C918", "#1FAAAA", "#101010", "#FF0086", "#00C918");
    public static RizzyCodeTheme TomorrowNight { get; } = new("#1d1f21", "#c5c8c6", "#969896", "#b294bb", "#de935f",
        "#81a2be", "#cc6666", "#b5bd68", "#8abeb7", "#c5c8c6", "#cc6666", "#b5bd68");
    public static RizzyCodeTheme Tomorrow { get; } = new("#ffffff", "#4d4d4c", "#8e908c", "#8959a8", "#f5871f",
        "#4271ae", "#c82829", "#718c00", "#3e999f", "#4d4d4c", "#c82829", "#718c00");
    public static RizzyCodeTheme Tube { get; } = new("#231f20", "#d9d8d8", "#737171", "#98005d", "#f386a1", "#009ddc",
        "#ee2e24", "#00853e", "#85cebc", "#d9d8d8", "#ee2e24", "#00853e");
    public static RizzyCodeTheme Twilight { get; } = new("#1e1e1e", "#a7a7a7", "#5f5a60", "#9b859d", "#cda869",
        "#7587a6", "#cf6a4c", "#8f9d6a", "#afc4db", "#a7a7a7", "#cf6a4c", "#8f9d6a");
    public static RizzyCodeTheme UnikittyDark { get; } = new("#2e2a31", "#bcbabe", "#838085", "#bb60ea", "#d65407",
        "#796af5", "#d8137f", "#17ad98", "#149bda", "#bcbabe", "#d8137f", "#17ad98");
    public static RizzyCodeTheme UnikittyLight { get; } = new("#ffffff", "#6c696e", "#a7a5a8", "#aa17e6", "#d65407",
        "#775dff", "#d8137f", "#17ad98", "#149bda", "#6c696e", "#d8137f", "#17ad98");
    public static RizzyCodeTheme UnikittyReversible { get; } = new("#2e2a31", "#c3c2c4", "#878589", "#b33ce8",
        "#d65407", "#7864fa", "#d8137f", "#17ad98", "#149bda", "#c3c2c4", "#d8137f", "#17ad98");
    public static RizzyCodeTheme Woodland { get; } = new("#231e18", "#cabcb1", "#9d8b70", "#bb90e2", "#ca7f32",
        "#88a4d3", "#d35c5c", "#b7ba53", "#6eb958", "#cabcb1", "#d35c5c", "#b7ba53");
    public static RizzyCodeTheme XcodeDusk { get; } = new("#282B35", "#939599", "#686A71", "#B21889", "#786DC5",
        "#790EAD", "#B21889", "#DF0002", "#00A0BE", "#939599", "#B21889", "#DF0002");
    public static RizzyCodeTheme Zenburn { get; } = new("#3f3f3f", "#dcdccc", "#4f4f4f", "#dc8cc3", "#dfaf8f",
        "#7cb8bb", "#dca3a3", "#5f7f5f", "#93e0e3", "#dcdccc", "#dca3a3", "#5f7f5f");
}
</file>

<file path="Components/Theme/Themes/Code/RizzyCodeTheme.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Defines a syntax highlighting color theme for code.
/// </summary>
public class RizzyCodeTheme
{
	/// <summary>
	///     Initialize theme
	/// </summary>
	/// <param name="background"></param>
	/// <param name="color"></param>
	/// <param name="comment"></param>
	/// <param name="keyword"></param>
	/// <param name="attribute"></param>
	/// <param name="symbol"></param>
	/// <param name="nameSpace"></param>
	/// <param name="variable"></param>
	/// <param name="literal"></param>
	/// <param name="punctuation"></param>
	/// <param name="deletion"></param>
	/// <param name="addition"></param>
	public RizzyCodeTheme(
        string background,
        string color,
        string comment,
        string keyword,
        string attribute,
        string symbol,
        string nameSpace,
        string variable,
        string literal,
        string punctuation,
        string deletion,
        string addition)
    {
        Background = new Color(background);
        Color = new Color(color);
        Comment = new Color(comment);
        Keyword = new Color(keyword);
        Attribute = new Color(attribute);
        Symbol = new Color(symbol);
        Namespace = new Color(nameSpace);
        Variable = new Color(variable);
        Literal = new Color(literal);
        Punctuation = new Color(punctuation);
        Deletion = new Color(deletion);
        Addition = new Color(addition);
    }
	/// <summary>
	///     Gets the background color used for code highlighting.
	/// </summary>
	public Color Background { get; init; }
	/// <summary>
	///     Gets the default color used for code highlighting.
	/// </summary>
	public Color Color { get; init; }
	/// <summary>
	///     Gets the color used for comments.
	/// </summary>
	public Color Comment { get; init; }
	/// <summary>
	///     Gets the color used for keywords.
	/// </summary>
	public Color Keyword { get; init; }
	/// <summary>
	///     Gets the color used for attributes.
	/// </summary>
	public Color Attribute { get; init; }
	/// <summary>
	///     Gets the color used for symbols.
	/// </summary>
	public Color Symbol { get; init; }
	/// <summary>
	///     Gets the color used for namespaces.
	/// </summary>
	public Color Namespace { get; init; }
	/// <summary>
	///     Gets the color used for variables.
	/// </summary>
	public Color Variable { get; init; }
	/// <summary>
	///     Gets the color used for literals.
	/// </summary>
	public Color Literal { get; init; }
	/// <summary>
	///     Gets the color used for punctuation.
	/// </summary>
	public Color Punctuation { get; init; }
	/// <summary>
	///     Gets the color used to indicate deletions.
	/// </summary>
	public Color Deletion { get; init; }
	/// <summary>
	///     Gets the color used to indicate additions.
	/// </summary>
	public Color Addition { get; init; }
}
</file>

<file path="Components/Theme/Themes/HighContrastTheme.cs">
namespace RizzyUI;
/// <summary>
///     Represents the High Contrast theme for the application. Inherits from <see cref="RzTheme" />.
///     Initializes the theme using the specified Tailwind color palette.
/// </summary>
public class HighContrastTheme : RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="HighContrastTheme" /> class with predefined high-contrast values.
    /// </summary>
    public HighContrastTheme() : base("High Contrast", "highcontrast")
    {
        // Light mode colors
        Light = new RzThemeVariant
        {
            Surface = Colors.Gray.L50, // gray-50: (249, 250, 251)
            OnSurface = Colors.Gray.L800, // gray-800: (31, 41, 55)
            OnSurfaceStrong = Colors.Gray.L950, // gray-950: (10, 10, 10)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Gray.L200, // gray-200: (229, 231, 235)
            SurfaceTertiary = Colors.Gray.L300,
            OnSurfaceTertiary = Colors.Gray.L700,
            Primary = Colors.Sky.L900, // sky-900: (8, 51, 68)
            OnPrimary = Colors.White, // white: (255, 255, 255)
            Secondary = Colors.Indigo.L900, // indigo-900: (17, 24, 39)
            OnSecondary = Colors.White, // white: (255, 255, 255)
            Outline = Colors.Gray.L500, // gray-500: (107, 114, 128)
            OutlineStrong = Colors.Gray.L900, // gray-900: (17, 24, 39)
            Code = CodeThemes.Github
        };
        // Dark mode colors
        Dark = new RzThemeVariant
        {
            Surface = Colors.Gray.L900, // gray-900: (17, 24, 39)
            OnSurface = Colors.Gray.L300, // gray-300: (209, 213, 219)
            OnSurfaceStrong = Colors.Gray.L100, // gray-100: (245, 245, 245)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Gray.L800, // gray-800: (31, 41, 55)
            SurfaceTertiary = Colors.Gray.L700,
            OnSurfaceTertiary = Colors.Gray.L300,
            Primary = Colors.Sky.L400, // sky-400: (14, 165, 233)
            OnPrimary = Colors.Black, // black: (0, 0, 0)
            Secondary = Colors.Indigo.L400, // indigo-400: (147, 51, 234)
            OnSecondary = Colors.Black, // black: (0, 0, 0)
            Outline = Colors.Gray.L500, // gray-500: (107, 114, 128)
            OutlineStrong = Colors.Gray.L300, // gray-300: (209, 213, 219)
            Code = CodeThemes.DefaultDark
        };
        // Shared Colors
        Destructive = Colors.Red.L500; // red-500: (239, 68, 68)
        DestructiveForeground = Colors.Black; // black: (0, 0, 0)
        Info = Colors.Sky.L500; // sky-500: (14, 165, 233)
        OnInfo = Colors.Black; // black: (0, 0, 0)
        Warning = Colors.Yellow.L500; // yellow-500: (234, 179, 8)
        OnWarning = Colors.Black; // black: (0, 0, 0)
        Success = Colors.Green.L500; // green-500: (34, 197, 94)
        OnSuccess = Colors.Black; // black: (0, 0, 0)
        // Borders and Radius
        BorderWidth = "1px";
        BorderRadius = "6px";
    }
}
</file>

<file path="Components/Theme/Themes/ModernTheme.cs">
namespace RizzyUI;
/// <summary>
///     Represents the Modern theme for the application. Inherits from <see cref="RzTheme" />.
///     Initializes the theme using the specified Tailwind color palette.
/// </summary>
public class ModernTheme : RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="ModernTheme" /> class with predefined modern values.
    /// </summary>
    public ModernTheme() : base("Modern", "modern")
    {
        // Light mode colors
        Light = new RzThemeVariant
        {
            Surface = Colors.White, // white: (255, 255, 255)
            OnSurface = Colors.Neutral.L600, // neutral-600: (75, 85, 99)
            OnSurfaceStrong = Colors.Neutral.L900, // neutral-900: (17, 24, 39)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Neutral.L50, // neutral-50: (249, 250, 251)
            SurfaceTertiary = Colors.Neutral.L100,
            OnSurfaceTertiary = Colors.Neutral.L500,
            Primary = Colors.Black, // black: (0, 0, 0)
            OnPrimary = Colors.Neutral.L100, // neutral-100: (245, 245, 245)
            Secondary = Colors.Neutral.L800, // neutral-800: (31, 41, 55)
            OnSecondary = Colors.White, // white: (255, 255, 255)
            Outline = Colors.Neutral.L300, // neutral-300: (209, 213, 219)
            OutlineStrong = Colors.Neutral.L800, // neutral-800: (31, 41, 55)
            Code = CodeThemes.Github
        };
        // Dark mode colors
        Dark = new RzThemeVariant
        {
            Surface = Colors.Neutral.L950, // neutral-950: (7, 7, 7)
            OnSurface = Colors.Neutral.L300, // neutral-300: (209, 213, 219)
            OnSurfaceStrong = Colors.White, // white: (255, 255, 255)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Neutral.L900, // neutral-900: (17, 24, 39)
            SurfaceTertiary = Colors.Neutral.L800,
            OnSurfaceTertiary = Colors.Neutral.L300,
            Primary = Colors.White, // white: (255, 255, 255)
            OnPrimary = Colors.Black, // black: (0, 0, 0)
            Secondary = Colors.Neutral.L300, // neutral-300: (209, 213, 219)
            OnSecondary = Colors.Black, // black: (0, 0, 0)
            Outline = Colors.Neutral.L700, // neutral-700: (55, 65, 81)
            OutlineStrong = Colors.Neutral.L300, // neutral-300: (209, 213, 219)
            Code = CodeThemes.DefaultDark
        };
        // Shared Colors
        Destructive = Colors.Red.L500; // red-500: (239, 68, 68)
        DestructiveForeground = Colors.White; // white: (255, 255, 255)
        Info = Colors.Sky.L500; // sky-500: (14, 165, 233)
        OnInfo = Colors.White; // white: (255, 255, 255)
        Warning = Colors.Amber.L500; // amber-500: (245, 158, 11)
        OnWarning = Colors.White; // white: (255, 255, 255)
        Success = Colors.Green.L500; // green-500: (34, 197, 94)
        OnSuccess = Colors.White; // white: (255, 255, 255)
        // Borders and Radius
        BorderWidth = "1px";
        BorderRadius = "6px";
    }
}
</file>

<file path="Components/Theme/Themes/NewsTheme.cs">
namespace RizzyUI;
/// <summary>
///     Represents the News theme for the application. Inherits from <see cref="RzTheme" />.
///     Initializes the theme using the specified Tailwind color palette.
/// </summary>
public class NewsTheme : RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="NewsTheme" /> class with predefined news-oriented values.
    /// </summary>
    public NewsTheme() : base("News", "news")
    {
        // Light mode colors
        Light = new RzThemeVariant
        {
            Surface = Colors.Zinc.L50, // zinc-50: (250, 250, 249)
            OnSurface = Colors.Neutral.L600, // neutral-600: (75, 85, 99)
            OnSurfaceStrong = Colors.Neutral.L900, // neutral-900: (17, 24, 39)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Zinc.L100, // zinc-100: (244, 244, 245)
            SurfaceTertiary = Colors.Zinc.L200,
            OnSurfaceTertiary = Colors.Zinc.L500,
            Primary = Colors.Sky.L700, // sky-700: (14, 165, 233)
            OnPrimary = Colors.White, // white: (255, 255, 255)
            Secondary = Colors.Black, // black: (0, 0, 0)
            OnSecondary = Colors.White, // white: (255, 255, 255)
            Outline = Colors.Zinc.L300, // zinc-300: (209, 213, 219)
            OutlineStrong = Colors.Zinc.L500, // zinc-500: (113, 113, 122)
            Code = CodeThemes.Github
        };
        // Dark mode colors
        Dark = new RzThemeVariant
        {
            Surface = Colors.Zinc.L900, // zinc-900: (15, 23, 42)
            OnSurface = Colors.Zinc.L200, // zinc-200: (229, 231, 235)
            OnSurfaceStrong = Colors.Zinc.L50, // zinc-50: (250, 250, 249)
            OnSurfaceMuted = Colors.Neutral.L500,
            SurfaceAlt = Colors.Zinc.L800, // zinc-800: (31, 41, 55)
            SurfaceTertiary = Colors.Zinc.L700,
            OnSurfaceTertiary = Colors.Zinc.L200,
            Primary = Colors.Sky.L600, // sky-600: (8, 51, 68)
            OnPrimary = Colors.White, // white: (255, 255, 255)
            Secondary = Colors.White, // white: (255, 255, 255)
            OnSecondary = Colors.Black, // black: (0, 0, 0)
            Outline = Colors.Zinc.L700, // zinc-700: (38, 38, 38)
            OutlineStrong = Colors.Zinc.L500, // zinc-500: (113, 113, 122)
            Code = CodeThemes.DefaultDark
        };
        // Shared Colors
        Destructive = Colors.Red.L700; // red-700: (185, 28, 28)
        DestructiveForeground = Colors.Slate.L100; // slate-100: (245, 245, 245)
        Info = Colors.Sky.L700; // sky-700: (14, 165, 233)
        OnInfo = Colors.Slate.L100; // slate-100: (245, 245, 245)
        Warning = Colors.Amber.L600; // amber-600: (217, 119, 6)
        OnWarning = Colors.Amber.L50; // amber-50: (255, 251, 235)
        Success = Colors.Green.L700; // green-700: (34, 197, 94)
        OnSuccess = Colors.White; // white: (255, 255, 255)
        // Borders and Radius
        BorderWidth = "1px";
        BorderRadius = "6px";
    }
}
</file>

<file path="Components/Typography/RzHeading.razor">
@namespace RizzyUI
@inherits RzTypographyBase

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
    <div x-data="rzHeading" data-alpine-root="@Id">
        @if (ChildContent == null && !string.IsNullOrEmpty(QuickReferenceTitle))
        {
            @QuickReferenceTitle
        }
        else
        {
            @ChildContent
        }
    </div>
</HtmlElement>
</file>

<file path="Components/Typography/RzHeading.razor.cs">
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using Rizzy;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders an HTML heading element (h1-h4) with appropriate typography styling based on the level and active
///     <see cref="RzTheme" />.
///     Inherits common text styling options from <see cref="RzTypographyBase" />. Can register itself with an
///     <see cref="RzQuickReferenceContainer" />.
/// </xmldoc>
public partial class RzHeading : RzTypographyBase
{
    private bool _registered;
    /// <summary> Represents the heading level (H1-H4), determining the HTML tag and base styles. Required. </summary>
    [Parameter]
    [EditorRequired]
    public required HeadingLevel Level { get; set; }
    /// <summary> The content to be rendered inside the heading tag. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary>
    ///     The title text to use when registering this heading with an <see cref="RzQuickReferenceContainer" />. If null
    ///     or empty, the heading will not be registered.
    /// </summary>
    [Parameter]
    public string? QuickReferenceTitle { get; set; }
    /// <summary> Gets the parent <see cref="RzQuickReferenceContainer" /> if this heading is nested within one. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        // Initialize base (gets theme) before using it
        base.OnParametersSet();
        Element = Level switch // Set the HTML tag based on Level
        {
            HeadingLevel.H1 => "h1", HeadingLevel.H2 => "h2",
            HeadingLevel.H3 => "h3", HeadingLevel.H4 => "h4",
            _ => "h1" // Default to h1
        };
        // Apply default text colors based on level if not explicitly set
        if (TextColor is null)
            TextColor = Level is HeadingLevel.H1 or HeadingLevel.H2
                ? SemanticColor.OnSurfaceStrong
                : SemanticColor.OnSurface;
        // Register with Quick Reference if applicable
        if (!_registered && QuickReferenceContainer != null)
        {
            if (string.IsNullOrEmpty(QuickReferenceTitle))
                QuickReferenceTitle = ChildContent?.AsMarkupString() ?? "[Missing QuickReferenceTitle]";
            QuickReferenceContainer.RegisterHeading(Level, QuickReferenceTitle, Id);
            _registered = true;
        }
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var headingStyles = Theme.RzHeading;
        // Merge base typography styles with level-specific styles
        return TwMerge.Merge(AdditionalAttributes,
            GetTypographyBaseCss(), // From RzTypographyBase
            headingStyles.GetLevelCss(Level) // From RzHeadingStyles
        );
    }
}
</file>

<file path="Components/Typography/RzParagraph.razor">
@namespace RizzyUI

@inherits RzTypographyBase

<HtmlElement Element="@EffectiveElement" @attributes="@AdditionalAttributes" id="@Id" class="@RootClass()">
	@ChildContent
</HtmlElement>
</file>

<file path="Components/Typography/RzParagraph.razor.cs">
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
namespace RizzyUI;
/// <xmldoc>
///     Renders a paragraph (<c>p</c>) element with standard typography styling.
///     Inherits text styling options from <see cref="RzTypographyBase" />.
///     Styling, including prose width, is determined by the active <see cref="RzTheme" />.
/// </xmldoc>
public partial class RzParagraph : RzTypographyBase
{
    // Theme is inherited from RzTypographyBase
    /// <summary> The content to be rendered inside the paragraph. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }
    /// <summary> Gets or sets the maximum character width of the paragraph. Defaults to Full. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Full;
    /// <inheritdoc />
    protected override void OnInitialized()
    {
        // Initialize inherited properties first
        base.OnInitialized();
        if (string.IsNullOrEmpty(Element))
            Element = "p"; // Set the specific element tag
        TextColor ??= SemanticColor.OnSurface; // Default paragraph text color if not set by base or parameter
    }
    /// <inheritdoc />
    protected override string? RootClass()
    {
        var styles = Theme.RzParagraph;
        return TwMerge.Merge(AdditionalAttributes,
            styles.Paragraph, // Base paragraph styles (margin, leading)
            GetTypographyBaseCss(), // Common typography styles (color, weight, size etc. from base)
            styles.GetProseWidthCss(ProseWidth) // Prose width class
        );
    }
}
</file>

<file path="Components/Typography/RzTypographyBase.cs">
using Microsoft.AspNetCore.Components;
// Required for TwMerge if used directly (though RootClass does it)
namespace RizzyUI;
/// <xmldoc>
///     Base class for typography components like <see cref="RzHeading" /> and <see cref="RzParagraph" />.
///     Provides common parameters for text styling (color, weight, size, etc.) and access to the theme's typography
///     styles.
/// </xmldoc>
public abstract class RzTypographyBase : RzComponent
{
    /// <summary> Gets or sets the text color. If null, defaults are often applied by inheriting components. </summary>
    [Parameter]
    public SemanticColor? TextColor { get; set; }
    /// <summary> Gets or sets the font weight. </summary>
    [Parameter]
    public TextWeight? Weight { get; set; }
    /// <summary> Gets or sets the text size. </summary>
    [Parameter]
    public TextSize? Size { get; set; }
    /// <summary> Gets or sets the line height (leading). </summary>
    [Parameter]
    public Leading? LineHeight { get; set; }
    /// <summary> Gets or sets the text decoration (underline, etc.). </summary>
    [Parameter]
    public TextDecoration? Decoration { get; set; }
    /// <summary> Gets or sets the text transformation (uppercase, etc.). </summary>
    [Parameter]
    public TextTransform? Transform { get; set; }
    /// <summary> Builds a string of combined typography CSS classes based on the component's parameters and the active theme. </summary>
    /// <returns>A string containing Tailwind CSS classes for typography styling.</returns>
    protected virtual string GetTypographyBaseCss()
    {
        return Theme.RzTypography.GetBaseCss(TextColor, Weight, Size, LineHeight, Decoration, Transform);
    }
}
</file>

<file path="Components/Typography/Styles.cs">
namespace RizzyUI;
/// <summary>
///     Represents the heading level, corresponding to HTML heading tags.
/// </summary>
public enum HeadingLevel
{
    /// <summary>
    ///     Heading level 1 (&lt;h1&gt;), typically the largest heading.
    /// </summary>
    H1,
    /// <summary>
    ///     Heading level 2 (&lt;h2&gt;), typically used for main sections.
    /// </summary>
    H2,
    /// <summary>
    ///     Heading level 3 (&lt;h3&gt;), typically used for subsections.
    /// </summary>
    H3,
    /// <summary>
    ///     Heading level 4 (&lt;h4&gt;), typically used for smaller subsections.
    /// </summary>
    H4
}
/// <summary>
///     Represents the font weight.
/// </summary>
public enum TextWeight
{
    /// <summary>
    ///     Thin font weight (font-weight: 100).
    /// </summary>
    Thin,
    /// <summary>
    ///     Normal font weight (font-weight: 400).
    /// </summary>
    Normal,
    /// <summary>
    ///     Bold font weight (font-weight: 700).
    /// </summary>
    Bold,
    /// <summary>
    ///     Extra bold font weight (font-weight: 800).
    /// </summary>
    ExtraBold
}
/// <summary>
///     Represents the font size.
/// </summary>
public enum TextSize
{
    /// <summary>
    ///     Small text size (font-size: 0.875rem; 14px).
    /// </summary>
    Small,
    /// <summary>
    ///     Medium text size (font-size: 1rem; 16px).
    /// </summary>
    Medium,
    /// <summary>
    ///     Large text size (font-size: 1.125rem; 18px).
    /// </summary>
    Large,
    /// <summary>
    ///     Extra large text size (font-size: 1.25rem; 20px).
    /// </summary>
    ExtraLarge,
    /// <summary>
    ///     2XL text size (font-size: 1.5rem; 24px).
    /// </summary>
    TwoXL,
    /// <summary>
    ///     3XL text size (font-size: 1.875rem; 30px).
    /// </summary>
    ThreeXL,
    /// <summary>
    ///     4XL text size (font-size: 2.25rem; 36px).
    /// </summary>
    FourXL,
    /// <summary>
    ///     5XL text size (font-size: 3rem; 48px).
    /// </summary>
    FiveXL
}
/// <summary>
///     Represents text decoration styles.
/// </summary>
public enum TextDecoration
{
    /// <summary>
    ///     No text decoration (text-decoration: none).
    /// </summary>
    None,
    /// <summary>
    ///     Underlined text (text-decoration: underline).
    /// </summary>
    Underline,
    /// <summary>
    ///     Overlined text (text-decoration: overline).
    /// </summary>
    Overline,
    /// <summary>
    ///     Line-through text (text-decoration: line-through).
    /// </summary>
    LineThrough
}
/// <summary>
///     Represents text transformation styles.
/// </summary>
public enum TextTransform
{
    /// <summary>
    ///     Normal text (text-transform: none).
    /// </summary>
    None,
    /// <summary>
    ///     Uppercase text (text-transform: uppercase).
    /// </summary>
    Uppercase,
    /// <summary>
    ///     Lowercase text (text-transform: lowercase).
    /// </summary>
    Lowercase,
    /// <summary>
    ///     Capitalized text (text-transform: capitalize).
    /// </summary>
    Capitalize
}
/// <summary>
///     Represents the line height.
/// </summary>
public enum Leading
{
    /// <summary>
    ///     None line height (line-height: 1).
    /// </summary>
    None,
    /// <summary>
    ///     Tight line height (line-height: 1.25).
    /// </summary>
    Tight,
    /// <summary>
    ///     Snug line height (line-height: 1.375).
    /// </summary>
    Snug,
    /// <summary>
    ///     Normal line height (line-height: 1.5).
    /// </summary>
    Normal,
    /// <summary>
    ///     Relaxed line height (line-height: 1.625).
    /// </summary>
    Relaxed,
    /// <summary>
    ///     Loose line height (line-height: 2).
    /// </summary>
    Loose
}
</file>

<file path="Components/Typography/Styling/DefaultRzTypographyStyles.cs">
namespace RizzyUI;
/// <summary> Provides default styles for base typography settings. </summary>
public class DefaultRzTypographyStyles : RzStylesBase.RzTypographyStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzTypographyStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzTypographyStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string GetTextWeightCss(TextWeight? weight)
    {
        return weight switch
        {
            TextWeight.Thin => "font-thin", TextWeight.Normal => "font-normal",
            TextWeight.Bold => "font-bold", TextWeight.ExtraBold => "font-extrabold",
            _ => ""
        };
    }
    /// <inheritdoc />
    public override string GetTextSizeCss(TextSize? size)
    {
        return size switch
        {
            TextSize.Small => "text-sm", TextSize.Medium => "text-base", TextSize.Large => "text-lg",
            TextSize.ExtraLarge => "text-xl", TextSize.TwoXL => "text-2xl", TextSize.ThreeXL => "text-3xl",
            TextSize.FourXL => "text-4xl", TextSize.FiveXL => "text-5xl",
            _ => ""
        };
    }
    /// <inheritdoc />
    public override string GetTextTransformCss(TextTransform? transform)
    {
        return transform switch
        {
            TextTransform.None => "normal-case", TextTransform.Uppercase => "uppercase",
            TextTransform.Lowercase => "lowercase", TextTransform.Capitalize => "capitalize",
            _ => ""
        };
    }
    /// <inheritdoc />
    public override string GetTextDecorationCss(TextDecoration? decoration)
    {
        return decoration switch
        {
            TextDecoration.None => "no-underline", TextDecoration.Underline => "underline",
            TextDecoration.Overline => "overline", TextDecoration.LineThrough => "line-through",
            _ => ""
        };
    }
    /// <inheritdoc />
    public override string GetLineHeightCss(Leading? leading)
    {
        return leading switch
        {
            Leading.None => "leading-none", Leading.Tight => "leading-tight", Leading.Snug => "leading-snug",
            Leading.Normal => "leading-normal", Leading.Relaxed => "leading-relaxed", Leading.Loose => "leading-loose",
            _ => ""
        };
    }
    /// <inheritdoc />
    public override string GetBaseCss(SemanticColor? textColor, TextWeight? weight, TextSize? size, Leading? lineHeight,
        TextDecoration? decoration, TextTransform? transform)
    {
        // Combine all individual style parts
        return
            $"{textColor?.ToTextClass() ?? ""} {GetTextWeightCss(weight)} {GetTextSizeCss(size)} {GetLineHeightCss(lineHeight)} {GetTextDecorationCss(decoration)} {GetTextTransformCss(transform)}"
                .Trim();
    }
}
/// <summary> Provides default styles for RzHeading. </summary>
public class DefaultRzHeadingStyles : RzStylesBase.RzHeadingStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzHeadingStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzHeadingStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string GetLevelCss(HeadingLevel level)
    {
        return level switch
        {
            // Tailwind defaults provide good responsive sizing based on H tag
            HeadingLevel.H1 => "mb-5 text-xl sm:text-2xl md:text-3xl lg:text-4xl font-bold",
            HeadingLevel.H2 => "mb-4 text-lg sm:text-xl md:text-2xl lg:text-3xl font-semibold",
            HeadingLevel.H3 => "mb-3 text-base sm:text-lg md:text-xl lg:text-2xl font-medium",
            HeadingLevel.H4 => "mb-2 text-base sm:text-lg md:text-xl lg:text-2xl font-normal", // Adjusted H4 slightly
            _ => GetLevelCss(HeadingLevel.H1) // Default to H1 style if needed
        };
    }
}
/// <summary> Provides default styles for RzParagraph. </summary>
public class DefaultRzParagraphStyles : RzStylesBase.RzParagraphStylesBase
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DefaultRzParagraphStyles" /> class.
    /// </summary>
    /// <param name="theme">The theme instance providing styling context.</param>
    public DefaultRzParagraphStyles(RzTheme theme) : base(theme)
    {
    }
    /// <inheritdoc />
    public override string Paragraph => "my-4 leading-relaxed"; // Base margin and leading
    /// <inheritdoc />
    public override string GetProseWidthCss(ProseWidth width)
    {
        return width switch
        {
            ProseWidth.Compact => "max-w-prose prose-compact", // Use standard prose and potentially a custom compact utility if defined
            ProseWidth.Comfortable => "max-w-prose prose-comfortable",
            ProseWidth.Relaxed => "max-w-prose prose-relaxed",
            ProseWidth.Wide => "max-w-prose prose-wide",
            ProseWidth.UltraWide => "max-w-prose prose-ultrawide",
            ProseWidth.Full => "max-w-none", // No max-width constraint
            _ => GetProseWidthCss(ProseWidth.Full) // Default Paragraphs to full width unless specified
        };
    }
}
</file>

<file path="Components/Utility/ColorUtil.cs">
using System.Diagnostics.CodeAnalysis;
namespace RizzyUI;
/// <summary>
///     Provides utility methods for converting accent and semantic color values to complete Tailwind CSS class strings for
///     background and text styling.
/// </summary>
public static class ColorUtil
{
    // ReSharper disable once UnusedMember.Local
    [SuppressMessage("CodeQuality", "IDE0051:Remove unused private members",
        Justification = "This is to allow Tailwind utilities to discover used classes")]
#pragma warning disable CS0414 // Field is assigned but its value is never used
    private static readonly string TwBackgroundClassAfterDiscovery =
#pragma warning restore CS0414 // Field is assigned but its value is never used
        "after:bg-background after:bg-foreground after:bg-foreground after:bg-secondary after:bg-primary after:bg-primary-foreground after:bg-secondary after:bg-secondary-foreground after:bg-outline after:bg-outline-strong after:bg-destructive after:bg-destructive-foreground after:bg-info after:bg-info-foreground after:bg-warning after:bg-warning-foreground after:bg-success after:bg-success-foreground after:bg-background";
    /// <summary>
    ///     Converts an AccentColor to a background class string
    /// </summary>
    /// <param name="accentColor"></param>
    /// <returns></returns>
    public static string ToLightBackgroundClass(this AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "bg-gray-100",
            AccentColor.Emerald => "bg-emerald-200",
            AccentColor.Teal => "bg-teal-200",
            AccentColor.Blue => "bg-blue-200",
            AccentColor.Indigo => "bg-indigo-200",
            AccentColor.Purple => "bg-purple-200",
            AccentColor.Pink => "bg-pink-200",
            AccentColor.Red => "bg-red-200",
            AccentColor.Orange => "bg-orange-200",
            AccentColor.Yellow => "bg-yellow-300",
            _ => "bg-gray-100"
        };
    }
    /// <summary>
    ///     Converts an AccentColor to a background class string
    /// </summary>
    /// <param name="accentColor"></param>
    /// <returns></returns>
    public static string ToDarkBackgroundClass(this AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "bg-gray-400",
            AccentColor.Emerald => "bg-emerald-800",
            AccentColor.Teal => "bg-teal-600",
            AccentColor.Blue => "bg-blue-600",
            AccentColor.Indigo => "bg-indigo-700",
            AccentColor.Purple => "bg-purple-600",
            AccentColor.Pink => "bg-pink-500",
            AccentColor.Red => "bg-red-500",
            AccentColor.Orange => "bg-orange-500",
            AccentColor.Yellow => "bg-yellow-300",
            _ => "bg-gray-400"
        };
    }
    /// <summary>
    ///     Converts an AccentColor to a text class string
    /// </summary>
    /// <param name="accentColor"></param>
    /// <returns></returns>
    public static string ToTextClass(AccentColor accentColor)
    {
        return accentColor switch
        {
            AccentColor.Inherit => "",
            AccentColor.Gray => "text-gray-600",
            AccentColor.Emerald => "text-emerald-700",
            AccentColor.Teal => "text-teal-700",
            AccentColor.Blue => "text-blue-700",
            AccentColor.Indigo => "text-indigo-700",
            AccentColor.Purple => "text-purple-700",
            AccentColor.Pink => "text-pink-700",
            AccentColor.Red => "text-red-700",
            AccentColor.Orange => "text-orange-700",
            AccentColor.Yellow => "text-yellow-800",
            _ => "text-gray-600"
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a text class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS class.</returns>
    public static string ToTextClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "",
            // Surface Colors
            SemanticColor.Surface => "text-surface ",
            SemanticColor.OnSurface => "text-foreground ",
            SemanticColor.OnSurfaceStrong => "text-foreground ",
            SemanticColor.SurfaceAlt => "text-secondary ",
            SemanticColor.Primary => "text-primary ",
            SemanticColor.OnPrimary => "text-primary-foreground ",
            SemanticColor.Secondary => "text-secondary ",
            SemanticColor.OnSecondary => "text-secondary-foreground ",
            SemanticColor.Outline => "text-outline ",
            SemanticColor.OutlineStrong => "text-outline-strong ",
            // Status Colors (no dark variants)
            SemanticColor.Destructive => "text-destructive",
            SemanticColor.DestructiveForeground => "text-destructive-foreground",
            SemanticColor.Info => "text-info",
            SemanticColor.OnInfo => "text-onInfo",
            SemanticColor.Warning => "text-warning",
            SemanticColor.OnWarning => "text-warning-foreground",
            SemanticColor.Success => "text-success",
            SemanticColor.OnSuccess => "text-success-foreground",
            _ => "text-foreground "
        };
    }
    /// <summary>
    /// Converts a SemanticColor to a fill class string.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS fill class.</returns>
    public static string ToFillClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "", // Uses SpinnerBase default (fill-foreground)
            SemanticColor.Surface => "fill-surface",
            SemanticColor.OnSurface => "fill-foreground",
            SemanticColor.OnSurfaceStrong => "fill-foreground",
            SemanticColor.SurfaceAlt => "fill-secondary",
            SemanticColor.Primary => "fill-primary",
            SemanticColor.OnPrimary => "fill-primary-foreground",
            SemanticColor.Secondary => "fill-secondary",
            SemanticColor.OnSecondary => "fill-secondary-foreground",
            SemanticColor.Outline => "fill-outline",
            SemanticColor.OutlineStrong => "fill-outline-strong",
            SemanticColor.Destructive => "fill-destructive",
            SemanticColor.DestructiveForeground => "fill-destructive-foreground",
            SemanticColor.Info => "fill-info",
            SemanticColor.OnInfo => "fill-info-foreground", // Check if onInfo fill exists or adjust
            SemanticColor.Warning => "fill-warning",
            SemanticColor.OnWarning => "fill-warning-foreground",
            SemanticColor.Success => "fill-success",
            SemanticColor.OnSuccess => "fill-success-foreground",
            _ => "" // Fallback to SpinnerBase default
        };
    }
    /// <summary>
    ///     Converts a StatusColor to a text class string, including dark mode variants for Status colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS class.</returns>
    public static string ToTextClass(this StatusColor color)
    {
        return color switch
        {
            StatusColor.Primary => "text-primary-foreground ",
            StatusColor.Destructive => "text-destructive-foreground",
            StatusColor.Info => "text-onInfo",
            StatusColor.Secondary => "text-secondary-foreground",
            StatusColor.Success => "text-success-foreground",
            StatusColor.Warning => "text-warning-foreground",
            _ => "text-primary-foreground "
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a background class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <returns>A string representing the corresponding CSS background class.</returns>
    public static string ToBackgroundClass(this SemanticColor color)
    {
        return color switch
        {
            SemanticColor.None => "",
            // Surface Colors
            SemanticColor.Surface => "bg-background",
            SemanticColor.OnSurface => "bg-foreground",
            SemanticColor.OnSurfaceStrong => "bg-foreground",
            SemanticColor.SurfaceAlt => "bg-secondary",
            SemanticColor.Primary => "bg-primary",
            SemanticColor.OnPrimary => "bg-primary-foreground",
            SemanticColor.Secondary => "bg-secondary",
            SemanticColor.OnSecondary => "bg-secondary-foreground",
            SemanticColor.Outline => "bg-outline",
            SemanticColor.OutlineStrong => "bg-outline-strong",
            // Status Colors (no dark variants)
            SemanticColor.Destructive => "bg-destructive",
            SemanticColor.DestructiveForeground => "bg-destructive-foreground",
            SemanticColor.Info => "bg-info",
            SemanticColor.OnInfo => "bg-onInfo",
            SemanticColor.Warning => "bg-warning",
            SemanticColor.OnWarning => "bg-warning-foreground",
            SemanticColor.Success => "bg-success",
            SemanticColor.OnSuccess => "bg-success-foreground",
            _ => "bg-background "
        };
    }
    /// <summary>
    ///     Converts a SemanticColor to a background class string, including dark mode variants for Surface colors.
    /// </summary>
    /// <param name="color">The color enum value.</param>
    /// <param name="pseudoSelector">Tailwind pseudo element modifier ("before" or "after")</param>
    /// <returns>A string representing the corresponding CSS background class.</returns>
    public static string ToBackgroundClass(this SemanticColor color, string pseudoSelector)
    {
        var ps = pseudoSelector + ":";
        return color switch
        {
            SemanticColor.None => "",
            // Surface Colors
            SemanticColor.Surface => $"{ps}bg-background",
            SemanticColor.OnSurface => $"{ps}bg-foreground",
            SemanticColor.OnSurfaceStrong => $"{ps}bg-foreground",
            SemanticColor.SurfaceAlt => $"{ps}bg-secondary",
            SemanticColor.Primary => $"{ps}bg-primary",
            SemanticColor.OnPrimary => $"{ps}bg-primary-foreground",
            SemanticColor.Secondary => $"{ps}bg-secondary",
            SemanticColor.OnSecondary => $"{ps}bg-secondary-foreground",
            SemanticColor.Outline => $"{ps}bg-outline",
            SemanticColor.OutlineStrong => $"{ps}bg-outline-strong",
            // Status Colors (no dark variants)
            SemanticColor.Destructive => ps + "bg-destructive",
            SemanticColor.DestructiveForeground => ps + "bg-destructive-foreground",
            SemanticColor.Info => ps + "bg-info",
            SemanticColor.OnInfo => ps + "bg-onInfo",
            SemanticColor.Warning => ps + "bg-warning",
            SemanticColor.OnWarning => ps + "bg-warning-foreground",
            SemanticColor.Success => ps + "bg-success",
            SemanticColor.OnSuccess => ps + "bg-success-foreground",
            _ => "bg-background "
        };
    }
}
</file>

<file path="Components/Variants.cs">
using System.Diagnostics.CodeAnalysis;
namespace RizzyUI;
/// <summary>
///     Variants for alert components, defining their visual appearance.
/// </summary>
public enum AlertVariant
{
	/// <summary>
	///     Alert using the alternate background color
	/// </summary>
	Alternate,
    /// <summary>Informational alert, typically blue or neutral.</summary>
    Information,
    /// <summary>Success alert, often green to indicate positive feedback.</summary>
    Success,
    /// <summary>Warning alert, often yellow to indicate caution.</summary>
    Warning,
    /// <summary>Destructive alert, often red to indicate errors or critical issues.</summary>
    Destructive
}
/// <summary>
///     Variants for badge components, defining their style and context.
/// </summary>
public enum BadgeVariant
{
    /// <summary>Default badge styling.</summary>
    Default,
    /// <summary>Secondary badge, typically for less emphasized content.</summary>
    Secondary,
    /// <summary>Outlined badge for a minimal look.</summary>
    Outline,
    /// <summary>Success badge, often green for positive actions or states.</summary>
    Success,
    /// <summary>Informational badge, often blue or neutral.</summary>
    Info,
    /// <summary>Warning badge, often yellow for caution.</summary>
    Warning,
    /// <summary>Destructive badge, often red to indicate critical actions.</summary>
    Destructive
}
/// <summary>
///     Variants for button components, defining their appearance and purpose.
/// </summary>
public enum ButtonVariant
{
    /// <summary>Default button styling.</summary>
    Default,
    /// <summary>Primary button for main actions, often bold and attention-grabbing.</summary>
    Primary,
    /// <summary>Secondary button for supporting actions.</summary>
    Secondary,
    /// <summary>Alternate button styling for varied contexts.</summary>
    Alternate,
    /// <summary>Inverse button styling for dark backgrounds.</summary>
    Inverse,
    /// <summary>Information button, typically blue for neutral actions.</summary>
    Information,
    /// <summary>Destructive button, often red for critical actions.</summary>
    Destructive,
    /// <summary>Warning button, often yellow for cautionary actions.</summary>
    Warning,
    /// <summary>Success button, often green for positive actions.</summary>
    Success,
    /// <summary>Ghost button for minimal and subtle interactions.</summary>
    Ghost
}
/// <summary>
///     Appearance option for divider
/// </summary>
public enum DividerStyle
{
	/// <summary>
	///     Solid line
	/// </summary>
	Solid,
	/// <summary>
	///     Dashed line
	/// </summary>
	Dashed,
	/// <summary>
	///     Dotted line
	/// </summary>
	Dotted
}
/// <summary>
///     Size options for various components to define their dimensions.
/// </summary>
public enum Size
{
    /// <summary>Extra small size, for compact components.</summary>
    ExtraSmall,
    /// <summary>Small size, smaller than the default.</summary>
    Small,
    /// <summary>Medium size, the default size.</summary>
    Medium,
    /// <summary>Large size, for bigger components.</summary>
    Large,
    /// <summary>Extra large size, for oversized components.</summary>
    ExtraLarge
}
/// <summary>
///     Defines available width options for prose content, measured in approximate characters per line (CPL).
/// </summary>
public enum ProseWidth
{
	/// <summary>
	///     A compact width, approximately 56 characters per line.
	///     Best for sidebars, footnotes, or narrow content blocks.
	/// </summary>
	Compact,
	/// <summary>
	///     A comfortable width, approximately 64 characters per line.
	///     Ideal for general prose readability in documentation and articles.
	/// </summary>
	Comfortable,
	/// <summary>
	///     A relaxed width, approximately 72 characters per line.
	///     Provides more space while maintaining good readability.
	/// </summary>
	Relaxed,
	/// <summary>
	///     A wide width, approximately 80 characters per line.
	///     Suitable for blog posts, long-form content, and expanded reading areas.
	/// </summary>
	Wide,
	/// <summary>
	///     An ultrawide width, approximately 100 characters per line.
	///     Best for technical documentation, research papers, or code-heavy content.
	/// </summary>
	UltraWide,
	/// <summary>
	///     No maximum width constraint.
	///     Useful for tables, charts, or content requiring full-width display.
	/// </summary>
	Full
}
/// <summary>
///     Justification options for layout alignment.
/// </summary>
public enum Justify
{
    /// <summary>Align items to the start.</summary>
    Start,
    /// <summary>Center align items.</summary>
    Center,
    /// <summary>Align items to the end.</summary>
    End
}
/// <summary>
///     Alignment options.
/// </summary>
public enum Align
{
    /// <summary>Align items to the start.</summary>
    Start,
    /// <summary>Center align items.</summary>
    Center,
    /// <summary>Align items to the end.</summary>
    End
}
/// <summary>
///     Anchor point options
/// </summary>
public enum AnchorPoint
{
	/// <summary>
	///     Anchor to top start
	/// </summary>
	TopStart,
	/// <summary>
	///     Anchor to top with center-alignment
	/// </summary>
	TopCenter,
	/// <summary>
	///     Anchor to top end
	/// </summary>
	TopEnd,
	/// <summary>
	///     Anchor to Start middle
	/// </summary>
	Start,
	/// <summary>
	///     Anchor to end middle
	/// </summary>
	End,
	/// <summary>
	///     Anchor to bottom end
	/// </summary>
	BottomEnd,
	/// <summary>
	///     Anchor to bottom start
	/// </summary>
	BottomStart,
	/// <summary>
	///     Anchor to bottom center
	/// </summary>
	BottomCenter
}
/// <summary>
///     Specifies the origin point for transformations.
/// </summary>
public enum OriginPoint
{
	/// <summary>
	///     Origin at the center.
	/// </summary>
	OriginCenter,
	/// <summary>
	///     Origin at the top.
	/// </summary>
	OriginTop,
	/// <summary>
	///     Origin at the top-right.
	/// </summary>
	OriginTopRight,
	/// <summary>
	///     Origin at the right.
	/// </summary>
	OriginRight,
	/// <summary>
	///     Origin at the bottom-right.
	/// </summary>
	OriginBottomRight,
	/// <summary>
	///     Origin at the bottom.
	/// </summary>
	OriginBottom,
	/// <summary>
	///     Origin at the bottom-left.
	/// </summary>
	OriginBottomLeft,
	/// <summary>
	///     Origin at the left.
	/// </summary>
	OriginLeft,
	/// <summary>
	///     Origin at the top-left.
	/// </summary>
	OriginTopLeft
}
/// <summary>
///     Shape options for avatar components.
/// </summary>
public enum AvatarShape
{
    /// <summary>Circle-shaped avatar.</summary>
    Circle,
    /// <summary>Square-shaped avatar.</summary>
    Square
}
/// <summary>
///     Size options for modal components based on Tailwind's max-width utilities.
/// </summary>
[SuppressMessage("ReSharper", "InconsistentNaming")]
public enum ModalSize
{
    /// <summary>Extra small modal, max-width: 320px.</summary>
    ExtraSmall,
    /// <summary>Small modal, max-width: 384px.</summary>
    Small,
    /// <summary>Medium modal, max-width: 448px.</summary>
    Medium,
    /// <summary>Large modal, max-width: 512px.</summary>
    Large,
    /// <summary>Extra large modal, max-width: 576px.</summary>
    ExtraLarge,
    /// <summary>2XL modal, max-width: 672px.</summary>
    TwoXL,
    /// <summary>3XL modal, max-width: 768px.</summary>
    ThreeXL,
    /// <summary>4XL modal, max-width: 896px.</summary>
    FourXL,
    /// <summary>5XL modal, max-width: 1024px.</summary>
    FiveXL,
    /// <summary>6XL modal, max-width: 1152px.</summary>
    SixXL,
    /// <summary>7XL modal, max-width: 1280px.</summary>
    SevenXL
}
/// <summary>
///     SemanticColor options for components, including surface and status colors.
/// </summary>
public enum SemanticColor
{
    /// <summary>No color specified.</summary>
    None,
    /// <summary>Surface color, typically for backgrounds.</summary>
    Surface,
    /// <summary>Foreground color on surface.</summary>
    OnSurface,
    /// <summary>Strong foreground color on surface.</summary>
    OnSurfaceStrong,
    /// <summary>Alternate surface color for secondary areas.</summary>
    SurfaceAlt,
    /// <summary>Primary color for highlights or accents.</summary>
    Primary,
    /// <summary>Foreground color on primary background.</summary>
    OnPrimary,
    /// <summary>Secondary color for less emphasized elements.</summary>
    Secondary,
    /// <summary>Foreground color on secondary background.</summary>
    OnSecondary,
    /// <summary>Outline color for borders or separators.</summary>
    Outline,
    /// <summary>Strong outline color for emphasis.</summary>
    OutlineStrong,
    /// <summary>Destructive color, often red for errors.</summary>
    Destructive,
    /// <summary>Foreground color on danger background.</summary>
    DestructiveForeground,
    /// <summary>Informational color, often blue or neutral.</summary>
    Info,
    /// <summary>Foreground color on info background.</summary>
    OnInfo,
    /// <summary>Warning color, often yellow for caution.</summary>
    Warning,
    /// <summary>Foreground color on warning background.</summary>
    OnWarning,
    /// <summary>Success color, often green for positive feedback.</summary>
    Success,
    /// <summary>Foreground color on success background.</summary>
    OnSuccess
}
/// <summary>
///     Accent color options for highlighting elements.
/// </summary>
public enum AccentColor
{
    /// <summary>Inherit accent color from parent context.</summary>
    Inherit,
    /// <summary>Gray accent color.</summary>
    Gray,
    /// <summary>Emerald green accent color.</summary>
    Emerald,
    /// <summary>Teal accent color.</summary>
    Teal,
    /// <summary>Blue accent color.</summary>
    Blue,
    /// <summary>Indigo accent color.</summary>
    Indigo,
    /// <summary>Purple accent color.</summary>
    Purple,
    /// <summary>Pink accent color.</summary>
    Pink,
    /// <summary>Red accent color.</summary>
    Red,
    /// <summary>Orange accent color.</summary>
    Orange,
    /// <summary>Yellow accent color.</summary>
    Yellow
}
/// <summary>
///     Defines the status color variants
/// </summary>
public enum StatusColor
{
    /// <summary>Primary status color.</summary>
    Primary,
    /// <summary>Secondary status color.</summary>
    Secondary,
    /// <summary>Success status color.</summary>
    Success,
    /// <summary>Info status color.</summary>
    Info,
    /// <summary>Warning status color.</summary>
    Warning,
    /// <summary>Destructive status color.</summary>
    Destructive
}
/// <summary>
///     Defines the label position options for the Progress component.
/// </summary>
public enum ProgressLabelPosition
{
    /// <summary>Label is positioned inside the progress bar.</summary>
    Inside,
    /// <summary>Label is positioned outside the progress bar.</summary>
    Outside
}
</file>

<file path="Constants.cs">
namespace RizzyUI;
/// <summary>
/// Contains constant values used throughout the RizzyUI library.
/// </summary>
public static class Constants
{
    /// <summary>
    /// Package name used for content resolution.
    /// </summary>
    public const string PackageName = "RizzyUI";
    /// <summary>
    /// Conventional name for RizzyLocalization override resource files provided by the consuming application.
    /// </summary>
    public const string RizzyLocalizationResourceName = "RizzyLocalization";
    /// <summary>
    /// Resolves path to internal package assets.
    /// </summary>
    /// <param name="path">The relative path within the package's wwwroot.</param>
    /// <returns>A URL path suitable for referencing package content (e.g., /_content/RizzyUI/js/rizzyui.js).</returns>
    public static string ContentUrl(string path)
    {
        // Ensure leading slash is removed if present, as ContentUrl assumes relative path from wwwroot
        path = path.TrimStart('/');
        return $"/_content/{PackageName}/{path}";
    }
    /// <summary>
    /// Contains constant definitions for custom JavaScript event names dispatched or listened to by RizzyUI components.
    /// Using these constants ensures consistency and avoids magic strings.
    /// </summary>
    public static class Events
    {
        /// <summary>
        /// The default event name that the RzModal component listens for to trigger closing via external sources (e.g., HTMX HX-Trigger header).
        /// Can be overridden via the `CloseEventName` parameter on RzModal.
        /// </summary>
        /// <remarks>Value: "rz:modal-close"</remarks>
        public const string ModalClose = "rz:modal-close";
        /// <summary>
        /// Fired by the RzModal Alpine component once during initialization, after its properties are set but before listeners are attached.
        /// Detail: `{ modalId: string, bodyId: string, footerId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-initialized"</remarks>
        public const string ModalInitialized = "rz:modal-initialized";
        /// <summary>
        /// Fired by the RzModal Alpine component just before the modal's `modalOpen` state is set to `true`. This event is cancelable.
        /// Detail: `{ modalId: string, originalEvent: Event | null }`
        /// </summary>
        /// <remarks>Value: "rz:modal-before-open"</remarks>
        public const string ModalBeforeOpen = "rz:modal-before-open";
        /// <summary>
        /// Fired by the RzModal Alpine component after the modal's `modalOpen` state is set to `true` and opening transitions are likely complete.
        /// Detail: `{ modalId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-after-open"</remarks>
        public const string ModalAfterOpen = "rz:modal-after-open";
        /// <summary>
        /// Fired by the RzModal Alpine component just before the modal's `modalOpen` state is set to `false`. This event is cancelable.
        /// Detail: `{ modalId: string, reason: 'escape' | 'backdrop' | 'button' | 'event' }`
        /// </summary>
        /// <remarks>Value: "rz:modal-before-close"</remarks>
        public const string ModalBeforeClose = "rz:modal-before-close";
        /// <summary>
        /// Fired by the RzModal Alpine component after the modal's `modalOpen` state is set to `false` and closing transitions are likely complete.
        /// Detail: `{ modalId: string }`
        /// </summary>
        /// <remarks>Value: "rz:modal-after-close"</remarks>
        public const string ModalAfterClose = "rz:modal-after-close";
    }
}
</file>

<file path="Extensions/MarkdigExtensions.cs">
using Markdig;
using Markdig.Renderers;
using Markdig.Renderers.Html;
using Markdig.Renderers.Html.Inlines;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
namespace RizzyUI.Extensions;
/// <summary>
///     A Markdown extension that customizes the rendering of both block and inline code.
///     It ensures that all code tags include the "hljs" class, wraps fenced code blocks in a &lt;pre&gt; tag,
///     and renders inline code without a &lt;pre&gt; wrapper.
/// </summary>
public class RizzyCodeBlockExtension : IMarkdownExtension
{
    /// <summary>
    ///     Performs initial setup for the Markdown pipeline.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline builder.</param>
    public void Setup(MarkdownPipelineBuilder pipeline)
    {
        // No additional setup required.
    }
    /// <summary>
    ///     Configures the Markdown renderer to use custom renderers for code blocks and inline code.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline.</param>
    /// <param name="renderer">The Markdown renderer.</param>
    public void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer)
    {
        if (renderer is HtmlRenderer htmlRenderer)
        {
            // Remove and replace the existing CodeBlockRenderer.
            var originalCodeBlockRenderer = htmlRenderer.ObjectRenderers.FindExact<CodeBlockRenderer>();
            if (originalCodeBlockRenderer != null) htmlRenderer.ObjectRenderers.Remove(originalCodeBlockRenderer);
            htmlRenderer.ObjectRenderers.AddIfNotAlready(new RizzyCodeBlockRenderer(originalCodeBlockRenderer));
            // Remove and replace the existing CodeInlineRenderer.
            var originalCodeInlineRenderer = htmlRenderer.ObjectRenderers.FindExact<CodeInlineRenderer>();
            if (originalCodeInlineRenderer != null) htmlRenderer.ObjectRenderers.Remove(originalCodeInlineRenderer);
            htmlRenderer.ObjectRenderers.AddIfNotAlready(new RizzyCodeInlineRenderer(originalCodeInlineRenderer));
        }
    }
}
/// <summary>
///     A custom HTML renderer for Markdown code blocks that outputs them with the "hljs" class and an optional language
///     class.
///     Fenced code blocks are wrapped in &lt;pre&gt; tags, while non-fenced blocks are rendered with just a &lt;code&gt;
///     tag.
/// </summary>
public class RizzyCodeBlockRenderer : HtmlObjectRenderer<CodeBlock>
{
    private readonly CodeBlockRenderer? _originalRenderer;
    /// <summary>
    ///     Initializes a new instance of the <see cref="RizzyCodeBlockRenderer" /> class.
    /// </summary>
    /// <param name="originalRenderer">The original code block renderer, if any.</param>
    public RizzyCodeBlockRenderer(CodeBlockRenderer? originalRenderer = null)
    {
        _originalRenderer = originalRenderer;
    }
    /// <summary>
    ///     Writes the specified <see cref="CodeBlock" /> as HTML.
    /// </summary>
    /// <param name="renderer">The HTML renderer.</param>
    /// <param name="obj">The code block to render.</param>
    protected override void Write(HtmlRenderer renderer, CodeBlock obj)
    {
        // Build the base class attribute value with "hljs".
        var classes = "hljs";
        if (obj is FencedCodeBlock fencedCodeBlock)
        {
            var language = fencedCodeBlock.Info?.Trim() ?? string.Empty;
            if (!string.IsNullOrEmpty(language)) classes += $" language-{language}";
            // Write the opening tags for a fenced code block.
            renderer.Write("<pre><code");
            renderer.Write($" class=\"{classes}\"");
            renderer.Write(">");
        }
        else
        {
            // For non-fenced code blocks, only write the <code> tag.
            renderer.Write("<code");
            renderer.Write($" class=\"{classes}\"");
            renderer.Write(">");
        }
        // Write the content of the code block with HTML escaping.
        var content = obj.Lines.ToString();
        renderer.WriteEscape(content);
        // Write the closing tags.
        if (obj is FencedCodeBlock)
            renderer.Write("</code></pre>");
        else
            renderer.Write("</code>");
    }
}
/// <summary>
///     A custom HTML renderer for inline code that outputs code spans with the "hljs" class.
///     Inline code is rendered without a wrapping &lt;pre&gt; tag.
/// </summary>
public class RizzyCodeInlineRenderer : HtmlObjectRenderer<CodeInline>
{
    private readonly CodeInlineRenderer? _originalRenderer;
    /// <summary>
    ///     Initializes a new instance of the <see cref="RizzyCodeInlineRenderer" /> class.
    /// </summary>
    /// <param name="originalRenderer">The original inline code renderer, if any.</param>
    public RizzyCodeInlineRenderer(CodeInlineRenderer? originalRenderer = null)
    {
        _originalRenderer = originalRenderer;
    }
    /// <summary>
    ///     Writes the specified <see cref="CodeInline" /> as HTML.
    /// </summary>
    /// <param name="renderer">The HTML renderer.</param>
    /// <param name="obj">The inline code element to render.</param>
    protected override void Write(HtmlRenderer renderer, CodeInline obj)
    {
        renderer.Write("<code class=\"hljs\">");
        renderer.WriteEscape(obj.Content);
        renderer.Write("</code>");
    }
}
/// <summary>
///     Provides extension methods for <see cref="MarkdownPipelineBuilder" /> to add Rizzy syntax highlighting.
/// </summary>
public static class MarkdownPipelineBuilderExtensions
{
    /// <summary>
    ///     Adds the Rizzy syntax highlighting extension to the Markdown pipeline.
    /// </summary>
    /// <param name="pipeline">The Markdown pipeline builder.</param>
    /// <returns>The updated Markdown pipeline builder.</returns>
    public static MarkdownPipelineBuilder UseRizzySyntaxHighlighting(this MarkdownPipelineBuilder pipeline)
    {
        pipeline.Extensions.Add(new RizzyCodeBlockExtension());
        return pipeline;
    }
}
</file>

<file path="Extensions/ServiceCollectionExtensions.cs">
using System;
using System.Linq;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
using RizzyUI.Localization;
using TailwindMerge.Extensions;
namespace RizzyUI;
/// <summary>
/// Provides extension methods for registering RizzyUI services with the dependency injection container.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds RizzyUI services to the specified <see cref="IServiceCollection"/> and configures RizzyUI options.
    /// </summary>
    /// <param name="services">The <see cref="IServiceCollection"/> to add services to.</param>
    /// <param name="configure">An action delegate to configure the <see cref="RizzyUIConfig"/>.</param>
    /// <returns>The <see cref="IServiceCollection"/> so that additional calls can be chained.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="configure"/> is null.</exception>
    public static IServiceCollection AddRizzyUI(this IServiceCollection services, Action<RizzyUIConfig> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);
        // Register IOptions<RizzyUIConfig> and apply the user's configuration.
        services.Configure(configure);
        // Call the internal method that performs the actual service registration.
        return services.AddRizzyUIInternal();
    }
    /// <summary>
    /// Adds RizzyUI services to the specified <see cref="IServiceCollection"/> with default options.
    /// </summary>
    /// <param name="services">The <see cref="IServiceCollection"/> to add services to.</param>
    /// <returns>The <see cref="IServiceCollection"/> so that additional calls can be chained.</returns>
    public static IServiceCollection AddRizzyUI(this IServiceCollection services)
    {
        // Ensure IOptions infrastructure is registered even if no specific configuration is provided.
        services.Configure<RizzyUIConfig>(config => { });
        return services.AddRizzyUIInternal();
    }
    /// <summary>
    /// Internal helper method containing the core service registrations for RizzyUI.
    /// Sets up TailwindMerge, HTTP context access, nonce provider, and localization.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <returns>The service collection.</returns>
    private static IServiceCollection AddRizzyUIInternal(this IServiceCollection services)
    {
        // Register core dependencies used by RizzyUI.
        services.AddTailwindMerge();
        services.AddHttpContextAccessor();
        services.TryAddScoped<IRizzyNonceProvider, RizzyNonceProvider>();
        // --- Localization Setup ---
        bool localizationFactoryRegistered = services.Any(d => d.ServiceType == typeof(IStringLocalizerFactory));
        if (localizationFactoryRegistered)
        {
            // Decorate the existing factory IF localization is configured.
            services.Decorate<IStringLocalizerFactory>((innerFactory, sp) =>
            {
                var config = sp.GetRequiredService<IOptions<RizzyUIConfig>>().Value;
                // Pass the original factory, the service provider, and override config.
                return new RizzyStringLocalizerFactory(
                    innerFactory,
                    sp, // Provide IServiceProvider
                    config.LocalizationResourceType,
                    config.LocalizationResourceLocation
                );
            });
        }
        else
        {
            // If no factory registered, register the dummy for RizzyUI's needs.
            services.TryAddSingleton<IStringLocalizer<RizzyLocalization>, DummyRizzyStringLocalizer>();
        }
        return services;
    }
}
</file>

<file path="Extensions/StringExtensions.cs">
using System.Text;
namespace RizzyUI.Extensions;
internal static class StringExtensions
{
    private static readonly Random _random = new(Environment.TickCount);
    /// <summary>
    ///     Removes the minimum shared run of leading whitespace characters
    ///     (spaces, tabs, etc.) from each non-empty line in the given text.
    /// </summary>
    /// <param name="text">Multi-line string input.</param>
    /// <returns>
    ///     A new string with each non-empty line outdented by the
    ///     minimal number of leading whitespace characters found.
    /// </returns>
    public static string Outdent(this string text)
    {
        // Early exit for null or empty input
        if (string.IsNullOrEmpty(text))
            return text;
        // Split the input text into lines, preserving empty lines
        var lines = text.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
        var minLeadingWhitespace = int.MaxValue;
        // 1st pass: Determine the minimum number of consecutive leading whitespace chars on non-whitespace lines
        foreach (var line in lines)
        {
            // Skip lines that are blank or entirely whitespace
            if (string.IsNullOrWhiteSpace(line))
                continue;
            var count = 0;
            while (count < line.Length && char.IsWhiteSpace(line[count])) count++;
            if (count < minLeadingWhitespace)
            {
                minLeadingWhitespace = count;
                if (minLeadingWhitespace == 0)
                    // Can't do better than zero; break early
                    break;
            }
        }
        // If no non-whitespace lines were found, or minLeadingWhitespace is zero, no outdent needed
        if (minLeadingWhitespace == int.MaxValue || minLeadingWhitespace == 0)
            return text;
        // 2nd pass: Build a new string with the computed leading whitespace removed
        var sb = new StringBuilder(text.Length);
        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];
            if (string.IsNullOrEmpty(line))
            {
                // Preserve blank lines as-is (including whitespace-only lines)
                sb.AppendLine(line);
            }
            else
            {
                // Remove exactly minLeadingWhitespace characters from the start,
                // or use an empty string if the line is shorter.
                var outdentedLine = line.Length >= minLeadingWhitespace
                    ? line.Substring(minLeadingWhitespace)
                    : string.Empty;
                sb.AppendLine(outdentedLine);
            }
        }
        // Optionally remove the final newline if you prefer not to have one
        if (sb.Length > 0 && sb[sb.Length - 1] == '\n')
        {
            sb.Length--;
            // If the preceding char is '\r', remove that too
            if (sb.Length > 0 && sb[sb.Length - 1] == '\r')
                sb.Length--;
        }
        return sb.ToString();
    }
    /// <summary>
    ///     Shuffle the characters in a string
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public static string Shuffle(this string input)
    {
        return new string(input.ToCharArray()
            .OrderBy(x => _random.Next())
            .ToArray());
    }
    public static string TrimEmptyLines(this string input)
    {
        if (string.IsNullOrWhiteSpace(input)) return string.Empty;
        // Split the string into lines
        var lines = input.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
        // Find the first non-empty line
        var start = 0;
        while (start < lines.Length && string.IsNullOrWhiteSpace(lines[start])) start++;
        // Find the last non-empty line
        var end = lines.Length - 1;
        while (end >= start && string.IsNullOrWhiteSpace(lines[end])) end--;
        // Join the lines back together, trimming the empty ones
        return string.Join(Environment.NewLine, lines[start..(end + 1)]);
    }
}
</file>

<file path="Extensions/TwMergeExtensions.cs">
using System.Globalization;
using TailwindMerge;
namespace RizzyUI.Extensions;
internal static class TwMergeExtensions
{
    public static string? Merge(this TwMerge twMerge, IReadOnlyDictionary<string, object>? additionalAttributes,
        params string[] classNames)
    {
        if (additionalAttributes is null || !additionalAttributes.TryGetValue("class", out var @class))
            return classNames.Length == 1 ? classNames[0] : twMerge.Merge(classNames);
        var classAttributeValue = Convert.ToString(@class, CultureInfo.InvariantCulture);
        if (string.IsNullOrEmpty(classAttributeValue))
            return classNames.Length == 1 ? classNames[0] : twMerge.Merge(classNames);
        if (classNames.Length == 0) return classAttributeValue;
        return twMerge.Merge([.. classNames, classAttributeValue]) ?? string.Empty;
    }
}
</file>

<file path="GlobalSuppressions.cs">
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project.
// Project-level suppressions either have no target or are given
// a specific target and scoped to a namespace, type, member, etc.
using System.Diagnostics.CodeAnalysis;
[assembly:
    SuppressMessage("Style", "IDE0130:Namespace does not match folder structure", Justification = "<Pending>",
        Scope = "namespace", Target = "~N:RizzyUI")]
</file>

<file path="GlobalUsings.cs">
// Global using directives
global using Rizzy;
</file>

<file path="Localization/DummyRizzyStringLocalizer.cs">
using System.Collections.Generic;
using System.Globalization;
using System.Linq; // Required for Enumerable.Empty
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging; // Required for ILogger
namespace RizzyUI.Localization;
/// <summary>
/// A dummy implementation of <see cref="IStringLocalizer{T}"/> for <see cref="RizzyLocalization"/>.
/// This is registered as a fallback when the consuming application has not configured
/// standard ASP.NET Core localization services. It returns the requested resource key
/// as the localized value and logs a warning upon creation.
/// </summary>
internal sealed class DummyRizzyStringLocalizer : IStringLocalizer<RizzyLocalization>
{
    private readonly ILogger<DummyRizzyStringLocalizer> _logger;
    /// <summary>
    /// Initializes a new instance of the <see cref="DummyRizzyStringLocalizer"/> class
    /// and logs a warning indicating that localization services are missing.
    /// </summary>
    /// <param name="logger">The logger instance.</param>
    public DummyRizzyStringLocalizer(ILogger<DummyRizzyStringLocalizer> logger)
    {
        _logger = logger;
        // Log the warning only once when this dummy localizer is instantiated.
        _logger.LogWarning("RizzyUI: ASP.NET Core Localization services (AddLocalization) were not detected or IStringLocalizerFactory is missing. RizzyUI components will display resource keys instead of localized text. Configure localization in Program.cs to enable translations.");
    }
    /// <summary>
    /// Returns a <see cref="LocalizedString"/> where the value is the resource key itself,
    /// indicating that the resource was not found because localization is not configured.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <returns>A <see cref="LocalizedString"/> with the key as the value and ResourceNotFound set to true.</returns>
    public LocalizedString this[string name] =>
        // Return the key itself as the value, marking it as not found.
        new(name, name, resourceNotFound: true);
    /// <summary>
    /// Returns a formatted <see cref="LocalizedString"/> where the value is the resource key itself,
    /// indicating that the resource was not found because localization is not configured.
    /// Formatting arguments are ignored as there is no format string.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <param name="arguments">The formatting arguments (ignored).</param>
    /// <returns>A <see cref="LocalizedString"/> with the key as the value and ResourceNotFound set to true.</returns>
    public LocalizedString this[string name, params object[] arguments] =>
        // Return the key itself, arguments are ignored as there's no format string.
        new(name, name, resourceNotFound: true);
    /// <summary>
    /// Returns an empty enumeration, as no localized strings are available
    /// when using this dummy implementation.
    /// </summary>
    /// <param name="includeParentCultures">This parameter is ignored.</param>
    /// <returns>An empty <see cref="IEnumerable{LocalizedString}"/>.</returns>
    public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures)
    {
        // No strings are technically "found" in this dummy implementation.
        return [];
    }
}
</file>

<file path="Localization/RizzyStringLocalizer.cs">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.Extensions.Localization;
namespace RizzyUI.Localization;
/// <summary>
/// Implements <see cref="IStringLocalizer{T}"/> for <see cref="RizzyLocalization"/> by first attempting
/// to find a localized string in the resources provided by the consuming application (override resources),
/// and if not found (or if the override only returned the key), falling back to the default resources
/// embedded within the RizzyUI library.
/// </summary>
/// <remarks>
/// This enables users of the RizzyUI library to override default translations or provide
/// translations for cultures not directly supported by the library. The correct culture is
/// determined by the ambient <see cref="CultureInfo.CurrentUICulture"/>.
/// </remarks>
internal sealed class RizzyStringLocalizer : IStringLocalizer<RizzyLocalization>, IStringLocalizer
{
    private readonly IStringLocalizer _applicationOverrideLocalizer;
    private readonly IStringLocalizer _rizzyLocalizer;
    /// <summary>
    /// Initializes a new instance of the <see cref="RizzyStringLocalizer"/> class.
    /// </summary>
    /// <param name="applicationOverrideLocalizer">The string localizer for the application's override resources (or a dummy if none configured).</param>
    /// <param name="rizzyLocalizer">The string localizer for RizzyUI's default embedded resources.</param>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="applicationOverrideLocalizer"/> or <paramref name="rizzyLocalizer"/> is null.</exception>
    public RizzyStringLocalizer(
        IStringLocalizer applicationOverrideLocalizer,
        IStringLocalizer rizzyLocalizer)
    {
        _applicationOverrideLocalizer = applicationOverrideLocalizer ?? throw new ArgumentNullException(nameof(applicationOverrideLocalizer));
        _rizzyLocalizer = rizzyLocalizer ?? throw new ArgumentNullException(nameof(rizzyLocalizer));
    }
    /// <summary>
    /// Gets the localized string for the specified name.
    /// It checks the application's override localizer first. If the resource is found there
    /// (and the value is not just the key itself), it returns the application's value.
    /// Otherwise, it falls back to RizzyUI's default embedded localizer.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <returns>The localized string.</returns>
    public LocalizedString this[string name]
    {
        get
        {
            var appString = _applicationOverrideLocalizer[name];
            // Check if the resource was truly found in the application override
            // Some localizers might return the key if not found, so check both flags.
            if (!appString.ResourceNotFound || !appString.Value.Equals(name, StringComparison.Ordinal))
            {
                return appString;
            }
            // Fallback to the library's default localizer
            return _rizzyLocalizer[name];
        }
    }
    /// <summary>
    /// Gets the formatted localized string for the specified name.
    /// It checks the application's override localizer first. If the resource is found there
    /// (and the value is not just the key itself), it returns the application's formatted value.
    /// Otherwise, it falls back to RizzyUI's default embedded localizer for formatting.
    /// </summary>
    /// <param name="name">The name (key) of the string resource.</param>
    /// <param name="arguments">The values to format the string with.</param>
    /// <returns>The formatted localized string.</returns>
    public LocalizedString this[string name, params object[] arguments]
    {
        get
        {
            var appString = _applicationOverrideLocalizer[name, arguments];
             if (!appString.ResourceNotFound || !appString.Value.Equals(name, StringComparison.Ordinal))
            {
                return appString;
            }
            // Fallback to the library's default localizer for formatting
            return _rizzyLocalizer[name, arguments];
        }
    }
    /// <summary>
    /// Gets all localized strings for the current UI culture, merging application overrides with
    /// RizzyUI's default embedded resources. Application strings take precedence if keys conflict
    /// and the application resource was actually found (not just the key returned).
    /// </summary>
    /// <param name="includeParentCultures">Flag indicating whether strings from parent cultures should be included.</param>
    /// <returns>A collection of localized strings, with application overrides taking precedence.</returns>
    public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures)
    {
        // Start with RizzyUI's default strings as the base.
        var mergedStrings = _rizzyLocalizer.GetAllStrings(includeParentCultures)
                               .ToDictionary(ls => ls.Name, ls => ls);
        // Get application strings and merge/overwrite entries in the dictionary.
        var appStrings = _applicationOverrideLocalizer.GetAllStrings(includeParentCultures);
        foreach (var appString in appStrings)
        {
            // Only overwrite if the application resource was truly found
            if (!appString.ResourceNotFound || !appString.Value.Equals(appString.Name, StringComparison.Ordinal))
            {
                 mergedStrings[appString.Name] = appString; // Overwrites library string if key exists
            }
        }
        return mergedStrings.Values;
    }
}
</file>

<file path="Localization/RizzyStringLocalizerFactory.cs">
using System.Globalization;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RizzyUI.Localization;
namespace RizzyUI;
/// <summary>
/// A custom <see cref="IStringLocalizerFactory"/> implementation that decorates the
/// default ASP.NET Core factory. When creating a localizer for <see cref="RizzyLocalization"/>,
/// it ensures the library's embedded resources are found correctly, independent of the
/// application's `LocalizationOptions.ResourcesPath`, while still allowing application overrides
/// that *do* respect the application's configuration. It caches the library-specific localizer
/// for performance.
/// </summary>
internal sealed class RizzyStringLocalizerFactory : IStringLocalizerFactory
{
    private readonly IStringLocalizerFactory _originalFactory;
    private readonly IServiceProvider _serviceProvider; // Needed to create a separate factory instance
    private readonly Type? _localizationResourceType;
    private readonly string? _localizationResourceLocation;
    // Replace the field and lock with a Lazy<T> instance
    private readonly Lazy<IStringLocalizer> _cachedLibraryLocalizer;
    /// <summary>
    /// Initializes a new instance of the <see cref="RizzyStringLocalizerFactory"/> class.
    /// </summary>
    /// <param name="originalFactory">The original <see cref="IStringLocalizerFactory"/> being decorated.</param>
    /// <param name="serviceProvider">The service provider to resolve dependencies for creating a default factory.</param>
    /// <param name="localizationResourceType">The application-provided marker type for override resources (optional).</param>
    /// <param name="localizationResourceLocation">The application-provided location for override resources (optional).</param>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="originalFactory"/> or <paramref name="serviceProvider"/> is null.</exception>
    public RizzyStringLocalizerFactory(
        IStringLocalizerFactory originalFactory,
        IServiceProvider serviceProvider,
        Type? localizationResourceType,
        string? localizationResourceLocation)
    {
        _originalFactory = originalFactory ?? throw new ArgumentNullException(nameof(originalFactory));
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
        _localizationResourceType = localizationResourceType;
        _localizationResourceLocation = localizationResourceLocation;
        // Initialize the lazy field with a factory delegate
        _cachedLibraryLocalizer = new Lazy<IStringLocalizer>(CreateLibraryLocalizer, LazyThreadSafetyMode.ExecutionAndPublication);
    }
    /// <summary>
    /// Creates an <see cref="IStringLocalizer"/> using the specified resource source type.
    /// If the type is <see cref="RizzyLocalization"/>, it returns a composite
    /// <see cref="RizzyStringLocalizer"/>. Otherwise, it delegates to the original factory.
    /// </summary>
    /// <param name="resourceSource">The <see cref="Type"/> to create a localizer for.</param>
    /// <returns>An appropriate <see cref="IStringLocalizer"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="resourceSource"/> is null.</exception>
    public IStringLocalizer Create(Type resourceSource)
    {
        ArgumentNullException.ThrowIfNull(resourceSource);
        if (resourceSource == typeof(RizzyLocalization))
        {
            // --- Get/Create the library localizer (cached) ---
            // This uses a separate factory instance with default options to ensure
            // RizzyUI's embedded resources are found regardless of app settings.
            var libraryLocalizer = GetOrCreateLibraryLocalizer();
            // --- Create the application override localizer (respects app config) ---
            // This uses the original factory passed in, so it honors the app's LocalizationOptions.
            IStringLocalizer appOverrideLocalizer = CreateAppOverrideLocalizer();
            // Return the composite localizer that handles the fallback logic.
            return new RizzyStringLocalizer(appOverrideLocalizer, libraryLocalizer);
        }
        // For any other type request, delegate directly to the original factory.
        return _originalFactory.Create(resourceSource);
    }
    /// <summary>
    /// Creates an <see cref="IStringLocalizer"/> using the specified base name and location.
    /// Delegates directly to the original factory.
    /// </summary>
    /// <param name="baseName">The base name of the resource.</param>
    /// <param name="location">The location (assembly name) to search for the resource.</param>
    /// <returns>An <see cref="IStringLocalizer"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="baseName"/> or <paramref name="location"/> is null.</exception>
    public IStringLocalizer Create(string baseName, string location)
    {
        ArgumentNullException.ThrowIfNull(baseName);
        ArgumentNullException.ThrowIfNull(location);
        return _originalFactory.Create(baseName, location);
    }
    /// <summary>
    /// Gets the cached library-specific localizer, lazily initialized in a thread-safe manner.
    /// </summary>
    /// <returns>The <see cref="IStringLocalizer"/> for RizzyUI's internal resources.</returns>
    private IStringLocalizer GetOrCreateLibraryLocalizer()
    {
        return _cachedLibraryLocalizer.Value;
    }
    /// <summary>
    /// Creates the library-specific localizer.
    /// </summary>
    /// <returns>A new <see cref="IStringLocalizer"/> for RizzyUI's internal resources.</returns>
    private IStringLocalizer CreateLibraryLocalizer()
    {
        // Resolve dependencies needed to create a default factory instance
        var loggerFactory = _serviceProvider.GetRequiredService<ILoggerFactory>();
        // Use default (empty) LocalizationOptions to ignore app's ResourcesPath
        var defaultLocalizationOptions = Options.Create(new LocalizationOptions() { ResourcesPath = "Resources"});
        // Instantiate the default Microsoft factory directly
        var librarySpecificFactory = new ResourceManagerStringLocalizerFactory(defaultLocalizationOptions, loggerFactory);
        // Create the localizer using the type marker, ensuring it finds embedded resources
        return librarySpecificFactory.Create(typeof(RizzyLocalization));
    }
    /// <summary>
    /// Creates the localizer for the application's override resources using the original factory.
    /// </summary>
    /// <returns>An <see cref="IStringLocalizer"/> for overrides, or a dummy if not configured.</returns>
    private IStringLocalizer CreateAppOverrideLocalizer()
    {
        if (_localizationResourceType != null)
        {
            // Use the type provided by the application config
            return _originalFactory.Create(_localizationResourceType);
        }
        if (!string.IsNullOrEmpty(_localizationResourceLocation))
        {
            // Use the location and convention name provided by the application config
            return _originalFactory.Create(Constants.RizzyLocalizationResourceName, _localizationResourceLocation);
        }
        // No override config provided, return the dummy instance
        return DummyLocalizer.Instance;
    }
    /// <summary>
    /// A private dummy localizer used when no application overrides are configured.
    /// </summary>
    private sealed class DummyLocalizer : IStringLocalizer
    {
        /// <summary>
        /// Gets the singleton instance of the dummy localizer.
        /// </summary>
        public static readonly DummyLocalizer Instance = new();
        // Private constructor to prevent external instantiation.
        private DummyLocalizer() { }
        /// <inheritdoc />
        public LocalizedString this[string name] => new(name, name, resourceNotFound: true);
        /// <inheritdoc />
        public LocalizedString this[string name, params object[] arguments] => new(name, name, resourceNotFound: true);
        /// <inheritdoc />
        public IEnumerable<LocalizedString> GetAllStrings(bool includeParentCultures) => [];
    }
}
</file>

<file path="Oklch.cs">
using System.Text.RegularExpressions;
namespace RizzyUI;
/*
/// <summary>
/// Represents a defined Semantic theme color
/// </summary>
public record SemanticColor : Color
{
    private Color? _dark;
    private SemanticColor(Color color) : base(color)
    {
    }
    private SemanticColor(Color light, Color dark) : base(light)
    {
        _dark = dark;
    }
    /// <summary>No color specified.</summary>
    public static SemanticColor None => new SemanticColor(Colors.Transparent);
    /// <summary>Surface color, typically for backgrounds.</summary>
    public static SemanticColor Surface => new SemanticColor(new ("--color-surface", "surface"),
        new ("--color-surface-dark", "surface-dark"));
    /// <summary>Foreground color on surface.</summary>
    public static SemanticColor OnSurface => new SemanticColor(new ("--color-foreground", "on-surface"),
        new ("--color-foreground", "on-surface-dark"));
    /// <summary>Strong foreground color on surface.</summary>
    public static SemanticColor OnSurfaceStrong => new SemanticColor(new ("--color-foreground", "on-surface-strong"),
        new ("--color-foreground", "on-surface-dark-strong"));
    /// <summary>Muted foreground color on surface.</summary>
    public static SemanticColor OnSurfaceMuted => new SemanticColor(new("--color-muted-foreground", "on-surface-muted"),
        new("--color-foreground-muted", "on-surface-dark-muted"));
    /// <summary>Alternate surface color for secondary areas.</summary>
    public static SemanticColor SurfaceAlt => new SemanticColor(new ("--color-secondary", "secondary"),
        new ("--color-surface-dark-alt", "surface-dark-alt"));
    /// <summary>Primary color for highlights or accents.</summary>
    public static SemanticColor Primary => new SemanticColor(new Color("--color-primary", "primary"));
    /// <summary>Foreground color on primary background.</summary>
    public static SemanticColor OnPrimary => new SemanticColor(new ("--color-primary-foreground", "on-primary"),
        new ("--color-primary-foreground", "on-primary-dark"));
    /// <summary>Secondary color for less emphasized elements.</summary>
    public static SemanticColor Secondary => new SemanticColor(new Color("--color-secondary", "secondary"),
        new Color("--color-secondary-dark", "secondary-dark"));
    /// <summary>Foreground color on secondary background.</summary>
    public static SemanticColor OnSecondary => new SemanticColor(new Color("--color-secondary-foreground", "on-secondary"),
        new Color("--color-secondary-foreground", "on-secondary-dark"));
    /// <summary>Outline color for borders or separators.</summary>
    public static SemanticColor Outline => new SemanticColor(new Color("--color-outline", "outline"),
        new Color("--color-outline-dark", "outline-dark"));
    /// <summary>Strong outline color for emphasis.</summary>
    public static SemanticColor OutlineStrong => new SemanticColor(new Color("--color-outline-strong", "outline-strong"),
        new Color("--color-outline-dark-strong", "outline-dark-strong"));
    /// <summary>Destructive color, often red for errors.</summary>
    public static SemanticColor Destructive => new SemanticColor(new Color("--color-destructive", "danger"));
    /// <summary>Foreground color on danger background.</summary>
    public static SemanticColor DestructiveForeground => new SemanticColor(new Color("--color-destructive-foreground", "on-destructive"));
    /// <summary>Informational color, often blue or neutral.</summary>
    public static SemanticColor Info => new SemanticColor(new Color("--color-info", "info"));
    /// <summary>Foreground color on info background.</summary>
    public static SemanticColor OnInfo => new SemanticColor(new Color("--color-info-foreground", "on-info"));
    /// <summary>Warning color, often yellow for caution.</summary>
    public static SemanticColor Warning => new SemanticColor(new Color("--color-warning", "warning"));
    /// <summary>Foreground color on warning background.</summary>
    public static SemanticColor OnWarning => new SemanticColor(new Color("--color-warning-foreground", "on-warning"));
    /// <summary>Success color, often green for positive feedback.</summary>
    public static SemanticColor Success => new SemanticColor(new Color("--color-success", "success"));
    /// <summary>Foreground color on success background.</summary>
    public static SemanticColor OnSuccess => new SemanticColor(new Color("--color-success-foreground", "on-success"));
    /// <summary>
    /// Creates a Tailwind class string that optionally includes a dark mode class
    /// </summary>
    /// <param name="utility"></param>
    /// <returns></returns>
    public override string ToCssClassString(string utility)
    {
        if (_dark == null)
            return base.ToCssClassString(utility);
        return $"{utility}-{_tailwindClass} dark:{_dark.ToCssClassString(utility)}";
    }
}
*/
/// <summary>
///     Represents a CSS color variable or Oklch color
/// </summary>
public record Color
{
	/// <summary>
	///     Stores oklch color (if _type is ColorType.Oklch)
	/// </summary>
	private readonly Oklch _oklchColor;
	/// <summary>
	///     Stores tailwind classname for color (e.g. rose-500)
	/// </summary>
	private readonly string _tailwindClass;
	/// <summary>
	///     Type of color
	/// </summary>
	protected readonly ColorType _type;
	/// <summary>
	///     Stores variable string name (if _type is ColorType.Variable)
	/// </summary>
	private readonly string _variable;
	/// <summary>
	///     Stores a color in Oklch format
	/// </summary>
	/// <param name="color"></param>
	public Color(Oklch color)
    {
        _type = ColorType.Oklch;
        _oklchColor = color;
        _variable = string.Empty;
        _tailwindClass = $"[{ToCssColorString()}]";
    }
	/// <summary>
	///     Stores a color as a variable
	/// </summary>
	/// <param name="colorVariable"></param>
	/// <param name="colorName"></param>
	public Color(string colorVariable, string colorName)
    {
        _type = ColorType.Variable;
        _variable = colorVariable;
        _tailwindClass = colorName;
    }
	/// <summary>
	///     Stores a color as RGB
	/// </summary>
	/// <param name="rgbHexColor">Hex color starting with a pound sign</param>
	public Color(string rgbHexColor)
    {
        if (!IsValidHexColor(rgbHexColor))
            throw new ArgumentException($"{nameof(rgbHexColor)} must be a valid CSS rgb hex color starting with a #");
        _type = ColorType.Rgb;
        _variable = rgbHexColor;
        _tailwindClass = string.Empty;
    }
	/// <summary>
	///     Initializes a color using another color as a base
	/// </summary>
	/// <param name="other"></param>
	public Color(Color other)
    {
        _type = other._type;
        _oklchColor = other._oklchColor;
        _variable = other._variable.ToLowerInvariant();
        _tailwindClass = other._tailwindClass;
    }
	/// <summary>
	///     Returns a Tailwind CSS utility class fragment corresponding to this color.
	///     - For Variable: The provided tailwind class name (e.g., "primary", "red-500").
	///     - For OKLCH/RgbHex: An arbitrary value class (e.g., "[oklch(0.5_0.1_20)]", "[#ff0000]").
	/// </summary>
	public string TailwindClassName => _tailwindClass;
    private static bool IsValidHexColor(string color)
    {
        return Regex.IsMatch(color, @"^#(?:[0-9A-Fa-f]{3,4}|[0-9A-Fa-f]{6,8})$");
    }
    /// <summary>
    ///     Outputs the standard CSS function syntax: oklch(L C H / Alpha) or var(--color-rose-500)
    /// </summary>
    public string ToCssColorString()
    {
        return _type switch
        {
            ColorType.Oklch => _oklchColor.Alpha < 1f
                ? $"oklch({_oklchColor.L} {_oklchColor.C} {_oklchColor.H})"
                : $"oklch({_oklchColor.L} {_oklchColor.C} {_oklchColor.H} / {_oklchColor.Alpha})",
            ColorType.Rgb => _variable,
            ColorType.Variable => $"var({_variable})",
            _ => throw new NotImplementedException()
        };
    }
    /// <summary>
    ///     Outputs a Tailwind class that can be directly used in a class attribute
    /// </summary>
    /// <param name="utility">bg, text, accent, etc. (as part of bg-rose-500, text-rose-500)</param>
    /// <returns></returns>
    public virtual string ToCssClassString(string utility)
    {
        return $"{utility}-{_tailwindClass}";
    }
    /// <summary>
    ///     Identifies color type internally
    /// </summary>
    protected enum ColorType
    {
	    /// <summary>
	    ///     Color is a CSS variable
	    /// </summary>
	    Variable,
	    /// <summary>
	    ///     Color is in Oklch format
	    /// </summary>
	    Oklch,
	    /// <summary>
	    ///     Color is in Rgb format (unsupported for now)
	    /// </summary>
	    Rgb
    }
}
/// <summary>
///     Represents a color in OKLCH space, plus an alpha (default 1.0).
/// </summary>
// ReSharper disable once IdentifierTypo
public readonly record struct Oklch(float L, float C, float H, float Alpha = 1.0f)
{
}
</file>

<file path="RizzyLocalization.cs">
using Microsoft.Extensions.Localization; // Added for xmldoc reference
namespace RizzyUI;
/// <summary>
/// An empty marker class used by <see cref="IStringLocalizer{T}"/>
/// to identify and locate RizzyUI's embedded resource files (.resx) named following the
/// convention `RizzyLocalization.{culture}.resx`.
/// This allows the library to manage its own default translations independently.
/// </summary>
/// <remarks>
/// This class is intentionally left empty. Its sole purpose is to serve as a type marker
/// for the localization system. Resource files should be named matching this class name
/// (e.g., RizzyLocalization.resx, RizzyLocalization.es.resx).
/// </remarks>
public sealed class RizzyLocalization
{
    // Intentionally empty.
}
</file>

<file path="RizzyUIConfig.cs">
namespace RizzyUI;
/// <summary>
/// Provides configuration options for the RizzyUI library.
/// </summary>
public sealed class RizzyUIConfig
{
    /// <summary>
    /// Gets or sets the default theme to be used by RizzyUI components if no theme is
    /// explicitly provided via <see cref="RzThemeProvider"/>.
    /// Defaults to <see cref="RzTheme.ArcticTheme"/>.
    /// </summary>
    public RzTheme DefaultTheme { get; set; } = RzTheme.Default;
    /// <summary>
    /// Gets or sets the marker <see cref="Type"/> used by the consuming application to identify
    /// its resource files (.resx) intended for overriding or augmenting RizzyUI's default translations.
    /// The resource files associated with this type should follow the naming convention `RizzyLocalization.{culture}.resx`.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If this property is set, RizzyUI's localization system will first look for translations
    /// within the application's resources associated with this type. If a key (e.g., "RzButton.AssistiveLabelDefault")
    /// is found, that translation will be used. If not found, it will fall back to RizzyUI's
    /// embedded default translation (found in `RizzyLocalization.resx` within the library).
    /// </para>
    /// <para>
    /// This allows users to customize RizzyUI component text or provide translations for languages
    /// not included in the library.
    /// </para>
    /// <para>
    /// This requires standard ASP.NET Core localization services (<c>AddLocalization</c>, <c>UseRequestLocalization</c>)
    /// to be configured in the consuming application's <c>Program.cs</c>.
    /// </para>
    /// <para>
    /// If both <see cref="LocalizationResourceType"/> and <see cref="LocalizationResourceLocation"/> are set,
    /// <see cref="LocalizationResourceType"/> takes precedence.
    /// </para>
    /// <example>
    /// In Program.cs:
    /// <code>
    /// builder.Services.AddRizzyUI(config =>
    /// {
    ///     // Assumes a marker type exists in the consuming app:
    ///     // namespace MyWebApp.Localization { public class RizzyOverrides { } }
    ///     config.LocalizationResourceType = typeof(MyWebApp.Localization.RizzyOverrides);
    /// });
    /// </code>
    /// The application would then provide `Resources/MyWebApp.Localization.RizzyOverrides.es.resx`
    /// containing keys like `RzButton.AssistiveLabelDefault`.
    /// </example>
    /// </remarks>
    public Type? LocalizationResourceType { get; set; }
    /// <summary>
    /// Gets or sets the resource location (typically the assembly name or root namespace) where the
    /// consuming application stores its RizzyUI override resource files.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Use this property if you don't have a specific marker <see cref="Type"/> for your override resources,
    /// but you follow the convention of naming the resource files <c>RizzyLocalization.resx</c>,
    /// <c>RizzyLocalization.es.resx</c>, etc., and place them within a designated location
    /// (e.g., a "Resources" folder within your application's project structure).
    /// </para>
    /// <para>
    /// The value should typically be the root namespace or assembly name where the resources reside,
    /// matching the configuration used in <c>AddLocalization</c>. The localization system will look
    /// for resources named `RizzyLocalization` within this location.
    /// </para>
    /// <para>
    /// <see cref="LocalizationResourceType"/> takes precedence if both are configured.
    /// </para>
    /// <para>
    /// Requires standard ASP.NET Core localization services to be configured.
    /// </para>
    /// <example>
    /// In Program.cs:
    /// <code>
    /// // Assuming override files are in WebApp/Resources/RizzyLocalization.resx
    /// builder.Services.AddLocalization(options => options.ResourcesPath = "Resources");
    /// builder.Services.AddRizzyUI(config =>
    /// {
    ///     config.LocalizationResourceLocation = "WebApp"; // Root namespace of the application
    /// });
    /// </code>
    /// </example>
    /// </remarks>
    public string? LocalizationResourceLocation { get; set; }
}
</file>

<file path="RzComponent.cs">
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.Localization; // Required for IStringLocalizer
using Microsoft.Extensions.Options;
using Rizzy.Htmx;
using Rizzy.Utility;
using TailwindMerge;
namespace RizzyUI;
/// <summary>
/// Base class for all RizzyUI components, providing common functionality
/// such as theme access, attribute merging, nonce handling, and localization support.
/// </summary>
public abstract class RzComponent : ComponentBase
{
    private string? _nonce;
    /// <summary>
    /// Gets the currently active theme instance via Cascading Parameter.
    /// This allows components to access theme settings defined by <see cref="RzThemeProvider"/>.
    /// </summary>
    [CascadingParameter]
    protected RzTheme? CascadedTheme { get; set; }
    /// <summary>
    /// Injected configuration options for RizzyUI. Used primarily to access the default theme
    /// if no theme is provided via the cascading parameter.
    /// </summary>
    [Inject]
    private IOptions<RizzyUIConfig>? Config { get; set; }
    /// <summary>
    /// Gets the Tailwind Merge service instance, used for intelligently merging
    /// Tailwind CSS classes, resolving conflicts, and removing redundancies.
    /// </summary>
    [Inject]
    protected TwMerge TwMerge { get; set; } = default!;
    /// <summary>
    /// Gets the nonce provider service, which supplies per-request nonce values
    /// required for Content Security Policy (CSP) compliance when components
    /// generate or load dynamic scripts or styles.
    /// </summary>
    [Inject]
    protected IRizzyNonceProvider RizzyNonceProvider { get; set; } = default!;
    /// <summary>
    /// Gets the string localizer instance configured for RizzyUI.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This localizer uses <see cref="RizzyLocalization"/> as its marker type. If the consuming
    /// application has configured localization overrides via <see cref="RizzyUIConfig"/> (by setting
    /// <see cref="RizzyUIConfig.LocalizationResourceType"/> or <see cref="RizzyUIConfig.LocalizationResourceLocation"/>),
    /// this instance will prioritize the application's resources before falling back to
    /// RizzyUI's embedded defaults.
    /// </para>
    /// <para>
    /// Use this property within derived components to access localized default strings, e.g.,
    /// <c>Localizer["RzButton.AssistiveLabelDefault"]</c>. The keys should follow the
    /// convention `ComponentName.ResourceKey`.
    /// </para>
    /// <para>
    /// For localizing text provided *by* the consuming application (e.g., via `Label` or
    /// `Title` parameters), the application should use its own <see cref="IStringLocalizer{T}"/> instance
    /// before passing the localized string to the component parameter.
    /// </para>
    /// </remarks>
    [Inject]
    protected IStringLocalizer<RizzyLocalization> Localizer { get; set; } = default!;
    /// <summary>
    /// Gets or sets the HTML element tag name to be rendered as the root of this component.
    /// Defaults to "div". Derived components can override this in their `OnInitialized` method if needed.
    /// </summary>
    [Parameter]
    public string Element { get; set; } = string.Empty;
    /// <summary>
    /// Unique identifier for the component instance. 
    /// </summary>
    [Parameter]
    public string Id { get; set; } = IdGenerator.UniqueId("rz");
    /// <summary>
    /// Captures unmatched HTML attributes passed to the component. These attributes are typically
    /// applied to the root element rendered by the component. Use the `class` attribute here
    /// for additional CSS classes; they will be merged with the component's base classes.
    /// </summary>
    [SuppressMessage("Usage", "CA2227:Collection properties should be read only", Justification = "Required by Blazor for parameter capture.")]
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }
    /// <summary>
    /// Gets the effective theme instance being used by this component. It prioritizes the
    /// theme cascaded from <see cref="RzThemeProvider"/>, falling back to the configured
    /// default theme (<see cref="RizzyUIConfig.DefaultTheme"/>), and finally to the library's
    /// hardcoded default (<see cref="RzTheme.Default"/>).
    /// </summary>
    protected RzTheme Theme { get; private set; } = RzTheme.Default;
    /// <summary>
    /// Gets the Content Security Policy (CSP) nonce value for the current HTTP request.
    /// This value is retrieved once per component instance from the <see cref="RizzyNonceProvider"/>
    /// and should be applied to inline `&lt;script>` or `&lt;style>` tags generated by the component, if any,
    /// to comply with strict CSP directives.
    /// </summary>
    protected string Nonce => _nonce ??= RizzyNonceProvider.GetNonce();
    /// <summary>
    /// Actual HTML element tag name to be rendered as the root of this component.
    /// </summary>
    protected string EffectiveElement => string.IsNullOrEmpty(Element) ? "div" : Element;
    /// <summary>
    /// Calculates the final CSS class string for the component's root element by merging
    /// base classes defined by the theme (if overridden) with any additional classes
    /// provided via the `class` attribute in <see cref="AdditionalAttributes"/>.
    /// Derived components MUST override this method to include their specific base classes.
    /// </summary>
    /// <returns>A string containing the merged CSS classes, or null/empty if no classes are applicable.</returns>
    protected virtual string? RootClass()
    {
        // Base implementation only handles the 'class' attribute from AdditionalAttributes.
        // Derived components should override and use TwMerge.Merge(AdditionalAttributes, baseClass, ...)
        return AdditionalAttributes?.GetValueOrDefault("class", string.Empty)?.ToString();
    }
    /// <summary>
    /// Initializes the component and resolves the effective theme.
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Resolve the theme instance based on cascade or config/default.
        Theme = CascadedTheme ?? Config?.Value.DefaultTheme ?? RzTheme.Default;
    }
}
</file>

<file path="RzTheme.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Represents the comprehensive theme data for the RizzyUI application.
///     It holds semantic colors (light/dark variants), status colors, border settings,
///     and references to style definitions for all individual RizzyUI components.
///     This class allows for theme customization and provides styling context to components.
/// </summary>
public partial class RzTheme
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="RzTheme" /> class, setting the name, code,
    ///     and instantiating all default component style definitions.
    /// </summary>
    /// <param name="name">The full, human-readable name of the theme.</param>
    /// <param name="themeCode">The short, lowercase code name for the theme.</param>
    public RzTheme(string name, string themeCode)
    {
        Name = name;
        ThemeCode = themeCode;
        // Instantiate default styles for all components
        RzAccordion = new DefaultRzAccordionStyles(this);
        RzAccordionSection = new DefaultRzAccordionSectionStyles(this);
        RzAlert = new DefaultRzAlertStyles(this);
        RzAlertTitle = new DefaultRzAlertTitleStyles(this);
        RzAlertDescription = new DefaultRzAlertDescriptionStyles(this);
        RzArticle = new DefaultRzArticleStyles(this);
        RzAvatar = new DefaultRzAvatarStyles(this);
        RzBadge = new DefaultRzBadgeStyles(this);
        RzBreadcrumb = new DefaultRzBreadcrumbStyles(this);
        RzBreadcrumbItem = new DefaultRzBreadcrumbItemStyles(this);
        RzBrowser = new DefaultRzBrowserStyles(this);
        RzButton = new DefaultRzButtonStyles(this);
        RzButtonGroup = new DefaultRzButtonGroupStyles(this);
        RzCard = new DefaultRzCardStyles(this);
        RzCardBody = new DefaultRzCardBodyStyles(this);
        RzCardButtons = new DefaultRzCardButtonsStyles(this);
        RzCardFooter = new DefaultRzCardFooterStyles(this);
        RzCardHeader = new DefaultRzCardHeaderStyles(this);
        RzCardSubtitle = new DefaultRzCardSubtitleStyles(this);
        RzCardTitle = new DefaultRzCardTitleStyles(this);
        RzCheckboxGroup = new DefaultRzCheckboxGroupStyles(this);
        RzCheckboxGroupField = new DefaultRzCheckboxGroupFieldStyles(this);
        RzCheckboxGroupItem = new DefaultRzCheckboxGroupItemStyles(this);
        RzCodeViewer = new DefaultRzCodeViewerStyles(this);
        RzDarkmodeToggle = new DefaultRzDarkmodeToggleStyles(this);
        RzDateEdit = new DefaultRzDateEditStyles(this);
        RzDivider = new DefaultRzDividerStyles(this);
        RzDropdown = new DefaultRzDropdownStyles(this);
        RzDropdownMenuItem = new DefaultRzDropdownMenuItemStyles(this);
        RzDropdownSection = new DefaultRzDropdownSectionStyles(this);
        RzEmbeddedPreview = new DefaultRzEmbeddedPreviewStyles(this);
        RzField = new DefaultRzFieldStyles(this);
        RzFieldHelp = new DefaultRzFieldHelpStyles(this);
        RzFieldLabel = new DefaultRzFieldLabelStyles(this);
        RzFormSection = new DefaultRzFormSectionStyles(this);
        RzHeading = new DefaultRzHeadingStyles(this);
        RzLink = new DefaultRzLinkStyles(this);
        RzMarkdown = new DefaultRzMarkdownStyles(this);
        RzModal = new DefaultRzModalStyles(this);
        RzNavbar = new DefaultRzNavbarStyles(this);
        RzNumberEdit = new DefaultRzNumberEditStyles(this);
        RzNumberField = new DefaultRzNumberFieldStyles(this);
        RzParagraph = new DefaultRzParagraphStyles(this);
        RzProgress = new DefaultRzProgressStyles(this);
        RzQuickReferenceContainer = new DefaultRzQuickReferenceContainerStyles(this);
        RzQuickReference = new DefaultRzQuickReferenceStyles(this);
        RzRadioGroup = new DefaultRzRadioGroupStyles(this);
        RzRadioGroupField = new DefaultRzRadioGroupFieldStyles(this);
        RzRadioGroupItem = new DefaultRzRadioGroupItemStyles(this);
        RzSearchButton = new DefaultRzSearchButtonStyles(this);
        RzSidebar = new DefaultRzSidebarStyles(this);
        RzSidebarLinkItem = new DefaultRzSidebarLinkItemStyles(this);
        RzSidebarLinks = new DefaultRzSidebarLinksStyles(this);
        RzSpinner = new DefaultRzSpinnerStyles(this); 
        RzSteps = new DefaultRzStepsStyles(this);
        RzTable = new DefaultRzTableStyles(this);
        RzTableHeaderCell = new DefaultRzTableHeaderCellStyles(this);
        RzTableBody = new DefaultRzTableBodyStyles(this);
        RzTableRow = new DefaultRzTableRowStyles(this);        
        RzTableCell = new DefaultRzTableCellStyles(this);
        RzPagination = new DefaultRzPaginationStyles(this);        
        RzTabs = new DefaultRzTabsStyles(this);
        RzTab = new DefaultRzTabStyles(this);
        RzTabPanel = new DefaultRzTabPanelStyles(this);
        RzTabStrip = new DefaultRzTabStripStyles(this);
        RzTextEdit = new DefaultRzTextEditStyles(this);
        RzTextField = new DefaultRzTextFieldStyles(this);
        RzToggle = new DefaultRzToggleStyles(this);
        RzToggleField = new DefaultRzToggleFieldStyles(this);
        RzTypography = new DefaultRzTypographyStyles(this);
    }
    /// <summary>
    ///     Gets the full, human-readable name of the theme (e.g., "Arctic", "High Contrast").
    /// </summary>
    public string Name { get; init; }
    /// <summary>
    ///     Gets the short code name of the theme (lowercase, no spaces, e.g., "arctic", "highcontrast").
    ///     Used internally, such as for generating theme-specific CSS token names.
    /// </summary>
    public string ThemeCode { get; init; }
    /// <summary>
    ///     Gets or sets the color scheme definitions for the light mode variant of the theme.
    /// </summary>
    public RzThemeVariant Light { get; set; } = new();
    /// <summary>
    ///     Gets or sets the color scheme definitions for the dark mode variant of the theme.
    /// </summary>
    public RzThemeVariant Dark { get; set; } = new();
    /// <summary>
    ///     Gets the <see cref="Color" /> used to indicate dangerous states or error conditions.
    /// </summary>
    public Color Destructive { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on a <see cref="Destructive" /> background.
    /// </summary>
    public Color DestructiveForeground { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for informational messages or states.
    /// </summary>
    public Color Info { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on an <see cref="Info" /> background.
    /// </summary>
    public Color OnInfo { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used to indicate warning or cautionary states.
    /// </summary>
    public Color Warning { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on a <see cref="Warning" /> background.
    /// </summary>
    public Color OnWarning { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used to indicate success or positive states.
    /// </summary>
    public Color Success { get; protected init; }
    /// <summary>
    ///     Gets the <see cref="Color" /> used for text or icons placed on a <see cref="Success" /> background.
    /// </summary>
    public Color OnSuccess { get; protected init; }
    /// <summary>
    ///     Gets the default border width value used across components (e.g., "1px").
    /// </summary>
    public string BorderWidth { get; protected init; }
    /// <summary>
    ///     Gets the default border radius value used across components (e.g., "6px", "0.5rem").
    /// </summary>
    public string BorderRadius { get; protected init; }
    /// <summary>
    ///     Gets the default Arctic theme instance.
    /// </summary>
    public static RzTheme Default => ArcticTheme;
    /// <summary>
    ///     Gets a new instance of the Arctic theme.
    /// </summary>
    public static RzTheme ArcticTheme => new ArcticTheme();
    /// <summary>
    ///     Gets a new instance of the High Contrast theme.
    /// </summary>
    public static RzTheme HighContrastTheme => new HighContrastTheme();
    /// <summary>
    ///     Gets a new instance of the Modern theme.
    /// </summary>
    public static RzTheme ModernTheme => new ModernTheme();
    /// <summary>
    ///     Gets a new instance of the News theme.
    /// </summary>
    public static RzTheme NewsTheme => new NewsTheme();
}
#pragma warning restore CS8618
</file>

<file path="RzTheme.StyleProviders.cs">
namespace RizzyUI;
/// <summary>
/// Tailwind classname providers for all components
/// </summary>
public partial class RzTheme
{
    // --- Component Style Properties ---
    /// <summary> Gets or sets the style definitions for the <see cref="RzAccordion" /> component. </summary>
    public virtual RzStylesBase.RzAccordionStylesBase RzAccordion { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzAccordionSection" /> component. </summary>
    public virtual RzStylesBase.RzAccordionSectionStylesBase RzAccordionSection { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzAlert" /> component. </summary>
    public virtual RzStylesBase.RzAlertStylesBase RzAlert { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzAlertTitle" /> component. </summary>
    public virtual RzStylesBase.RzAlertTitleStylesBase RzAlertTitle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzAlertDescription" /> component. </summary>
    public virtual RzStylesBase.RzAlertDescriptionStylesBase RzAlertDescription { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzArticle" /> component. </summary>
    public virtual RzStylesBase.RzArticleStylesBase RzArticle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzAvatar" /> component. </summary>
    public virtual RzStylesBase.RzAvatarStylesBase RzAvatar { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzBadge" /> component. </summary>
    public virtual RzStylesBase.RzBadgeStylesBase RzBadge { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzBreadcrumb" /> component. </summary>
    public virtual RzStylesBase.RzBreadcrumbStylesBase RzBreadcrumb { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzBreadcrumbItem" /> component. </summary>
    public virtual RzStylesBase.RzBreadcrumbItemStylesBase RzBreadcrumbItem { get; }
    /// <summary>
    /// Gets or sets the style definitions for the <see cref="RzBrowser" /> component.
    /// </summary>
    public virtual RzStylesBase.RzBrowserStylesBase RzBrowser { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzButton" /> component. </summary>
    public virtual RzStylesBase.RzButtonStylesBase RzButton { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzButtonGroup" /> component. </summary>
    public virtual RzStylesBase.RzButtonGroupStylesBase RzButtonGroup { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCard" /> component. </summary>
    public virtual RzStylesBase.RzCardStylesBase RzCard { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardBody" /> component. </summary>
    public virtual RzStylesBase.RzCardBodyStylesBase RzCardBody { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardButtons" /> component. </summary>
    public virtual RzStylesBase.RzCardButtonsStylesBase RzCardButtons { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardFooter" /> component. </summary>
    public virtual RzStylesBase.RzCardFooterStylesBase RzCardFooter { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardHeader" /> component. </summary>
    public virtual RzStylesBase.RzCardHeaderStylesBase RzCardHeader { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardSubtitle" /> component. </summary>
    public virtual RzStylesBase.RzCardSubtitleStylesBase RzCardSubtitle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCardTitle" /> component. </summary>
    public virtual RzStylesBase.RzCardTitleStylesBase RzCardTitle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCheckboxGroup{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzCheckboxGroupStylesBase RzCheckboxGroup { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCheckboxGroupField{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzCheckboxGroupFieldStylesBase RzCheckboxGroupField { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCheckboxGroupItem{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzCheckboxGroupItemStylesBase RzCheckboxGroupItem { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzCodeViewer" /> component. </summary>
    public virtual RzStylesBase.RzCodeViewerStylesBase RzCodeViewer { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDarkmodeToggle" /> component. </summary>
    public virtual RzStylesBase.RzDarkmodeToggleStylesBase RzDarkmodeToggle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDateEdit" /> component. </summary>
    public virtual RzStylesBase.RzDateEditStylesBase RzDateEdit { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDivider" /> component. </summary>
    public virtual RzStylesBase.RzDividerStylesBase RzDivider { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDropdown" /> component. </summary>
    public virtual RzStylesBase.RzDropdownStylesBase RzDropdown { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDropdownMenuItem" /> component. </summary>
    public virtual RzStylesBase.RzDropdownMenuItemStylesBase RzDropdownMenuItem { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzDropdownSection" /> component. </summary>
    public virtual RzStylesBase.RzDropdownSectionStylesBase RzDropdownSection { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzEmbeddedPreview" /> component. </summary>
    public virtual RzStylesBase.RzEmbeddedPreviewStylesBase RzEmbeddedPreview { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzField" /> component. </summary>
    public virtual RzStylesBase.RzFieldStylesBase RzField { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzFieldHelp" /> component. </summary>
    public virtual RzStylesBase.RzFieldHelpStylesBase RzFieldHelp { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzFieldLabel{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzFieldLabelStylesBase RzFieldLabel { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzFormSection" /> component. </summary>
    public virtual RzStylesBase.RzFormSectionStylesBase RzFormSection { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzHeading" /> component. </summary>
    public virtual RzStylesBase.RzHeadingStylesBase RzHeading { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzLink" /> component. </summary>
    public virtual RzStylesBase.RzLinkStylesBase RzLink { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzMarkdown" /> component. </summary>
    public virtual RzStylesBase.RzMarkdownStylesBase RzMarkdown { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzModal"/> component. </summary>
    public virtual RzStylesBase.RzModalStylesBase RzModal { get; }    
    /// <summary> Gets or sets the style definitions for the <see cref="RzNavbar" /> component. </summary>
    public virtual RzStylesBase.RzNavbarStylesBase RzNavbar { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzNumberEdit{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzNumberEditStylesBase RzNumberEdit { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzNumberField{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzNumberFieldStylesBase RzNumberField { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzParagraph" /> component. </summary>
    public virtual RzStylesBase.RzParagraphStylesBase RzParagraph { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzProgress" /> component. </summary>
    public virtual RzStylesBase.RzProgressStylesBase RzProgress { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSpinner" /> component. </summary>
    public virtual RzStylesBase.RzSpinnerStylesBase RzSpinner { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzQuickReferenceContainer" /> component. </summary>
    public virtual RzStylesBase.RzQuickReferenceContainerStylesBase RzQuickReferenceContainer { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzQuickReference" /> component. </summary>
    public virtual RzStylesBase.RzQuickReferenceStylesBase RzQuickReference { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzRadioGroup{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzRadioGroupStylesBase RzRadioGroup { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzRadioGroupField{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzRadioGroupFieldStylesBase RzRadioGroupField { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzRadioGroupItem{TValue}" /> component. </summary>
    public virtual RzStylesBase.RzRadioGroupItemStylesBase RzRadioGroupItem { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSearchButton" /> component. </summary>
    public virtual RzStylesBase.RzSearchButtonStylesBase RzSearchButton { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSidebar" /> component. </summary>
    public virtual RzStylesBase.RzSidebarStylesBase RzSidebar { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSidebarLinkItem" /> component. </summary>
    public virtual RzStylesBase.RzSidebarLinkItemStylesBase RzSidebarLinkItem { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSidebarLinks" /> component. </summary>
    public virtual RzStylesBase.RzSidebarLinksStylesBase RzSidebarLinks { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzSteps" /> component. </summary>
    public virtual RzStylesBase.RzStepsStylesBase RzSteps { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTable{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzTableStylesBase RzTable { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTableHeaderCell{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzTableHeaderCellStylesBase RzTableHeaderCell { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTableBody{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzTableBodyStylesBase RzTableBody { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTableRow{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzTableRowStylesBase RzTableRow { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTableCell{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzTableCellStylesBase RzTableCell { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzPagination{TItem}" /> component. </summary>
    public virtual RzStylesBase.RzPaginationStylesBase RzPagination { get; }   
    /// <summary> Gets or sets the style definitions for the <see cref="RzTabs" /> component. </summary>
    public virtual RzStylesBase.RzTabsStylesBase RzTabs { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTab" /> component. </summary>
    public virtual RzStylesBase.RzTabStylesBase RzTab { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTabPanel" /> component. </summary>
    public virtual RzStylesBase.RzTabPanelStylesBase RzTabPanel { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTabStrip" /> component. </summary>
    public virtual RzStylesBase.RzTabStripStylesBase RzTabStrip { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTextEdit" /> component. </summary>
    public virtual RzStylesBase.RzTextEditStylesBase RzTextEdit { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzTextField" /> component. </summary>
    public virtual RzStylesBase.RzTextFieldStylesBase RzTextField { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzToggle" /> component. </summary>
    public virtual RzStylesBase.RzToggleStylesBase RzToggle { get; }
    /// <summary> Gets or sets the style definitions for the <see cref="RzToggleField" /> component. </summary>
    public virtual RzStylesBase.RzToggleFieldStylesBase RzToggleField { get; }
    /// <summary> Gets or sets the style definitions for base typography used by multiple components. </summary>
    public virtual RzStylesBase.RzTypographyStylesBase RzTypography { get; }
}
</file>

<file path="RzThemeVariant.cs">
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
namespace RizzyUI;
/// <summary>
///     Defines a base shared color theme
/// </summary>
public class RzThemeVariant
{
    /// <summary>
    ///     Gets the surface background color
    /// </summary>
    public Color Surface { get; init; }
    /// <summary>
    ///     Gets the color used for content displayed on the surface.
    /// </summary>
    public Color OnSurface { get; init; }
    /// <summary>
    ///     Gets the color used for strongly emphasized content displayed on the surface.
    /// </summary>
    public Color OnSurfaceStrong { get; init; }
    /// <summary>
    ///     Gets the color used for disabled or inactive text elements.
    /// </summary>
    public Color OnSurfaceMuted { get; init; }
    /// <summary>
    ///     Gets the alternate surface background color.
    /// </summary>
    public Color SurfaceAlt { get; init; }
    /// <summary>
    ///     Gets the tertiary surface background color.
    /// </summary>
    public Color SurfaceTertiary { get; init; }
    /// <summary>
    ///     Gets the color used for content displayed on the tertiary surface.
    /// </summary>
    public Color OnSurfaceTertiary { get; init; }
    /// <summary>
    ///     Gets the primary brand color.
    /// </summary>
    public Color Primary { get; init; }
    /// <summary>
    ///     Gets the color used for content displayed on the primary color.
    /// </summary>
    public Color OnPrimary { get; init; }
    /// <summary>
    ///     Gets the secondary brand color.
    /// </summary>
    public Color Secondary { get; init; }
    /// <summary>
    ///     Gets the color used for content displayed on the secondary color.
    /// </summary>
    public Color OnSecondary { get; init; }
    /// <summary>
    ///     Gets the outline color used for borders and dividers.
    /// </summary>
    public Color Outline { get; init; }
    /// <summary>
    ///     Gets the stronger outline color used for heavier borders.
    /// </summary>
    public Color OutlineStrong { get; init; }
    /// <summary>
    ///     Gets the code theme for this variant
    /// </summary>
    public RizzyCodeTheme Code { get; init; }
}
</file>

<file path="Styles/RzStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
}
</file>

<file path="Styles/RzStylesBase.RzAccordionStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzAccordion Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAccordion" /> component.
    /// </summary>
    public abstract class RzAccordionStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAccordionStylesBase" /> class. </summary>
        protected RzAccordionStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzAccordion container div. </summary>
        public abstract string Container { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAccordionSection" /> component.
    /// </summary>
    public abstract class RzAccordionSectionStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAccordionSectionStylesBase" /> class. </summary>
        protected RzAccordionSectionStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main container div of the accordion section. </summary>
        public abstract string Container { get; }
        /// <summary> Gets the base CSS classes for the section's clickable button element. </summary>
        public abstract string Button { get; }
        /// <summary> Gets the base CSS classes for the div wrapping the collapsible content (often used with x-collapse). </summary>
        public abstract string ContentContainerWrapper { get; }
        /// <summary> Gets the base CSS classes for the inner content container div (padding, typography). </summary>
        public abstract string ContentContainer { get; }
        /// <summary> Gets the CSS classes for the chevron indicator icon (base size, transitions). </summary>
        public abstract string ChevronIcon { get; }
        /// <summary> Gets the CSS classes applied to the chevron icon when the section is expanded (e.g., rotation). </summary>
        public abstract string ChevronIconExpanded { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzAlertStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzAlert Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAlert" /> component.
    /// </summary>
    public abstract class RzAlertStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAlertStylesBase" /> class. </summary>
        protected RzAlertStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzAlert container element. </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the inner div containing icon, content, and close button. </summary>
        public abstract string InnerContainer { get; }
        /// <summary> Gets the CSS classes for the div wrapping the alert icon. </summary>
        public abstract string IconContainer { get; }
        /// <summary> Gets the CSS classes for the pulsing animation div behind the icon (when applicable). Includes motion reduction. </summary>
        public abstract string IconPulse { get; }
        /// <summary> Gets the CSS classes for the div containing the alert title and description. </summary>
        public abstract string ContentContainer { get; }
        /// <summary> Gets the CSS classes for the alert's close button. </summary>
        public abstract string CloseButton { get; }
        /// <summary> Gets the CSS classes for the SVG icon within the close button. </summary>
        public abstract string CloseButtonIcon { get; }
        /// <summary> Gets the variant-specific CSS classes (border, background, text color) for the alert container. </summary>
        /// <param name="variant">The alert variant type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetVariantCss(AlertVariant variant);
        /// <summary> Gets the variant-specific light background CSS class for the inner container or icon background. </summary>
        /// <param name="variant">The alert variant type.</param>
        /// <returns>A string representing a background CSS class (e.g., "bg-info/10").</returns>
        public abstract string GetVariantBackgroundLightCss(AlertVariant variant);
        /// <summary> Gets the variant-specific lighter background CSS class, often used for icon pulse or hover states. </summary>
        /// <param name="variant">The alert variant type.</param>
        /// <returns>A string representing a background CSS class (e.g., "bg-info/15").</returns>
        public abstract string GetVariantBackgroundLighterCss(AlertVariant variant);
        /// <summary> Gets the variant-specific text color CSS class, typically used for the icon. </summary>
        /// <param name="variant">The alert variant type.</param>
        /// <returns>A string representing a text color CSS class (e.g., "text-info").</returns>
        public abstract string GetVariantIconColorCss(AlertVariant variant);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAlertTitle" /> component.
    /// </summary>
    public abstract class RzAlertTitleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAlertTitleStylesBase" /> class. </summary>
        protected RzAlertTitleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzAlertTitle element (e.g., h3). </summary>
        public abstract string Title { get; }
        /// <summary> Gets the variant-specific text color CSS class for the alert title. </summary>
        /// <param name="variant">The alert variant type (can be null if context is unavailable).</param>
        /// <returns>A string representing a text color CSS class.</returns>
        public abstract string GetVariantTextColorCss(AlertVariant? variant);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAlertDescription" /> component.
    /// </summary>
    public abstract class RzAlertDescriptionStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAlertDescriptionStylesBase" /> class. </summary>
        protected RzAlertDescriptionStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzAlertDescription element (e.g., p). </summary>
        public abstract string Description { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzArticleStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzArticle Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzArticle" /> layout component.
    /// </summary>
    public abstract class RzArticleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzArticleStylesBase" /> class. </summary>
        protected RzArticleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzArticle container div (layout, text color). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the inner div wrapping the article and aside (layout, max-width, overflow). </summary>
        public abstract string InnerContainer { get; }
        /// <summary> Gets the base CSS classes for the article element. Prose width is applied separately. </summary>
        public abstract string Article { get; }
        /// <summary>
        ///     Gets the base CSS classes for the aside element (side content: layout, overflow, padding, typography). Width
        ///     and positioning are applied separately.
        /// </summary>
        public abstract string Aside { get; }
        /// <summary> Gets the prose width utility class based on the specified width. </summary>
        /// <param name="width">The desired prose width.</param>
        /// <returns>A string representing a Tailwind prose width class.</returns>
        public abstract string GetArticleProseCss(ProseWidth width);
        /// <summary> Gets the CSS classes for the aside element based on column width and fixed state. </summary>
        /// <param name="columnWidth">The desired width of the aside column.</param>
        /// <param name="isFixed">Whether the aside should be fixed-positioned.</param>
        /// <returns>A string of CSS classes including width and positioning.</returns>
        public abstract string GetAsideCss(Size columnWidth, bool isFixed);
        /// <summary>
        ///     Gets the CSS class for the main container's right padding, used to prevent content overlap with a fixed
        ///     aside.
        /// </summary>
        /// <param name="columnWidth">The width of the aside column.</param>
        /// <returns>A string representing a right padding class (e.g., "xl:pr-72").</returns>
        public abstract string GetContainerPaddingCss(Size columnWidth);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzAvatarStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzAvatar Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzAvatar" /> component.
    /// </summary>
    public abstract class RzAvatarStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzAvatarStylesBase" /> class. </summary>
        protected RzAvatarStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the main RzAvatar container element (positioning and object-fit). Size is
        ///     applied separately.
        /// </summary>
        public abstract string Container { get; }
        /// <summary>
        ///     Gets the CSS classes for the status indicator div (base style, border). Size and color are applied
        ///     separately.
        /// </summary>
        public abstract string Indicator { get; }
        /// <summary> Gets the base CSS classes for the img element. Size and shape are applied separately. </summary>
        public abstract string Image { get; }
        /// <summary>
        ///     Gets the base CSS classes for the initials container div (flex, alignment, base colors). Size, shape, and
        ///     text size are applied separately.
        /// </summary>
        public abstract string InitialsContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the placeholder container div (flex, alignment, base colors). Size and shape
        ///     are applied separately.
        /// </summary>
        public abstract string PlaceholderContainer { get; }
        /// <summary> Gets the base CSS classes for the placeholder SVG icon. Size is applied separately. </summary>
        public abstract string PlaceholderIcon { get; }
        /// <summary> Gets the CSS classes for the avatar's shape (e.g., rounded-full, rounded-lg). </summary>
        /// <param name="shape">The desired avatar shape.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetShapeCss(AvatarShape shape);
        /// <summary> Gets the CSS classes for the avatar's overall size (width and height). </summary>
        /// <param name="size">The desired avatar size.</param>
        /// <returns>A string of CSS classes (e.g., "size-10").</returns>
        public abstract string GetSizeCss(Size size);
        /// <summary> Gets the CSS classes for the text size of the initials. </summary>
        /// <param name="size">The corresponding avatar size.</param>
        /// <returns>A string of CSS classes (e.g., "text-base").</returns>
        public abstract string GetInitialsSizeCss(Size size);
        /// <summary> Gets the CSS classes for the size of the placeholder icon. </summary>
        /// <param name="size">The corresponding avatar size.</param>
        /// <returns>A string of CSS classes (e.g., "size-6").</returns>
        public abstract string GetPlaceholderSizeCss(Size size);
        /// <summary> Gets the CSS classes for the size of the status indicator. </summary>
        /// <param name="size">The corresponding avatar size.</param>
        /// <returns>A string of CSS classes (e.g., "size-3").</returns>
        public abstract string GetIndicatorSizeCss(Size size);
        /// <summary> Gets the CSS background color classes (light and dark) for the status indicator. </summary>
        /// <param name="color">The desired accent color.</param>
        /// <returns>A string of CSS classes (e.g., "bg-emerald-200 dark:bg-emerald-800").</returns>
        public abstract string GetIndicatorColorCss(AccentColor color);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzBadgeStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzBadge Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzBadge" /> component.
    /// </summary>
    public abstract class RzBadgeStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzBadgeStylesBase" /> class. </summary>
        protected RzBadgeStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzBadge span element (layout, border, font). </summary>
        public abstract string Badge { get; }
        /// <summary> Gets the CSS classes for the inner span containing the icon and text content (padding, alignment). </summary>
        public abstract string InnerSpan { get; }
        /// <summary> Gets the variant-specific CSS classes (border, background, text color) for a standard badge. </summary>
        /// <param name="color">The semantic color for the badge.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetVariantCss(SemanticColor color);
        /// <summary> Gets the variant-specific CSS classes (border, background, text color) for a "soft" badge. </summary>
        /// <param name="color">The semantic color for the badge.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetVariantSoftCss(SemanticColor color);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzBreadcrumbStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzBreadcrumb Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzBreadcrumb" /> component container.
    /// </summary>
    public abstract class RzBreadcrumbStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzBreadcrumbStylesBase" /> class. </summary>
        protected RzBreadcrumbStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzBreadcrumb nav element (typography, margin). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the ordered list (ol) element wrapping the items (layout, gap). </summary>
        public abstract string List { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling individual items within the <see cref="RzBreadcrumb" /> component.
    /// </summary>
    public abstract class RzBreadcrumbItemStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzBreadcrumbItemStylesBase" /> class. </summary>
        protected RzBreadcrumbItemStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the CSS classes for the list item (li) element (layout, gap, base text color). </summary>
        public abstract string ListItem { get; }
        /// <summary> Gets the CSS classes for the anchor (a) element used for non-active items (hover states). </summary>
        public abstract string Link { get; }
        /// <summary> Gets the CSS classes for the span element used for the active item (font weight). </summary>
        public abstract string ActiveSpan { get; }
        /// <summary> Gets the CSS classes for the span wrapping an icon, if used. </summary>
        public abstract string IconSpan { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzBrowserStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzBrowser Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzBrowser" /> component.
    /// </summary>
    public abstract class RzBrowserStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzBrowserStylesBase" /> class. </summary>
        protected RzBrowserStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzBrowser container div. </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the browser top bar (holding traffic lights and controls). </summary>
        public abstract string TopBar { get; }
        /// <summary> Gets the CSS classes for the traffic lights container. </summary>
        public abstract string TrafficLightsContainer { get; }
        /// <summary> Gets the CSS class for the red traffic light. </summary>
        public abstract string TrafficLightRed { get; }
        /// <summary> Gets the CSS class for the yellow traffic light. </summary>
        public abstract string TrafficLightYellow { get; }
        /// <summary> Gets the CSS class for the green traffic light. </summary>
        public abstract string TrafficLightGreen { get; }
        /// <summary> Gets the CSS classes for the screen size controls container (desktop only). </summary>
        public abstract string ScreenSizeControlsContainer { get; }
        /// <summary> Gets the CSS classes for the screen size control buttons' shared style. </summary>
        public abstract string ScreenSizeButton { get; }
        /// <summary> Gets the CSS classes for the inner div grouping the screen size buttons </summary>
        public abstract string ScreenSizeButtonGroup { get; }
        // Note: ScreenSizeButtonIcon is removed as its dynamic part is handled by Alpine :class
        /// <summary> Gets the CSS classes for the main content area div with the grid pattern. </summary>
        public abstract string ContentArea { get; }
        /// <summary> Gets the CSS classes for the inner container div that holds the actual preview/iframe. </summary>
        public abstract string PreviewContainer { get; }
        // Note: Methods for dynamic classes (GetBrowserBorderCss, GetDesktopScreenButtonCss, etc.) are REMOVED
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzButtonStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzButton Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzButton" /> component.
    /// </summary>
    public abstract class RzButtonStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzButtonStylesBase" /> class. </summary>
        protected RzButtonStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the button element (layout, cursor, base typography, transitions). </summary>
        public abstract string Button { get; }
        /// <summary> Gets the CSS classes applied when the button has animation enabled (transforms, transitions). </summary>
        public abstract string Animated { get; }
        /// <summary> Gets the variant-specific CSS classes (background, text, focus styles) for a standard (solid) button. </summary>
        /// <param name="variant">The button variant type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetVariantCss(ButtonVariant variant);
        /// <summary> Gets the variant-specific CSS classes (background, border, text, focus styles) for an outlined button. </summary>
        /// <param name="variant">The button variant type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetVariantOutlineCss(ButtonVariant variant);
        /// <summary> Gets the size-specific CSS classes (padding, text size) for the button. </summary>
        /// <param name="size">The desired button size.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetSizeCss(Size size);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzButtonGroup" /> component and its interaction with
    ///     child buttons.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzButtonGroup" /> component.
    /// </summary>
    public abstract class RzButtonGroupStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzButtonGroupStylesBase" /> class. </summary>
        protected RzButtonGroupStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the ButtonGroup container div (layout). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes applied to the first button in a group (corner rounding). </summary>
        public abstract string GroupFirst { get; }
        /// <summary> Gets the CSS classes applied to the last button in a group (corner rounding, border adjustment). </summary>
        public abstract string GroupLast { get; }
        /// <summary>
        ///     Gets the CSS classes applied to buttons that are neither first nor last in a group (corner rounding, border
        ///     adjustment).
        /// </summary>
        public abstract string GroupMiddle { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDarkModeToggle" /> button.
    /// </summary>
    public abstract class RzDarkmodeToggleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzDarkmodeToggleStylesBase" /> class. </summary>
        protected RzDarkmodeToggleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the DarkmodeToggle button element (layout, padding, base colors, transitions). </summary>
        public abstract string Button { get; }
        /// <summary> Gets the CSS classes for the icons (SVG/Blazicon) within the button (transitions). </summary>
        public abstract string Icon { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSearchButton" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSearchButton" /> component.
    /// </summary>
    public abstract class RzSearchButtonStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzSearchButtonStylesBase" /> class. </summary>
        protected RzSearchButtonStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the SearchButton button element (layout, border, background, typography,
        ///     transitions).
        /// </summary>
        public abstract string Button { get; }
        /// <summary> Gets the CSS classes for the inner div containing the icon and label (layout, gap). </summary>
        public abstract string InnerContainer { get; }
        /// <summary> Gets the CSS classes for the span wrapping the search icon (text size). </summary>
        public abstract string IconSpan { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzCardStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzCard Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCard" /> component container.
    /// </summary>
    public abstract class RzCardStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardStylesBase" /> class. </summary>
        protected RzCardStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCard container div (layout, rounding, overflow, shadow, border). </summary>
        public abstract string Container { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardHeader" /> section.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardHeader" /> component.
    /// </summary>
    public abstract class RzCardHeaderStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardHeaderStylesBase" /> class. </summary>
        protected RzCardHeaderStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardHeader div (layout, padding, alignment). </summary>
        public abstract string Header { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardBody" /> section.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardBody" /> component.
    /// </summary>
    public abstract class RzCardBodyStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardBodyStylesBase" /> class. </summary>
        protected RzCardBodyStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardBody div (flex grow, padding). </summary>
        public abstract string Body { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardFooter" /> section.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardFooter" /> component.
    /// </summary>
    public abstract class RzCardFooterStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardFooterStylesBase" /> class. </summary>
        protected RzCardFooterStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardFooter div (padding, typography, bottom rounding). </summary>
        public abstract string Footer { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardTitle" />.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardTitle" /> component.
    /// </summary>
    public abstract class RzCardTitleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardTitleStylesBase" /> class. </summary>
        protected RzCardTitleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardTitle h3 element (layout, margin, typography). </summary>
        public abstract string Title { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardSubtitle" />.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardSubtitle" /> component.
    /// </summary>
    public abstract class RzCardSubtitleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardSubtitleStylesBase" /> class. </summary>
        protected RzCardSubtitleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardSubtitle h4 element (typography). </summary>
        public abstract string Subtitle { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardButtons" /> container in a card header.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCardButtons" /> component.
    /// </summary>
    public abstract class RzCardButtonsStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCardButtonsStylesBase" /> class. </summary>
        protected RzCardButtonsStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCardButtons div (layout, gap, negative margin for alignment). </summary>
        public abstract string ButtonsContainer { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzCheckboxGroupStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzCheckbox Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCheckboxGroup{TValue}" /> container.
    /// </summary>
    public abstract class RzCheckboxGroupStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCheckboxGroupStylesBase" /> class. </summary>
        protected RzCheckboxGroupStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCheckboxGroup container div (layout, gap). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the layout-specific CSS classes based on the Orientation (flex direction). </summary>
        /// <param name="orientation">The layout orientation.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetOrientationCss(Orientation orientation);
    }
    /// <summary>
    ///     Defines the abstract structure for styling individual <see cref="RzCheckboxGroupItem{TValue}" /> components.
    /// </summary>
    public abstract class RzCheckboxGroupItemStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCheckboxGroupItemStylesBase" /> class. </summary>
        protected RzCheckboxGroupItemStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzCheckboxGroupItem label element (layout, cursor). </summary>
        public abstract string Label { get; }
        /// <summary> Gets the CSS classes for the relative div wrapping the checkbox input and icon. </summary>
        public abstract string CheckboxWrapper { get; }
        /// <summary> Gets the CSS classes for the checkbox input element itself (size, border, rounding, focus styles). </summary>
        public abstract string CheckboxInput { get; }
        /// <summary> Gets the CSS classes for the div containing the check icon (positioning, text color). </summary>
        public abstract string IconContainer { get; }
        /// <summary> Gets the CSS classes for the span containing the title text (margin). </summary>
        public abstract string TitleSpan { get; }
        /// <summary>
        ///     Returns the CSS class ("hidden" or "") to control the visibility of the check icon based on the checked
        ///     state.
        /// </summary>
        /// <param name="isChecked">Whether the checkbox is checked.</param>
        /// <returns>A string ("hidden" or "").</returns>
        public abstract string GetIconVisibilityCss(bool isChecked);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCheckboxGroupField{TValue}" /> component.
    /// </summary>
    public abstract class RzCheckboxGroupFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCheckboxGroupFieldStylesBase" /> class. </summary>
        protected RzCheckboxGroupFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzCheckboxGroupField container (typically handled by
        ///     <see cref="RzFieldStylesBase" />).
        /// </summary>
        public abstract string Field { get; }
        /// <summary>
        ///     Gets the CSS classes applied specifically to the <see cref="RzCheckboxGroup{TValue}" /> when it's rendered
        ///     inside this field container (e.g., margins).
        /// </summary>
        public abstract string GroupWithinField { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzCodeViewerStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzCodeViewer Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzCodeViewer" /> component.
    /// </summary>
    public abstract class RzCodeViewerStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzCodeViewerStylesBase" /> class. </summary>
        protected RzCodeViewerStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzCodeViewer container div (margin, overflow). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the configuration header div (layout, padding, border, background, typography). </summary>
        public abstract string Header { get; }
        /// <summary> Gets the CSS classes for the title span within the header. </summary>
        public abstract string HeaderTitle { get; }
        /// <summary> Gets the CSS classes for the main code display container div (border, rounding, overflow). </summary>
        public abstract string CodeContainer { get; }
        /// <summary> Gets the CSS classes for the div containing the copy button (layout, border, background). </summary>
        public abstract string CopyButtonContainer { get; }
        /// <summary> Gets the CSS classes for the copy button (layout, padding, rounding, focus styles). </summary>
        public abstract string CopyButton { get; }
        /// <summary> Gets the CSS classes for the SVG icon when the content is not yet copied. </summary>
        public abstract string CopyIconDefault { get; }
        /// <summary> Gets the CSS classes for the SVG icon when the content has been copied. </summary>
        public abstract string CopyIconCopied { get; }
        /// <summary> Gets the CSS classes for the div wrapping the pre/code block (positioning, overflow). </summary>
        public abstract string PreWrapper { get; }
        /// <summary> Gets the CSS classes for the pre element (typography, padding, overflow, border). </summary>
        public abstract string PreElement { get; }
        // Note: Code element classes are added by Highlight.js and theme variables
        /// <summary> Gets the CSS classes for the expand/collapse button (layout, padding, border, background, focus styles). </summary>
        public abstract string ExpandButton { get; }
        /// <summary> Gets the CSS classes for the expand/collapse SVG icon (size, transition). </summary>
        public abstract string ExpandIcon { get; }
        /// <summary> Gets the CSS classes for the PreWrapper div based on the expand state (e.g., max-height). </summary>
        /// <param name="isExpanded">Whether the code view is expanded.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetExpandContentCss(bool isExpanded);
        /// <summary> Gets the CSS classes for the expand icon based on the expand state (e.g., rotate-180). </summary>
        /// <param name="isExpanded">Whether the code view is expanded.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetExpandButtonIconCss(bool isExpanded);
        /// <summary> Gets the CSS classes for the copy button based on the copied state (e.g., focus outline color). </summary>
        /// <param name="isCopied">Whether the code has just been copied.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetCopyButtonStateCss(bool isCopied);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzDateEditStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzDateEdit Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDateEdit" /> component.
    /// </summary>
    public abstract class RzDateEditStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzDateEditStylesBase" /> class. </summary>
        protected RzDateEditStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzDateEdit container div (width). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the relative div wrapping the input and prepend element. </summary>
        public abstract string InputWrapper { get; }
        /// <summary>
        ///     Gets the CSS classes for the prepend element div (positioning, layout, padding, border, background,
        ///     typography).
        /// </summary>
        public abstract string PrependElement { get; }
        /// <summary> Gets the CSS classes for the Blazicon component if PrependIcon is used (text size). </summary>
        public abstract string PrependIconContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the input element (layout, rounding, border, padding, typography, focus
        ///     styles).
        /// </summary>
        public abstract string Input { get; }
        // Note: Flatpickr calendar styles are handled separately by its CSS file.
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzDividerStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzDividerStyles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDivider" /> component,
    ///     including variants for thickness and inset positioning.
    /// </summary>
    public abstract class RzDividerStylesBase
    {
        /// <summary>The theme instance providing color and sizing tokens.</summary>
        protected readonly RzTheme Theme;
        /// <summary>Initializes a new instance of the <see cref="RzDividerStylesBase" /> class.</summary>
        protected RzDividerStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        // ──────────────────────────────────────────────────────────────
        // Base / variant properties
        // ──────────────────────────────────────────────────────────────
        /// <summary>Standard horizontal rule (margin + solid border).</summary>
        public abstract string Container { get; }
        /// <summary>Thick variant rendered with <c>h‑px</c> + background.</summary>
        public abstract string Thick { get; }
        /// <summary>Dotted border style.</summary>
        public abstract string Dotted { get; }
        /// <summary>Dashed border style.</summary>
        public abstract string Dashed { get; }
        /// <summary>Inset (indented) solid rule.</summary>
        public abstract string Inset { get; }
        /// <summary>Inset thick rule.</summary>
        public abstract string InsetThick { get; }
        /// <summary>Inset dotted rule.</summary>
        public abstract string InsetDotted { get; }
        /// <summary>Inset dashed rule.</summary>
        public abstract string InsetDashed { get; }
        /// <summary>
        ///     Base classes applied to the <c>&lt;div></c> wrapper when the divider
        ///     contains <see cref="Microsoft.AspNetCore.Components.RenderFragment" /> content
        ///     (label, child markup, etc.).
        /// </summary>
        public abstract string Divider { get; }
        // ──────────────────────────────────────────────────────────────
        // Helper methods used by <see cref="RzDivider"/> runtime logic
        // ──────────────────────────────────────────────────────────────
        /// <summary>Returns the CSS for a plain <c>&lt;hr></c> in the requested style.</summary>
        public abstract string GetStyleCss(DividerStyle style);
        /// <summary>
        ///     Returns the CSS (incl. <c>::before</c>/<c>::after</c> pseudo‑elements) for
        ///     a labelled divider, taking alignment and desired line style into account.
        /// </summary>
        public abstract string GetAlignmentCss(Align alignment, DividerStyle style);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzDropdownStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzDropdown Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDropdown" /> component.
    /// </summary>
    public abstract class RzDropdownStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzDropdownStylesBase" /> class. </summary>
        protected RzDropdownStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzDropdown container div (usually empty or just display property). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the relative div that wraps both the trigger and the floating menu. </summary>
        public abstract string RelativeWrapper { get; }
        /// <summary> Gets the CSS classes for the div that wraps the trigger content (layout properties). </summary>
        public abstract string TriggerWrapper { get; }
        /// <summary>
        ///     Gets the CSS classes for the dropdown menu container div (positioning, width, rounding, shadow). Anchor
        ///     positioning classes are added dynamically.
        /// </summary>
        public abstract string MenuContainer { get; }
        /// <summary>
        ///     Gets the CSS classes for the inner div inside the menu container, which typically holds sections and provides
        ///     background/border styling.
        /// </summary>
        public abstract string MenuInnerContainer { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling sections within an <see cref="RzDropdown" />.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDropdownSection" /> component.
    /// </summary>
    public abstract class RzDropdownSectionStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzDropdownSectionStylesBase" /> class. </summary>
        protected RzDropdownSectionStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzDropdownSection div (layout, padding). </summary>
        public abstract string Section { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling individual items within an <see cref="RzDropdownSection" />.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzDropdownMenuItem" /> component.
    /// </summary>
    public abstract class RzDropdownMenuItemStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzDropdownMenuItemStylesBase" /> class. </summary>
        protected RzDropdownMenuItemStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzDropdownMenuItem anchor (a) element (layout, rounding, cursor, border,
        ///     padding, typography, transitions, focus styles).
        /// </summary>
        public abstract string MenuItem { get; }
        /// <summary> Gets the CSS classes for the span wrapping the icon (typography size). </summary>
        public abstract string IconSpan { get; }
        /// <summary> Gets the CSS classes for the Blazicon component within the icon span (size, layout, opacity). </summary>
        public abstract string Icon { get; }
        /// <summary> Gets the CSS classes for the span containing the title text (flex grow). </summary>
        public abstract string TitleSpan { get; }
        /// <summary>
        ///     Gets the CSS classes for the div displaying the optional count badge (layout, rounding, border, padding,
        ///     typography).
        /// </summary>
        public abstract string CountDiv { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzEmbeddedPreviewStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzEmbeddedPreview Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzEmbeddedPreview" /> component.
    /// </summary>
    public abstract class RzEmbeddedPreviewStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzEmbeddedPreviewStylesBase" /> class. </summary>
        protected RzEmbeddedPreviewStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzEmbeddedPreview container div (typically just width). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the iframe element (width, height, transitions). </summary>
        public abstract string IFrame { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzFieldStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzField Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzField" /> container component.
    /// </summary>
    public abstract class RzFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzFieldStylesBase" /> class. </summary>
        protected RzFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzField container div (layout, spacing). </summary>
        public abstract string Field { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzFieldLabel{TValue}" /> component.
    /// </summary>
    public abstract class RzFieldLabelStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzFieldLabelStylesBase" /> class. </summary>
        protected RzFieldLabelStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzFieldLabel label element (typography). </summary>
        public abstract string Label { get; }
        /// <summary> Gets the CSS classes for the required indicator span (color, typography). </summary>
        public abstract string RequiredIndicator { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzFieldHelp" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzFieldHelp" /> component.
    /// </summary>
    public abstract class RzFieldHelpStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzFieldHelpStylesBase" /> class. </summary>
        protected RzFieldHelpStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzFieldHelp p element (typography, color). </summary>
        public abstract string HelpText { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzFormSectionStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzFormSection Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzFormSection" /> component.
    /// </summary>
    public abstract class RzFormSectionStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzFormSectionStylesBase" /> class. </summary>
        protected RzFormSectionStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzFormSection container div (layout determined by method). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the description container div (layout determined by method). </summary>
        public abstract string DescriptionContainer { get; }
        /// <summary> Gets the CSS classes for the title h2 element (typography). </summary>
        public abstract string Title { get; }
        /// <summary> Gets the CSS classes for the description p element (typography). </summary>
        public abstract string Description { get; }
        /// <summary> Gets the CSS classes for the content container div (layout determined by method). </summary>
        public abstract string ContentContainer { get; }
        /// <summary> Gets the layout-specific CSS classes for the main container div. </summary>
        /// <param name="layout">The section layout type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetLayoutCss(SectionLayout layout);
        /// <summary> Gets the layout-specific CSS classes for the description container div. </summary>
        /// <param name="layout">The section layout type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetDescriptionLayoutCss(SectionLayout layout);
        /// <summary> Gets the layout-specific CSS classes for the content container div. </summary>
        /// <param name="layout">The section layout type.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetContentLayoutCss(SectionLayout layout);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzHeadingStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzHeading Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzHeading" /> component.
    /// </summary>
    public abstract class RzHeadingStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzHeadingStylesBase" /> class. </summary>
        protected RzHeadingStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the level-specific CSS classes for the heading element (margins, responsive text sizes, font weight). </summary>
        /// <param name="level">The heading level (H1-H4).</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetLevelCss(HeadingLevel level);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzLinkStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzLink Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzLink" /> component.
    /// </summary>
    public abstract class RzLinkStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzLinkStylesBase" /> class. </summary>
        protected RzLinkStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzLink anchor (a) element (typography, color, focus styles). </summary>
        public abstract string Link { get; }
        /// <summary> Gets the CSS classes applied when underlining is enabled (hover/focus states). </summary>
        public abstract string UnderlineEnabled { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzMarkdownStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzMarkdown Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzMarkdown" /> component container.
    /// </summary>
    public abstract class RzMarkdownStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzMarkdownStylesBase" /> class. </summary>
        protected RzMarkdownStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzMarkdown container div (prose base, dark mode, text color, max-width
        ///     reset).
        /// </summary>
        public abstract string Container { get; }
        /// <summary> Gets the prose width utility class based on the specified width. </summary>
        /// <param name="width">The desired prose width.</param>
        /// <returns>A string representing a Tailwind prose width class (e.g., "prose-wide").</returns>
        public abstract string GetProseWidthCss(ProseWidth width);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzModalStylesBase.cs">
namespace RizzyUI;
/// <summary>
/// Abstract base class defining the structure for component style definitions.
/// Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
/// allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzModal Styles
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzModal"/> component.
    /// </summary>
    public abstract class RzModalStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzModalStylesBase"/> class. </summary>
        protected RzModalStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the CSS classes for the modal backdrop overlay. </summary>
        public abstract string Backdrop { get; }
        /// <summary> Gets the base CSS classes for the modal dialog container. Size class is added separately. </summary>
        public abstract string Dialog { get; }
        /// <summary> Gets the CSS classes for the modal header section. </summary>
        public abstract string Header { get; }
        /// <summary> Gets the CSS classes for the container div optionally wrapping the title content. </summary>
        public abstract string TitleContainer { get; }
        /// <summary> Gets the CSS classes for the modal title (h3) element. </summary>
        public abstract string Title { get; }
        /// <summary> Gets the CSS classes for the container div holding the close button. </summary>
        public abstract string CloseButtonContainer { get; }
        /// <summary> Gets the CSS classes for the close button element. </summary>
        public abstract string CloseButton { get; }
        /// <summary> Gets the CSS classes for the icon within the close button. </summary>
        public abstract string CloseButtonIcon { get; }
        /// <summary> Gets the CSS classes for the modal body section. </summary>
        public abstract string Body { get; }
        /// <summary> Gets the CSS classes for the modal footer section. </summary>
        public abstract string Footer { get; }
        /// <summary> Gets the size-specific max-width CSS class for the modal dialog. </summary>
        /// <param name="size">The desired modal size.</param>
        /// <returns>A string representing a max-width class (e.g., "max-w-lg").</returns>
        public abstract string GetSizeCss(ModalSize size);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzNavbarStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzNavbar Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzNavbar" /> component.
    /// </summary>
    public abstract class RzNavbarStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzNavbarStylesBase" /> class. </summary>
        protected RzNavbarStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzNavbar nav element (positioning, size, layout, border, background, blur). </summary>
        public abstract string Navbar { get; }
        /// <summary> Gets the CSS classes for the mobile toggle button (visibility, layout, text color). </summary>
        public abstract string ToggleButton { get; }
        /// <summary> Gets the CSS classes for the icon container inside the toggle button (text size). </summary>
        public abstract string ToggleButtonIconContainer { get; }
        /// <summary> Gets the CSS classes for the screen-reader-only span inside the toggle button. </summary>
        public abstract string ToggleButtonSrText { get; }
        /// <summary> Gets the CSS classes for the main content container div within the navbar (size, layout). </summary>
        public abstract string ContentContainer { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzNumberEditStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzNumber Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzNumberEdit{TValue}" /> component.
    /// </summary>
    public abstract class RzNumberEditStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzNumberEditStylesBase" /> class. </summary>
        protected RzNumberEditStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the CSS classes for the relative div wrapping the input and prepend element. </summary>
        public abstract string InputWrapper { get; }
        /// <summary>
        ///     Gets the CSS classes for the prepend element div (positioning, layout, padding, border, background,
        ///     typography).
        /// </summary>
        public abstract string PrependElement { get; }
        /// <summary> Gets the CSS classes for the Blazicon component if PrependIcon is used (text size). </summary>
        public abstract string PrependIconContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the input element (layout, rounding, border, padding, typography, focus
        ///     styles).
        /// </summary>
        public abstract string Input { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzNumberField{TValue}" /> component.
    /// </summary>
    public abstract class RzNumberFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzNumberFieldStylesBase" /> class. </summary>
        protected RzNumberFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzNumberField container (typically handled by
        ///     <see cref="RzFieldStylesBase" />).
        /// </summary>
        public abstract string Field { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzParagraphStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzParagraph Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzParagraph" /> component.
    /// </summary>
    public abstract class RzParagraphStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzParagraphStylesBase" /> class. </summary>
        protected RzParagraphStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzParagraph p element (margin, leading). </summary>
        public abstract string Paragraph { get; }
        /// <summary> Gets the prose width utility class based on the specified width. </summary>
        /// <param name="width">The desired prose width.</param>
        /// <returns>A string representing a Tailwind prose width class.</returns>
        public abstract string GetProseWidthCss(ProseWidth width);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzProgressStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzProgress Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzProgress" /> component.
    /// </summary>
    public abstract class RzProgressStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzProgressStylesBase" /> class. </summary>
        protected RzProgressStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzProgress container div (width). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the optional outside label container div (layout, margin). </summary>
        public abstract string OutsideLabelContainer { get; }
        /// <summary> Gets the CSS classes for the outside label text span (text color). </summary>
        public abstract string OutsideLabelText { get; }
        /// <summary>
        ///     Gets the CSS classes for the outer progress bar container div (track styling: layout, overflow, rounding,
        ///     background).
        /// </summary>
        public abstract string OuterBar { get; }
        /// <summary>
        ///     Gets the base CSS classes for the inner progress bar div (value indicator: layout, typography, transitions).
        ///     Variant styles are applied separately.
        /// </summary>
        public abstract string InnerBarBase { get; }
        /// <summary> Gets the CSS classes for the inside label container div (positioning). </summary>
        public abstract string InsideLabelContainer { get; }
        /// <summary> Gets the base CSS classes for the inside label text span (usually empty, styled by container). </summary>
        public abstract string InsideLabelText { get; }
        /// <summary> Gets the height CSS class for the OuterBar based on the label's position. </summary>
        /// <param name="position">The position of the label.</param>
        /// <returns>A string representing a height class (e.g., "h-4").</returns>
        public abstract string GetOuterBarHeightCss(ProgressLabelPosition position);
        /// <summary> Gets the variant-specific CSS classes for the InnerBar (height, rounding, background, text color). </summary>
        /// <param name="variant">The status color variant.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetInnerBarVariantCss(StatusColor variant);
        /// <summary> Gets the text color CSS class for the InsideLabel when it overflows the InnerBar. </summary>
        /// <param name="overflows">Whether the label overflows the bar.</param>
        /// <returns>A string representing a text color class or an empty string.</returns>
        public abstract string GetInsideLabelColorCss(bool overflows);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzQuickReferenceStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzQuickReference Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzQuickReference" /> component.
    /// </summary>
    public abstract class RzQuickReferenceStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzQuickReferenceStylesBase" /> class. </summary>
        protected RzQuickReferenceStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzQuickReference container div (base text color). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the title paragraph (margin, font weight). </summary>
        public abstract string Title { get; }
        /// <summary> Gets the CSS classes for the list (ul) element containing heading links (layout, gap). </summary>
        public abstract string List { get; }
        /// <summary> Gets the base CSS classes for individual list items (li). Indentation is applied separately. </summary>
        public abstract string ListItem { get; }
        /// <summary> Gets the base CSS classes for the anchor (a) tag linking to headings. </summary>
        public abstract string Link { get; }
        /// <summary> Gets the CSS class applied to the link when it corresponds to the currently highlighted heading. </summary>
        public abstract string LinkSelected { get; }
        /// <summary>
        ///     Gets the indentation CSS class (e.g., "ml-4") for a list item based on its heading level relative to the
        ///     minimum level shown.
        /// </summary>
        /// <param name="level">The heading level of the item.</param>
        /// <param name="minLevel">The minimum heading level being displayed in the quick reference.</param>
        /// <returns>A string representing a margin-left class.</returns>
        public abstract string GetIndentationCss(HeadingLevel level, HeadingLevel minLevel);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzQuickReferenceContainer" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzQuickReferenceContainer" /> component.
    /// </summary>
    public abstract class RzQuickReferenceContainerStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzQuickReferenceContainerStylesBase" /> class. </summary>
        protected RzQuickReferenceContainerStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzQuickReferenceContainer div (usually none). </summary>
        public abstract string Container { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzRadioGroupStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzRadio Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzRadioGroup{TValue}" /> container.
    /// </summary>
    public abstract class RzRadioGroupStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzRadioGroupStylesBase" /> class. </summary>
        protected RzRadioGroupStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzRadioGroup container div (layout, gap, padding). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the grid column CSS class based on the orientation and item count. </summary>
        /// <param name="orientation">The layout orientation.</param>
        /// <param name="itemCount">The number of radio items.</param>
        /// <returns>A string representing a grid columns class (e.g., "grid-cols-1").</returns>
        public abstract string GetGridColumnsCss(Orientation orientation, int itemCount);
    }
    /// <summary>
    ///     Defines the abstract structure for styling individual <see cref="RzRadioGroupItem{TValue}" /> components.
    /// </summary>
    public abstract class RzRadioGroupItemStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzRadioGroupItemStylesBase" /> class. </summary>
        protected RzRadioGroupItemStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzRadioGroupItem label element (layout). </summary>
        public abstract string LabelWrapper { get; }
        /// <summary> Gets the CSS classes for the visually hidden radio input element. </summary>
        public abstract string RadioInput { get; }
        /// <summary> Gets the CSS classes for the check icon container span (positioning, appearance, transitions). </summary>
        public abstract string IconContainer { get; }
        /// <summary>
        ///     Gets the CSS classes for the main clickable container span (layout, cursor, rounding, border, padding, peer
        ///     states).
        /// </summary>
        public abstract string ClickableContainer { get; }
        /// <summary> Gets the CSS classes for the div containing the optional icon and text content (layout). </summary>
        public abstract string ContentWrapper { get; }
        /// <summary> Gets the CSS classes for the optional leading icon div (margin, typography). </summary>
        public abstract string LeadingIconContainer { get; }
        /// <summary> Gets the CSS classes for the span holding the label and description (layout, padding). </summary>
        public abstract string TextContainer { get; }
        /// <summary> Gets the CSS classes for the label text span (margin, typography). </summary>
        public abstract string LabelText { get; }
        /// <summary> Gets the CSS classes for the description text span (layout, typography). </summary>
        public abstract string DescriptionText { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzRadioGroupField{TValue}" /> component.
    /// </summary>
    public abstract class RzRadioGroupFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzRadioGroupFieldStylesBase" /> class. </summary>
        protected RzRadioGroupFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzRadioGroupField container (typically handled by
        ///     <see cref="RzFieldStylesBase" />).
        /// </summary>
        public abstract string Field { get; }
        /// <summary>
        ///     Gets the CSS classes applied specifically to the <see cref="RzRadioGroup{TValue}" /> when it's rendered
        ///     inside this field container.
        /// </summary>
        public abstract string GroupWithinField { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzSidebarStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzSidebar Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSidebar" /> component and layout.
    /// </summary>
    public abstract class RzSidebarStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzSidebarStylesBase" /> class. </summary>
        protected RzSidebarStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the main RzSidebar container div (which holds the Alpine.js x-data). Usually
        ///     empty.
        /// </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the primary div containing both the sidebar (aside) and main content area (section). </summary>
        public abstract string LayoutContainer { get; }
        /// <summary> Gets the CSS classes for the screen reader skip link. </summary>
        public abstract string SkipLink { get; }
        /// <summary> Gets the CSS classes for the dark overlay div shown on mobile when the sidebar is open. </summary>
        public abstract string Overlay { get; }
        /// <summary>
        ///     Gets the base CSS classes for the aside element (sidebar container: positioning, width, overflow, background,
        ///     border, z-index, padding, transitions).
        /// </summary>
        public abstract string Sidebar { get; }
        /// <summary> Gets the CSS classes for the main content section element (padding-left offset, width, background). </summary>
        public abstract string MainContentContainer { get; }
        /// <summary> Gets the CSS classes for the inner div providing padding within the main content area. </summary>
        public abstract string MainContentPadding { get; }
        /// <summary> Gets the CSS classes for the floating toggle button used when no <see cref="RzNavbar" /> is provided. </summary>
        public abstract string FloatingToggleButton { get; }
        /// <summary> Gets the CSS 'top' positioning class for the sidebar based on whether a navbar is present. </summary>
        /// <param name="hasNavbar">True if a navbar is rendered within the sidebar.</param>
        /// <returns>A string like "top-16" or "top-0".</returns>
        public abstract string GetSidebarTopCss(bool hasNavbar);
        /// <summary> Gets the CSS top margin class for the main layout container based on whether a navbar is present. </summary>
        /// <param name="hasNavbar">True if a navbar is rendered within the sidebar.</param>
        /// <returns>A string like "mt-16" or "".</returns>
        public abstract string GetLayoutContainerTopCss(bool hasNavbar);
        /// <summary> Gets the CSS transform class for the sidebar's visibility state (used by Alpine.js binding). </summary>
        /// <param name="isVisible">True if the sidebar should be visible.</param>
        /// <returns>A string like "translate-x-0" or "-translate-x-60".</returns>
        public abstract string GetSidebarTranslationCss(bool isVisible);
    }
    /// <summary>
    ///     Defines the abstract structure for styling individual items (<see cref="RzSidebarLinkItem" />) within the sidebar.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSidebarLinkItem" /> component.
    /// </summary>
    public abstract class RzSidebarLinkItemStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzSidebarLinkItemStylesBase" /> class. </summary>
        protected RzSidebarLinkItemStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the list item (li) when it represents a collapsible section. </summary>
        public abstract string CollapsibleListItem { get; }
        /// <summary> Gets the CSS classes for the inner div used within a collapsible list item. </summary>
        public abstract string CollapsibleInnerDiv { get; }
        /// <summary> Gets the base CSS classes for the button element used as the header for a collapsible section. </summary>
        public abstract string CollapsibleButton { get; }
        /// <summary> Gets the CSS classes for the icon container div within the collapsible button. </summary>
        public abstract string CollapsibleButtonIconContainer { get; }
        /// <summary> Gets the CSS classes for the title span within the collapsible button. </summary>
        public abstract string CollapsibleButtonTitle { get; }
        /// <summary> Gets the CSS classes for the trailer content div (e.g., badge) within the collapsible button. </summary>
        public abstract string CollapsibleButtonTrailer { get; }
        /// <summary> Gets the base CSS classes for the expand/collapse chevron icon. </summary>
        public abstract string CollapsibleButtonChevron { get; }
        /// <summary> Gets the CSS classes for the nested list (ul) containing child items within a collapsible section. </summary>
        public abstract string CollapsibleNestedList { get; }
        /// <summary> Gets the CSS classes for the list item (li) when it's a non-collapsible sub-item (indented style). </summary>
        public abstract string SubListItem { get; }
        /// <summary> Gets the CSS classes for the anchor (a) or div element used for a non-collapsible sub-item. </summary>
        public abstract string SubLinkOrDiv { get; }
        /// <summary> Gets the CSS classes for the list item (li) when it's a non-collapsible top-level item. </summary>
        public abstract string TopLevelListItem { get; }
        /// <summary> Gets the CSS classes for the div element used when a top-level item has children but is not collapsible. </summary>
        public abstract string TopLevelNonCollapsibleDiv { get; }
        /// <summary> Gets the CSS classes for the anchor (a) element used for a non-collapsible top-level item. </summary>
        public abstract string TopLevelLink { get; }
        /// <summary> Gets the CSS classes for the icon container div used within non-collapsible items. </summary>
        public abstract string ItemIconContainer { get; }
        /// <summary> Gets the CSS classes for the title span used within non-collapsible items. </summary>
        public abstract string ItemTitle { get; }
        /// <summary> Gets the CSS classes for the trailer content div used within non-collapsible items. </summary>
        public abstract string ItemTrailer { get; }
        /// <summary> Gets the CSS classes for the nested list (ul) used within non-collapsible items that have children. </summary>
        public abstract string NonCollapsibleNestedList { get; }
        /// <summary> Gets the CSS transform class (e.g., "rotate-180") for the chevron icon based on the expanded state. </summary>
        /// <param name="isExpanded">True if the collapsible section is expanded.</param>
        /// <returns>A string representing a rotation class.</returns>
        public abstract string GetChevronRotationCss(bool isExpanded);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSidebarLinks" /> container list.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSidebarLinks" /> component.
    /// </summary>
    public abstract class RzSidebarLinksStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzSidebarLinksStylesBase" /> class. </summary>
        protected RzSidebarLinksStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzSidebarLinks ul element (layout, spacing). </summary>
        public abstract string List { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzSpinnerStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
	#region RzSpinner Styles
	/// <summary>
	/// Defines the abstract structure for styling the <see cref="RzSpinner" /> component.
	/// </summary>
	public abstract class RzSpinnerStylesBase
	{
		/// <summary> The theme instance providing color and sizing tokens. </summary>
		protected readonly RzTheme Theme;
		/// <summary> Initializes a new instance of the <see cref="RzSpinnerStylesBase" /> class. </summary>
		protected RzSpinnerStylesBase(RzTheme theme)
		{
			Theme = theme;
		}
		/// <summary> Gets the base CSS classes for the spinner SVG element (animation, default fill). </summary>
		public abstract string SpinnerBase { get; }
		/// <summary> Gets the size-specific CSS class for the spinner. </summary>
		/// <param name="size">The desired spinner size.</param>
		/// <returns>A string representing a size class (e.g., "size-6").</returns>
		public abstract string GetSizeCss(Size size);
		/// <summary> Gets the color-specific CSS fill class for the spinner. </summary>
		/// <param name="color">The semantic color for the spinner.</param>
		/// <returns>A string representing a fill color class (e.g., "fill-primary").</returns>
		public abstract string GetColorCss(SemanticColor color);
	}
	#endregion
}
</file>

<file path="Styles/RzStylesBase.RzStepsStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzStep Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzSteps" /> component.
    /// </summary>
    public abstract class RzStepsStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzStepsStylesBase" /> class. </summary>
        protected RzStepsStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzSteps ordered list (ol) element (layout, gap). </summary>
        public abstract string Container { get; }
        /// <summary>
        ///     Gets the base CSS classes for the list item (li) element representing a step (layout, positioning,
        ///     typography).
        /// </summary>
        public abstract string StepItem { get; }
        /// <summary> Gets the base CSS classes for the connector span element between steps. </summary>
        public abstract string ConnectorBase { get; }
        /// <summary> Gets the CSS classes for the div wrapping the step circle and label (layout, gap). </summary>
        public abstract string StepContentContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the span representing the step circle when completed (layout, size, rounding,
        ///     border).
        /// </summary>
        public abstract string CircleCompletedBase { get; }
        /// <summary> Gets the CSS classes for the SVG icon within the completed circle (size). </summary>
        public abstract string CircleCompletedIcon { get; }
        /// <summary> Gets the CSS classes for the screen reader text within the completed circle. </summary>
        public abstract string CircleCompletedSrText { get; }
        /// <summary>
        ///     Gets the base CSS classes for the span representing the step circle for current or upcoming steps (layout,
        ///     size, rounding, border).
        /// </summary>
        public abstract string CircleDefaultBase { get; }
        /// <summary>
        ///     Gets the CSS classes for the icon (if used) within the default step circle (size).
        /// </summary>
        public abstract string CircleDefaultIcon { get; }
        /// <summary>
        ///     Gets the base CSS classes for the step label span (visibility, width). Status-specific styles are applied
        ///     separately.
        /// </summary>
        public abstract string LabelBase { get; }
        /// <summary> Gets the CSS classes for the optional caption span (typography). </summary>
        public abstract string Caption { get; }
        /// <summary> Gets the layout-specific CSS classes for the main container based on Orientation. </summary>
        /// <param name="orientation">The layout orientation.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetOrientationCss(Orientation orientation);
        /// <summary>
        ///     Gets the width CSS class for a step list item based on whether it's the first item (relevant for horizontal
        ///     layout).
        /// </summary>
        /// <param name="isFirst">True if this is the first step item.</param>
        /// <returns>A string like "w-full" or "".</returns>
        public abstract string GetStepItemWidthCss(bool isFirst);
        /// <summary>
        ///     Gets the CSS classes for the connector line between steps, considering orientation, previous step status, and
        ///     the active color.
        /// </summary>
        /// <param name="orientation">The layout orientation.</param>
        /// <param name="previousStatus">The status of the preceding step.</param>
        /// <param name="activeColor">The theme's active status color.</param>
        /// <returns>A string of CSS classes for positioning, size, and color.</returns>
        public abstract string GetConnectorCss(Orientation orientation, StepStatus previousStatus,
            StatusColor activeColor);
        /// <summary> Gets the variant-specific CSS classes for the completed step circle (border, background, text color). </summary>
        /// <param name="activeColor">The theme's active status color.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetCircleCompletedCss(StatusColor activeColor);
        /// <summary>
        ///     Gets the variant-specific CSS classes for the step circle based on its status (Current or Upcoming) and the
        ///     active color. Includes focus styles.
        /// </summary>
        /// <param name="status">The current status of the step.</param>
        /// <param name="activeColor">The theme's active status color.</param>
        /// <returns>A string of CSS classes.</returns>
        public abstract string GetCircleDefaultCss(StepStatus status, StatusColor activeColor);
        /// <summary> Gets the variant-specific CSS classes for the step label based on its status and the active color. </summary>
        /// <param name="status">The current status of the step.</param>
        /// <param name="activeColor">The theme's active status color.</param>
        /// <returns>A string representing text color and font weight classes.</returns>
        public abstract string GetLabelStatusCss(StepStatus status, StatusColor activeColor);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzTableRowStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzTableRow{TItem}"/> component.
    /// </summary>
    public abstract class RzTableRowStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzTableRowStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzTableRowStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the base CSS classes for the table row (&lt;tr&gt;) element, without hover or striping.</summary>
        public abstract string TableRowBase { get; }
        /// <summary>Gets the CSS classes to apply for hover effects on a table row.</summary>
        public abstract string TableRowHover { get; }
    }    
}
</file>

<file path="Styles/RzStylesBase.RzTableStylesBase.cs">
using Blazicons; 
namespace RizzyUI;
/// <summary>
/// Serves as the foundational abstract class for defining style structures and behaviors specific to various UI components within the RizzyUI framework.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzTable Component Family Styles
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzTable{TItem}"/> component and its direct parts.
    /// </summary>
    public abstract class RzTableStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzTableStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzTableStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the CSS classes for the outermost wrapper div of the RzTable (e.g., overflow, rounding, border).</summary>
        public abstract string Container { get; }
        /// <summary>Gets the CSS classes for the &lt;table&gt; element (e.g., width, text alignment, base text styles).</summary>
        public abstract string Table { get; }
        /// <summary>Gets the CSS classes for the &lt;thead&gt; element (e.g., border, background, text styles for headers).</summary>
        public abstract string Thead { get; }
        /// <summary>Gets the CSS classes for the &lt;tfoot&gt; element (e.g., border, background, text styles for footers).</summary>
        public abstract string Tfoot { get; }
        /// <summary>Gets the CSS classes applied to the RzTable's root container when FixedHeader is true.</summary>
        public abstract string FixedHeaderContainer { get; } 
        /// <summary>Gets the CSS classes for the &lt;thead&gt; element when it should be fixed (sticky).</summary>
        public abstract string FixedThead { get; }      
        /// <summary>Gets the CSS classes for the &lt;tfoot&gt; element when it should be fixed (sticky).</summary>
        public abstract string FixedTfoot { get; }         
    }
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzTableHeaderCell{TItem}"/> component.
    /// </summary>
    public abstract class RzTableHeaderCellStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzTableHeaderCellStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzTableHeaderCellStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the CSS classes for the base &lt;th&gt; element.</summary>
        public abstract string HeaderCellBase { get; }
        /// <summary>Gets the CSS classes for the button element inside a sortable header cell.</summary>
        public abstract string SortableButton { get; }
        /// <summary>Gets the CSS classes applied to a header cell when it is sortable (e.g., cursor, hover effects).</summary>
        public abstract string SortableHeaderCell { get; }
        /// <summary>Gets the CSS classes for the span containing the title text within the header cell.</summary>
        public abstract string TitleSpan { get; }
        /// <summary>Gets the CSS classes for a bordered &lt;th&gt; element.</summary>
        public abstract string HeaderCellBordered { get; }
        /// <summary>Gets the CSS classes for the sort direction indicator icon.</summary>
        /// <param name="direction">The current sort direction.</param>
        /// <returns>CSS classes for the indicator (e.g., size, color, opacity).</returns>
        public abstract string GetSortIndicatorCss(SortDirection direction);
        /// <summary>Gets the SVG Icon for the sort direction indicator.</summary>
        /// <param name="direction">The current sort direction.</param>
        /// <returns>An SvgIcon instance (e.g., MdiIcon.ArrowUp) or null if no icon should be displayed.</returns>
        public abstract SvgIcon? GetSortIndicatorIcon(SortDirection direction);
    }
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzTableBody{TItem}"/> component.
    /// </summary>
    public abstract class RzTableBodyStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzTableBodyStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzTableBodyStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the CSS classes for the &lt;tbody&gt; element (e.g., row dividers, relative positioning for indicators).</summary>
        public abstract string TableBody { get; }
        /// <summary>Gets the CSS classes for the default cell (&lt;td&gt;) used when displaying the empty row message (e.g., padding, text alignment, color).</summary>
        public abstract string EmptyRowCell { get; }
        /// <summary>Gets the CSS classes for the &lt;tbody&gt; element to make it scrollable when FixedHeader is true.</summary>
        public abstract string ScrollableBody { get; }        
    }
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzTableCell{TItem}"/> component.
    /// </summary>
    public abstract class RzTableCellStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzTableCellStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzTableCellStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the CSS classes for the base &lt;td&gt; element (e.g., padding).</summary>
        public abstract string TableCellBase { get; }
        /// <summary>Gets the CSS classes for a bordered &lt;td&gt; element.</summary>
        public abstract string TableCellBordered { get; }
    }
    /// <summary>
    /// Defines the abstract structure for styling the <see cref="RzPagination{TItem}"/> component.
    /// </summary>
    public abstract class RzPaginationStylesBase
    {
        /// <summary>
        /// The theme that provides the styling context.
        /// </summary>
        protected readonly RzTheme Theme;
        /// <summary>
        /// Initializes a new instance of the <see cref="RzPaginationStylesBase"/> class with the specified theme.
        /// </summary>
        /// <param name="theme">The theme to use for styling.</param>
        protected RzPaginationStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>Gets the CSS classes for the main pagination navigation container (e.g., &lt;nav&gt;, flex properties).</summary>
        public abstract string Container { get; }
        /// <summary>Gets the CSS classes for the unordered list (&lt;ul&gt;) holding the pagination items (e.g., flex, spacing, rounding).</summary>
        public abstract string List { get; }
        /// <summary>Gets the CSS classes for individual page links/buttons (&lt;a&gt; or &lt;button&gt;) in their default state.</summary>
        public abstract string Link { get; }
        /// <summary>Gets the CSS classes for the currently active/selected page link/button.</summary>
        public abstract string LinkCurrent { get; }
        /// <summary>Gets the CSS classes for disabled page links/buttons (e.g., previous on first page, next on last page).</summary>
        public abstract string LinkDisabled { get; }
        /// <summary>Gets the CSS classes for ellipsis items (...) used when some page numbers are skipped.</summary>
        public abstract string Ellipsis { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzTabsStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzTab Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTabs" /> container.
    /// </summary>
    public abstract class RzTabsStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTabsStylesBase" /> class. </summary>
        protected RzTabsStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the main RzTabs container div (which holds Alpine.js x-data). </summary>
        public abstract string Container { get; }
        /// <summary> Gets the CSS classes for the div containing the TabPanels. </summary>
        public abstract string PanelsContainer { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTabStrip" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTabStrip" /> component.
    /// </summary>
    public abstract class RzTabStripStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTabStripStylesBase" /> class. </summary>
        protected RzTabStripStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the RzTabStrip container div (positioning, layout). </summary>
        public abstract string Strip { get; }
        /// <summary>
        ///     Gets the CSS classes for the tab marker div used for selection indication (positioning, size, transitions,
        ///     pseudo-element setup).
        /// </summary>
        public abstract string Marker { get; }
        /// <summary> Gets the CSS classes for the inner div within the marker. </summary>
        public abstract string MarkerInner { get; }
        /// <summary> Gets the grid columns CSS class based on the number of tabs. </summary>
        /// <param name="tabCount">The number of tabs.</param>
        /// <returns>A string representing a grid columns class (e.g., "grid-cols-3").</returns>
        public abstract string GetColumnsCss(int tabCount);
        /// <summary> Gets the gap CSS class based on the specified spacing size. </summary>
        /// <param name="spaceBetween">The desired gap size.</param>
        /// <returns>A string representing a gap class (e.g., "gap-2").</returns>
        public abstract string GetGapCss(Size spaceBetween);
        /// <summary> Gets the background color class for the marker's ::after pseudo-element based on the specified SemanticColor. </summary>
        /// <param name="color">The semantic color for the marker underline.</param>
        /// <returns>A string representing a background color class prefixed with 'after:' (e.g., "after:bg-primary").</returns>
        public abstract string GetMarkerAfterBackgroundCss(SemanticColor color);
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTab" /> button component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTab" /> component.
    /// </summary>
    public abstract class RzTabStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTabStylesBase" /> class. </summary>
        protected RzTabStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzTab button element (positioning, layout, size, cursor, whitespace,
        ///     rounding, typography, transitions).
        /// </summary>
        public abstract string Button { get; }
        /// <summary> Gets the justification CSS class based on the Justify enum. </summary>
        /// <param name="justify">The desired justification.</param>
        /// <returns>A string representing a justify-content class (e.g., "justify-center").</returns>
        public abstract string GetJustifyCss(Justify justify);
        /// <summary> Gets the text color CSS class for the tab in its non-selected state. </summary>
        /// <param name="color">The semantic color specified by the parent RzTabs.</param>
        /// <returns>A string representing a text color class.</returns>
        public abstract string GetTextColorCss(SemanticColor color);
        /// <summary> Gets the background color CSS class for the tab in its non-selected state. </summary>
        /// <param name="color">The semantic color specified by the parent RzTabs.</param>
        /// <returns>A string representing a background color class.</returns>
        public abstract string GetBackgroundColorCss(SemanticColor color);
        // Note: Selected text color is handled dynamically via Alpine :class binding based on RzTabs parameter
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTabPanel" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTabPanel" /> component.
    /// </summary>
    public abstract class RzTabPanelStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTabPanelStylesBase" /> class. </summary>
        protected RzTabPanelStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the base CSS classes for the outer container div of the RzTabPanel (positioning). </summary>
        public abstract string OuterContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the inner content div of the RzTabPanel (padding/background are often applied
        ///     via attributes).
        /// </summary>
        public abstract string InnerContainer { get; }
        /// <summary> Gets the text color CSS class, typically inherited from the parent RzTabs component. </summary>
        /// <param name="color">The semantic text color specified by the parent RzTabs.</param>
        /// <returns>A string representing a text color class.</returns>
        public abstract string GetTextColorCss(SemanticColor color);
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzTextEditStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzText Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTextEdit" /> component.
    /// </summary>
    public abstract class RzTextEditStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTextEditStylesBase" /> class. </summary>
        protected RzTextEditStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the CSS classes for the relative div wrapping the input and optional prepend element. </summary>
        public abstract string InputWrapper { get; }
        /// <summary>
        ///     Gets the CSS classes for the prepend element div (positioning, layout, padding, border, background,
        ///     typography).
        /// </summary>
        public abstract string PrependElement { get; }
        /// <summary> Gets the CSS classes for the Blazicon component if PrependIcon is used (text size). </summary>
        public abstract string PrependIconContainer { get; }
        /// <summary>
        ///     Gets the base CSS classes for the input element (layout, rounding, border, padding, typography, focus styles,
        ///     initial transition state).
        /// </summary>
        public abstract string Input { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTextField" /> component.
    /// </summary>
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzTextField" /> component.
    /// </summary>
    public abstract class RzTextFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTextFieldStylesBase" /> class. </summary>
        protected RzTextFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzTextField container (typically handled by
        ///     <see cref="RzFieldStylesBase" />).
        /// </summary>
        public abstract string Field { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzToggleStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region RzToggle Styles
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzToggle" /> switch component.
    /// </summary>
    public abstract class RzToggleStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzToggleStylesBase" /> class. </summary>
        protected RzToggleStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzToggle input (checkbox) element, including base appearance, ::before
        ///     pseudo-element styles, and checked state styles.
        /// </summary>
        public abstract string Toggle { get; }
    }
    /// <summary>
    ///     Defines the abstract structure for styling the <see cref="RzToggleField" /> component.
    /// </summary>
    public abstract class RzToggleFieldStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzToggleFieldStylesBase" /> class. </summary>
        protected RzToggleFieldStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary>
        ///     Gets the base CSS classes for the RzToggleField container (typically handled by
        ///     <see cref="RzFieldStylesBase" />).
        /// </summary>
        public abstract string Field { get; }
        /// <summary> Gets the CSS classes for the div containing the label and toggle switch (layout). </summary>
        public abstract string ContentWrapper { get; }
        /// <summary> Gets the CSS classes for the inner div structuring the label and toggle (layout, alignment). </summary>
        public abstract string InnerWrapper { get; }
        /// <summary> Gets the CSS classes for the <see cref="RzFieldLabel{TValue}" /> component when used within this field. </summary>
        public abstract string LabelInField { get; }
        /// <summary> Gets the CSS classes for the <see cref="RzToggle" /> component when used within this field (usually empty). </summary>
        public abstract string ToggleInField { get; }
        /// <summary> Gets the CSS classes for the Description span within the label. </summary>
        public abstract string DescriptionInLabel { get; }
    }
    #endregion
}
</file>

<file path="Styles/RzStylesBase.RzTypographyStylesBase.cs">
namespace RizzyUI;
/// <summary>
///     Abstract base class defining the structure for component style definitions.
///     Concrete themes (<see cref="RzTheme" />) will provide instances derived from these nested abstract classes,
///     allowing for customizable component styling across the application.
/// </summary>
public abstract partial class RzStylesBase
{
    #region Typography Styles (Shared by RzHeading, RzParagraph)
    /// <summary>
    ///     Defines the abstract structure for base typography styling utilities used by components like
    ///     <see cref="RzHeading" /> and <see cref="RzParagraph" />.
    /// </summary>
    public abstract class RzTypographyStylesBase
    {
        /// <summary> The theme instance providing color and sizing tokens. </summary>
        protected readonly RzTheme Theme;
        /// <summary> Initializes a new instance of the <see cref="RzTypographyStylesBase" /> class. </summary>
        protected RzTypographyStylesBase(RzTheme theme)
        {
            Theme = theme;
        }
        /// <summary> Gets the CSS class corresponding to the specified text weight. </summary>
        /// <param name="weight">The desired text weight.</param>
        /// <returns>A string like "font-bold" or "".</returns>
        public abstract string GetTextWeightCss(TextWeight? weight);
        /// <summary> Gets the CSS class corresponding to the specified text size. </summary>
        /// <param name="size">The desired text size.</param>
        /// <returns>A string like "text-lg" or "".</returns>
        public abstract string GetTextSizeCss(TextSize? size);
        /// <summary> Gets the CSS class corresponding to the specified text transformation. </summary>
        /// <param name="transform">The desired text transformation.</param>
        /// <returns>A string like "uppercase" or "".</returns>
        public abstract string GetTextTransformCss(TextTransform? transform);
        /// <summary> Gets the CSS class corresponding to the specified text decoration. </summary>
        /// <param name="decoration">The desired text decoration.</param>
        /// <returns>A string like "underline" or "".</returns>
        public abstract string GetTextDecorationCss(TextDecoration? decoration);
        /// <summary> Gets the CSS class corresponding to the specified line height (leading). </summary>
        /// <param name="leading">The desired line height.</param>
        /// <returns>A string like "leading-relaxed" or "".</returns>
        public abstract string GetLineHeightCss(Leading? leading);
        /// <summary> Combines all individual typography style classes (color, weight, size, etc.) into a single string. </summary>
        /// <param name="textColor">Optional text color.</param>
        /// <param name="weight">Optional text weight.</param>
        /// <param name="size">Optional text size.</param>
        /// <param name="lineHeight">Optional line height.</param>
        /// <param name="decoration">Optional text decoration.</param>
        /// <param name="transform">Optional text transformation.</param>
        /// <returns>A consolidated string of CSS classes.</returns>
        public abstract string GetBaseCss(SemanticColor? textColor, TextWeight? weight, TextSize? size,
            Leading? lineHeight, TextDecoration? decoration, TextTransform? transform);
    }
    #endregion
}
</file>

<file path="Utility/Serialization/Converters/CalendarPositionConverter.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
using RizzyUI;
namespace Jalex.UI.Components.Form.Converters;
/// <summary>
///     Converts a Flatpickr CalendarPosition to/from json
/// </summary>
public class CalendarPositionConverter : JsonConverter<CalendarPosition>
{
    /// <summary>
    ///     Converts string enum representation of CalendarPosition into it's enum counterpart
    /// </summary>
    /// <param name="reader"></param>
    /// <param name="typeToConvert"></param>
    /// <param name="options"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    public override CalendarPosition Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString() ?? string.Empty;
        // Convert string values back to enum values during deserialization
        return value switch
        {
            "auto" => CalendarPosition.Auto,
            "above" => CalendarPosition.Above,
            "below" => CalendarPosition.Below,
            "auto left" => CalendarPosition.AutoLeft,
            "auto center" => CalendarPosition.AutoCenter,
            "auto right" => CalendarPosition.AutoRight,
            "above left" => CalendarPosition.AboveLeft,
            "above center" => CalendarPosition.AboveCenter,
            "above right" => CalendarPosition.AboveRight,
            "below left" => CalendarPosition.BelowLeft,
            "below center" => CalendarPosition.BelowCenter,
            "below right" => CalendarPosition.BelowRight,
            _ => throw new ArgumentOutOfRangeException($"Unexpected value when parsing CalendarPosition: {value}")
        };
    }
    /// <summary>
    ///     Converts CalendarPosition enum to text
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="value"></param>
    /// <param name="options"></param>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    public override void Write(Utf8JsonWriter writer, CalendarPosition value, JsonSerializerOptions options)
    {
        // Convert enum values to specific string representations for serialization
        var stringValue = value switch
        {
            CalendarPosition.Auto => "auto",
            CalendarPosition.Above => "above",
            CalendarPosition.Below => "below",
            CalendarPosition.AutoLeft => "auto left",
            CalendarPosition.AutoCenter => "auto center",
            CalendarPosition.AutoRight => "auto right",
            CalendarPosition.AboveLeft => "above left",
            CalendarPosition.AboveCenter => "above center",
            CalendarPosition.AboveRight => "above right",
            CalendarPosition.BelowLeft => "below left",
            CalendarPosition.BelowCenter => "below center",
            CalendarPosition.BelowRight => "below right",
            _ => throw new ArgumentOutOfRangeException($"Unexpected CalendarPosition value: {value}")
        };
        writer.WriteStringValue(stringValue);
    }
}
</file>

<file path="Utility/Serialization/Converters/RawStringConverter.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
namespace RizzyUI.Utility.Serialization.Converters;
/// <summary>
///     A custom JSON converter that serializes and deserializes strings as raw values. This allows a developer to embed
///     javascript code in an object and it will serialize that value without any quotation or JSON escaping.
/// </summary>
public class RawStringConverter : JsonConverter<string>
{
    /// <summary>
    ///     Deserialization of json objects with raw values not supported
    /// </summary>
    /// <param name="reader"></param>
    /// <param name="typeToConvert"></param>
    /// <param name="options"></param>
    /// <returns></returns>
    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return string.Empty;
    }
    /// <summary>
    ///     Writes the raw value, bypassing JSON escaping and quotation marks
    /// </summary>
    /// <param name="writer"></param>
    /// <param name="value"></param>
    /// <param name="options"></param>
    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        writer.WriteRawValue(value, true);
    }
}
</file>

<file path="Utility/Serialization/Converters/SingleQuoteStringConverter.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
namespace RizzyUI.Utility.Serialization.Converters;
internal class SingleQuoteStringConverter : JsonConverter<string>
{
    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        // Reading logic (not relevant for serialization)
        return reader.GetString() ?? string.Empty;
    }
    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
    {
        // Attempt to write single-quoted string
        writer.WriteRawValue($"'{value.Replace("'", "\\'")}'", true);
    }
}
</file>

<file path="wwwroot/js/antiforgerySnippet.js">
if (!document.body.attributes.__htmx_antiforgery) {
    document.addEventListener("htmx:configRequest", evt => {
        let httpVerb = evt.detail.verb.toUpperCase();
        if (httpVerb === 'GET') return;
        let antiforgery = htmx.config.antiforgery;
        if (antiforgery) {
            // already specified on the form, short circuit
            if (evt.detail.parameters[antiforgery.formFieldName])
                return;
            if (antiforgery.headerName) {
                evt.detail.headers[antiforgery.headerName]
                    = antiforgery.requestToken;
            } else {
                evt.detail.parameters[antiforgery.formFieldName]
                    = antiforgery.requestToken;
            }
        }
    });
    document.addEventListener("htmx:afterOnLoad", evt => {
        if (evt.detail.boosted) {
            const parser = new DOMParser();
            const html = parser.parseFromString(evt.detail.xhr.responseText, 'text/html');
            const selector = 'meta[name=htmx-config]';
            const config = html.querySelector(selector);
            if (config) {
                const current = document.querySelector(selector);
                // only change the anti-forgery token
                const key = 'antiforgery';
                htmx.config[key] = JSON.parse(config.attributes['content'].value)[key];
                // update DOM, probably not necessary, but for sanity's sake
                current.replaceWith(config);
            }
        }
    });
    document.body.attributes.__htmx_antiforgery = true;
}
</file>

<file path="wwwroot/js/antiforgerySnippet.min.js">
document.body.attributes.__htmx_antiforgery||(document.addEventListener("htmx:configRequest",t=>{if(t.detail.verb.toUpperCase()==="GET")return;let e=htmx.config.antiforgery;if(e){if(t.detail.parameters[e.formFieldName])return;e.headerName?t.detail.headers[e.headerName]=e.requestToken:t.detail.parameters[e.formFieldName]=e.requestToken}}),document.addEventListener("htmx:afterOnLoad",t=>{if(t.detail.boosted){const e=new DOMParser().parseFromString(t.detail.xhr.responseText,"text/html"),a="meta[name=htmx-config]",r=e.querySelector(a);if(r){const i=document.querySelector(a),n="antiforgery";htmx.config[n]=JSON.parse(r.attributes.content.value)[n],i.replaceWith(r)}}}),document.body.attributes.__htmx_antiforgery=!0);
</file>

<file path="wwwroot/js/rizzyui-csp.es.js">
var flushPending = false;
var flushing = false;
var queue = [];
var lastFlushedIndex = -1;
function scheduler(callback) {
  queueJob(callback);
}
function queueJob(job) {
  if (!queue.includes(job))
    queue.push(job);
  queueFlush();
}
function dequeueJob(job) {
  let index = queue.indexOf(job);
  if (index !== -1 && index > lastFlushedIndex)
    queue.splice(index, 1);
}
function queueFlush() {
  if (!flushing && !flushPending) {
    flushPending = true;
    queueMicrotask(flushJobs);
  }
}
function flushJobs() {
  flushPending = false;
  flushing = true;
  for (let i2 = 0; i2 < queue.length; i2++) {
    queue[i2]();
    lastFlushedIndex = i2;
  }
  queue.length = 0;
  lastFlushedIndex = -1;
  flushing = false;
}
var reactive;
var effect;
var release;
var raw;
var shouldSchedule = true;
function disableEffectScheduling(callback) {
  shouldSchedule = false;
  callback();
  shouldSchedule = true;
}
function setReactivityEngine(engine) {
  reactive = engine.reactive;
  release = engine.release;
  effect = (callback) => engine.effect(callback, { scheduler: (task) => {
    if (shouldSchedule) {
      scheduler(task);
    } else {
      task();
    }
  } });
  raw = engine.raw;
}
function overrideEffect(override) {
  effect = override;
}
function elementBoundEffect(el) {
  let cleanup2 = () => {
  };
  let wrappedEffect = (callback) => {
    let effectReference = effect(callback);
    if (!el._x_effects) {
      el._x_effects = /* @__PURE__ */ new Set();
      el._x_runEffects = () => {
        el._x_effects.forEach((i2) => i2());
      };
    }
    el._x_effects.add(effectReference);
    cleanup2 = () => {
      if (effectReference === void 0)
        return;
      el._x_effects.delete(effectReference);
      release(effectReference);
    };
    return effectReference;
  };
  return [wrappedEffect, () => {
    cleanup2();
  }];
}
function watch(getter, callback) {
  let firstTime = true;
  let oldValue;
  let effectReference = effect(() => {
    let value = getter();
    JSON.stringify(value);
    if (!firstTime) {
      queueMicrotask(() => {
        callback(value, oldValue);
        oldValue = value;
      });
    } else {
      oldValue = value;
    }
    firstTime = false;
  });
  return () => release(effectReference);
}
var onAttributeAddeds = [];
var onElRemoveds = [];
var onElAddeds = [];
function onElAdded(callback) {
  onElAddeds.push(callback);
}
function onElRemoved(el, callback) {
  if (typeof callback === "function") {
    if (!el._x_cleanups)
      el._x_cleanups = [];
    el._x_cleanups.push(callback);
  } else {
    callback = el;
    onElRemoveds.push(callback);
  }
}
function onAttributesAdded(callback) {
  onAttributeAddeds.push(callback);
}
function onAttributeRemoved(el, name, callback) {
  if (!el._x_attributeCleanups)
    el._x_attributeCleanups = {};
  if (!el._x_attributeCleanups[name])
    el._x_attributeCleanups[name] = [];
  el._x_attributeCleanups[name].push(callback);
}
function cleanupAttributes(el, names) {
  if (!el._x_attributeCleanups)
    return;
  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
    if (names === void 0 || names.includes(name)) {
      value.forEach((i2) => i2());
      delete el._x_attributeCleanups[name];
    }
  });
}
function cleanupElement(el) {
  el._x_effects?.forEach(dequeueJob);
  while (el._x_cleanups?.length)
    el._x_cleanups.pop()();
}
var observer = new MutationObserver(onMutate);
var currentlyObserving = false;
function startObservingMutations() {
  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
  currentlyObserving = true;
}
function stopObservingMutations() {
  flushObserver();
  observer.disconnect();
  currentlyObserving = false;
}
var queuedMutations = [];
function flushObserver() {
  let records = observer.takeRecords();
  queuedMutations.push(() => records.length > 0 && onMutate(records));
  let queueLengthWhenTriggered = queuedMutations.length;
  queueMicrotask(() => {
    if (queuedMutations.length === queueLengthWhenTriggered) {
      while (queuedMutations.length > 0)
        queuedMutations.shift()();
    }
  });
}
function mutateDom(callback) {
  if (!currentlyObserving)
    return callback();
  stopObservingMutations();
  let result = callback();
  startObservingMutations();
  return result;
}
var isCollecting = false;
var deferredMutations = [];
function deferMutations() {
  isCollecting = true;
}
function flushAndStopDeferringMutations() {
  isCollecting = false;
  onMutate(deferredMutations);
  deferredMutations = [];
}
function onMutate(mutations) {
  if (isCollecting) {
    deferredMutations = deferredMutations.concat(mutations);
    return;
  }
  let addedNodes = [];
  let removedNodes = /* @__PURE__ */ new Set();
  let addedAttributes = /* @__PURE__ */ new Map();
  let removedAttributes = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < mutations.length; i2++) {
    if (mutations[i2].target._x_ignoreMutationObserver)
      continue;
    if (mutations[i2].type === "childList") {
      mutations[i2].removedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (!node._x_marker)
          return;
        removedNodes.add(node);
      });
      mutations[i2].addedNodes.forEach((node) => {
        if (node.nodeType !== 1)
          return;
        if (removedNodes.has(node)) {
          removedNodes.delete(node);
          return;
        }
        if (node._x_marker)
          return;
        addedNodes.push(node);
      });
    }
    if (mutations[i2].type === "attributes") {
      let el = mutations[i2].target;
      let name = mutations[i2].attributeName;
      let oldValue = mutations[i2].oldValue;
      let add2 = () => {
        if (!addedAttributes.has(el))
          addedAttributes.set(el, []);
        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
      };
      let remove = () => {
        if (!removedAttributes.has(el))
          removedAttributes.set(el, []);
        removedAttributes.get(el).push(name);
      };
      if (el.hasAttribute(name) && oldValue === null) {
        add2();
      } else if (el.hasAttribute(name)) {
        remove();
        add2();
      } else {
        remove();
      }
    }
  }
  removedAttributes.forEach((attrs, el) => {
    cleanupAttributes(el, attrs);
  });
  addedAttributes.forEach((attrs, el) => {
    onAttributeAddeds.forEach((i2) => i2(el, attrs));
  });
  for (let node of removedNodes) {
    if (addedNodes.some((i2) => i2.contains(node)))
      continue;
    onElRemoveds.forEach((i2) => i2(node));
  }
  for (let node of addedNodes) {
    if (!node.isConnected)
      continue;
    onElAddeds.forEach((i2) => i2(node));
  }
  addedNodes = null;
  removedNodes = null;
  addedAttributes = null;
  removedAttributes = null;
}
function scope(node) {
  return mergeProxies(closestDataStack(node));
}
function addScopeToNode(node, data2, referenceNode) {
  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
  return () => {
    node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
  };
}
function closestDataStack(node) {
  if (node._x_dataStack)
    return node._x_dataStack;
  if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
    return closestDataStack(node.host);
  }
  if (!node.parentNode) {
    return [];
  }
  return closestDataStack(node.parentNode);
}
function mergeProxies(objects) {
  return new Proxy({ objects }, mergeProxyTrap);
}
var mergeProxyTrap = {
  ownKeys({ objects }) {
    return Array.from(
      new Set(objects.flatMap((i2) => Object.keys(i2)))
    );
  },
  has({ objects }, name) {
    if (name == Symbol.unscopables)
      return false;
    return objects.some(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
    );
  },
  get({ objects }, name, thisProxy) {
    if (name == "toJSON")
      return collapseProxies;
    return Reflect.get(
      objects.find(
        (obj) => Reflect.has(obj, name)
      ) || {},
      name,
      thisProxy
    );
  },
  set({ objects }, name, value, thisProxy) {
    const target = objects.find(
      (obj) => Object.prototype.hasOwnProperty.call(obj, name)
    ) || objects[objects.length - 1];
    const descriptor = Object.getOwnPropertyDescriptor(target, name);
    if (descriptor?.set && descriptor?.get)
      return descriptor.set.call(thisProxy, value) || true;
    return Reflect.set(target, name, value);
  }
};
function collapseProxies() {
  let keys = Reflect.ownKeys(this);
  return keys.reduce((acc, key) => {
    acc[key] = Reflect.get(this, key);
    return acc;
  }, {});
}
function initInterceptors(data2) {
  let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
  let recurse = (obj, basePath = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
      if (enumerable === false || value === void 0)
        return;
      if (typeof value === "object" && value !== null && value.__v_skip)
        return;
      let path = basePath === "" ? key : `${basePath}.${key}`;
      if (typeof value === "object" && value !== null && value._x_interceptor) {
        obj[key] = value.initialize(data2, path, key);
      } else {
        if (isObject2(value) && value !== obj && !(value instanceof Element)) {
          recurse(value, path);
        }
      }
    });
  };
  return recurse(data2);
}
function interceptor(callback, mutateObj = () => {
}) {
  let obj = {
    initialValue: void 0,
    _x_interceptor: true,
    initialize(data2, path, key) {
      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
    }
  };
  mutateObj(obj);
  return (initialValue) => {
    if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
      let initialize = obj.initialize.bind(obj);
      obj.initialize = (data2, path, key) => {
        let innerValue = initialValue.initialize(data2, path, key);
        obj.initialValue = innerValue;
        return initialize(data2, path, key);
      };
    } else {
      obj.initialValue = initialValue;
    }
    return obj;
  };
}
function get(obj, path) {
  return path.split(".").reduce((carry, segment) => carry[segment], obj);
}
function set(obj, path, value) {
  if (typeof path === "string")
    path = path.split(".");
  if (path.length === 1)
    obj[path[0]] = value;
  else if (path.length === 0)
    throw error;
  else {
    if (obj[path[0]])
      return set(obj[path[0]], path.slice(1), value);
    else {
      obj[path[0]] = {};
      return set(obj[path[0]], path.slice(1), value);
    }
  }
}
var magics = {};
function magic(name, callback) {
  magics[name] = callback;
}
function injectMagics(obj, el) {
  let memoizedUtilities = getUtilities(el);
  Object.entries(magics).forEach(([name, callback]) => {
    Object.defineProperty(obj, `$${name}`, {
      get() {
        return callback(el, memoizedUtilities);
      },
      enumerable: false
    });
  });
  return obj;
}
function getUtilities(el) {
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  let utils = { interceptor, ...utilities };
  onElRemoved(el, cleanup2);
  return utils;
}
function tryCatch(el, expression, callback, ...args) {
  try {
    return callback(...args);
  } catch (e2) {
    handleError(e2, el, expression);
  }
}
function handleError(error2, el, expression = void 0) {
  error2 = Object.assign(
    error2 ?? { message: "No error message given." },
    { el, expression }
  );
  console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
  setTimeout(() => {
    throw error2;
  }, 0);
}
var shouldAutoEvaluateFunctions = true;
function dontAutoEvaluateFunctions(callback) {
  let cache = shouldAutoEvaluateFunctions;
  shouldAutoEvaluateFunctions = false;
  let result = callback();
  shouldAutoEvaluateFunctions = cache;
  return result;
}
function evaluate(el, expression, extras = {}) {
  let result;
  evaluateLater(el, expression)((value) => result = value, extras);
  return result;
}
function evaluateLater(...args) {
  return theEvaluatorFunction(...args);
}
var theEvaluatorFunction = normalEvaluator;
function setEvaluator(newEvaluator) {
  theEvaluatorFunction = newEvaluator;
}
function normalEvaluator(el, expression) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  let dataStack = [overriddenMagics, ...closestDataStack(el)];
  let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateEvaluatorFromFunction(dataStack, func) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
    runIfTypeOfFunction(receiver, result);
  };
}
var evaluatorMemo = {};
function generateFunctionFromString(expression, el) {
  if (evaluatorMemo[expression]) {
    return evaluatorMemo[expression];
  }
  let AsyncFunction = Object.getPrototypeOf(async function() {
  }).constructor;
  let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
  const safeAsyncFunction = () => {
    try {
      let func2 = new AsyncFunction(
        ["__self", "scope"],
        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
      );
      Object.defineProperty(func2, "name", {
        value: `[Alpine] ${expression}`
      });
      return func2;
    } catch (error2) {
      handleError(error2, el, expression);
      return Promise.resolve();
    }
  };
  let func = safeAsyncFunction();
  evaluatorMemo[expression] = func;
  return func;
}
function generateEvaluatorFromString(dataStack, expression, el) {
  let func = generateFunctionFromString(expression, el);
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    func.result = void 0;
    func.finished = false;
    let completeScope = mergeProxies([scope2, ...dataStack]);
    if (typeof func === "function") {
      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
      if (func.finished) {
        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
        func.result = void 0;
      } else {
        promise.then((result) => {
          runIfTypeOfFunction(receiver, result, completeScope, params, el);
        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
      }
    }
  };
}
function runIfTypeOfFunction(receiver, value, scope2, params, el) {
  if (shouldAutoEvaluateFunctions && typeof value === "function") {
    let result = value.apply(scope2, params);
    if (result instanceof Promise) {
      result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
    } else {
      receiver(result);
    }
  } else if (typeof value === "object" && value instanceof Promise) {
    value.then((i2) => receiver(i2));
  } else {
    receiver(value);
  }
}
var prefixAsString = "x-";
function prefix(subject = "") {
  return prefixAsString + subject;
}
function setPrefix(newPrefix) {
  prefixAsString = newPrefix;
}
var directiveHandlers = {};
function directive(name, callback) {
  directiveHandlers[name] = callback;
  return {
    before(directive2) {
      if (!directiveHandlers[directive2]) {
        console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
        return;
      }
      const pos = directiveOrder.indexOf(directive2);
      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
    }
  };
}
function directiveExists(name) {
  return Object.keys(directiveHandlers).includes(name);
}
function directives(el, attributes, originalAttributeOverride) {
  attributes = Array.from(attributes);
  if (el._x_virtualDirectives) {
    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(vAttributes);
    vAttributes = vAttributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    attributes = attributes.concat(vAttributes);
  }
  let transformedAttributeMap = {};
  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
  return directives2.map((directive2) => {
    return getDirectiveHandler(el, directive2);
  });
}
function attributesOnly(attributes) {
  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
}
var isDeferringHandlers = false;
var directiveHandlerStacks = /* @__PURE__ */ new Map();
var currentHandlerStackKey = Symbol();
function deferHandlingDirectives(callback) {
  isDeferringHandlers = true;
  let key = Symbol();
  currentHandlerStackKey = key;
  directiveHandlerStacks.set(key, []);
  let flushHandlers = () => {
    while (directiveHandlerStacks.get(key).length)
      directiveHandlerStacks.get(key).shift()();
    directiveHandlerStacks.delete(key);
  };
  let stopDeferring = () => {
    isDeferringHandlers = false;
    flushHandlers();
  };
  callback(flushHandlers);
  stopDeferring();
}
function getElementBoundUtilities(el) {
  let cleanups = [];
  let cleanup2 = (callback) => cleanups.push(callback);
  let [effect3, cleanupEffect] = elementBoundEffect(el);
  cleanups.push(cleanupEffect);
  let utilities = {
    Alpine: alpine_default,
    effect: effect3,
    cleanup: cleanup2,
    evaluateLater: evaluateLater.bind(evaluateLater, el),
    evaluate: evaluate.bind(evaluate, el)
  };
  let doCleanup = () => cleanups.forEach((i2) => i2());
  return [utilities, doCleanup];
}
function getDirectiveHandler(el, directive2) {
  let noop = () => {
  };
  let handler4 = directiveHandlers[directive2.type] || noop;
  let [utilities, cleanup2] = getElementBoundUtilities(el);
  onAttributeRemoved(el, directive2.original, cleanup2);
  let fullHandler = () => {
    if (el._x_ignore || el._x_ignoreSelf)
      return;
    handler4.inline && handler4.inline(el, directive2, utilities);
    handler4 = handler4.bind(handler4, el, directive2, utilities);
    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
  };
  fullHandler.runCleanups = cleanup2;
  return fullHandler;
}
var startingWith = (subject, replacement) => ({ name, value }) => {
  if (name.startsWith(subject))
    name = name.replace(subject, replacement);
  return { name, value };
};
var into = (i2) => i2;
function toTransformedAttributes(callback = () => {
}) {
  return ({ name, value }) => {
    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
      return transform(carry);
    }, { name, value });
    if (newName !== name)
      callback(newName, name);
    return { name: newName, value: newValue };
  };
}
var attributeTransformers = [];
function mapAttributes(callback) {
  attributeTransformers.push(callback);
}
function outNonAlpineAttributes({ name }) {
  return alpineAttributeRegex().test(name);
}
var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
  return ({ name, value }) => {
    let typeMatch = name.match(alpineAttributeRegex());
    let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
    let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
    let original = originalAttributeOverride || transformedAttributeMap[name] || name;
    return {
      type: typeMatch ? typeMatch[1] : null,
      value: valueMatch ? valueMatch[1] : null,
      modifiers: modifiers.map((i2) => i2.replace(".", "")),
      expression: value,
      original
    };
  };
}
var DEFAULT = "DEFAULT";
var directiveOrder = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  DEFAULT,
  "teleport"
];
function byPriority(a2, b) {
  let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
}
function dispatch(el, name, detail = {}) {
  el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      // Allows events to pass the shadow DOM barrier.
      composed: true,
      cancelable: true
    })
  );
}
function walk(el, callback) {
  if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
    Array.from(el.children).forEach((el2) => walk(el2, callback));
    return;
  }
  let skip = false;
  callback(el, () => skip = true);
  if (skip)
    return;
  let node = el.firstElementChild;
  while (node) {
    walk(node, callback);
    node = node.nextElementSibling;
  }
}
function warn(message, ...args) {
  console.warn(`Alpine Warning: ${message}`, ...args);
}
var started = false;
function start() {
  if (started)
    warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
  started = true;
  if (!document.body)
    warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
  dispatch(document, "alpine:init");
  dispatch(document, "alpine:initializing");
  startObservingMutations();
  onElAdded((el) => initTree(el, walk));
  onElRemoved((el) => destroyTree(el));
  onAttributesAdded((el, attrs) => {
    directives(el, attrs).forEach((handle) => handle());
  });
  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
  Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
    initTree(el);
  });
  dispatch(document, "alpine:initialized");
  setTimeout(() => {
    warnAboutMissingPlugins();
  });
}
var rootSelectorCallbacks = [];
var initSelectorCallbacks = [];
function rootSelectors() {
  return rootSelectorCallbacks.map((fn) => fn());
}
function allSelectors() {
  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
}
function addRootSelector(selectorCallback) {
  rootSelectorCallbacks.push(selectorCallback);
}
function addInitSelector(selectorCallback) {
  initSelectorCallbacks.push(selectorCallback);
}
function closestRoot(el, includeInitSelectors = false) {
  return findClosest(el, (element) => {
    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
    if (selectors.some((selector) => element.matches(selector)))
      return true;
  });
}
function findClosest(el, callback) {
  if (!el)
    return;
  if (callback(el))
    return el;
  if (el._x_teleportBack)
    el = el._x_teleportBack;
  if (!el.parentElement)
    return;
  return findClosest(el.parentElement, callback);
}
function isRoot(el) {
  return rootSelectors().some((selector) => el.matches(selector));
}
var initInterceptors2 = [];
function interceptInit(callback) {
  initInterceptors2.push(callback);
}
var markerDispenser = 1;
function initTree(el, walker = walk, intercept = () => {
}) {
  if (findClosest(el, (i2) => i2._x_ignore))
    return;
  deferHandlingDirectives(() => {
    walker(el, (el2, skip) => {
      if (el2._x_marker)
        return;
      intercept(el2, skip);
      initInterceptors2.forEach((i2) => i2(el2, skip));
      directives(el2, el2.attributes).forEach((handle) => handle());
      if (!el2._x_ignore)
        el2._x_marker = markerDispenser++;
      el2._x_ignore && skip();
    });
  });
}
function destroyTree(root, walker = walk) {
  walker(root, (el) => {
    cleanupElement(el);
    cleanupAttributes(el);
    delete el._x_marker;
  });
}
function warnAboutMissingPlugins() {
  let pluginDirectives = [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ];
  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
    if (directiveExists(directive2))
      return;
    selectors.some((selector) => {
      if (document.querySelector(selector)) {
        warn(`found "${selector}", but missing ${plugin2} plugin`);
        return true;
      }
    });
  });
}
var tickStack = [];
var isHolding = false;
function nextTick(callback = () => {
}) {
  queueMicrotask(() => {
    isHolding || setTimeout(() => {
      releaseNextTicks();
    });
  });
  return new Promise((res) => {
    tickStack.push(() => {
      callback();
      res();
    });
  });
}
function releaseNextTicks() {
  isHolding = false;
  while (tickStack.length)
    tickStack.shift()();
}
function holdNextTicks() {
  isHolding = true;
}
function setClasses(el, value) {
  if (Array.isArray(value)) {
    return setClassesFromString(el, value.join(" "));
  } else if (typeof value === "object" && value !== null) {
    return setClassesFromObject(el, value);
  } else if (typeof value === "function") {
    return setClasses(el, value());
  }
  return setClassesFromString(el, value);
}
function setClassesFromString(el, classString) {
  let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
  let addClassesAndReturnUndo = (classes) => {
    el.classList.add(...classes);
    return () => {
      el.classList.remove(...classes);
    };
  };
  classString = classString === true ? classString = "" : classString || "";
  return addClassesAndReturnUndo(missingClasses(classString));
}
function setClassesFromObject(el, classObject) {
  let split = (classString) => classString.split(" ").filter(Boolean);
  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
  let added = [];
  let removed = [];
  forRemove.forEach((i2) => {
    if (el.classList.contains(i2)) {
      el.classList.remove(i2);
      removed.push(i2);
    }
  });
  forAdd.forEach((i2) => {
    if (!el.classList.contains(i2)) {
      el.classList.add(i2);
      added.push(i2);
    }
  });
  return () => {
    removed.forEach((i2) => el.classList.add(i2));
    added.forEach((i2) => el.classList.remove(i2));
  };
}
function setStyles(el, value) {
  if (typeof value === "object" && value !== null) {
    return setStylesFromObject(el, value);
  }
  return setStylesFromString(el, value);
}
function setStylesFromObject(el, value) {
  let previousStyles = {};
  Object.entries(value).forEach(([key, value2]) => {
    previousStyles[key] = el.style[key];
    if (!key.startsWith("--")) {
      key = kebabCase(key);
    }
    el.style.setProperty(key, value2);
  });
  setTimeout(() => {
    if (el.style.length === 0) {
      el.removeAttribute("style");
    }
  });
  return () => {
    setStyles(el, previousStyles);
  };
}
function setStylesFromString(el, value) {
  let cache = el.getAttribute("style", value);
  el.setAttribute("style", value);
  return () => {
    el.setAttribute("style", cache || "");
  };
}
function kebabCase(subject) {
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function once(callback, fallback = () => {
}) {
  let called = false;
  return function() {
    if (!called) {
      called = true;
      callback.apply(this, arguments);
    } else {
      fallback.apply(this, arguments);
    }
  };
}
directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "function")
    expression = evaluate2(expression);
  if (expression === false)
    return;
  if (!expression || typeof expression === "boolean") {
    registerTransitionsFromHelper(el, modifiers, value);
  } else {
    registerTransitionsFromClassString(el, expression, value);
  }
});
function registerTransitionsFromClassString(el, classString, stage) {
  registerTransitionObject(el, setClasses, "");
  let directiveStorageMap = {
    "enter": (classes) => {
      el._x_transition.enter.during = classes;
    },
    "enter-start": (classes) => {
      el._x_transition.enter.start = classes;
    },
    "enter-end": (classes) => {
      el._x_transition.enter.end = classes;
    },
    "leave": (classes) => {
      el._x_transition.leave.during = classes;
    },
    "leave-start": (classes) => {
      el._x_transition.leave.start = classes;
    },
    "leave-end": (classes) => {
      el._x_transition.leave.end = classes;
    }
  };
  directiveStorageMap[stage](classString);
}
function registerTransitionsFromHelper(el, modifiers, stage) {
  registerTransitionObject(el, setStyles);
  let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
  let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
  let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
  if (modifiers.includes("in") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
  }
  if (modifiers.includes("out") && !doesntSpecify) {
    modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
  }
  let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
  let wantsOpacity = wantsAll || modifiers.includes("opacity");
  let wantsScale = wantsAll || modifiers.includes("scale");
  let opacityValue = wantsOpacity ? 0 : 1;
  let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
  let delay3 = modifierValue$1(modifiers, "delay", 0) / 1e3;
  let origin = modifierValue$1(modifiers, "origin", "center");
  let property = "opacity, transform";
  let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
  let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
  if (transitioningIn) {
    el._x_transition.enter.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationIn}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.enter.start = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
    el._x_transition.enter.end = {
      opacity: 1,
      transform: `scale(1)`
    };
  }
  if (transitioningOut) {
    el._x_transition.leave.during = {
      transformOrigin: origin,
      transitionDelay: `${delay3}s`,
      transitionProperty: property,
      transitionDuration: `${durationOut}s`,
      transitionTimingFunction: easing
    };
    el._x_transition.leave.start = {
      opacity: 1,
      transform: `scale(1)`
    };
    el._x_transition.leave.end = {
      opacity: opacityValue,
      transform: `scale(${scaleValue})`
    };
  }
}
function registerTransitionObject(el, setFunction, defaultValue = {}) {
  if (!el._x_transition)
    el._x_transition = {
      enter: { during: defaultValue, start: defaultValue, end: defaultValue },
      leave: { during: defaultValue, start: defaultValue, end: defaultValue },
      in(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.enter.during,
          start: this.enter.start,
          end: this.enter.end
        }, before, after);
      },
      out(before = () => {
      }, after = () => {
      }) {
        transition(el, setFunction, {
          during: this.leave.during,
          start: this.leave.start,
          end: this.leave.end
        }, before, after);
      }
    };
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
  const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let clickAwayCompatibleShow = () => nextTick2(show);
  if (value) {
    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
    } else {
      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
    }
    return;
  }
  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
    el._x_transition.out(() => {
    }, () => resolve(hide));
    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
  }) : Promise.resolve(hide);
  queueMicrotask(() => {
    let closest = closestHide(el);
    if (closest) {
      if (!closest._x_hideChildren)
        closest._x_hideChildren = [];
      closest._x_hideChildren.push(el);
    } else {
      nextTick2(() => {
        let hideAfterChildren = (el2) => {
          let carry = Promise.all([
            el2._x_hidePromise,
            ...(el2._x_hideChildren || []).map(hideAfterChildren)
          ]).then(([i2]) => i2?.());
          delete el2._x_hidePromise;
          delete el2._x_hideChildren;
          return carry;
        };
        hideAfterChildren(el).catch((e2) => {
          if (!e2.isFromCancelledTransition)
            throw e2;
        });
      });
    }
  });
};
function closestHide(el) {
  let parent = el.parentNode;
  if (!parent)
    return;
  return parent._x_hidePromise ? parent : closestHide(parent);
}
function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
}, after = () => {
}) {
  if (el._x_transitioning)
    el._x_transitioning.cancel();
  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
    before();
    after();
    return;
  }
  let undoStart, undoDuring, undoEnd;
  performTransition(el, {
    start() {
      undoStart = setFunction(el, start2);
    },
    during() {
      undoDuring = setFunction(el, during);
    },
    before,
    end() {
      undoStart();
      undoEnd = setFunction(el, end);
    },
    after,
    cleanup() {
      undoDuring();
      undoEnd();
    }
  });
}
function performTransition(el, stages) {
  let interrupted, reachedBefore, reachedEnd;
  let finish = once(() => {
    mutateDom(() => {
      interrupted = true;
      if (!reachedBefore)
        stages.before();
      if (!reachedEnd) {
        stages.end();
        releaseNextTicks();
      }
      stages.after();
      if (el.isConnected)
        stages.cleanup();
      delete el._x_transitioning;
    });
  });
  el._x_transitioning = {
    beforeCancels: [],
    beforeCancel(callback) {
      this.beforeCancels.push(callback);
    },
    cancel: once(function() {
      while (this.beforeCancels.length) {
        this.beforeCancels.shift()();
      }
      finish();
    }),
    finish
  };
  mutateDom(() => {
    stages.start();
    stages.during();
  });
  holdNextTicks();
  requestAnimationFrame(() => {
    if (interrupted)
      return;
    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
    let delay3 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    if (duration === 0)
      duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
    mutateDom(() => {
      stages.before();
    });
    reachedBefore = true;
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      mutateDom(() => {
        stages.end();
      });
      releaseNextTicks();
      setTimeout(el._x_transitioning.finish, duration + delay3);
      reachedEnd = true;
    });
  });
}
function modifierValue$1(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "scale") {
    if (isNaN(rawValue))
      return fallback;
  }
  if (key === "duration" || key === "delay") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "origin") {
    if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
    }
  }
  return rawValue;
}
var isCloning = false;
function skipDuringClone(callback, fallback = () => {
}) {
  return (...args) => isCloning ? fallback(...args) : callback(...args);
}
function onlyDuringClone(callback) {
  return (...args) => isCloning && callback(...args);
}
var interceptors = [];
function interceptClone(callback) {
  interceptors.push(callback);
}
function cloneNode(from, to) {
  interceptors.forEach((i2) => i2(from, to));
  isCloning = true;
  dontRegisterReactiveSideEffects(() => {
    initTree(to, (el, callback) => {
      callback(el, () => {
      });
    });
  });
  isCloning = false;
}
var isCloningLegacy = false;
function clone(oldEl, newEl) {
  if (!newEl._x_dataStack)
    newEl._x_dataStack = oldEl._x_dataStack;
  isCloning = true;
  isCloningLegacy = true;
  dontRegisterReactiveSideEffects(() => {
    cloneTree(newEl);
  });
  isCloning = false;
  isCloningLegacy = false;
}
function cloneTree(el) {
  let hasRunThroughFirstEl = false;
  let shallowWalker = (el2, callback) => {
    walk(el2, (el3, skip) => {
      if (hasRunThroughFirstEl && isRoot(el3))
        return skip();
      hasRunThroughFirstEl = true;
      callback(el3, skip);
    });
  };
  initTree(el, shallowWalker);
}
function dontRegisterReactiveSideEffects(callback) {
  let cache = effect;
  overrideEffect((callback2, el) => {
    let storedEffect = cache(callback2);
    release(storedEffect);
    return () => {
    };
  });
  callback();
  overrideEffect(cache);
}
function bind(el, name, value, modifiers = []) {
  if (!el._x_bindings)
    el._x_bindings = reactive({});
  el._x_bindings[name] = value;
  name = modifiers.includes("camel") ? camelCase(name) : name;
  switch (name) {
    case "value":
      bindInputValue(el, value);
      break;
    case "style":
      bindStyles(el, value);
      break;
    case "class":
      bindClasses(el, value);
      break;
    case "selected":
    case "checked":
      bindAttributeAndProperty(el, name, value);
      break;
    default:
      bindAttribute(el, name, value);
      break;
  }
}
function bindInputValue(el, value) {
  if (isRadio$1(el)) {
    if (el.attributes.value === void 0) {
      el.value = value;
    }
    if (window.fromModel) {
      if (typeof value === "boolean") {
        el.checked = safeParseBoolean(el.value) === value;
      } else {
        el.checked = checkedAttrLooseCompare(el.value, value);
      }
    }
  } else if (isCheckbox(el)) {
    if (Number.isInteger(value)) {
      el.value = value;
    } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
      el.value = String(value);
    } else {
      if (Array.isArray(value)) {
        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
      } else {
        el.checked = !!value;
      }
    }
  } else if (el.tagName === "SELECT") {
    updateSelect(el, value);
  } else {
    if (el.value === value)
      return;
    el.value = value === void 0 ? "" : value;
  }
}
function bindClasses(el, value) {
  if (el._x_undoAddedClasses)
    el._x_undoAddedClasses();
  el._x_undoAddedClasses = setClasses(el, value);
}
function bindStyles(el, value) {
  if (el._x_undoAddedStyles)
    el._x_undoAddedStyles();
  el._x_undoAddedStyles = setStyles(el, value);
}
function bindAttributeAndProperty(el, name, value) {
  bindAttribute(el, name, value);
  setPropertyIfChanged(el, name, value);
}
function bindAttribute(el, name, value) {
  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
    el.removeAttribute(name);
  } else {
    if (isBooleanAttr(name))
      value = name;
    setIfChanged(el, name, value);
  }
}
function setIfChanged(el, attrName, value) {
  if (el.getAttribute(attrName) != value) {
    el.setAttribute(attrName, value);
  }
}
function setPropertyIfChanged(el, propName, value) {
  if (el[propName] !== value) {
    el[propName] = value;
  }
}
function updateSelect(el, value) {
  const arrayWrappedValue = [].concat(value).map((value2) => {
    return value2 + "";
  });
  Array.from(el.options).forEach((option) => {
    option.selected = arrayWrappedValue.includes(option.value);
  });
}
function camelCase(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function checkedAttrLooseCompare(valueA, valueB) {
  return valueA == valueB;
}
function safeParseBoolean(rawValue) {
  if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
    return true;
  }
  if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
    return false;
  }
  return rawValue ? Boolean(rawValue) : null;
}
var booleanAttributes = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function isBooleanAttr(attrName) {
  return booleanAttributes.has(attrName);
}
function attributeShouldntBePreservedIfFalsy(name) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
}
function getBinding(el, name, fallback) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  return getAttributeBinding(el, name, fallback);
}
function extractProp(el, name, fallback, extract = true) {
  if (el._x_bindings && el._x_bindings[name] !== void 0)
    return el._x_bindings[name];
  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
    let binding = el._x_inlineBindings[name];
    binding.extract = extract;
    return dontAutoEvaluateFunctions(() => {
      return evaluate(el, binding.expression);
    });
  }
  return getAttributeBinding(el, name, fallback);
}
function getAttributeBinding(el, name, fallback) {
  let attr = el.getAttribute(name);
  if (attr === null)
    return typeof fallback === "function" ? fallback() : fallback;
  if (attr === "")
    return true;
  if (isBooleanAttr(name)) {
    return !![name, "true"].includes(attr);
  }
  return attr;
}
function isCheckbox(el) {
  return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
}
function isRadio$1(el) {
  return el.type === "radio" || el.localName === "ui-radio";
}
function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
function throttle(func, limit) {
  let inThrottle;
  return function() {
    let context = this, args = arguments;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
  let firstRun = true;
  let outerHash;
  let reference = effect(() => {
    let outer = outerGet();
    let inner = innerGet();
    if (firstRun) {
      innerSet(cloneIfObject(outer));
      firstRun = false;
    } else {
      let outerHashLatest = JSON.stringify(outer);
      let innerHashLatest = JSON.stringify(inner);
      if (outerHashLatest !== outerHash) {
        innerSet(cloneIfObject(outer));
      } else if (outerHashLatest !== innerHashLatest) {
        outerSet(cloneIfObject(inner));
      } else ;
    }
    outerHash = JSON.stringify(outerGet());
    JSON.stringify(innerGet());
  });
  return () => {
    release(reference);
  };
}
function cloneIfObject(value) {
  return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
}
function plugin(callback) {
  let callbacks = Array.isArray(callback) ? callback : [callback];
  callbacks.forEach((i2) => i2(alpine_default));
}
var stores = {};
var isReactive = false;
function store(name, value) {
  if (!isReactive) {
    stores = reactive(stores);
    isReactive = true;
  }
  if (value === void 0) {
    return stores[name];
  }
  stores[name] = value;
  initInterceptors(stores[name]);
  if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
    stores[name].init();
  }
}
function getStores() {
  return stores;
}
var binds = {};
function bind2(name, bindings) {
  let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
  if (name instanceof Element) {
    return applyBindingsObject(name, getBindings());
  } else {
    binds[name] = getBindings;
  }
  return () => {
  };
}
function injectBindingProviders(obj) {
  Object.entries(binds).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback(...args);
        };
      }
    });
  });
  return obj;
}
function applyBindingsObject(el, obj, original) {
  let cleanupRunners = [];
  while (cleanupRunners.length)
    cleanupRunners.pop()();
  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
  let staticAttributes = attributesOnly(attributes);
  attributes = attributes.map((attribute) => {
    if (staticAttributes.find((attr) => attr.name === attribute.name)) {
      return {
        name: `x-bind:${attribute.name}`,
        value: `"${attribute.value}"`
      };
    }
    return attribute;
  });
  directives(el, attributes, original).map((handle) => {
    cleanupRunners.push(handle.runCleanups);
    handle();
  });
  return () => {
    while (cleanupRunners.length)
      cleanupRunners.pop()();
  };
}
var datas = {};
function data(name, callback) {
  datas[name] = callback;
}
function injectDataProviders(obj, context) {
  Object.entries(datas).forEach(([name, callback]) => {
    Object.defineProperty(obj, name, {
      get() {
        return (...args) => {
          return callback.bind(context)(...args);
        };
      },
      enumerable: false
    });
  });
  return obj;
}
var Alpine$1 = {
  get reactive() {
    return reactive;
  },
  get release() {
    return release;
  },
  get effect() {
    return effect;
  },
  get raw() {
    return raw;
  },
  version: "3.14.9",
  flushAndStopDeferringMutations,
  dontAutoEvaluateFunctions,
  disableEffectScheduling,
  startObservingMutations,
  stopObservingMutations,
  setReactivityEngine,
  onAttributeRemoved,
  onAttributesAdded,
  closestDataStack,
  skipDuringClone,
  onlyDuringClone,
  addRootSelector,
  addInitSelector,
  interceptClone,
  addScopeToNode,
  deferMutations,
  mapAttributes,
  evaluateLater,
  interceptInit,
  setEvaluator,
  mergeProxies,
  extractProp,
  findClosest,
  onElRemoved,
  closestRoot,
  destroyTree,
  interceptor,
  // INTERNAL: not public API and is subject to change without major release.
  transition,
  // INTERNAL
  setStyles,
  // INTERNAL
  mutateDom,
  directive,
  entangle,
  throttle,
  debounce,
  evaluate,
  initTree,
  nextTick,
  prefixed: prefix,
  prefix: setPrefix,
  plugin,
  magic,
  store,
  start,
  clone,
  // INTERNAL
  cloneNode,
  // INTERNAL
  bound: getBinding,
  $data: scope,
  watch,
  walk,
  data,
  bind: bind2
};
var alpine_default = Alpine$1;
function cspEvaluator(el, expression) {
  let dataStack = generateDataStack(el);
  if (typeof expression === "function") {
    return generateEvaluatorFromFunction(dataStack, expression);
  }
  let evaluator = generateEvaluator(el, expression, dataStack);
  return tryCatch.bind(null, el, expression, evaluator);
}
function generateDataStack(el) {
  let overriddenMagics = {};
  injectMagics(overriddenMagics, el);
  return [overriddenMagics, ...closestDataStack(el)];
}
function generateEvaluator(el, expression, dataStack) {
  return (receiver = () => {
  }, { scope: scope2 = {}, params = [] } = {}) => {
    let completeScope = mergeProxies([scope2, ...dataStack]);
    let evaluatedExpression = expression.split(".").reduce(
      (currentScope, currentExpression) => {
        if (currentScope[currentExpression] === void 0) {
          throwExpressionError(el, expression);
        }
        return currentScope[currentExpression];
      },
      completeScope
    );
    runIfTypeOfFunction(receiver, evaluatedExpression, completeScope, params);
  };
}
function throwExpressionError(el, expression) {
  console.warn(
    `Alpine Error: Alpine is unable to interpret the following expression using the CSP-friendly build:
"${expression}"
Read more about the Alpine's CSP-friendly build restrictions here: https://alpinejs.dev/advanced/csp
`,
    el
  );
}
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return (val) => !!map[val];
}
var EMPTY_OBJ = Object.freeze({});
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty.call(val, key);
var isArray = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
var targetMap = /* @__PURE__ */ new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol("iterate");
var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
function isEffect(fn) {
  return fn && fn._isEffect === true;
}
function effect2(fn, options = EMPTY_OBJ) {
  if (isEffect(fn)) {
    fn = fn.raw;
  }
  const effect3 = createReactiveEffect(fn, options);
  if (!options.lazy) {
    effect3();
  }
  return effect3;
}
function stop(effect3) {
  if (effect3.active) {
    cleanup(effect3);
    if (effect3.options.onStop) {
      effect3.options.onStop();
    }
    effect3.active = false;
  }
}
var uid = 0;
function createReactiveEffect(fn, options) {
  const effect3 = function reactiveEffect() {
    if (!effect3.active) {
      return fn();
    }
    if (!effectStack.includes(effect3)) {
      cleanup(effect3);
      try {
        enableTracking();
        effectStack.push(effect3);
        activeEffect = effect3;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };
  effect3.id = uid++;
  effect3.allowRecurse = !!options.allowRecurse;
  effect3._isEffect = true;
  effect3.active = true;
  effect3.raw = fn;
  effect3.deps = [];
  effect3.options = options;
  return effect3;
}
function cleanup(effect3) {
  const { deps } = effect3;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect3);
    }
    deps.length = 0;
  }
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (!shouldTrack || activeEffect === void 0) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
  }
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, dep = /* @__PURE__ */ new Set());
  }
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      });
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  const effects = /* @__PURE__ */ new Set();
  const add2 = (effectsToAdd) => {
    if (effectsToAdd) {
      effectsToAdd.forEach((effect3) => {
        if (effect3 !== activeEffect || effect3.allowRecurse) {
          effects.add(effect3);
        }
      });
    }
  };
  if (type === "clear") {
    depsMap.forEach(add2);
  } else if (key === "length" && isArray(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        add2(dep);
      }
    });
  } else {
    if (key !== void 0) {
      add2(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          add2(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          add2(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            add2(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          add2(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const run = (effect3) => {
    if (effect3.options.onTrigger) {
      effect3.options.onTrigger({
        effect: effect3,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      });
    }
    if (effect3.options.scheduler) {
      effect3.options.scheduler(effect3);
    } else {
      effect3();
    }
  };
  effects.forEach(run);
}
var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
var get2 = /* @__PURE__ */ createGetter();
var readonlyGet = /* @__PURE__ */ createGetter(true);
var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject(res)) {
      return isReadonly ? readonly(res) : reactive2(res);
    }
    return res;
  };
}
var set2 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
var mutableHandlers = {
  get: get2,
  set: set2,
  deleteProperty,
  has,
  ownKeys: ownKeys$1
};
var readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
var toReactive = (value) => isObject(value) ? reactive2(value) : value;
var toReadonly = (value) => isObject(value) ? readonly(value) : value;
var toShallow = (value) => value;
var getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly = false, isShallow = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get", key);
  }
  !isReadonly && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly = false) {
  const target = this[
    "__v_raw"
    /* RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has", key);
  }
  !isReadonly && track(rawTarget, "has", rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
  target = target[
    "__v_raw"
    /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly, isShallow) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done: done2 } = innerIterator.next();
        return done2 ? { value, done: done2 } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done2
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
  const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly;
    } else if (key === "__v_isReadonly") {
      return isReadonly;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
var mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false)
};
var readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive2(target) {
  if (target && target[
    "__v_isReadonly"
    /* IS_READONLY */
  ]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* RAW */
  ] && !(isReadonly && target[
    "__v_isReactive"
    /* IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function toRaw(observed) {
  return observed && toRaw(observed[
    "__v_raw"
    /* RAW */
  ]) || observed;
}
function isRef(r2) {
  return Boolean(r2 && r2.__v_isRef === true);
}
magic("nextTick", () => nextTick);
magic("dispatch", (el) => dispatch.bind(dispatch, el));
magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
  let evaluate2 = evaluateLater2(key);
  let getter = () => {
    let value;
    evaluate2((i2) => value = i2);
    return value;
  };
  let unwatch = watch(getter, callback);
  cleanup2(unwatch);
});
magic("store", getStores);
magic("data", (el) => scope(el));
magic("root", (el) => closestRoot(el));
magic("refs", (el) => {
  if (el._x_refs_proxy)
    return el._x_refs_proxy;
  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
  return el._x_refs_proxy;
});
function getArrayOfRefObject(el) {
  let refObjects = [];
  findClosest(el, (i2) => {
    if (i2._x_refs)
      refObjects.push(i2._x_refs);
  });
  return refObjects;
}
var globalIdMemo = {};
function findAndIncrementId(name) {
  if (!globalIdMemo[name])
    globalIdMemo[name] = 0;
  return ++globalIdMemo[name];
}
function closestIdRoot(el, name) {
  return findClosest(el, (element) => {
    if (element._x_ids && element._x_ids[name])
      return true;
  });
}
function setIdRoot(el, name) {
  if (!el._x_ids)
    el._x_ids = {};
  if (!el._x_ids[name])
    el._x_ids[name] = findAndIncrementId(name);
}
magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
  let cacheKey = `${name}${key ? `-${key}` : ""}`;
  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
    let root = closestIdRoot(el, name);
    let id = root ? root._x_ids[name] : findAndIncrementId(name);
    return key ? `${name}-${id}-${key}` : `${name}-${id}`;
  });
});
interceptClone((from, to) => {
  if (from._x_id) {
    to._x_id = from._x_id;
  }
});
function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
  if (!el._x_id)
    el._x_id = {};
  if (el._x_id[cacheKey])
    return el._x_id[cacheKey];
  let output = callback();
  el._x_id[cacheKey] = output;
  cleanup2(() => {
    delete el._x_id[cacheKey];
  });
  return output;
}
magic("el", (el) => el);
warnMissingPluginMagic("Focus", "focus", "focus");
warnMissingPluginMagic("Persist", "persist", "persist");
function warnMissingPluginMagic(name, magicName, slug) {
  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
  let func = evaluateLater2(expression);
  let innerGet = () => {
    let result;
    func((i2) => result = i2);
    return result;
  };
  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
  let innerSet = (val) => evaluateInnerSet(() => {
  }, { scope: { "__placeholder": val } });
  let initialValue = innerGet();
  innerSet(initialValue);
  queueMicrotask(() => {
    if (!el._x_model)
      return;
    el._x_removeModelListeners["default"]();
    let outerGet = el._x_model.get;
    let outerSet = el._x_model.set;
    let releaseEntanglement = entangle(
      {
        get() {
          return outerGet();
        },
        set(value) {
          outerSet(value);
        }
      },
      {
        get() {
          return innerGet();
        },
        set(value) {
          innerSet(value);
        }
      }
    );
    cleanup2(releaseEntanglement);
  });
});
directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-teleport can only be used on a <template> tag", el);
  let target = getTarget(expression);
  let clone2 = el.content.cloneNode(true).firstElementChild;
  el._x_teleport = clone2;
  clone2._x_teleportBack = el;
  el.setAttribute("data-teleport-template", true);
  clone2.setAttribute("data-teleport-target", true);
  if (el._x_forwardEvents) {
    el._x_forwardEvents.forEach((eventName) => {
      clone2.addEventListener(eventName, (e2) => {
        e2.stopPropagation();
        el.dispatchEvent(new e2.constructor(e2.type, e2));
      });
    });
  }
  addScopeToNode(clone2, {}, el);
  let placeInDom = (clone3, target2, modifiers2) => {
    if (modifiers2.includes("prepend")) {
      target2.parentNode.insertBefore(clone3, target2);
    } else if (modifiers2.includes("append")) {
      target2.parentNode.insertBefore(clone3, target2.nextSibling);
    } else {
      target2.appendChild(clone3);
    }
  };
  mutateDom(() => {
    placeInDom(clone2, target, modifiers);
    skipDuringClone(() => {
      initTree(clone2);
    })();
  });
  el._x_teleportPutBack = () => {
    let target2 = getTarget(expression);
    mutateDom(() => {
      placeInDom(el._x_teleport, target2, modifiers);
    });
  };
  cleanup2(
    () => mutateDom(() => {
      clone2.remove();
      destroyTree(clone2);
    })
  );
});
var teleportContainerDuringClone = document.createElement("div");
function getTarget(expression) {
  let target = skipDuringClone(() => {
    return document.querySelector(expression);
  }, () => {
    return teleportContainerDuringClone;
  })();
  if (!target)
    warn(`Cannot find x-teleport element for selector: "${expression}"`);
  return target;
}
var handler = () => {
};
handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
  modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
  cleanup2(() => {
    modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
  });
};
directive("ignore", handler);
directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
  effect3(evaluateLater(el, expression));
}));
function on(el, event, modifiers, callback) {
  let listenerTarget = el;
  let handler4 = (e2) => callback(e2);
  let options = {};
  let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
  if (modifiers.includes("dot"))
    event = dotSyntax(event);
  if (modifiers.includes("camel"))
    event = camelCase2(event);
  if (modifiers.includes("passive"))
    options.passive = true;
  if (modifiers.includes("capture"))
    options.capture = true;
  if (modifiers.includes("window"))
    listenerTarget = window;
  if (modifiers.includes("document"))
    listenerTarget = document;
  if (modifiers.includes("debounce")) {
    let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = debounce(handler4, wait);
  }
  if (modifiers.includes("throttle")) {
    let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
    let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
    handler4 = throttle(handler4, wait);
  }
  if (modifiers.includes("prevent"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.preventDefault();
      next(e2);
    });
  if (modifiers.includes("stop"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.stopPropagation();
      next(e2);
    });
  if (modifiers.includes("once")) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      next(e2);
      listenerTarget.removeEventListener(event, handler4, options);
    });
  }
  if (modifiers.includes("away") || modifiers.includes("outside")) {
    listenerTarget = document;
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (el.contains(e2.target))
        return;
      if (e2.target.isConnected === false)
        return;
      if (el.offsetWidth < 1 && el.offsetHeight < 1)
        return;
      if (el._x_isShown === false)
        return;
      next(e2);
    });
  }
  if (modifiers.includes("self"))
    handler4 = wrapHandler(handler4, (next, e2) => {
      e2.target === el && next(e2);
    });
  if (isKeyEvent(event) || isClickEvent(event)) {
    handler4 = wrapHandler(handler4, (next, e2) => {
      if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
        return;
      }
      next(e2);
    });
  }
  listenerTarget.addEventListener(event, handler4, options);
  return () => {
    listenerTarget.removeEventListener(event, handler4, options);
  };
}
function dotSyntax(subject) {
  return subject.replace(/-/g, ".");
}
function camelCase2(subject) {
  return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
}
function isNumeric(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function kebabCase2(subject) {
  if ([" ", "_"].includes(
    subject
  ))
    return subject;
  return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function isKeyEvent(event) {
  return ["keydown", "keyup"].includes(event);
}
function isClickEvent(event) {
  return ["contextmenu", "click", "mouse"].some((i2) => event.includes(i2));
}
function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
  let keyModifiers = modifiers.filter((i2) => {
    return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(i2);
  });
  if (keyModifiers.includes("debounce")) {
    let debounceIndex = keyModifiers.indexOf("debounce");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.includes("throttle")) {
    let debounceIndex = keyModifiers.indexOf("throttle");
    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (keyModifiers.length === 0)
    return false;
  if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
    return false;
  const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
  keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
  if (selectedSystemKeyModifiers.length > 0) {
    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
      if (modifier === "cmd" || modifier === "super")
        modifier = "meta";
      return e2[`${modifier}Key`];
    });
    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
      if (isClickEvent(e2.type))
        return false;
      if (keyToModifiers(e2.key).includes(keyModifiers[0]))
        return false;
    }
  }
  return true;
}
function keyToModifiers(key) {
  if (!key)
    return [];
  key = kebabCase2(key);
  let modifierToKeyMap = {
    "ctrl": "control",
    "slash": "/",
    "space": " ",
    "spacebar": " ",
    "cmd": "meta",
    "esc": "escape",
    "up": "arrow-up",
    "down": "arrow-down",
    "left": "arrow-left",
    "right": "arrow-right",
    "period": ".",
    "comma": ",",
    "equal": "=",
    "minus": "-",
    "underscore": "_"
  };
  modifierToKeyMap[key] = key;
  return Object.keys(modifierToKeyMap).map((modifier) => {
    if (modifierToKeyMap[modifier] === key)
      return modifier;
  }).filter((modifier) => modifier);
}
directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let scopeTarget = el;
  if (modifiers.includes("parent")) {
    scopeTarget = el.parentNode;
  }
  let evaluateGet = evaluateLater(scopeTarget, expression);
  let evaluateSet;
  if (typeof expression === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
  } else if (typeof expression === "function" && typeof expression() === "string") {
    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
  } else {
    evaluateSet = () => {
    };
  }
  let getValue = () => {
    let result;
    evaluateGet((value) => result = value);
    return isGetterSetter(result) ? result.get() : result;
  };
  let setValue = (value) => {
    let result;
    evaluateGet((value2) => result = value2);
    if (isGetterSetter(result)) {
      result.set(value);
    } else {
      evaluateSet(() => {
      }, {
        scope: { "__placeholder": value }
      });
    }
  };
  if (typeof expression === "string" && el.type === "radio") {
    mutateDom(() => {
      if (!el.hasAttribute("name"))
        el.setAttribute("name", expression);
    });
  }
  var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
  let removeListener = isCloning ? () => {
  } : on(el, event, modifiers, (e2) => {
    setValue(getInputValue(el, modifiers, e2, getValue()));
  });
  if (modifiers.includes("fill")) {
    if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
      setValue(
        getInputValue(el, modifiers, { target: el }, getValue())
      );
    }
  }
  if (!el._x_removeModelListeners)
    el._x_removeModelListeners = {};
  el._x_removeModelListeners["default"] = removeListener;
  cleanup2(() => el._x_removeModelListeners["default"]());
  if (el.form) {
    let removeResetListener = on(el.form, "reset", [], (e2) => {
      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
    });
    cleanup2(() => removeResetListener());
  }
  el._x_model = {
    get() {
      return getValue();
    },
    set(value) {
      setValue(value);
    }
  };
  el._x_forceModelUpdate = (value) => {
    if (value === void 0 && typeof expression === "string" && expression.match(/\./))
      value = "";
    window.fromModel = true;
    mutateDom(() => bind(el, "value", value));
    delete window.fromModel;
  };
  effect3(() => {
    let value = getValue();
    if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
      return;
    el._x_forceModelUpdate(value);
  });
});
function getInputValue(el, modifiers, event, currentValue) {
  return mutateDom(() => {
    if (event instanceof CustomEvent && event.detail !== void 0)
      return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
    else if (isCheckbox(el)) {
      if (Array.isArray(currentValue)) {
        let newValue = null;
        if (modifiers.includes("number")) {
          newValue = safeParseNumber(event.target.value);
        } else if (modifiers.includes("boolean")) {
          newValue = safeParseBoolean(event.target.value);
        } else {
          newValue = event.target.value;
        }
        return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
      } else {
        return event.target.checked;
      }
    } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
      if (modifiers.includes("number")) {
        return Array.from(event.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseNumber(rawValue);
        });
      } else if (modifiers.includes("boolean")) {
        return Array.from(event.target.selectedOptions).map((option) => {
          let rawValue = option.value || option.text;
          return safeParseBoolean(rawValue);
        });
      }
      return Array.from(event.target.selectedOptions).map((option) => {
        return option.value || option.text;
      });
    } else {
      let newValue;
      if (isRadio$1(el)) {
        if (event.target.checked) {
          newValue = event.target.value;
        } else {
          newValue = currentValue;
        }
      } else {
        newValue = event.target.value;
      }
      if (modifiers.includes("number")) {
        return safeParseNumber(newValue);
      } else if (modifiers.includes("boolean")) {
        return safeParseBoolean(newValue);
      } else if (modifiers.includes("trim")) {
        return newValue.trim();
      } else {
        return newValue;
      }
    }
  });
}
function safeParseNumber(rawValue) {
  let number = rawValue ? parseFloat(rawValue) : null;
  return isNumeric2(number) ? number : rawValue;
}
function checkedAttrLooseCompare2(valueA, valueB) {
  return valueA == valueB;
}
function isNumeric2(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function isGetterSetter(value) {
  return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
}
directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
addInitSelector(() => `[${prefix("init")}]`);
directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
  if (typeof expression === "string") {
    return !!expression.trim() && evaluate2(expression, {}, false);
  }
  return evaluate2(expression, {}, false);
}));
directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.textContent = value;
      });
    });
  });
});
directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
  let evaluate2 = evaluateLater2(expression);
  effect3(() => {
    evaluate2((value) => {
      mutateDom(() => {
        el.innerHTML = value;
        el._x_ignoreSelf = true;
        initTree(el);
        delete el._x_ignoreSelf;
      });
    });
  });
});
mapAttributes(startingWith(":", into(prefix("bind:"))));
var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
  if (!value) {
    let bindingProviders = {};
    injectBindingProviders(bindingProviders);
    let getBindings = evaluateLater(el, expression);
    getBindings((bindings) => {
      applyBindingsObject(el, bindings, original);
    }, { scope: bindingProviders });
    return;
  }
  if (value === "key")
    return storeKeyForXFor(el, expression);
  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
    return;
  }
  let evaluate2 = evaluateLater(el, expression);
  effect3(() => evaluate2((result) => {
    if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
      result = "";
    }
    mutateDom(() => bind(el, value, result, modifiers));
  }));
  cleanup2(() => {
    el._x_undoAddedClasses && el._x_undoAddedClasses();
    el._x_undoAddedStyles && el._x_undoAddedStyles();
  });
};
handler2.inline = (el, { value, modifiers, expression }) => {
  if (!value)
    return;
  if (!el._x_inlineBindings)
    el._x_inlineBindings = {};
  el._x_inlineBindings[value] = { expression, extract: false };
};
directive("bind", handler2);
function storeKeyForXFor(el, expression) {
  el._x_keyExpression = expression;
}
addRootSelector(() => `[${prefix("data")}]`);
directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
  if (shouldSkipRegisteringDataDuringClone(el))
    return;
  expression = expression === "" ? "{}" : expression;
  let magicContext = {};
  injectMagics(magicContext, el);
  let dataProviderContext = {};
  injectDataProviders(dataProviderContext, magicContext);
  let data2 = evaluate(el, expression, { scope: dataProviderContext });
  if (data2 === void 0 || data2 === true)
    data2 = {};
  injectMagics(data2, el);
  let reactiveData = reactive(data2);
  initInterceptors(reactiveData);
  let undo = addScopeToNode(el, reactiveData);
  reactiveData["init"] && evaluate(el, reactiveData["init"]);
  cleanup2(() => {
    reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
    undo();
  });
});
interceptClone((from, to) => {
  if (from._x_dataStack) {
    to._x_dataStack = from._x_dataStack;
    to.setAttribute("data-has-alpine-state", true);
  }
});
function shouldSkipRegisteringDataDuringClone(el) {
  if (!isCloning)
    return false;
  if (isCloningLegacy)
    return true;
  return el.hasAttribute("data-has-alpine-state");
}
directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
  let evaluate2 = evaluateLater(el, expression);
  if (!el._x_doHide)
    el._x_doHide = () => {
      mutateDom(() => {
        el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
      });
    };
  if (!el._x_doShow)
    el._x_doShow = () => {
      mutateDom(() => {
        if (el.style.length === 1 && el.style.display === "none") {
          el.removeAttribute("style");
        } else {
          el.style.removeProperty("display");
        }
      });
    };
  let hide = () => {
    el._x_doHide();
    el._x_isShown = false;
  };
  let show = () => {
    el._x_doShow();
    el._x_isShown = true;
  };
  let clickAwayCompatibleShow = () => setTimeout(show);
  let toggle = once(
    (value) => value ? show() : hide(),
    (value) => {
      if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
      } else {
        value ? clickAwayCompatibleShow() : hide();
      }
    }
  );
  let oldValue;
  let firstTime = true;
  effect3(() => evaluate2((value) => {
    if (!firstTime && value === oldValue)
      return;
    if (modifiers.includes("immediate"))
      value ? clickAwayCompatibleShow() : hide();
    toggle(value);
    oldValue = value;
    firstTime = false;
  }));
});
directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  let iteratorNames = parseForExpression(expression);
  let evaluateItems = evaluateLater(el, iteratorNames.items);
  let evaluateKey = evaluateLater(
    el,
    // the x-bind:key expression is stored for our use instead of evaluated.
    el._x_keyExpression || "index"
  );
  el._x_prevKeys = [];
  el._x_lookup = {};
  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
  cleanup2(() => {
    Object.values(el._x_lookup).forEach((el2) => mutateDom(
      () => {
        destroyTree(el2);
        el2.remove();
      }
    ));
    delete el._x_prevKeys;
    delete el._x_lookup;
  });
});
function loop(el, iteratorNames, evaluateItems, evaluateKey) {
  let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
  let templateEl = el;
  evaluateItems((items) => {
    if (isNumeric3(items) && items >= 0) {
      items = Array.from(Array(items).keys(), (i2) => i2 + 1);
    }
    if (items === void 0)
      items = [];
    let lookup = el._x_lookup;
    let prevKeys = el._x_prevKeys;
    let scopes = [];
    let keys = [];
    if (isObject2(items)) {
      items = Object.entries(items).map(([key, value]) => {
        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
        evaluateKey((value2) => {
          if (keys.includes(value2))
            warn("Duplicate key on x-for", el);
          keys.push(value2);
        }, { scope: { index: key, ...scope2 } });
        scopes.push(scope2);
      });
    } else {
      for (let i2 = 0; i2 < items.length; i2++) {
        let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
        evaluateKey((value) => {
          if (keys.includes(value))
            warn("Duplicate key on x-for", el);
          keys.push(value);
        }, { scope: { index: i2, ...scope2 } });
        scopes.push(scope2);
      }
    }
    let adds = [];
    let moves = [];
    let removes = [];
    let sames = [];
    for (let i2 = 0; i2 < prevKeys.length; i2++) {
      let key = prevKeys[i2];
      if (keys.indexOf(key) === -1)
        removes.push(key);
    }
    prevKeys = prevKeys.filter((key) => !removes.includes(key));
    let lastKey = "template";
    for (let i2 = 0; i2 < keys.length; i2++) {
      let key = keys[i2];
      let prevIndex = prevKeys.indexOf(key);
      if (prevIndex === -1) {
        prevKeys.splice(i2, 0, key);
        adds.push([lastKey, i2]);
      } else if (prevIndex !== i2) {
        let keyInSpot = prevKeys.splice(i2, 1)[0];
        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
        prevKeys.splice(i2, 0, keyForSpot);
        prevKeys.splice(prevIndex, 0, keyInSpot);
        moves.push([keyInSpot, keyForSpot]);
      } else {
        sames.push(key);
      }
      lastKey = key;
    }
    for (let i2 = 0; i2 < removes.length; i2++) {
      let key = removes[i2];
      if (!(key in lookup))
        continue;
      mutateDom(() => {
        destroyTree(lookup[key]);
        lookup[key].remove();
      });
      delete lookup[key];
    }
    for (let i2 = 0; i2 < moves.length; i2++) {
      let [keyInSpot, keyForSpot] = moves[i2];
      let elInSpot = lookup[keyInSpot];
      let elForSpot = lookup[keyForSpot];
      let marker = document.createElement("div");
      mutateDom(() => {
        if (!elForSpot)
          warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
        elForSpot.after(marker);
        elInSpot.after(elForSpot);
        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
        marker.before(elInSpot);
        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
        marker.remove();
      });
      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
    }
    for (let i2 = 0; i2 < adds.length; i2++) {
      let [lastKey2, index] = adds[i2];
      let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
      if (lastEl._x_currentIfEl)
        lastEl = lastEl._x_currentIfEl;
      let scope2 = scopes[index];
      let key = keys[index];
      let clone2 = document.importNode(templateEl.content, true).firstElementChild;
      let reactiveScope = reactive(scope2);
      addScopeToNode(clone2, reactiveScope, templateEl);
      clone2._x_refreshXForScope = (newScope) => {
        Object.entries(newScope).forEach(([key2, value]) => {
          reactiveScope[key2] = value;
        });
      };
      mutateDom(() => {
        lastEl.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      if (typeof key === "object") {
        warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
      }
      lookup[key] = clone2;
    }
    for (let i2 = 0; i2 < sames.length; i2++) {
      lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
    }
    templateEl._x_prevKeys = keys;
  });
}
function parseForExpression(expression) {
  let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  let stripParensRE = /^\s*\(|\)\s*$/g;
  let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  let inMatch = expression.match(forAliasRE);
  if (!inMatch)
    return;
  let res = {};
  res.items = inMatch[2].trim();
  let item = inMatch[1].replace(stripParensRE, "").trim();
  let iteratorMatch = item.match(forIteratorRE);
  if (iteratorMatch) {
    res.item = item.replace(forIteratorRE, "").trim();
    res.index = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.collection = iteratorMatch[2].trim();
    }
  } else {
    res.item = item;
  }
  return res;
}
function getIterationScopeVariables(iteratorNames, item, index, items) {
  let scopeVariables = {};
  if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
    let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
    names.forEach((name, i2) => {
      scopeVariables[name] = item[i2];
    });
  } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
    let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
    names.forEach((name) => {
      scopeVariables[name] = item[name];
    });
  } else {
    scopeVariables[iteratorNames.item] = item;
  }
  if (iteratorNames.index)
    scopeVariables[iteratorNames.index] = index;
  if (iteratorNames.collection)
    scopeVariables[iteratorNames.collection] = items;
  return scopeVariables;
}
function isNumeric3(subject) {
  return !Array.isArray(subject) && !isNaN(subject);
}
function handler3() {
}
handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
  let root = closestRoot(el);
  if (!root._x_refs)
    root._x_refs = {};
  root._x_refs[expression] = el;
  cleanup2(() => delete root._x_refs[expression]);
};
directive("ref", handler3);
directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
  if (el.tagName.toLowerCase() !== "template")
    warn("x-if can only be used on a <template> tag", el);
  let evaluate2 = evaluateLater(el, expression);
  let show = () => {
    if (el._x_currentIfEl)
      return el._x_currentIfEl;
    let clone2 = el.content.cloneNode(true).firstElementChild;
    addScopeToNode(clone2, {}, el);
    mutateDom(() => {
      el.after(clone2);
      skipDuringClone(() => initTree(clone2))();
    });
    el._x_currentIfEl = clone2;
    el._x_undoIf = () => {
      mutateDom(() => {
        destroyTree(clone2);
        clone2.remove();
      });
      delete el._x_currentIfEl;
    };
    return clone2;
  };
  let hide = () => {
    if (!el._x_undoIf)
      return;
    el._x_undoIf();
    delete el._x_undoIf;
  };
  effect3(() => evaluate2((value) => {
    value ? show() : hide();
  }));
  cleanup2(() => el._x_undoIf && el._x_undoIf());
});
directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
  let names = evaluate2(expression);
  names.forEach((name) => setIdRoot(el, name));
});
interceptClone((from, to) => {
  if (from._x_ids) {
    to._x_ids = from._x_ids;
  }
});
mapAttributes(startingWith("@", into(prefix("on:"))));
directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
  let evaluate2 = expression ? evaluateLater(el, expression) : () => {
  };
  if (el.tagName.toLowerCase() === "template") {
    if (!el._x_forwardEvents)
      el._x_forwardEvents = [];
    if (!el._x_forwardEvents.includes(value))
      el._x_forwardEvents.push(value);
  }
  let removeListener = on(el, value, modifiers, (e2) => {
    evaluate2(() => {
    }, { scope: { "$event": e2 }, params: [e2] });
  });
  cleanup2(() => removeListener());
}));
warnMissingPluginDirective("Collapse", "collapse", "collapse");
warnMissingPluginDirective("Intersect", "intersect", "intersect");
warnMissingPluginDirective("Focus", "trap", "focus");
warnMissingPluginDirective("Mask", "mask", "mask");
function warnMissingPluginDirective(name, directiveName, slug) {
  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
}
alpine_default.setEvaluator(cspEvaluator);
alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
var src_default$3 = alpine_default;
var module_default$3 = src_default$3;
function src_default$2(Alpine2) {
  Alpine2.directive("collapse", collapse);
  collapse.inline = (el, { modifiers }) => {
    if (!modifiers.includes("min"))
      return;
    el._x_doShow = () => {
    };
    el._x_doHide = () => {
    };
  };
  function collapse(el, { modifiers }) {
    let duration = modifierValue(modifiers, "duration", 250) / 1e3;
    let floor = modifierValue(modifiers, "min", 0);
    let fullyHide = !modifiers.includes("min");
    if (!el._x_isShown)
      el.style.height = `${floor}px`;
    if (!el._x_isShown && fullyHide)
      el.hidden = true;
    if (!el._x_isShown)
      el.style.overflow = "hidden";
    let setFunction = (el2, styles) => {
      let revertFunction = Alpine2.setStyles(el2, styles);
      return styles.height ? () => {
      } : revertFunction;
    };
    let transitionStyles = {
      transitionProperty: "height",
      transitionDuration: `${duration}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    el._x_transition = {
      in(before = () => {
      }, after = () => {
      }) {
        if (fullyHide)
          el.hidden = false;
        if (fullyHide)
          el.style.display = null;
        let current = el.getBoundingClientRect().height;
        el.style.height = "auto";
        let full = el.getBoundingClientRect().height;
        if (current === full) {
          current = floor;
        }
        Alpine2.transition(el, Alpine2.setStyles, {
          during: transitionStyles,
          start: { height: current + "px" },
          end: { height: full + "px" }
        }, () => el._x_isShown = true, () => {
          if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
            el.style.overflow = null;
          }
        });
      },
      out(before = () => {
      }, after = () => {
      }) {
        let full = el.getBoundingClientRect().height;
        Alpine2.transition(el, setFunction, {
          during: transitionStyles,
          start: { height: full + "px" },
          end: { height: floor + "px" }
        }, () => el.style.overflow = "hidden", () => {
          el._x_isShown = false;
          if (el.style.height == `${floor}px` && fullyHide) {
            el.style.display = "none";
            el.hidden = true;
          }
        });
      }
    };
  }
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "min") {
    let match = rawValue.match(/([0-9]+)px/);
    if (match)
      return match[1];
  }
  return rawValue;
}
var module_default$2 = src_default$2;
function src_default$1(Alpine2) {
  Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let evaluate2 = evaluateLater2(expression);
    let options = {
      rootMargin: getRootMargin(modifiers),
      threshold: getThreshold(modifiers)
    };
    let observer2 = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting === (value === "leave"))
          return;
        evaluate2();
        modifiers.includes("once") && observer2.disconnect();
      });
    }, options);
    observer2.observe(el);
    cleanup2(() => {
      observer2.disconnect();
    });
  }));
}
function getThreshold(modifiers) {
  if (modifiers.includes("full"))
    return 0.99;
  if (modifiers.includes("half"))
    return 0.5;
  if (!modifiers.includes("threshold"))
    return 0;
  let threshold = modifiers[modifiers.indexOf("threshold") + 1];
  if (threshold === "100")
    return 1;
  if (threshold === "0")
    return 0;
  return Number(`.${threshold}`);
}
function getLengthValue(rawValue) {
  let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
  return match ? match[1] + (match[2] || "px") : void 0;
}
function getRootMargin(modifiers) {
  const key = "margin";
  const fallback = "0px 0px 0px 0px";
  const index = modifiers.indexOf(key);
  if (index === -1)
    return fallback;
  let values = [];
  for (let i2 = 1; i2 < 5; i2++) {
    values.push(getLengthValue(modifiers[index + i2] || ""));
  }
  values = values.filter((v2) => v2 !== void 0);
  return values.length ? values.join(" ").trim() : fallback;
}
var module_default$1 = src_default$1;
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
  return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = /* @__PURE__ */ function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return e2.key === "Tab" || e2.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i2) {
    if (fn(value)) {
      idx = i2;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n2) {
            return n2 === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
            return isTabbable(n2, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e2) {
    var target = getActualTarget(e2);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e2.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e2) {
    var target = getActualTarget(e2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e2.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e2.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e2.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e2) {
    if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
      e2.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e2)) {
      checkTab(e2);
      return;
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
function src_default(Alpine2) {
  let lastFocused;
  let currentFocused;
  window.addEventListener("focusin", () => {
    lastFocused = currentFocused;
    currentFocused = document.activeElement;
  });
  Alpine2.magic("focus", (el) => {
    let within = el;
    return {
      __noscroll: false,
      __wrapAround: false,
      within(el2) {
        within = el2;
        return this;
      },
      withoutScrolling() {
        this.__noscroll = true;
        return this;
      },
      noscroll() {
        this.__noscroll = true;
        return this;
      },
      withWrapAround() {
        this.__wrapAround = true;
        return this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(el2) {
        return isFocusable(el2);
      },
      previouslyFocused() {
        return lastFocused;
      },
      lastFocused() {
        return lastFocused;
      },
      focused() {
        return currentFocused;
      },
      focusables() {
        if (Array.isArray(within))
          return within;
        return focusable(within, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(el2) {
        let els = this.all();
        return els[0] && els[0].isSameNode(el2);
      },
      isLast(el2) {
        let els = this.all();
        return els.length && els.slice(-1)[0].isSameNode(el2);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
          return list[0];
        }
        return list[list.indexOf(current) + 1];
      },
      getPrevious() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === 0) {
          return list.slice(-1)[0];
        }
        return list[list.indexOf(current) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(el2) {
        if (!el2)
          return;
        setTimeout(() => {
          if (!el2.hasAttribute("tabindex"))
            el2.setAttribute("tabindex", "0");
          el2.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  });
  Alpine2.directive("trap", Alpine2.skipDuringClone(
    (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluator = evaluateLater2(expression);
      let oldValue = false;
      let options = {
        escapeDeactivates: false,
        allowOutsideClick: true,
        fallbackFocus: () => el
      };
      if (modifiers.includes("noautofocus")) {
        options.initialFocus = false;
      } else {
        let autofocusEl = el.querySelector("[autofocus]");
        if (autofocusEl)
          options.initialFocus = autofocusEl;
      }
      let trap = createFocusTrap(el, options);
      let undoInert = () => {
      };
      let undoDisableScrolling = () => {
      };
      const releaseFocus = () => {
        undoInert();
        undoInert = () => {
        };
        undoDisableScrolling();
        undoDisableScrolling = () => {
        };
        trap.deactivate({
          returnFocus: !modifiers.includes("noreturn")
        });
      };
      effect3(() => evaluator((value) => {
        if (oldValue === value)
          return;
        if (value && !oldValue) {
          if (modifiers.includes("noscroll"))
            undoDisableScrolling = disableScrolling();
          if (modifiers.includes("inert"))
            undoInert = setInert(el);
          setTimeout(() => {
            trap.activate();
          }, 15);
        }
        if (!value && oldValue) {
          releaseFocus();
        }
        oldValue = !!value;
      }));
      cleanup2(releaseFocus);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
      if (modifiers.includes("inert") && evaluate2(expression))
        setInert(el);
    }
  ));
}
function setInert(el) {
  let undos = [];
  crawlSiblingsUp(el, (sibling) => {
    let cache = sibling.hasAttribute("aria-hidden");
    sibling.setAttribute("aria-hidden", "true");
    undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
  });
  return () => {
    while (undos.length)
      undos.pop()();
  };
}
function crawlSiblingsUp(el, callback) {
  if (el.isSameNode(document.body) || !el.parentNode)
    return;
  Array.from(el.parentNode.children).forEach((sibling) => {
    if (sibling.isSameNode(el)) {
      crawlSiblingsUp(el.parentNode, callback);
    } else {
      callback(sibling);
    }
  });
}
function disableScrolling() {
  let overflow = document.documentElement.style.overflow;
  let paddingRight = document.documentElement.style.paddingRight;
  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.overflow = "hidden";
  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
  return () => {
    document.documentElement.style.overflow = overflow;
    document.documentElement.style.paddingRight = paddingRight;
  };
}
var module_default = src_default;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function t(t2, e2) {
  if (!(t2 instanceof e2)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function e(t2, e2) {
  for (var s2 = 0; s2 < e2.length; s2++) {
    var i2 = e2[s2];
    i2.enumerable = i2.enumerable || false;
    i2.configurable = true;
    if ("value" in i2) i2.writable = true;
    Object.defineProperty(t2, i2.key, i2);
  }
}
function s(t2, s2, i2) {
  if (s2) e(t2.prototype, s2);
  return t2;
}
var i = Object.defineProperty;
var n = function(t2, e2) {
  return i(t2, "name", { value: e2, configurable: true });
};
var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var h = n(function(t2) {
  return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
}, "stringToHTML"), d = n(function(t2) {
  var e2 = new DOMParser().parseFromString(t2, "application/xml");
  return document.importNode(e2.documentElement, true).outerHTML;
}, "getSvgNode");
var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
var N = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), O = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "fadeOut"), T = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), E = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "slideOut");
var m = function() {
  function e2(s2) {
    var i2 = this;
    t(this, e2);
    this.notifyOut = n(function(t2) {
      t2(i2);
    }, "notifyOut");
    var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
    if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  s(e2, [{ key: "checkRequirements", value: function t2() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function t2() {
    var t3 = document.querySelector(".".concat(u.CONTAINER));
    t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function t2() {
    this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function t2() {
    var t3 = this;
    var e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
      t3.close();
    });
  } }, { key: "setWrapper", value: function t2() {
    var t3 = this;
    switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
      case p.OUTLINE:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
        break;
      case p.FILLED:
        this.wrapper.classList.add(u.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case f.SUCCESS:
        this.wrapper.classList.add(u.NOTIFY_SUCCESS);
        break;
      case f.ERROR:
        this.wrapper.classList.add(u.NOTIFY_ERROR);
        break;
      case f.WARNING:
        this.wrapper.classList.add(u.NOTIFY_WARNING);
        break;
      case f.INFO:
        this.wrapper.classList.add(u.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
      t3.wrapper.classList.add(e3);
    });
  } }, { key: "setContent", value: function t2() {
    var t3 = document.createElement("div");
    t3.classList.add(u.NOTIFY_CONTENT);
    var e3, s2;
    this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
  } }, { key: "setIcon", value: function t2() {
    var t3 = n(function(t4) {
      switch (t4) {
        case f.SUCCESS:
          return v.SUCCESS;
        case f.ERROR:
          return v.ERROR;
        case f.WARNING:
          return v.WARNING;
        case f.INFO:
          return v.INFO;
      }
    }, "computedIcon"), e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
  } }, { key: "setObserver", value: function t2() {
    var t3 = this;
    var e3 = new IntersectionObserver(function(e4) {
      if (e4[0].intersectionRatio <= 0) t3.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      e3.observe(t3.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function t2(t2) {
    t2(this);
  } }, { key: "autoClose", value: function t2() {
    var t3 = this;
    setTimeout(function() {
      t3.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function t2() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function t2() {
    switch (this.effect) {
      case I.FADE:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
        break;
      case I.SLIDE:
        this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
        break;
      default:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
    }
  } }]);
  return e2;
}();
n(m, "Notify");
var w = m;
globalThis.Notify = w;
const allowedStatuses = ["success", "error", "warning", "info"];
const allowedPositions = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
];
const defaultConfig = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: true,
  autotimeout: 4e3,
  position: "right top"
};
function renderToast(options = {}) {
  const config = {
    ...defaultConfig,
    ...options
  };
  if (!allowedStatuses.includes(config.status)) {
    console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
    config.status = "info";
  }
  if (!allowedPositions.includes(config.position)) {
    console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
    config.position = "right top";
  }
  new w(config);
}
const Toast = {
  custom: renderToast,
  success(text, title = "Success", options = {}) {
    renderToast({
      status: "success",
      title,
      text,
      ...options
    });
  },
  error(text, title = "Error", options = {}) {
    renderToast({
      status: "error",
      title,
      text,
      ...options
    });
  },
  warning(text, title = "Warning", options = {}) {
    renderToast({
      status: "warning",
      title,
      text,
      ...options
    });
  },
  info(text, title = "Info", options = {}) {
    renderToast({
      status: "info",
      title,
      text,
      ...options
    });
  },
  setDefaults(newDefaults = {}) {
    Object.assign(defaultConfig, newDefaults);
  },
  get allowedStatuses() {
    return [...allowedStatuses];
  },
  get allowedPositions() {
    return [...allowedPositions];
  }
};
const devnull = function() {
}, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
function subscribe(bundleIds, callbackFn) {
  bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
  const depsNotFound = [];
  let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
  fn = function(bundleId2, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId2);
    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };
  while (i2--) {
    bundleId = bundleIds[i2];
    r2 = bundleResultCache[bundleId];
    if (r2) {
      fn(bundleId, r2);
      continue;
    }
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}
function publish(bundleId, pathsNotFound) {
  if (!bundleId) return;
  const q = bundleCallbackQueue[bundleId];
  bundleResultCache[bundleId] = pathsNotFound;
  if (!q) return;
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}
function executeCallbacks(args, depsNotFound) {
  if (typeof args === "function") args = { success: args };
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}
function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
  let result = ev.type[0];
  if (isLegacyIECss) {
    try {
      if (!e2.sheet.cssText.length) result = "e";
    } catch (x) {
      if (x.code !== 18) result = "e";
    }
  }
  if (result === "e") {
    numTries += 1;
    if (numTries < maxTries) {
      return loadFile(path, callbackFn, args, numTries);
    }
  } else if (e2.rel === "preload" && e2.as === "style") {
    e2.rel = "stylesheet";
    return;
  }
  callbackFn(path, result, ev.defaultPrevented);
}
function loadFile(path, callbackFn, args, numTries) {
  const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
  let isLegacyIECss, hasModuleSupport, e2;
  numTries = numTries || 0;
  if (/(^css!|\.css$)/.test(pathname)) {
    e2 = doc.createElement("link");
    e2.rel = "stylesheet";
    e2.href = pathStripped;
    isLegacyIECss = "hideFocus" in e2;
    if (isLegacyIECss && e2.relList) {
      isLegacyIECss = 0;
      e2.rel = "preload";
      e2.as = "style";
    }
    if (args.inlineStyleNonce) {
      e2.setAttribute("nonce", args.inlineStyleNonce);
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    e2 = doc.createElement("img");
    e2.src = pathStripped;
  } else {
    e2 = doc.createElement("script");
    e2.src = pathStripped;
    e2.async = async === void 0 ? true : async;
    if (args.inlineScriptNonce) {
      e2.setAttribute("nonce", args.inlineScriptNonce);
    }
    hasModuleSupport = "noModule" in e2;
    if (/^module!/.test(pathname)) {
      if (!hasModuleSupport) return callbackFn(path, "l");
      e2.type = "module";
    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
      return callbackFn(path, "l");
    }
  }
  const onEvent = function(ev) {
    handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
  };
  e2.addEventListener("load", onEvent, { once: true });
  e2.addEventListener("error", onEvent, { once: true });
  if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
}
function loadFiles(paths, callbackFn, args) {
  paths = Array.isArray(paths) ? paths : [paths];
  let numWaiting = paths.length, pathsNotFound = [];
  function fn(path, result, defaultPrevented) {
    if (result === "e") pathsNotFound.push(path);
    if (result === "b") {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }
    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  }
  for (let i2 = 0; i2 < paths.length; i2++) {
    loadFile(paths[i2], fn, args);
  }
}
function loadjs(paths, arg1, arg2) {
  let bundleId, args;
  if (arg1 && typeof arg1 === "string" && arg1.trim) {
    bundleId = arg1.trim();
  }
  args = (bundleId ? arg2 : arg1) || {};
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }
  function loadFn(resolve, reject) {
    loadFiles(paths, function(pathsNotFound) {
      executeCallbacks(args, pathsNotFound);
      if (resolve) {
        executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
      }
      publish(bundleId, pathsNotFound);
    }, args);
  }
  if (args.returnPromise) {
    return new Promise(loadFn);
  } else {
    loadFn();
  }
}
loadjs.ready = function ready(deps, args) {
  subscribe(deps, function(depsNotFound) {
    executeCallbacks(args, depsNotFound);
  });
  return loadjs;
};
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};
loadjs.reset = function reset() {
  Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
  Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
  Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
};
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};
function registerRzAccordion(Alpine2) {
  Alpine2.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: false,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function registerRzAccordionSection(Alpine2) {
  Alpine2.data("rzAccordionSection", () => ({
    open: false,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true";
      this.sectionId = this.$el.dataset.sectionId;
      this.expandedClass = this.$el.dataset.expandedClass;
      const self = this;
      if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
        this.$watch("selected", (value, oldValue) => {
          if (value !== self.sectionId && !self.allowMultiple) {
            self.open = false;
          }
        });
      } else {
        console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
      }
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId;
      this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function registerRzAlert(Alpine2) {
  Alpine2.data("rzAlert", () => {
    return {
      showAlert: true,
      dismiss() {
        this.showAlert = false;
      }
    };
  });
}
function registerRzBrowser(Alpine2) {
  Alpine2.data("rzBrowser", () => {
    return {
      screenSize: "",
      setDesktopScreenSize() {
        this.screenSize = "";
      },
      setTabletScreenSize() {
        this.screenSize = "max-w-2xl";
      },
      setPhoneScreenSize() {
        this.screenSize = "max-w-sm";
      },
      // Get CSS classes for browser border based on screen size
      getBrowserBorderCss() {
        return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
      },
      // Get CSS classes for desktop screen button styling
      getDesktopScreenCss() {
        return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for tablet screen button styling
      getTabletScreenCss() {
        return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for phone screen button styling
      getPhoneScreenCss() {
        return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      }
    };
  });
}
function registerRzCheckboxGroupItem(Alpine2) {
  Alpine2.data("rzCheckboxGroupItem", () => {
    return {
      checkbox: null,
      isChecked: false,
      init() {
        this.checkbox = this.$refs.chk;
        this.isChecked = this.checkbox.checked;
      },
      toggleCheckbox() {
        this.isChecked = this.checkbox.checked;
      },
      getIconCss() {
        return this.isChecked ? "" : "hidden";
      }
    };
  });
}
function registerRzCodeViewer(Alpine2, require2) {
  Alpine2.data("rzCodeViewer", () => {
    return {
      expand: false,
      border: true,
      copied: false,
      copyTitle: "Copy",
      // Default title
      copiedTitle: "Copied!",
      // Default title
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const codeId = this.$el.dataset.codeid;
        const nonce = this.$el.dataset.nonce;
        this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
        this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
        require2(assets, {
          success: function() {
            const codeBlock = document.getElementById(codeId);
            if (window.hljs && codeBlock) {
              window.hljs.highlightElement(codeBlock);
            }
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      },
      // Function to check if code is NOT copied (for x-show)
      notCopied() {
        return !this.copied;
      },
      // Function to reset the copied state (e.g., on blur)
      disableCopied() {
        this.copied = false;
      },
      // Function to toggle the expand state
      toggleExpand() {
        this.expand = !this.expand;
      },
      // Function to copy code to clipboard
      copyHTML() {
        navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
        this.copied = !this.copied;
      },
      // Get the title for the copy button (copy/copied)
      getCopiedTitle() {
        return this.copied ? this.copiedTitle : this.copyTitle;
      },
      // Get CSS classes for the copy button based on copied state
      getCopiedCss() {
        return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
      },
      // Get CSS classes for the code container based on expand state
      getExpandCss() {
        return [this.expand ? "" : "max-h-60"];
      },
      // Get CSS classes for the expand button icon based on expand state
      getExpandButtonCss() {
        return this.expand ? "rotate-180" : "rotate-0";
      }
    };
  });
}
function registerRzDateEdit(Alpine2, require2) {
  Alpine2.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const cfgString = this.$el.dataset.config;
      const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
      if (cfgString) {
        const parsed = JSON.parse(cfgString);
        if (parsed) {
          this.options = parsed.options || {};
          this.placeholder = parsed.placeholder || "";
          this.prependText = parsed.prependText || "";
        }
      }
      const assets = JSON.parse(this.$el.dataset.assets);
      const nonce = this.$el.dataset.nonce;
      require2(assets, {
        success: function() {
          if (window.flatpickr && inputElem) {
            window.flatpickr(inputElem, this.options);
          }
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, nonce);
    }
  }));
}
function registerRzDropdown(Alpine2) {
  Alpine2.data("rzDropdown", () => ({
    dropdownEl: null,
    anchorCss: "",
    dropdownOpen: false,
    openedWithKeyboard: false,
    init() {
      this.dropdownEl = this.$el;
      this.anchorCss = this.getAnchorCss();
    },
    toggleDropdown() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = !this.dropdownOpen;
    },
    openDropdown() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = true;
      this.openedWithKeyboard = false;
    },
    openWithKeyboard() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = true;
      this.openedWithKeyboard = true;
      this.focusWrapNext();
    },
    closeDropdown() {
      this.dropdownOpen = false;
      this.openedWithKeyboard = false;
    },
    focusWrapNext() {
      this.$focus.wrap().next();
    },
    focusWrapPrevious() {
      this.$focus.wrap().previous();
    },
    // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
    getAnchorCss() {
      let defaultAnchorRaw = this.dropdownEl.getAttribute("data-anchor") || "";
      let defaultAnchor = defaultAnchorRaw.replace(/-/g, "").toLowerCase();
      const anchorClasses = {
        "topstart": "bottom-full right-0 mb-2 origin-bottom-right",
        "topcenter": "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
        "topend": "bottom-full left-0 mb-2 origin-bottom-left",
        "start": "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
        "end": "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
        "bottomstart": "right-0 mt-2 origin-top-right",
        "bottomcenter": "-translate-x-1/2 mt-2 origin-top",
        "bottomend": "left-0 mt-2 origin-top-left"
      };
      let cssClasses = anchorClasses[defaultAnchor] || "";
      const triggerRect = this.dropdownEl.getBoundingClientRect();
      let tempContainer = document.createElement("div");
      tempContainer.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;";
      this.dropdownEl.appendChild(tempContainer);
      const originalMenu = this.dropdownEl.querySelector('[role="menu"]');
      if (!originalMenu) {
        return cssClasses;
      }
      let clone2 = originalMenu.cloneNode(true);
      clone2.style.transition = "none";
      clone2.style.transform = "none";
      clone2.style.opacity = "1";
      clone2.style.display = "block";
      tempContainer.appendChild(clone2);
      let cloneRect = clone2.getBoundingClientRect();
      tempContainer.parentNode.removeChild(tempContainer);
      const margin = 8;
      let wouldClip = false;
      if (defaultAnchor.startsWith("top")) {
        if (triggerRect.top < cloneRect.height + margin) {
          wouldClip = true;
        }
      } else if (defaultAnchor.startsWith("bottom")) {
        if (triggerRect.bottom + cloneRect.height + margin > window.innerHeight) {
          wouldClip = true;
        }
      } else if (defaultAnchor === "start") {
        if (triggerRect.left < cloneRect.width + margin) {
          wouldClip = true;
        }
      } else if (defaultAnchor === "end") {
        if (triggerRect.right + cloneRect.width + margin > window.innerWidth) {
          wouldClip = true;
        }
      }
      if (wouldClip) {
        const fallbackMapping = {
          "topstart": "bottomstart",
          "topcenter": "bottomcenter",
          "topend": "bottomend",
          "bottomstart": "topstart",
          "bottomcenter": "topcenter",
          "bottomend": "topend",
          "start": "end",
          "end": "start"
        };
        let fallbackAnchor = fallbackMapping[defaultAnchor] || defaultAnchor;
        cssClasses = anchorClasses[fallbackAnchor] || cssClasses;
      }
      return cssClasses;
    }
  }));
}
function registerRzDarkModeToggle(Alpine2) {
  Alpine2.data("rzDarkModeToggle", () => ({
    mode: "light",
    applyTheme: null,
    init() {
      const hasLocalStorage = typeof window !== "undefined" && "localStorage" in window;
      const allowedModes = ["light", "dark", "auto"];
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      let storedMode = "auto";
      if (hasLocalStorage) {
        storedMode = localStorage.getItem("darkMode") ?? "auto";
        if (!allowedModes.includes(storedMode)) {
          storedMode = "light";
        }
      }
      if (hasLocalStorage) {
        localStorage.setItem("darkMode", storedMode);
      }
      this.applyTheme = () => {
        document.documentElement.classList.toggle(
          "dark",
          storedMode === "dark" || storedMode === "auto" && prefersDark
        );
      };
      this.applyTheme();
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
    },
    // Returns true if dark mode should be active
    isDark() {
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      localStorage.getItem("darkMode");
      return this.mode === "dark" || this.mode === "auto" && prefersDark;
    },
    // Returns true if light mode should be active
    isLight() {
      return !this.isDark();
    },
    // Toggle the dark mode setting and dispatch a custom event
    toggle() {
      let storedMode = localStorage.getItem("darkMode");
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (storedMode === "light")
        storedMode = "dark";
      else if (storedMode === "dark")
        storedMode = "light";
      else if (storedMode === "auto") {
        storedMode = prefersDark ? "light" : "dark";
      }
      this.mode = storedMode;
      localStorage.setItem("darkMode", storedMode);
      const isDark = storedMode === "dark" || storedMode === "auto" && prefersDark;
      document.documentElement.classList.toggle("dark", isDark);
      const darkModeEvent = new CustomEvent("darkModeToggle", {
        detail: { darkMode: isDark }
      });
      window.dispatchEvent(darkModeEvent);
    },
    destroy() {
      if (this.applyTheme) {
        window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
      }
    }
  }));
}
function registerRzEmbeddedPreview(Alpine2) {
  Alpine2.data("rzEmbeddedPreview", () => {
    return {
      iframe: null,
      onDarkModeToggle: null,
      init() {
        try {
          this.iframe = this.$refs.iframe;
          const resize = this.debounce(() => {
            this.resizeIframe(this.iframe);
          }, 50);
          this.resizeIframe(this.iframe);
          const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
              resize();
            }
          });
          resizeObserver.observe(this.iframe);
          const iframe = this.iframe;
          this.onDarkModeToggle = (event) => {
            iframe.contentWindow.postMessage(event.detail, "*");
          };
          window.addEventListener("darkModeToggle", this.onDarkModeToggle);
        } catch (error2) {
          console.error("Cannot access iframe content");
        }
      },
      // Adjusts the iframe height based on its content
      resizeIframe(iframe) {
        if (iframe) {
          try {
            const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
            if (iframeDocument) {
              const iframeBody = iframeDocument.body;
              if (!iframeBody) {
                setInterval(() => {
                  this.resizeIframe(iframe);
                }, 150);
              } else {
                const newHeight = iframeBody.scrollHeight + 15;
                iframe.style.height = newHeight + "px";
              }
            }
          } catch (error2) {
            console.error("Error resizing iframe:", error2);
          }
        }
      },
      // Debounce helper to limit function calls
      debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      },
      destroy() {
        window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
      }
    };
  });
}
function registerRzEmpty(Alpine2) {
  Alpine2.data("rzEmpty", () => {
  });
}
function registerRzHeading(Alpine2) {
  Alpine2.data("rzHeading", () => {
    return {
      observer: null,
      headingId: "",
      init() {
        this.headingId = this.$el.dataset.alpineRoot;
        const self = this;
        if (typeof this.setCurrentHeading === "function") {
          const callback = (entries, observer2) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                self.setCurrentHeading(self.headingId);
              }
            });
          };
          const options = { threshold: 0.5 };
          this.observer = new IntersectionObserver(callback, options);
          this.observer.observe(this.$el);
        } else {
          console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
        }
      },
      destroy() {
        if (this.observer != null)
          this.observer.disconnect();
      }
    };
  });
}
function registerRzMarkdown(Alpine2, require2) {
  Alpine2.data("rzMarkdown", () => {
    return {
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require2(assets, {
          success: function() {
            window.hljs.highlightAll();
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      }
    };
  });
}
function registerRzModal(Alpine2) {
  Alpine2.data("rzModal", () => ({
    modalOpen: false,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: true,
    closeOnClickOutside: true,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "";
      this.bodyId = this.$el.dataset.bodyId || "";
      this.footerId = this.$el.dataset.footerId || "";
      this.nonce = this.$el.dataset.nonce || "";
      this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
      this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
      this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
      this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
      this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: true
      }));
      if (this.eventTriggerName) {
        this._openListener = (e2) => {
          this.openModal(e2);
        };
        window.addEventListener(this.eventTriggerName, this._openListener);
      }
      this._closeEventListener = (event) => {
        if (this.modalOpen) {
          this.closeModalInternally("event");
        }
      };
      window.addEventListener(this.closeEventName, this._closeEventListener);
      this._escapeListener = (e2) => {
        if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
          this.closeModalInternally("escape");
        }
      };
      window.addEventListener("keydown", this._escapeListener);
      this.$watch("modalOpen", (value) => {
        const currentWidth = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", value);
        const scrollBarWidth = document.body.offsetWidth - currentWidth;
        document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
        if (value) {
          this.$nextTick(() => {
            const dialogElement = this.$el.querySelector('[role="document"]');
            const focusable3 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
            focusable3?.focus();
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        } else {
          this.$nextTick(() => {
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        }
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      if (this._openListener && this.eventTriggerName) {
        window.removeEventListener(this.eventTriggerName, this._openListener);
      }
      if (this._closeEventListener) {
        window.removeEventListener(this.closeEventName, this._closeEventListener);
      }
      if (this._escapeListener) {
        window.removeEventListener("keydown", this._escapeListener);
      }
      document.body.classList.remove("overflow-hidden");
      document.body.style.setProperty("--page-scrollbar-width", `0px`);
    },
    openModal(event = null) {
      const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: event },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeOpenEvent);
      if (!beforeOpenEvent.defaultPrevented) {
        this.modalOpen = true;
      }
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(reason = "unknown") {
      const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeCloseEvent);
      if (!beforeCloseEvent.defaultPrevented) {
        document.activeElement?.blur && document.activeElement.blur();
        this.modalOpen = false;
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      }
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      if (this.closeOnClickOutside) {
        this.closeModalInternally("backdrop");
      }
    }
  }));
}
function registerRzPrependInput(Alpine2) {
  Alpine2.data("rzPrependInput", () => {
    return {
      prependContainer: null,
      textInput: null,
      init() {
        this.prependContainer = this.$refs.prependContainer;
        this.textInput = this.$refs.textInput;
        let self = this;
        setTimeout(() => {
          self.updatePadding();
        }, 50);
        window.addEventListener("resize", this.updatePadding);
      },
      destroy() {
        window.removeEventListener("resize", this.updatePadding);
      },
      updatePadding() {
        const prependDiv = this.prependContainer;
        const inputElem = this.textInput;
        if (!prependDiv || !inputElem) {
          if (inputElem) {
            inputElem.classList.remove("text-transparent");
          }
          return;
        }
        const prependWidth = prependDiv.offsetWidth;
        const leftPadding = prependWidth + 10;
        inputElem.style.paddingLeft = leftPadding + "px";
        inputElem.classList.remove("text-transparent");
      }
    };
  });
}
function registerRzProgress(Alpine2) {
  Alpine2.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const element = this.$el;
      this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
      this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
      this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
      this.label = element.getAttribute("data-label");
      this.calculatePercentage();
      element.setAttribute("aria-valuenow", this.currentVal);
      element.setAttribute("aria-valuemin", this.minVal);
      element.setAttribute("aria-valuemax", this.maxVal);
      element.setAttribute("aria-valuetext", `${this.percentage}%`);
      this.updateProgressBar();
      const resizeObserver = new ResizeObserver((entries) => {
        this.updateProgressBar();
      });
      resizeObserver.observe(element);
      this.$watch("currentVal", () => {
        this.calculatePercentage();
        this.updateProgressBar();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      if (this.maxVal === this.minVal) {
        this.percentage = 0;
      } else {
        this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
      }
    },
    buildLabel() {
      var label = this.label || "{percent}%";
      this.calculatePercentage();
      return label.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const progressBar = this.$refs.progressBar;
      const barLabel = this.$refs.progressBarLabel;
      const innerLabel = this.$refs.innerLabel;
      if (barLabel && progressBar && innerLabel) {
        innerLabel.innerText = this.buildLabel();
        if (barLabel.clientWidth > progressBar.clientWidth) {
          barLabel.style.left = progressBar.clientWidth + 10 + "px";
        } else {
          barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
        }
      }
    },
    getLabelCss() {
      const barLabel = this.$refs.progressBarLabel;
      const progressBar = this.$refs.progressBar;
      if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
        return "text-foreground dark:text-foreground";
      }
      return "";
    },
    updateProgressBar() {
      const progressBar = this.$refs.progressBar;
      if (progressBar) {
        progressBar.style.width = `${this.percentage}%`;
        this.buildInsideLabelPosition();
      }
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(value) {
      this.currentVal = value;
    },
    increment(val = 1) {
      this.currentVal = Math.min(this.currentVal + val, this.maxVal);
    },
    decrement(val = 1) {
      this.currentVal = Math.max(this.currentVal - val, this.minVal);
    }
  }));
}
function registerRzQuickReferenceContainer(Alpine2) {
  Alpine2.data("rzQuickReferenceContainer", () => {
    return {
      headings: [],
      // Array of heading IDs
      currentHeadingId: "",
      // ID of the currently highlighted heading
      // Initializes the component with headings and the initial current heading from data attributes.
      init() {
        this.headings = JSON.parse(this.$el.dataset.headings || "[]");
        this.currentHeadingId = this.$el.dataset.currentheadingid || "";
      },
      // Handles click events on quick reference links.
      handleHeadingClick() {
        const id = this.$el.dataset.headingid;
        window.requestAnimationFrame(() => {
          this.currentHeadingId = id;
        });
      },
      // Sets the current heading ID based on intersection observer events from rzHeading.
      setCurrentHeading(id) {
        if (this.headings.includes(id)) {
          this.currentHeadingId = id;
        }
      },
      // Provides CSS classes for a link based on whether it's the current heading.
      // Returns an object suitable for :class binding.
      getSelectedCss() {
        const id = this.$el.dataset.headingid;
        return {
          "font-bold": this.currentHeadingId === id
          // Apply 'font-bold' if current
        };
      },
      // Determines the value for the aria-current attribute.
      getSelectedAriaCurrent() {
        const id = this.$el.dataset.headingid;
        return this.currentHeadingId === id ? "true" : null;
      }
    };
  });
}
function registerRzTabs(Alpine2) {
  Alpine2.data("rzTabs", () => {
    return {
      buttonRef: null,
      tabSelected: "",
      tabButton: null,
      init() {
        this.buttonRef = document.getElementById(this.$el.dataset.buttonref);
        this.tabSelected = this.$el.dataset.tabselected;
        this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']");
        this.tabRepositionMarker(this.tabButton);
      },
      tabButtonClicked(tabButton) {
        if (tabButton instanceof Event)
          tabButton = tabButton.target;
        this.tabSelected = tabButton.dataset.name;
        this.tabRepositionMarker(tabButton);
        tabButton.focus();
      },
      tabRepositionMarker(tabButton) {
        this.tabButton = tabButton;
        this.$refs.tabMarker.style.width = tabButton.offsetWidth + "px";
        this.$refs.tabMarker.style.height = tabButton.offsetHeight + "px";
        this.$refs.tabMarker.style.left = tabButton.offsetLeft + "px";
        setTimeout(() => {
          this.$refs.tabMarker.style.opacity = 1;
        }, 150);
      },
      // Get the CSS classes for the tab content panel based on selection
      getTabContentCss() {
        return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
      },
      tabContentActive(tabContent) {
        tabContent = tabContent ?? this.$el;
        return this.tabSelected === tabContent.dataset.name;
      },
      tabButtonActive(tabButton) {
        tabButton = tabButton ?? this.$el;
        return this.tabSelected === tabButton.dataset.name;
      },
      // Get the value for the aria-selected attribute
      getTabButtonAriaSelected() {
        return this.tabSelected === this.$el.dataset.name ? "true" : "false";
      },
      // Get the CSS classes for the tab button text color based on selection
      getSelectedTabTextColorCss() {
        const color = this.$el.dataset.selectedtextcolor ?? "";
        return this.tabSelected === this.$el.dataset.name ? color : "";
      },
      handleResize() {
        this.tabRepositionMarker(this.tabButton);
      },
      handleKeyDown(event) {
        const key = event.key;
        const tabButtons = Array.from(this.buttonRef.querySelectorAll("[role='tab']"));
        const currentIndex = tabButtons.findIndex((button) => this.tabSelected === button.dataset.name);
        let newIndex = currentIndex;
        if (key === "ArrowRight") {
          newIndex = (currentIndex + 1) % tabButtons.length;
          event.preventDefault();
        } else if (key === "ArrowLeft") {
          newIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;
          event.preventDefault();
        } else if (key === "Home") {
          newIndex = 0;
          event.preventDefault();
        } else if (key === "End") {
          newIndex = tabButtons.length - 1;
          event.preventDefault();
        }
        if (newIndex !== currentIndex) {
          this.tabButtonClicked(tabButtons[newIndex]);
        }
      }
    };
  });
}
function registerRzSidebar(Alpine2) {
  Alpine2.data("rzSidebar", () => {
    return {
      showSidebar: false,
      isSidebarHidden() {
        return !this.showSidebar;
      },
      toggleSidebar() {
        this.showSidebar = !this.showSidebar;
      },
      hideSidebar() {
        this.showSidebar = false;
      },
      // Return translation classes based on sidebar state for smooth slide-in/out
      getSidebarTranslation() {
        return this.showSidebar ? "translate-x-0" : "-translate-x-60";
      }
    };
  });
}
function registerRzSidebarLinkItem(Alpine2) {
  Alpine2.data("rzSidebarLinkItem", () => {
    return {
      isExpanded: false,
      chevronExpandedClass: "",
      chevronCollapsedClass: "",
      init() {
        this.isExpanded = this.$el.dataset.expanded === "true";
        this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass;
        this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
      },
      isCollapsed() {
        return !this.isExpanded;
      },
      toggleExpanded() {
        this.isExpanded = !this.isExpanded;
      },
      hideSidebar() {
        const sidebarScope = this.$el.closest('[x-data^="rzSidebar"]');
        if (sidebarScope) {
          let data2 = Alpine2.$data(sidebarScope);
          data2.showSidebar = false;
        } else {
          console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
        }
      },
      getExpandedClass() {
        return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
      },
      // Get the value for the aria-expanded attribute
      getAriaExpanded() {
        return this.isExpanded ? "true" : "false";
      }
    };
  });
}
async function generateBundleId(paths) {
  paths = [...paths].sort();
  const joinedPaths = paths.join("|");
  const encoder = new TextEncoder();
  const data2 = encoder.encode(joinedPaths);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function rizzyRequire(paths, callbackFn, nonce) {
  generateBundleId(paths).then((bundleId) => {
    if (!loadjs.isDefined(bundleId)) {
      loadjs(
        paths,
        bundleId,
        {
          async: false,
          inlineScriptNonce: nonce,
          inlineStyleNonce: nonce
        }
      );
    }
    loadjs.ready([bundleId], callbackFn);
  });
}
function registerComponents(Alpine2) {
  registerRzAccordion(Alpine2);
  registerRzAccordionSection(Alpine2);
  registerRzAlert(Alpine2);
  registerRzBrowser(Alpine2);
  registerRzCheckboxGroupItem(Alpine2);
  registerRzCodeViewer(Alpine2, rizzyRequire);
  registerRzDateEdit(Alpine2, rizzyRequire);
  registerRzDropdown(Alpine2);
  registerRzDarkModeToggle(Alpine2);
  registerRzEmbeddedPreview(Alpine2);
  registerRzEmpty(Alpine2);
  registerRzHeading(Alpine2);
  registerRzMarkdown(Alpine2, rizzyRequire);
  registerRzModal(Alpine2);
  registerRzPrependInput(Alpine2);
  registerRzProgress(Alpine2);
  registerRzQuickReferenceContainer(Alpine2);
  registerRzTabs(Alpine2);
  registerRzSidebar(Alpine2);
  registerRzSidebarLinkItem(Alpine2);
}
function $data(idOrElement) {
  if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
    console.error(
      "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
    );
    return void 0;
  }
  let outerElement = null;
  let componentId = null;
  if (typeof idOrElement === "string") {
    if (!idOrElement) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return void 0;
    }
    componentId = idOrElement;
    outerElement = document.getElementById(componentId);
    if (!outerElement) {
      console.warn(`Rizzy.$data: Rizzy component with ID "${componentId}" not found in the DOM.`);
      return void 0;
    }
  } else if (idOrElement instanceof Element) {
    outerElement = idOrElement;
    if (!outerElement.id) {
      console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
      return void 0;
    }
    componentId = outerElement.id;
  } else {
    console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
    return void 0;
  }
  const alpineRootSelector = `[data-alpine-root="${componentId}"]`;
  let alpineRootElement = null;
  if (outerElement.matches(alpineRootSelector)) {
    alpineRootElement = outerElement;
  } else {
    alpineRootElement = outerElement.querySelector(alpineRootSelector);
  }
  if (!alpineRootElement) {
    console.warn(
      `Rizzy.$data: Could not locate the designated Alpine root element using selector "${alpineRootSelector}" on or inside the wrapper element (ID: #${componentId}). Verify the 'data-alpine-root' attribute placement.`
    );
    return void 0;
  }
  const alpineData = Alpine.$data(alpineRootElement);
  if (alpineData === void 0) {
    const targetDesc = `${alpineRootElement.tagName.toLowerCase()}${alpineRootElement.id ? "#" + alpineRootElement.id : ""}${alpineRootElement.classList.length ? "." + Array.from(alpineRootElement.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located designated Alpine root (${targetDesc}) via 'data-alpine-root="${componentId}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
    );
  }
  return alpineData;
}
module_default$3.plugin(module_default$2);
module_default$3.plugin(module_default$1);
module_default$3.plugin(module_default);
registerComponents(module_default$3);
const RizzyUI = {
  Alpine: module_default$3,
  require: rizzyRequire,
  toast: Toast,
  $data
};
window.Alpine = module_default$3;
window.Rizzy = { ...window.Rizzy || {}, ...RizzyUI };
module_default$3.start();
export {
  RizzyUI as default
};
//# sourceMappingURL=rizzyui-csp.es.js.map
</file>

<file path="wwwroot/js/rizzyui-csp.min.es.js">
var lt = !1, ut = !1, Z = [], dt = -1;
function Gr(e) {
  Zr(e);
}
function Zr(e) {
  Z.includes(e) || Z.push(e), Xr();
}
function Jr(e) {
  let t = Z.indexOf(e);
  t !== -1 && t > dt && Z.splice(t, 1);
}
function Xr() {
  !ut && !lt && (lt = !0, queueMicrotask(Qr));
}
function Qr() {
  lt = !1, ut = !0;
  for (let e = 0; e < Z.length; e++)
    Z[e](), dt = e;
  Z.length = 0, dt = -1, ut = !1;
}
var ae, re, oe, xn, ft = !0;
function ei(e) {
  ft = !1, e(), ft = !0;
}
function ti(e) {
  ae = e.reactive, oe = e.release, re = (t) => e.effect(t, { scheduler: (n) => {
    ft ? Gr(n) : n();
  } }), xn = e.raw;
}
function Zt(e) {
  re = e;
}
function ni(e) {
  let t = () => {
  };
  return [(r) => {
    let i = re(r);
    return e._x_effects || (e._x_effects = /* @__PURE__ */ new Set(), e._x_runEffects = () => {
      e._x_effects.forEach((s) => s());
    }), e._x_effects.add(i), t = () => {
      i !== void 0 && (e._x_effects.delete(i), oe(i));
    }, i;
  }, () => {
    t();
  }];
}
function En(e, t) {
  let n = !0, r, i = re(() => {
    let s = e();
    JSON.stringify(s), n ? r = s : queueMicrotask(() => {
      t(s, r), r = s;
    }), n = !1;
  });
  return () => oe(i);
}
var Sn = [], Cn = [], In = [];
function ri(e) {
  In.push(e);
}
function At(e, t) {
  typeof t == "function" ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, Cn.push(t));
}
function Tn(e) {
  Sn.push(e);
}
function On(e, t, n) {
  e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(n);
}
function An(e, t) {
  e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach(([n, r]) => {
    (t === void 0 || t.includes(n)) && (r.forEach((i) => i()), delete e._x_attributeCleanups[n]);
  });
}
function ii(e) {
  for (e._x_effects?.forEach(Jr); e._x_cleanups?.length; )
    e._x_cleanups.pop()();
}
var Nt = new MutationObserver($t), Rt = !1;
function kt() {
  Nt.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), Rt = !0;
}
function Nn() {
  si(), Nt.disconnect(), Rt = !1;
}
var he = [];
function si() {
  let e = Nt.takeRecords();
  he.push(() => e.length > 0 && $t(e));
  let t = he.length;
  queueMicrotask(() => {
    if (he.length === t)
      for (; he.length > 0; )
        he.shift()();
  });
}
function C(e) {
  if (!Rt)
    return e();
  Nn();
  let t = e();
  return kt(), t;
}
var Lt = !1, je = [];
function ai() {
  Lt = !0;
}
function oi() {
  Lt = !1, $t(je), je = [];
}
function $t(e) {
  if (Lt) {
    je = je.concat(e);
    return;
  }
  let t = [], n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (let s = 0; s < e.length; s++)
    if (!e[s].target._x_ignoreMutationObserver && (e[s].type === "childList" && (e[s].removedNodes.forEach((a) => {
      a.nodeType === 1 && a._x_marker && n.add(a);
    }), e[s].addedNodes.forEach((a) => {
      if (a.nodeType === 1) {
        if (n.has(a)) {
          n.delete(a);
          return;
        }
        a._x_marker || t.push(a);
      }
    })), e[s].type === "attributes")) {
      let a = e[s].target, o = e[s].attributeName, c = e[s].oldValue, l = () => {
        r.has(a) || r.set(a, []), r.get(a).push({ name: o, value: a.getAttribute(o) });
      }, u = () => {
        i.has(a) || i.set(a, []), i.get(a).push(o);
      };
      a.hasAttribute(o) && c === null ? l() : a.hasAttribute(o) ? (u(), l()) : u();
    }
  i.forEach((s, a) => {
    An(a, s);
  }), r.forEach((s, a) => {
    Sn.forEach((o) => o(a, s));
  });
  for (let s of n)
    t.some((a) => a.contains(s)) || Cn.forEach((a) => a(s));
  for (let s of t)
    s.isConnected && In.forEach((a) => a(s));
  t = null, n = null, r = null, i = null;
}
function Rn(e) {
  return ce(ee(e));
}
function Te(e, t, n) {
  return e._x_dataStack = [t, ...ee(n || e)], () => {
    e._x_dataStack = e._x_dataStack.filter((r) => r !== t);
  };
}
function ee(e) {
  return e._x_dataStack ? e._x_dataStack : typeof ShadowRoot == "function" && e instanceof ShadowRoot ? ee(e.host) : e.parentNode ? ee(e.parentNode) : [];
}
function ce(e) {
  return new Proxy({ objects: e }, ci);
}
var ci = {
  ownKeys({ objects: e }) {
    return Array.from(
      new Set(e.flatMap((t) => Object.keys(t)))
    );
  },
  has({ objects: e }, t) {
    return t == Symbol.unscopables ? !1 : e.some(
      (n) => Object.prototype.hasOwnProperty.call(n, t) || Reflect.has(n, t)
    );
  },
  get({ objects: e }, t, n) {
    return t == "toJSON" ? li : Reflect.get(
      e.find(
        (r) => Reflect.has(r, t)
      ) || {},
      t,
      n
    );
  },
  set({ objects: e }, t, n, r) {
    const i = e.find(
      (a) => Object.prototype.hasOwnProperty.call(a, t)
    ) || e[e.length - 1], s = Object.getOwnPropertyDescriptor(i, t);
    return s?.set && s?.get ? s.set.call(r, n) || !0 : Reflect.set(i, t, n);
  }
};
function li() {
  return Reflect.ownKeys(this).reduce((t, n) => (t[n] = Reflect.get(this, n), t), {});
}
function kn(e) {
  let t = (r) => typeof r == "object" && !Array.isArray(r) && r !== null, n = (r, i = "") => {
    Object.entries(Object.getOwnPropertyDescriptors(r)).forEach(([s, { value: a, enumerable: o }]) => {
      if (o === !1 || a === void 0 || typeof a == "object" && a !== null && a.__v_skip)
        return;
      let c = i === "" ? s : `${i}.${s}`;
      typeof a == "object" && a !== null && a._x_interceptor ? r[s] = a.initialize(e, c, s) : t(a) && a !== r && !(a instanceof Element) && n(a, c);
    });
  };
  return n(e);
}
function Ln(e, t = () => {
}) {
  let n = {
    initialValue: void 0,
    _x_interceptor: !0,
    initialize(r, i, s) {
      return e(this.initialValue, () => ui(r, i), (a) => ht(r, i, a), i, s);
    }
  };
  return t(n), (r) => {
    if (typeof r == "object" && r !== null && r._x_interceptor) {
      let i = n.initialize.bind(n);
      n.initialize = (s, a, o) => {
        let c = r.initialize(s, a, o);
        return n.initialValue = c, i(s, a, o);
      };
    } else
      n.initialValue = r;
    return n;
  };
}
function ui(e, t) {
  return t.split(".").reduce((n, r) => n[r], e);
}
function ht(e, t, n) {
  if (typeof t == "string" && (t = t.split(".")), t.length === 1)
    e[t[0]] = n;
  else {
    if (t.length === 0)
      throw error;
    return e[t[0]] || (e[t[0]] = {}), ht(e[t[0]], t.slice(1), n);
  }
}
var $n = {};
function D(e, t) {
  $n[e] = t;
}
function We(e, t) {
  let n = di(t);
  return Object.entries($n).forEach(([r, i]) => {
    Object.defineProperty(e, `$${r}`, {
      get() {
        return i(t, n);
      },
      enumerable: !1
    });
  }), e;
}
function di(e) {
  let [t, n] = jn(e), r = { interceptor: Ln, ...t };
  return At(e, n), r;
}
function Fn(e, t, n, ...r) {
  try {
    return n(...r);
  } catch (i) {
    Ee(i, e, t);
  }
}
function Ee(e, t, n = void 0) {
  e = Object.assign(
    e ?? { message: "No error message given." },
    { el: t, expression: n }
  ), console.warn(`Alpine Expression Error: ${e.message}
${n ? 'Expression: "' + n + `"
` : ""}`, t), setTimeout(() => {
    throw e;
  }, 0);
}
var De = !0;
function Mn(e) {
  let t = De;
  De = !1;
  let n = e();
  return De = t, n;
}
function J(e, t, n = {}) {
  let r;
  return R(e, t)((i) => r = i, n), r;
}
function R(...e) {
  return Dn(...e);
}
var Dn = hi;
function fi(e) {
  Dn = e;
}
function hi(e, t) {
  let n = {};
  We(n, e);
  let r = [n, ...ee(e)], i = typeof t == "function" ? Pn(r, t) : gi(r, t, e);
  return Fn.bind(null, e, t, i);
}
function Pn(e, t) {
  return (n = () => {
  }, { scope: r = {}, params: i = [] } = {}) => {
    let s = t.apply(ce([r, ...e]), i);
    Se(n, s);
  };
}
var rt = {};
function pi(e, t) {
  if (rt[e])
    return rt[e];
  let n = Object.getPrototypeOf(async function() {
  }).constructor, r = /^[\n\s]*if.*\(.*\)/.test(e.trim()) || /^(let|const)\s/.test(e.trim()) ? `(async()=>{ ${e} })()` : e, s = (() => {
    try {
      let a = new n(
        ["__self", "scope"],
        `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`
      );
      return Object.defineProperty(a, "name", {
        value: `[Alpine] ${e}`
      }), a;
    } catch (a) {
      return Ee(a, t, e), Promise.resolve();
    }
  })();
  return rt[e] = s, s;
}
function gi(e, t, n) {
  let r = pi(t, n);
  return (i = () => {
  }, { scope: s = {}, params: a = [] } = {}) => {
    r.result = void 0, r.finished = !1;
    let o = ce([s, ...e]);
    if (typeof r == "function") {
      let c = r(r, o).catch((l) => Ee(l, n, t));
      r.finished ? (Se(i, r.result, o, a, n), r.result = void 0) : c.then((l) => {
        Se(i, l, o, a, n);
      }).catch((l) => Ee(l, n, t)).finally(() => r.result = void 0);
    }
  };
}
function Se(e, t, n, r, i) {
  if (De && typeof t == "function") {
    let s = t.apply(n, r);
    s instanceof Promise ? s.then((a) => Se(e, a, n, r)).catch((a) => Ee(a, i, t)) : e(s);
  } else typeof t == "object" && t instanceof Promise ? t.then((s) => e(s)) : e(t);
}
var Ft = "x-";
function le(e = "") {
  return Ft + e;
}
function vi(e) {
  Ft = e;
}
var He = {};
function O(e, t) {
  return He[e] = t, {
    before(n) {
      if (!He[n]) {
        console.warn(String.raw`Cannot find directive \`${n}\`. \`${e}\` will use the default order of execution`);
        return;
      }
      const r = G.indexOf(n);
      G.splice(r >= 0 ? r : G.indexOf("DEFAULT"), 0, e);
    }
  };
}
function bi(e) {
  return Object.keys(He).includes(e);
}
function Mt(e, t, n) {
  if (t = Array.from(t), e._x_virtualDirectives) {
    let s = Object.entries(e._x_virtualDirectives).map(([o, c]) => ({ name: o, value: c })), a = zn(s);
    s = s.map((o) => a.find((c) => c.name === o.name) ? {
      name: `x-bind:${o.name}`,
      value: `"${o.value}"`
    } : o), t = t.concat(s);
  }
  let r = {};
  return t.map(Yn((s, a) => r[s] = a)).filter(Vn).map(yi(r, n)).sort(wi).map((s) => _i(e, s));
}
function zn(e) {
  return Array.from(e).map(Yn()).filter((t) => !Vn(t));
}
var pt = !1, ye = /* @__PURE__ */ new Map(), Bn = Symbol();
function mi(e) {
  pt = !0;
  let t = Symbol();
  Bn = t, ye.set(t, []);
  let n = () => {
    for (; ye.get(t).length; )
      ye.get(t).shift()();
    ye.delete(t);
  }, r = () => {
    pt = !1, n();
  };
  e(n), r();
}
function jn(e) {
  let t = [], n = (o) => t.push(o), [r, i] = ni(e);
  return t.push(i), [{
    Alpine: Oe,
    effect: r,
    cleanup: n,
    evaluateLater: R.bind(R, e),
    evaluate: J.bind(J, e)
  }, () => t.forEach((o) => o())];
}
function _i(e, t) {
  let n = () => {
  }, r = He[t.type] || n, [i, s] = jn(e);
  On(e, t.original, s);
  let a = () => {
    e._x_ignore || e._x_ignoreSelf || (r.inline && r.inline(e, t, i), r = r.bind(r, e, t, i), pt ? ye.get(Bn).push(r) : r());
  };
  return a.runCleanups = s, a;
}
var Wn = (e, t) => ({ name: n, value: r }) => (n.startsWith(e) && (n = n.replace(e, t)), { name: n, value: r }), Hn = (e) => e;
function Yn(e = () => {
}) {
  return ({ name: t, value: n }) => {
    let { name: r, value: i } = Kn.reduce((s, a) => a(s), { name: t, value: n });
    return r !== t && e(r, t), { name: r, value: i };
  };
}
var Kn = [];
function Dt(e) {
  Kn.push(e);
}
function Vn({ name: e }) {
  return qn().test(e);
}
var qn = () => new RegExp(`^${Ft}([^:^.]+)\\b`);
function yi(e, t) {
  return ({ name: n, value: r }) => {
    let i = n.match(qn()), s = n.match(/:([a-zA-Z0-9\-_:]+)/), a = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], o = t || e[n] || n;
    return {
      type: i ? i[1] : null,
      value: s ? s[1] : null,
      modifiers: a.map((c) => c.replace(".", "")),
      expression: r,
      original: o
    };
  };
}
var gt = "DEFAULT", G = [
  "ignore",
  "ref",
  "data",
  "id",
  "anchor",
  "bind",
  "init",
  "for",
  "model",
  "modelable",
  "transition",
  "show",
  "if",
  gt,
  "teleport"
];
function wi(e, t) {
  let n = G.indexOf(e.type) === -1 ? gt : e.type, r = G.indexOf(t.type) === -1 ? gt : t.type;
  return G.indexOf(n) - G.indexOf(r);
}
function we(e, t, n = {}) {
  e.dispatchEvent(
    new CustomEvent(t, {
      detail: n,
      bubbles: !0,
      // Allows events to pass the shadow DOM barrier.
      composed: !0,
      cancelable: !0
    })
  );
}
function te(e, t) {
  if (typeof ShadowRoot == "function" && e instanceof ShadowRoot) {
    Array.from(e.children).forEach((i) => te(i, t));
    return;
  }
  let n = !1;
  if (t(e, () => n = !0), n)
    return;
  let r = e.firstElementChild;
  for (; r; )
    te(r, t), r = r.nextElementSibling;
}
function L(e, ...t) {
  console.warn(`Alpine Warning: ${e}`, ...t);
}
var Jt = !1;
function xi() {
  Jt && L("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."), Jt = !0, document.body || L("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), we(document, "alpine:init"), we(document, "alpine:initializing"), kt(), ri((t) => z(t, te)), At((t) => de(t)), Tn((t, n) => {
    Mt(t, n).forEach((r) => r());
  });
  let e = (t) => !Ue(t.parentElement, !0);
  Array.from(document.querySelectorAll(Zn().join(","))).filter(e).forEach((t) => {
    z(t);
  }), we(document, "alpine:initialized"), setTimeout(() => {
    Ii();
  });
}
var Pt = [], Un = [];
function Gn() {
  return Pt.map((e) => e());
}
function Zn() {
  return Pt.concat(Un).map((e) => e());
}
function Jn(e) {
  Pt.push(e);
}
function Xn(e) {
  Un.push(e);
}
function Ue(e, t = !1) {
  return ue(e, (n) => {
    if ((t ? Zn() : Gn()).some((i) => n.matches(i)))
      return !0;
  });
}
function ue(e, t) {
  if (e) {
    if (t(e))
      return e;
    if (e._x_teleportBack && (e = e._x_teleportBack), !!e.parentElement)
      return ue(e.parentElement, t);
  }
}
function Ei(e) {
  return Gn().some((t) => e.matches(t));
}
var Qn = [];
function Si(e) {
  Qn.push(e);
}
var Ci = 1;
function z(e, t = te, n = () => {
}) {
  ue(e, (r) => r._x_ignore) || mi(() => {
    t(e, (r, i) => {
      r._x_marker || (n(r, i), Qn.forEach((s) => s(r, i)), Mt(r, r.attributes).forEach((s) => s()), r._x_ignore || (r._x_marker = Ci++), r._x_ignore && i());
    });
  });
}
function de(e, t = te) {
  t(e, (n) => {
    ii(n), An(n), delete n._x_marker;
  });
}
function Ii() {
  [
    ["ui", "dialog", ["[x-dialog], [x-popover]"]],
    ["anchor", "anchor", ["[x-anchor]"]],
    ["sort", "sort", ["[x-sort]"]]
  ].forEach(([t, n, r]) => {
    bi(n) || r.some((i) => {
      if (document.querySelector(i))
        return L(`found "${i}", but missing ${t} plugin`), !0;
    });
  });
}
var vt = [], zt = !1;
function Bt(e = () => {
}) {
  return queueMicrotask(() => {
    zt || setTimeout(() => {
      bt();
    });
  }), new Promise((t) => {
    vt.push(() => {
      e(), t();
    });
  });
}
function bt() {
  for (zt = !1; vt.length; )
    vt.shift()();
}
function Ti() {
  zt = !0;
}
function jt(e, t) {
  return Array.isArray(t) ? Xt(e, t.join(" ")) : typeof t == "object" && t !== null ? Oi(e, t) : typeof t == "function" ? jt(e, t()) : Xt(e, t);
}
function Xt(e, t) {
  let n = (i) => i.split(" ").filter((s) => !e.classList.contains(s)).filter(Boolean), r = (i) => (e.classList.add(...i), () => {
    e.classList.remove(...i);
  });
  return t = t === !0 ? t = "" : t || "", r(n(t));
}
function Oi(e, t) {
  let n = (o) => o.split(" ").filter(Boolean), r = Object.entries(t).flatMap(([o, c]) => c ? n(o) : !1).filter(Boolean), i = Object.entries(t).flatMap(([o, c]) => c ? !1 : n(o)).filter(Boolean), s = [], a = [];
  return i.forEach((o) => {
    e.classList.contains(o) && (e.classList.remove(o), a.push(o));
  }), r.forEach((o) => {
    e.classList.contains(o) || (e.classList.add(o), s.push(o));
  }), () => {
    a.forEach((o) => e.classList.add(o)), s.forEach((o) => e.classList.remove(o));
  };
}
function Ge(e, t) {
  return typeof t == "object" && t !== null ? Ai(e, t) : Ni(e, t);
}
function Ai(e, t) {
  let n = {};
  return Object.entries(t).forEach(([r, i]) => {
    n[r] = e.style[r], r.startsWith("--") || (r = Ri(r)), e.style.setProperty(r, i);
  }), setTimeout(() => {
    e.style.length === 0 && e.removeAttribute("style");
  }), () => {
    Ge(e, n);
  };
}
function Ni(e, t) {
  let n = e.getAttribute("style", t);
  return e.setAttribute("style", t), () => {
    e.setAttribute("style", n || "");
  };
}
function Ri(e) {
  return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function mt(e, t = () => {
}) {
  let n = !1;
  return function() {
    n ? t.apply(this, arguments) : (n = !0, e.apply(this, arguments));
  };
}
O("transition", (e, { value: t, modifiers: n, expression: r }, { evaluate: i }) => {
  typeof r == "function" && (r = i(r)), r !== !1 && (!r || typeof r == "boolean" ? Li(e, n, t) : ki(e, r, t));
});
function ki(e, t, n) {
  er(e, jt, ""), {
    enter: (i) => {
      e._x_transition.enter.during = i;
    },
    "enter-start": (i) => {
      e._x_transition.enter.start = i;
    },
    "enter-end": (i) => {
      e._x_transition.enter.end = i;
    },
    leave: (i) => {
      e._x_transition.leave.during = i;
    },
    "leave-start": (i) => {
      e._x_transition.leave.start = i;
    },
    "leave-end": (i) => {
      e._x_transition.leave.end = i;
    }
  }[n](t);
}
function Li(e, t, n) {
  er(e, Ge);
  let r = !t.includes("in") && !t.includes("out") && !n, i = r || t.includes("in") || ["enter"].includes(n), s = r || t.includes("out") || ["leave"].includes(n);
  t.includes("in") && !r && (t = t.filter((m, w) => w < t.indexOf("out"))), t.includes("out") && !r && (t = t.filter((m, w) => w > t.indexOf("out")));
  let a = !t.includes("opacity") && !t.includes("scale"), o = a || t.includes("opacity"), c = a || t.includes("scale"), l = o ? 0 : 1, u = c ? pe(t, "scale", 95) / 100 : 1, f = pe(t, "delay", 0) / 1e3, h = pe(t, "origin", "center"), b = "opacity, transform", T = pe(t, "duration", 150) / 1e3, k = pe(t, "duration", 75) / 1e3, g = "cubic-bezier(0.4, 0.0, 0.2, 1)";
  i && (e._x_transition.enter.during = {
    transformOrigin: h,
    transitionDelay: `${f}s`,
    transitionProperty: b,
    transitionDuration: `${T}s`,
    transitionTimingFunction: g
  }, e._x_transition.enter.start = {
    opacity: l,
    transform: `scale(${u})`
  }, e._x_transition.enter.end = {
    opacity: 1,
    transform: "scale(1)"
  }), s && (e._x_transition.leave.during = {
    transformOrigin: h,
    transitionDelay: `${f}s`,
    transitionProperty: b,
    transitionDuration: `${k}s`,
    transitionTimingFunction: g
  }, e._x_transition.leave.start = {
    opacity: 1,
    transform: "scale(1)"
  }, e._x_transition.leave.end = {
    opacity: l,
    transform: `scale(${u})`
  });
}
function er(e, t, n = {}) {
  e._x_transition || (e._x_transition = {
    enter: { during: n, start: n, end: n },
    leave: { during: n, start: n, end: n },
    in(r = () => {
    }, i = () => {
    }) {
      _t(e, t, {
        during: this.enter.during,
        start: this.enter.start,
        end: this.enter.end
      }, r, i);
    },
    out(r = () => {
    }, i = () => {
    }) {
      _t(e, t, {
        during: this.leave.during,
        start: this.leave.start,
        end: this.leave.end
      }, r, i);
    }
  });
}
window.Element.prototype._x_toggleAndCascadeWithTransitions = function(e, t, n, r) {
  const i = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
  let s = () => i(n);
  if (t) {
    e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(n) : s() : e._x_transition ? e._x_transition.in(n) : s();
    return;
  }
  e._x_hidePromise = e._x_transition ? new Promise((a, o) => {
    e._x_transition.out(() => {
    }, () => a(r)), e._x_transitioning && e._x_transitioning.beforeCancel(() => o({ isFromCancelledTransition: !0 }));
  }) : Promise.resolve(r), queueMicrotask(() => {
    let a = tr(e);
    a ? (a._x_hideChildren || (a._x_hideChildren = []), a._x_hideChildren.push(e)) : i(() => {
      let o = (c) => {
        let l = Promise.all([
          c._x_hidePromise,
          ...(c._x_hideChildren || []).map(o)
        ]).then(([u]) => u?.());
        return delete c._x_hidePromise, delete c._x_hideChildren, l;
      };
      o(e).catch((c) => {
        if (!c.isFromCancelledTransition)
          throw c;
      });
    });
  });
};
function tr(e) {
  let t = e.parentNode;
  if (t)
    return t._x_hidePromise ? t : tr(t);
}
function _t(e, t, { during: n, start: r, end: i } = {}, s = () => {
}, a = () => {
}) {
  if (e._x_transitioning && e._x_transitioning.cancel(), Object.keys(n).length === 0 && Object.keys(r).length === 0 && Object.keys(i).length === 0) {
    s(), a();
    return;
  }
  let o, c, l;
  $i(e, {
    start() {
      o = t(e, r);
    },
    during() {
      c = t(e, n);
    },
    before: s,
    end() {
      o(), l = t(e, i);
    },
    after: a,
    cleanup() {
      c(), l();
    }
  });
}
function $i(e, t) {
  let n, r, i, s = mt(() => {
    C(() => {
      n = !0, r || t.before(), i || (t.end(), bt()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning;
    });
  });
  e._x_transitioning = {
    beforeCancels: [],
    beforeCancel(a) {
      this.beforeCancels.push(a);
    },
    cancel: mt(function() {
      for (; this.beforeCancels.length; )
        this.beforeCancels.shift()();
      s();
    }),
    finish: s
  }, C(() => {
    t.start(), t.during();
  }), Ti(), requestAnimationFrame(() => {
    if (n)
      return;
    let a = Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3, o = Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
    a === 0 && (a = Number(getComputedStyle(e).animationDuration.replace("s", "")) * 1e3), C(() => {
      t.before();
    }), r = !0, requestAnimationFrame(() => {
      n || (C(() => {
        t.end();
      }), bt(), setTimeout(e._x_transitioning.finish, a + o), i = !0);
    });
  });
}
function pe(e, t, n) {
  if (e.indexOf(t) === -1)
    return n;
  const r = e[e.indexOf(t) + 1];
  if (!r || t === "scale" && isNaN(r))
    return n;
  if (t === "duration" || t === "delay") {
    let i = r.match(/([0-9]+)ms/);
    if (i)
      return i[1];
  }
  return t === "origin" && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [r, e[e.indexOf(t) + 2]].join(" ") : r;
}
var Y = !1;
function V(e, t = () => {
}) {
  return (...n) => Y ? t(...n) : e(...n);
}
function Fi(e) {
  return (...t) => Y && e(...t);
}
var nr = [];
function Ze(e) {
  nr.push(e);
}
function Mi(e, t) {
  nr.forEach((n) => n(e, t)), Y = !0, rr(() => {
    z(t, (n, r) => {
      r(n, () => {
      });
    });
  }), Y = !1;
}
var yt = !1;
function Di(e, t) {
  t._x_dataStack || (t._x_dataStack = e._x_dataStack), Y = !0, yt = !0, rr(() => {
    Pi(t);
  }), Y = !1, yt = !1;
}
function Pi(e) {
  let t = !1;
  z(e, (r, i) => {
    te(r, (s, a) => {
      if (t && Ei(s))
        return a();
      t = !0, i(s, a);
    });
  });
}
function rr(e) {
  let t = re;
  Zt((n, r) => {
    let i = t(n);
    return oe(i), () => {
    };
  }), e(), Zt(t);
}
function ir(e, t, n, r = []) {
  switch (e._x_bindings || (e._x_bindings = ae({})), e._x_bindings[t] = n, t = r.includes("camel") ? Vi(t) : t, t) {
    case "value":
      zi(e, n);
      break;
    case "style":
      ji(e, n);
      break;
    case "class":
      Bi(e, n);
      break;
    case "selected":
    case "checked":
      Wi(e, t, n);
      break;
    default:
      sr(e, t, n);
      break;
  }
}
function zi(e, t) {
  if (cr(e))
    e.attributes.value === void 0 && (e.value = t), window.fromModel && (typeof t == "boolean" ? e.checked = Pe(e.value) === t : e.checked = Qt(e.value, t));
  else if (Wt(e))
    Number.isInteger(t) ? e.value = t : !Array.isArray(t) && typeof t != "boolean" && ![null, void 0].includes(t) ? e.value = String(t) : Array.isArray(t) ? e.checked = t.some((n) => Qt(n, e.value)) : e.checked = !!t;
  else if (e.tagName === "SELECT")
    Ki(e, t);
  else {
    if (e.value === t)
      return;
    e.value = t === void 0 ? "" : t;
  }
}
function Bi(e, t) {
  e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedClasses = jt(e, t);
}
function ji(e, t) {
  e._x_undoAddedStyles && e._x_undoAddedStyles(), e._x_undoAddedStyles = Ge(e, t);
}
function Wi(e, t, n) {
  sr(e, t, n), Yi(e, t, n);
}
function sr(e, t, n) {
  [null, void 0, !1].includes(n) && Ui(t) ? e.removeAttribute(t) : (ar(t) && (n = t), Hi(e, t, n));
}
function Hi(e, t, n) {
  e.getAttribute(t) != n && e.setAttribute(t, n);
}
function Yi(e, t, n) {
  e[t] !== n && (e[t] = n);
}
function Ki(e, t) {
  const n = [].concat(t).map((r) => r + "");
  Array.from(e.options).forEach((r) => {
    r.selected = n.includes(r.value);
  });
}
function Vi(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase());
}
function Qt(e, t) {
  return e == t;
}
function Pe(e) {
  return [1, "1", "true", "on", "yes", !0].includes(e) ? !0 : [0, "0", "false", "off", "no", !1].includes(e) ? !1 : e ? !!e : null;
}
var qi = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected",
  "shadowrootclonable",
  "shadowrootdelegatesfocus",
  "shadowrootserializable"
]);
function ar(e) {
  return qi.has(e);
}
function Ui(e) {
  return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e);
}
function Gi(e, t, n) {
  return e._x_bindings && e._x_bindings[t] !== void 0 ? e._x_bindings[t] : or(e, t, n);
}
function Zi(e, t, n, r = !0) {
  if (e._x_bindings && e._x_bindings[t] !== void 0)
    return e._x_bindings[t];
  if (e._x_inlineBindings && e._x_inlineBindings[t] !== void 0) {
    let i = e._x_inlineBindings[t];
    return i.extract = r, Mn(() => J(e, i.expression));
  }
  return or(e, t, n);
}
function or(e, t, n) {
  let r = e.getAttribute(t);
  return r === null ? typeof n == "function" ? n() : n : r === "" ? !0 : ar(t) ? !![t, "true"].includes(r) : r;
}
function Wt(e) {
  return e.type === "checkbox" || e.localName === "ui-checkbox" || e.localName === "ui-switch";
}
function cr(e) {
  return e.type === "radio" || e.localName === "ui-radio";
}
function lr(e, t) {
  var n;
  return function() {
    var r = this, i = arguments, s = function() {
      n = null, e.apply(r, i);
    };
    clearTimeout(n), n = setTimeout(s, t);
  };
}
function ur(e, t) {
  let n;
  return function() {
    let r = this, i = arguments;
    n || (e.apply(r, i), n = !0, setTimeout(() => n = !1, t));
  };
}
function dr({ get: e, set: t }, { get: n, set: r }) {
  let i = !0, s, a = re(() => {
    let o = e(), c = n();
    if (i)
      r(it(o)), i = !1;
    else {
      let l = JSON.stringify(o), u = JSON.stringify(c);
      l !== s ? r(it(o)) : l !== u && t(it(c));
    }
    s = JSON.stringify(e()), JSON.stringify(n());
  });
  return () => {
    oe(a);
  };
}
function it(e) {
  return typeof e == "object" ? JSON.parse(JSON.stringify(e)) : e;
}
function Ji(e) {
  (Array.isArray(e) ? e : [e]).forEach((n) => n(Oe));
}
var U = {}, en = !1;
function Xi(e, t) {
  if (en || (U = ae(U), en = !0), t === void 0)
    return U[e];
  U[e] = t, kn(U[e]), typeof t == "object" && t !== null && t.hasOwnProperty("init") && typeof t.init == "function" && U[e].init();
}
function Qi() {
  return U;
}
var fr = {};
function es(e, t) {
  let n = typeof t != "function" ? () => t : t;
  return e instanceof Element ? hr(e, n()) : (fr[e] = n, () => {
  });
}
function ts(e) {
  return Object.entries(fr).forEach(([t, n]) => {
    Object.defineProperty(e, t, {
      get() {
        return (...r) => n(...r);
      }
    });
  }), e;
}
function hr(e, t, n) {
  let r = [];
  for (; r.length; )
    r.pop()();
  let i = Object.entries(t).map(([a, o]) => ({ name: a, value: o })), s = zn(i);
  return i = i.map((a) => s.find((o) => o.name === a.name) ? {
    name: `x-bind:${a.name}`,
    value: `"${a.value}"`
  } : a), Mt(e, i, n).map((a) => {
    r.push(a.runCleanups), a();
  }), () => {
    for (; r.length; )
      r.pop()();
  };
}
var pr = {};
function ns(e, t) {
  pr[e] = t;
}
function rs(e, t) {
  return Object.entries(pr).forEach(([n, r]) => {
    Object.defineProperty(e, n, {
      get() {
        return (...i) => r.bind(t)(...i);
      },
      enumerable: !1
    });
  }), e;
}
var is = {
  get reactive() {
    return ae;
  },
  get release() {
    return oe;
  },
  get effect() {
    return re;
  },
  get raw() {
    return xn;
  },
  version: "3.14.9",
  flushAndStopDeferringMutations: oi,
  dontAutoEvaluateFunctions: Mn,
  disableEffectScheduling: ei,
  startObservingMutations: kt,
  stopObservingMutations: Nn,
  setReactivityEngine: ti,
  onAttributeRemoved: On,
  onAttributesAdded: Tn,
  closestDataStack: ee,
  skipDuringClone: V,
  onlyDuringClone: Fi,
  addRootSelector: Jn,
  addInitSelector: Xn,
  interceptClone: Ze,
  addScopeToNode: Te,
  deferMutations: ai,
  mapAttributes: Dt,
  evaluateLater: R,
  interceptInit: Si,
  setEvaluator: fi,
  mergeProxies: ce,
  extractProp: Zi,
  findClosest: ue,
  onElRemoved: At,
  closestRoot: Ue,
  destroyTree: de,
  interceptor: Ln,
  // INTERNAL: not public API and is subject to change without major release.
  transition: _t,
  // INTERNAL
  setStyles: Ge,
  // INTERNAL
  mutateDom: C,
  directive: O,
  entangle: dr,
  throttle: ur,
  debounce: lr,
  evaluate: J,
  initTree: z,
  nextTick: Bt,
  prefixed: le,
  prefix: vi,
  plugin: Ji,
  magic: D,
  store: Xi,
  start: xi,
  clone: Di,
  // INTERNAL
  cloneNode: Mi,
  // INTERNAL
  bound: Gi,
  $data: Rn,
  watch: En,
  walk: te,
  data: ns,
  bind: es
}, Oe = is;
function ss(e, t) {
  let n = as(e);
  if (typeof t == "function")
    return Pn(n, t);
  let r = os(e, t, n);
  return Fn.bind(null, e, t, r);
}
function as(e) {
  let t = {};
  return We(t, e), [t, ...ee(e)];
}
function os(e, t, n) {
  return (r = () => {
  }, { scope: i = {}, params: s = [] } = {}) => {
    let a = ce([i, ...n]), o = t.split(".").reduce(
      (c, l) => (c[l] === void 0 && cs(e, t), c[l]),
      a
    );
    Se(r, o, a, s);
  };
}
function cs(e, t) {
  console.warn(
    `Alpine Error: Alpine is unable to interpret the following expression using the CSP-friendly build:
"${t}"
Read more about the Alpine's CSP-friendly build restrictions here: https://alpinejs.dev/advanced/csp
`,
    e
  );
}
function ls(e, t) {
  const n = /* @__PURE__ */ Object.create(null), r = e.split(",");
  for (let i = 0; i < r.length; i++)
    n[r[i]] = !0;
  return (i) => !!n[i];
}
var us = Object.freeze({}), ds = Object.prototype.hasOwnProperty, Je = (e, t) => ds.call(e, t), X = Array.isArray, xe = (e) => gr(e) === "[object Map]", fs = (e) => typeof e == "string", Ht = (e) => typeof e == "symbol", Xe = (e) => e !== null && typeof e == "object", hs = Object.prototype.toString, gr = (e) => hs.call(e), vr = (e) => gr(e).slice(8, -1), Yt = (e) => fs(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, ps = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, gs = ps((e) => e.charAt(0).toUpperCase() + e.slice(1)), br = (e, t) => e !== t && (e === e || t === t), wt = /* @__PURE__ */ new WeakMap(), ge = [], P, Q = Symbol("iterate"), xt = Symbol("Map key iterate");
function vs(e) {
  return e && e._isEffect === !0;
}
function bs(e, t = us) {
  vs(e) && (e = e.raw);
  const n = ys(e, t);
  return t.lazy || n(), n;
}
function ms(e) {
  e.active && (mr(e), e.options.onStop && e.options.onStop(), e.active = !1);
}
var _s = 0;
function ys(e, t) {
  const n = function() {
    if (!n.active)
      return e();
    if (!ge.includes(n)) {
      mr(n);
      try {
        return xs(), ge.push(n), P = n, e();
      } finally {
        ge.pop(), _r(), P = ge[ge.length - 1];
      }
    }
  };
  return n.id = _s++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n;
}
function mr(e) {
  const { deps: t } = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++)
      t[n].delete(e);
    t.length = 0;
  }
}
var se = !0, Kt = [];
function ws() {
  Kt.push(se), se = !1;
}
function xs() {
  Kt.push(se), se = !0;
}
function _r() {
  const e = Kt.pop();
  se = e === void 0 ? !0 : e;
}
function M(e, t, n) {
  if (!se || P === void 0)
    return;
  let r = wt.get(e);
  r || wt.set(e, r = /* @__PURE__ */ new Map());
  let i = r.get(n);
  i || r.set(n, i = /* @__PURE__ */ new Set()), i.has(P) || (i.add(P), P.deps.push(i), P.options.onTrack && P.options.onTrack({
    effect: P,
    target: e,
    type: t,
    key: n
  }));
}
function K(e, t, n, r, i, s) {
  const a = wt.get(e);
  if (!a)
    return;
  const o = /* @__PURE__ */ new Set(), c = (u) => {
    u && u.forEach((f) => {
      (f !== P || f.allowRecurse) && o.add(f);
    });
  };
  if (t === "clear")
    a.forEach(c);
  else if (n === "length" && X(e))
    a.forEach((u, f) => {
      (f === "length" || f >= r) && c(u);
    });
  else
    switch (n !== void 0 && c(a.get(n)), t) {
      case "add":
        X(e) ? Yt(n) && c(a.get("length")) : (c(a.get(Q)), xe(e) && c(a.get(xt)));
        break;
      case "delete":
        X(e) || (c(a.get(Q)), xe(e) && c(a.get(xt)));
        break;
      case "set":
        xe(e) && c(a.get(Q));
        break;
    }
  const l = (u) => {
    u.options.onTrigger && u.options.onTrigger({
      effect: u,
      target: e,
      key: n,
      type: t,
      newValue: r,
      oldValue: i,
      oldTarget: s
    }), u.options.scheduler ? u.options.scheduler(u) : u();
  };
  o.forEach(l);
}
var Es = /* @__PURE__ */ ls("__proto__,__v_isRef,__isVue"), yr = new Set(Object.getOwnPropertyNames(Symbol).map((e) => Symbol[e]).filter(Ht)), Ss = /* @__PURE__ */ wr(), Cs = /* @__PURE__ */ wr(!0), tn = /* @__PURE__ */ Is();
function Is() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((t) => {
    e[t] = function(...n) {
      const r = x(this);
      for (let s = 0, a = this.length; s < a; s++)
        M(r, "get", s + "");
      const i = r[t](...n);
      return i === -1 || i === !1 ? r[t](...n.map(x)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((t) => {
    e[t] = function(...n) {
      ws();
      const r = x(this)[t].apply(this, n);
      return _r(), r;
    };
  }), e;
}
function wr(e = !1, t = !1) {
  return function(r, i, s) {
    if (i === "__v_isReactive")
      return !e;
    if (i === "__v_isReadonly")
      return e;
    if (i === "__v_raw" && s === (e ? t ? Bs : Cr : t ? zs : Sr).get(r))
      return r;
    const a = X(r);
    if (!e && a && Je(tn, i))
      return Reflect.get(tn, i, s);
    const o = Reflect.get(r, i, s);
    return (Ht(i) ? yr.has(i) : Es(i)) || (e || M(r, "get", i), t) ? o : Et(o) ? !a || !Yt(i) ? o.value : o : Xe(o) ? e ? Ir(o) : Gt(o) : o;
  };
}
var Ts = /* @__PURE__ */ Os();
function Os(e = !1) {
  return function(n, r, i, s) {
    let a = n[r];
    if (!e && (i = x(i), a = x(a), !X(n) && Et(a) && !Et(i)))
      return a.value = i, !0;
    const o = X(n) && Yt(r) ? Number(r) < n.length : Je(n, r), c = Reflect.set(n, r, i, s);
    return n === x(s) && (o ? br(i, a) && K(n, "set", r, i, a) : K(n, "add", r, i)), c;
  };
}
function As(e, t) {
  const n = Je(e, t), r = e[t], i = Reflect.deleteProperty(e, t);
  return i && n && K(e, "delete", t, void 0, r), i;
}
function Ns(e, t) {
  const n = Reflect.has(e, t);
  return (!Ht(t) || !yr.has(t)) && M(e, "has", t), n;
}
function Rs(e) {
  return M(e, "iterate", X(e) ? "length" : Q), Reflect.ownKeys(e);
}
var ks = {
  get: Ss,
  set: Ts,
  deleteProperty: As,
  has: Ns,
  ownKeys: Rs
}, Ls = {
  get: Cs,
  set(e, t) {
    return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  },
  deleteProperty(e, t) {
    return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0;
  }
}, Vt = (e) => Xe(e) ? Gt(e) : e, qt = (e) => Xe(e) ? Ir(e) : e, Ut = (e) => e, Qe = (e) => Reflect.getPrototypeOf(e);
function Ne(e, t, n = !1, r = !1) {
  e = e.__v_raw;
  const i = x(e), s = x(t);
  t !== s && !n && M(i, "get", t), !n && M(i, "get", s);
  const { has: a } = Qe(i), o = r ? Ut : n ? qt : Vt;
  if (a.call(i, t))
    return o(e.get(t));
  if (a.call(i, s))
    return o(e.get(s));
  e !== i && e.get(t);
}
function Re(e, t = !1) {
  const n = this.__v_raw, r = x(n), i = x(e);
  return e !== i && !t && M(r, "has", e), !t && M(r, "has", i), e === i ? n.has(e) : n.has(e) || n.has(i);
}
function ke(e, t = !1) {
  return e = e.__v_raw, !t && M(x(e), "iterate", Q), Reflect.get(e, "size", e);
}
function nn(e) {
  e = x(e);
  const t = x(this);
  return Qe(t).has.call(t, e) || (t.add(e), K(t, "add", e, e)), this;
}
function rn(e, t) {
  t = x(t);
  const n = x(this), { has: r, get: i } = Qe(n);
  let s = r.call(n, e);
  s ? Er(n, r, e) : (e = x(e), s = r.call(n, e));
  const a = i.call(n, e);
  return n.set(e, t), s ? br(t, a) && K(n, "set", e, t, a) : K(n, "add", e, t), this;
}
function sn(e) {
  const t = x(this), { has: n, get: r } = Qe(t);
  let i = n.call(t, e);
  i ? Er(t, n, e) : (e = x(e), i = n.call(t, e));
  const s = r ? r.call(t, e) : void 0, a = t.delete(e);
  return i && K(t, "delete", e, void 0, s), a;
}
function an() {
  const e = x(this), t = e.size !== 0, n = xe(e) ? new Map(e) : new Set(e), r = e.clear();
  return t && K(e, "clear", void 0, void 0, n), r;
}
function Le(e, t) {
  return function(r, i) {
    const s = this, a = s.__v_raw, o = x(a), c = t ? Ut : e ? qt : Vt;
    return !e && M(o, "iterate", Q), a.forEach((l, u) => r.call(i, c(l), c(u), s));
  };
}
function $e(e, t, n) {
  return function(...r) {
    const i = this.__v_raw, s = x(i), a = xe(s), o = e === "entries" || e === Symbol.iterator && a, c = e === "keys" && a, l = i[e](...r), u = n ? Ut : t ? qt : Vt;
    return !t && M(s, "iterate", c ? xt : Q), {
      // iterator protocol
      next() {
        const { value: f, done: h } = l.next();
        return h ? { value: f, done: h } : {
          value: o ? [u(f[0]), u(f[1])] : u(f),
          done: h
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function j(e) {
  return function(...t) {
    {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      console.warn(`${gs(e)} operation ${n}failed: target is readonly.`, x(this));
    }
    return e === "delete" ? !1 : this;
  };
}
function $s() {
  const e = {
    get(s) {
      return Ne(this, s);
    },
    get size() {
      return ke(this);
    },
    has: Re,
    add: nn,
    set: rn,
    delete: sn,
    clear: an,
    forEach: Le(!1, !1)
  }, t = {
    get(s) {
      return Ne(this, s, !1, !0);
    },
    get size() {
      return ke(this);
    },
    has: Re,
    add: nn,
    set: rn,
    delete: sn,
    clear: an,
    forEach: Le(!1, !0)
  }, n = {
    get(s) {
      return Ne(this, s, !0);
    },
    get size() {
      return ke(this, !0);
    },
    has(s) {
      return Re.call(this, s, !0);
    },
    add: j(
      "add"
      /* ADD */
    ),
    set: j(
      "set"
      /* SET */
    ),
    delete: j(
      "delete"
      /* DELETE */
    ),
    clear: j(
      "clear"
      /* CLEAR */
    ),
    forEach: Le(!0, !1)
  }, r = {
    get(s) {
      return Ne(this, s, !0, !0);
    },
    get size() {
      return ke(this, !0);
    },
    has(s) {
      return Re.call(this, s, !0);
    },
    add: j(
      "add"
      /* ADD */
    ),
    set: j(
      "set"
      /* SET */
    ),
    delete: j(
      "delete"
      /* DELETE */
    ),
    clear: j(
      "clear"
      /* CLEAR */
    ),
    forEach: Le(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((s) => {
    e[s] = $e(s, !1, !1), n[s] = $e(s, !0, !1), t[s] = $e(s, !1, !0), r[s] = $e(s, !0, !0);
  }), [
    e,
    n,
    t,
    r
  ];
}
var [Fs, Ms, xo, Eo] = /* @__PURE__ */ $s();
function xr(e, t) {
  const n = e ? Ms : Fs;
  return (r, i, s) => i === "__v_isReactive" ? !e : i === "__v_isReadonly" ? e : i === "__v_raw" ? r : Reflect.get(Je(n, i) && i in r ? n : r, i, s);
}
var Ds = {
  get: /* @__PURE__ */ xr(!1)
}, Ps = {
  get: /* @__PURE__ */ xr(!0)
};
function Er(e, t, n) {
  const r = x(n);
  if (r !== n && t.call(e, r)) {
    const i = vr(e);
    console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
var Sr = /* @__PURE__ */ new WeakMap(), zs = /* @__PURE__ */ new WeakMap(), Cr = /* @__PURE__ */ new WeakMap(), Bs = /* @__PURE__ */ new WeakMap();
function js(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Ws(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : js(vr(e));
}
function Gt(e) {
  return e && e.__v_isReadonly ? e : Tr(e, !1, ks, Ds, Sr);
}
function Ir(e) {
  return Tr(e, !0, Ls, Ps, Cr);
}
function Tr(e, t, n, r, i) {
  if (!Xe(e))
    return console.warn(`value cannot be made reactive: ${String(e)}`), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const s = i.get(e);
  if (s)
    return s;
  const a = Ws(e);
  if (a === 0)
    return e;
  const o = new Proxy(e, a === 2 ? r : n);
  return i.set(e, o), o;
}
function x(e) {
  return e && x(e.__v_raw) || e;
}
function Et(e) {
  return !!(e && e.__v_isRef === !0);
}
D("nextTick", () => Bt);
D("dispatch", (e) => we.bind(we, e));
D("watch", (e, { evaluateLater: t, cleanup: n }) => (r, i) => {
  let s = t(r), o = En(() => {
    let c;
    return s((l) => c = l), c;
  }, i);
  n(o);
});
D("store", Qi);
D("data", (e) => Rn(e));
D("root", (e) => Ue(e));
D("refs", (e) => (e._x_refs_proxy || (e._x_refs_proxy = ce(Hs(e))), e._x_refs_proxy));
function Hs(e) {
  let t = [];
  return ue(e, (n) => {
    n._x_refs && t.push(n._x_refs);
  }), t;
}
var st = {};
function Or(e) {
  return st[e] || (st[e] = 0), ++st[e];
}
function Ys(e, t) {
  return ue(e, (n) => {
    if (n._x_ids && n._x_ids[t])
      return !0;
  });
}
function Ks(e, t) {
  e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = Or(t));
}
D("id", (e, { cleanup: t }) => (n, r = null) => {
  let i = `${n}${r ? `-${r}` : ""}`;
  return Vs(e, i, t, () => {
    let s = Ys(e, n), a = s ? s._x_ids[n] : Or(n);
    return r ? `${n}-${a}-${r}` : `${n}-${a}`;
  });
});
Ze((e, t) => {
  e._x_id && (t._x_id = e._x_id);
});
function Vs(e, t, n, r) {
  if (e._x_id || (e._x_id = {}), e._x_id[t])
    return e._x_id[t];
  let i = r();
  return e._x_id[t] = i, n(() => {
    delete e._x_id[t];
  }), i;
}
D("el", (e) => e);
Ar("Focus", "focus", "focus");
Ar("Persist", "persist", "persist");
function Ar(e, t, n) {
  D(t, (r) => L(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r));
}
O("modelable", (e, { expression: t }, { effect: n, evaluateLater: r, cleanup: i }) => {
  let s = r(t), a = () => {
    let u;
    return s((f) => u = f), u;
  }, o = r(`${t} = __placeholder`), c = (u) => o(() => {
  }, { scope: { __placeholder: u } }), l = a();
  c(l), queueMicrotask(() => {
    if (!e._x_model)
      return;
    e._x_removeModelListeners.default();
    let u = e._x_model.get, f = e._x_model.set, h = dr(
      {
        get() {
          return u();
        },
        set(b) {
          f(b);
        }
      },
      {
        get() {
          return a();
        },
        set(b) {
          c(b);
        }
      }
    );
    i(h);
  });
});
O("teleport", (e, { modifiers: t, expression: n }, { cleanup: r }) => {
  e.tagName.toLowerCase() !== "template" && L("x-teleport can only be used on a <template> tag", e);
  let i = on(n), s = e.content.cloneNode(!0).firstElementChild;
  e._x_teleport = s, s._x_teleportBack = e, e.setAttribute("data-teleport-template", !0), s.setAttribute("data-teleport-target", !0), e._x_forwardEvents && e._x_forwardEvents.forEach((o) => {
    s.addEventListener(o, (c) => {
      c.stopPropagation(), e.dispatchEvent(new c.constructor(c.type, c));
    });
  }), Te(s, {}, e);
  let a = (o, c, l) => {
    l.includes("prepend") ? c.parentNode.insertBefore(o, c) : l.includes("append") ? c.parentNode.insertBefore(o, c.nextSibling) : c.appendChild(o);
  };
  C(() => {
    a(s, i, t), V(() => {
      z(s);
    })();
  }), e._x_teleportPutBack = () => {
    let o = on(n);
    C(() => {
      a(e._x_teleport, o, t);
    });
  }, r(
    () => C(() => {
      s.remove(), de(s);
    })
  );
});
var qs = document.createElement("div");
function on(e) {
  let t = V(() => document.querySelector(e), () => qs)();
  return t || L(`Cannot find x-teleport element for selector: "${e}"`), t;
}
var Nr = () => {
};
Nr.inline = (e, { modifiers: t }, { cleanup: n }) => {
  t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, n(() => {
    t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore;
  });
};
O("ignore", Nr);
O("effect", V((e, { expression: t }, { effect: n }) => {
  n(R(e, t));
}));
function St(e, t, n, r) {
  let i = e, s = (c) => r(c), a = {}, o = (c, l) => (u) => l(c, u);
  if (n.includes("dot") && (t = Us(t)), n.includes("camel") && (t = Gs(t)), n.includes("passive") && (a.passive = !0), n.includes("capture") && (a.capture = !0), n.includes("window") && (i = window), n.includes("document") && (i = document), n.includes("debounce")) {
    let c = n[n.indexOf("debounce") + 1] || "invalid-wait", l = Ye(c.split("ms")[0]) ? Number(c.split("ms")[0]) : 250;
    s = lr(s, l);
  }
  if (n.includes("throttle")) {
    let c = n[n.indexOf("throttle") + 1] || "invalid-wait", l = Ye(c.split("ms")[0]) ? Number(c.split("ms")[0]) : 250;
    s = ur(s, l);
  }
  return n.includes("prevent") && (s = o(s, (c, l) => {
    l.preventDefault(), c(l);
  })), n.includes("stop") && (s = o(s, (c, l) => {
    l.stopPropagation(), c(l);
  })), n.includes("once") && (s = o(s, (c, l) => {
    c(l), i.removeEventListener(t, s, a);
  })), (n.includes("away") || n.includes("outside")) && (i = document, s = o(s, (c, l) => {
    e.contains(l.target) || l.target.isConnected !== !1 && (e.offsetWidth < 1 && e.offsetHeight < 1 || e._x_isShown !== !1 && c(l));
  })), n.includes("self") && (s = o(s, (c, l) => {
    l.target === e && c(l);
  })), (Js(t) || Rr(t)) && (s = o(s, (c, l) => {
    Xs(l, n) || c(l);
  })), i.addEventListener(t, s, a), () => {
    i.removeEventListener(t, s, a);
  };
}
function Us(e) {
  return e.replace(/-/g, ".");
}
function Gs(e) {
  return e.toLowerCase().replace(/-(\w)/g, (t, n) => n.toUpperCase());
}
function Ye(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function Zs(e) {
  return [" ", "_"].includes(
    e
  ) ? e : e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
}
function Js(e) {
  return ["keydown", "keyup"].includes(e);
}
function Rr(e) {
  return ["contextmenu", "click", "mouse"].some((t) => e.includes(t));
}
function Xs(e, t) {
  let n = t.filter((s) => !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(s));
  if (n.includes("debounce")) {
    let s = n.indexOf("debounce");
    n.splice(s, Ye((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (n.includes("throttle")) {
    let s = n.indexOf("throttle");
    n.splice(s, Ye((n[s + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
  }
  if (n.length === 0 || n.length === 1 && cn(e.key).includes(n[0]))
    return !1;
  const i = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter((s) => n.includes(s));
  return n = n.filter((s) => !i.includes(s)), !(i.length > 0 && i.filter((a) => ((a === "cmd" || a === "super") && (a = "meta"), e[`${a}Key`])).length === i.length && (Rr(e.type) || cn(e.key).includes(n[0])));
}
function cn(e) {
  if (!e)
    return [];
  e = Zs(e);
  let t = {
    ctrl: "control",
    slash: "/",
    space: " ",
    spacebar: " ",
    cmd: "meta",
    esc: "escape",
    up: "arrow-up",
    down: "arrow-down",
    left: "arrow-left",
    right: "arrow-right",
    period: ".",
    comma: ",",
    equal: "=",
    minus: "-",
    underscore: "_"
  };
  return t[e] = e, Object.keys(t).map((n) => {
    if (t[n] === e)
      return n;
  }).filter((n) => n);
}
O("model", (e, { modifiers: t, expression: n }, { effect: r, cleanup: i }) => {
  let s = e;
  t.includes("parent") && (s = e.parentNode);
  let a = R(s, n), o;
  typeof n == "string" ? o = R(s, `${n} = __placeholder`) : typeof n == "function" && typeof n() == "string" ? o = R(s, `${n()} = __placeholder`) : o = () => {
  };
  let c = () => {
    let h;
    return a((b) => h = b), ln(h) ? h.get() : h;
  }, l = (h) => {
    let b;
    a((T) => b = T), ln(b) ? b.set(h) : o(() => {
    }, {
      scope: { __placeholder: h }
    });
  };
  typeof n == "string" && e.type === "radio" && C(() => {
    e.hasAttribute("name") || e.setAttribute("name", n);
  });
  var u = e.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input";
  let f = Y ? () => {
  } : St(e, u, t, (h) => {
    l(at(e, t, h, c()));
  });
  if (t.includes("fill") && ([void 0, null, ""].includes(c()) || Wt(e) && Array.isArray(c()) || e.tagName.toLowerCase() === "select" && e.multiple) && l(
    at(e, t, { target: e }, c())
  ), e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = f, i(() => e._x_removeModelListeners.default()), e.form) {
    let h = St(e.form, "reset", [], (b) => {
      Bt(() => e._x_model && e._x_model.set(at(e, t, { target: e }, c())));
    });
    i(() => h());
  }
  e._x_model = {
    get() {
      return c();
    },
    set(h) {
      l(h);
    }
  }, e._x_forceModelUpdate = (h) => {
    h === void 0 && typeof n == "string" && n.match(/\./) && (h = ""), window.fromModel = !0, C(() => ir(e, "value", h)), delete window.fromModel;
  }, r(() => {
    let h = c();
    t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate(h);
  });
});
function at(e, t, n, r) {
  return C(() => {
    if (n instanceof CustomEvent && n.detail !== void 0)
      return n.detail !== null && n.detail !== void 0 ? n.detail : n.target.value;
    if (Wt(e))
      if (Array.isArray(r)) {
        let i = null;
        return t.includes("number") ? i = ot(n.target.value) : t.includes("boolean") ? i = Pe(n.target.value) : i = n.target.value, n.target.checked ? r.includes(i) ? r : r.concat([i]) : r.filter((s) => !Qs(s, i));
      } else
        return n.target.checked;
    else {
      if (e.tagName.toLowerCase() === "select" && e.multiple)
        return t.includes("number") ? Array.from(n.target.selectedOptions).map((i) => {
          let s = i.value || i.text;
          return ot(s);
        }) : t.includes("boolean") ? Array.from(n.target.selectedOptions).map((i) => {
          let s = i.value || i.text;
          return Pe(s);
        }) : Array.from(n.target.selectedOptions).map((i) => i.value || i.text);
      {
        let i;
        return cr(e) ? n.target.checked ? i = n.target.value : i = r : i = n.target.value, t.includes("number") ? ot(i) : t.includes("boolean") ? Pe(i) : t.includes("trim") ? i.trim() : i;
      }
    }
  });
}
function ot(e) {
  let t = e ? parseFloat(e) : null;
  return ea(t) ? t : e;
}
function Qs(e, t) {
  return e == t;
}
function ea(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function ln(e) {
  return e !== null && typeof e == "object" && typeof e.get == "function" && typeof e.set == "function";
}
O("cloak", (e) => queueMicrotask(() => C(() => e.removeAttribute(le("cloak")))));
Xn(() => `[${le("init")}]`);
O("init", V((e, { expression: t }, { evaluate: n }) => typeof t == "string" ? !!t.trim() && n(t, {}, !1) : n(t, {}, !1)));
O("text", (e, { expression: t }, { effect: n, evaluateLater: r }) => {
  let i = r(t);
  n(() => {
    i((s) => {
      C(() => {
        e.textContent = s;
      });
    });
  });
});
O("html", (e, { expression: t }, { effect: n, evaluateLater: r }) => {
  let i = r(t);
  n(() => {
    i((s) => {
      C(() => {
        e.innerHTML = s, e._x_ignoreSelf = !0, z(e), delete e._x_ignoreSelf;
      });
    });
  });
});
Dt(Wn(":", Hn(le("bind:"))));
var kr = (e, { value: t, modifiers: n, expression: r, original: i }, { effect: s, cleanup: a }) => {
  if (!t) {
    let c = {};
    ts(c), R(e, r)((u) => {
      hr(e, u, i);
    }, { scope: c });
    return;
  }
  if (t === "key")
    return ta(e, r);
  if (e._x_inlineBindings && e._x_inlineBindings[t] && e._x_inlineBindings[t].extract)
    return;
  let o = R(e, r);
  s(() => o((c) => {
    c === void 0 && typeof r == "string" && r.match(/\./) && (c = ""), C(() => ir(e, t, c, n));
  })), a(() => {
    e._x_undoAddedClasses && e._x_undoAddedClasses(), e._x_undoAddedStyles && e._x_undoAddedStyles();
  });
};
kr.inline = (e, { value: t, modifiers: n, expression: r }) => {
  t && (e._x_inlineBindings || (e._x_inlineBindings = {}), e._x_inlineBindings[t] = { expression: r, extract: !1 });
};
O("bind", kr);
function ta(e, t) {
  e._x_keyExpression = t;
}
Jn(() => `[${le("data")}]`);
O("data", (e, { expression: t }, { cleanup: n }) => {
  if (na(e))
    return;
  t = t === "" ? "{}" : t;
  let r = {};
  We(r, e);
  let i = {};
  rs(i, r);
  let s = J(e, t, { scope: i });
  (s === void 0 || s === !0) && (s = {}), We(s, e);
  let a = ae(s);
  kn(a);
  let o = Te(e, a);
  a.init && J(e, a.init), n(() => {
    a.destroy && J(e, a.destroy), o();
  });
});
Ze((e, t) => {
  e._x_dataStack && (t._x_dataStack = e._x_dataStack, t.setAttribute("data-has-alpine-state", !0));
});
function na(e) {
  return Y ? yt ? !0 : e.hasAttribute("data-has-alpine-state") : !1;
}
O("show", (e, { modifiers: t, expression: n }, { effect: r }) => {
  let i = R(e, n);
  e._x_doHide || (e._x_doHide = () => {
    C(() => {
      e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0);
    });
  }), e._x_doShow || (e._x_doShow = () => {
    C(() => {
      e.style.length === 1 && e.style.display === "none" ? e.removeAttribute("style") : e.style.removeProperty("display");
    });
  });
  let s = () => {
    e._x_doHide(), e._x_isShown = !1;
  }, a = () => {
    e._x_doShow(), e._x_isShown = !0;
  }, o = () => setTimeout(a), c = mt(
    (f) => f ? a() : s(),
    (f) => {
      typeof e._x_toggleAndCascadeWithTransitions == "function" ? e._x_toggleAndCascadeWithTransitions(e, f, a, s) : f ? o() : s();
    }
  ), l, u = !0;
  r(() => i((f) => {
    !u && f === l || (t.includes("immediate") && (f ? o() : s()), c(f), l = f, u = !1);
  }));
});
O("for", (e, { expression: t }, { effect: n, cleanup: r }) => {
  let i = ia(t), s = R(e, i.items), a = R(
    e,
    // the x-bind:key expression is stored for our use instead of evaluated.
    e._x_keyExpression || "index"
  );
  e._x_prevKeys = [], e._x_lookup = {}, n(() => ra(e, i, s, a)), r(() => {
    Object.values(e._x_lookup).forEach((o) => C(
      () => {
        de(o), o.remove();
      }
    )), delete e._x_prevKeys, delete e._x_lookup;
  });
});
function ra(e, t, n, r) {
  let i = (a) => typeof a == "object" && !Array.isArray(a), s = e;
  n((a) => {
    sa(a) && a >= 0 && (a = Array.from(Array(a).keys(), (g) => g + 1)), a === void 0 && (a = []);
    let o = e._x_lookup, c = e._x_prevKeys, l = [], u = [];
    if (i(a))
      a = Object.entries(a).map(([g, m]) => {
        let w = un(t, m, g, a);
        r((I) => {
          u.includes(I) && L("Duplicate key on x-for", e), u.push(I);
        }, { scope: { index: g, ...w } }), l.push(w);
      });
    else
      for (let g = 0; g < a.length; g++) {
        let m = un(t, a[g], g, a);
        r((w) => {
          u.includes(w) && L("Duplicate key on x-for", e), u.push(w);
        }, { scope: { index: g, ...m } }), l.push(m);
      }
    let f = [], h = [], b = [], T = [];
    for (let g = 0; g < c.length; g++) {
      let m = c[g];
      u.indexOf(m) === -1 && b.push(m);
    }
    c = c.filter((g) => !b.includes(g));
    let k = "template";
    for (let g = 0; g < u.length; g++) {
      let m = u[g], w = c.indexOf(m);
      if (w === -1)
        c.splice(g, 0, m), f.push([k, g]);
      else if (w !== g) {
        let I = c.splice(g, 1)[0], N = c.splice(w - 1, 1)[0];
        c.splice(g, 0, N), c.splice(w, 0, I), h.push([I, N]);
      } else
        T.push(m);
      k = m;
    }
    for (let g = 0; g < b.length; g++) {
      let m = b[g];
      m in o && (C(() => {
        de(o[m]), o[m].remove();
      }), delete o[m]);
    }
    for (let g = 0; g < h.length; g++) {
      let [m, w] = h[g], I = o[m], N = o[w], _ = document.createElement("div");
      C(() => {
        N || L('x-for ":key" is undefined or invalid', s, w, o), N.after(_), I.after(N), N._x_currentIfEl && N.after(N._x_currentIfEl), _.before(I), I._x_currentIfEl && I.after(I._x_currentIfEl), _.remove();
      }), N._x_refreshXForScope(l[u.indexOf(w)]);
    }
    for (let g = 0; g < f.length; g++) {
      let [m, w] = f[g], I = m === "template" ? s : o[m];
      I._x_currentIfEl && (I = I._x_currentIfEl);
      let N = l[w], _ = u[w], d = document.importNode(s.content, !0).firstElementChild, p = ae(N);
      Te(d, p, s), d._x_refreshXForScope = (v) => {
        Object.entries(v).forEach(([E, S]) => {
          p[E] = S;
        });
      }, C(() => {
        I.after(d), V(() => z(d))();
      }), typeof _ == "object" && L("x-for key cannot be an object, it must be a string or an integer", s), o[_] = d;
    }
    for (let g = 0; g < T.length; g++)
      o[T[g]]._x_refreshXForScope(l[u.indexOf(T[g])]);
    s._x_prevKeys = u;
  });
}
function ia(e) {
  let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = /^\s*\(|\)\s*$/g, r = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, i = e.match(r);
  if (!i)
    return;
  let s = {};
  s.items = i[2].trim();
  let a = i[1].replace(n, "").trim(), o = a.match(t);
  return o ? (s.item = a.replace(t, "").trim(), s.index = o[1].trim(), o[2] && (s.collection = o[2].trim())) : s.item = a, s;
}
function un(e, t, n, r) {
  let i = {};
  return /^\[.*\]$/.test(e.item) && Array.isArray(t) ? e.item.replace("[", "").replace("]", "").split(",").map((a) => a.trim()).forEach((a, o) => {
    i[a] = t[o];
  }) : /^\{.*\}$/.test(e.item) && !Array.isArray(t) && typeof t == "object" ? e.item.replace("{", "").replace("}", "").split(",").map((a) => a.trim()).forEach((a) => {
    i[a] = t[a];
  }) : i[e.item] = t, e.index && (i[e.index] = n), e.collection && (i[e.collection] = r), i;
}
function sa(e) {
  return !Array.isArray(e) && !isNaN(e);
}
function Lr() {
}
Lr.inline = (e, { expression: t }, { cleanup: n }) => {
  let r = Ue(e);
  r._x_refs || (r._x_refs = {}), r._x_refs[t] = e, n(() => delete r._x_refs[t]);
};
O("ref", Lr);
O("if", (e, { expression: t }, { effect: n, cleanup: r }) => {
  e.tagName.toLowerCase() !== "template" && L("x-if can only be used on a <template> tag", e);
  let i = R(e, t), s = () => {
    if (e._x_currentIfEl)
      return e._x_currentIfEl;
    let o = e.content.cloneNode(!0).firstElementChild;
    return Te(o, {}, e), C(() => {
      e.after(o), V(() => z(o))();
    }), e._x_currentIfEl = o, e._x_undoIf = () => {
      C(() => {
        de(o), o.remove();
      }), delete e._x_currentIfEl;
    }, o;
  }, a = () => {
    e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf);
  };
  n(() => i((o) => {
    o ? s() : a();
  })), r(() => e._x_undoIf && e._x_undoIf());
});
O("id", (e, { expression: t }, { evaluate: n }) => {
  n(t).forEach((i) => Ks(e, i));
});
Ze((e, t) => {
  e._x_ids && (t._x_ids = e._x_ids);
});
Dt(Wn("@", Hn(le("on:"))));
O("on", V((e, { value: t, modifiers: n, expression: r }, { cleanup: i }) => {
  let s = r ? R(e, r) : () => {
  };
  e.tagName.toLowerCase() === "template" && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t));
  let a = St(e, t, n, (o) => {
    s(() => {
    }, { scope: { $event: o }, params: [o] });
  });
  i(() => a());
}));
et("Collapse", "collapse", "collapse");
et("Intersect", "intersect", "intersect");
et("Focus", "trap", "focus");
et("Mask", "mask", "mask");
function et(e, t, n) {
  O(t, (r) => L(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r));
}
Oe.setEvaluator(ss);
Oe.setReactivityEngine({ reactive: Gt, effect: bs, release: ms, raw: x });
var aa = Oe, ie = aa;
function oa(e) {
  e.directive("collapse", t), t.inline = (n, { modifiers: r }) => {
    r.includes("min") && (n._x_doShow = () => {
    }, n._x_doHide = () => {
    });
  };
  function t(n, { modifiers: r }) {
    let i = dn(r, "duration", 250) / 1e3, s = dn(r, "min", 0), a = !r.includes("min");
    n._x_isShown || (n.style.height = `${s}px`), !n._x_isShown && a && (n.hidden = !0), n._x_isShown || (n.style.overflow = "hidden");
    let o = (l, u) => {
      let f = e.setStyles(l, u);
      return u.height ? () => {
      } : f;
    }, c = {
      transitionProperty: "height",
      transitionDuration: `${i}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    n._x_transition = {
      in(l = () => {
      }, u = () => {
      }) {
        a && (n.hidden = !1), a && (n.style.display = null);
        let f = n.getBoundingClientRect().height;
        n.style.height = "auto";
        let h = n.getBoundingClientRect().height;
        f === h && (f = s), e.transition(n, e.setStyles, {
          during: c,
          start: { height: f + "px" },
          end: { height: h + "px" }
        }, () => n._x_isShown = !0, () => {
          Math.abs(n.getBoundingClientRect().height - h) < 1 && (n.style.overflow = null);
        });
      },
      out(l = () => {
      }, u = () => {
      }) {
        let f = n.getBoundingClientRect().height;
        e.transition(n, o, {
          during: c,
          start: { height: f + "px" },
          end: { height: s + "px" }
        }, () => n.style.overflow = "hidden", () => {
          n._x_isShown = !1, n.style.height == `${s}px` && a && (n.style.display = "none", n.hidden = !0);
        });
      }
    };
  }
}
function dn(e, t, n) {
  if (e.indexOf(t) === -1)
    return n;
  const r = e[e.indexOf(t) + 1];
  if (!r)
    return n;
  if (t === "duration") {
    let i = r.match(/([0-9]+)ms/);
    if (i)
      return i[1];
  }
  if (t === "min") {
    let i = r.match(/([0-9]+)px/);
    if (i)
      return i[1];
  }
  return r;
}
var ca = oa;
function la(e) {
  e.directive("intersect", e.skipDuringClone((t, { value: n, expression: r, modifiers: i }, { evaluateLater: s, cleanup: a }) => {
    let o = s(r), c = {
      rootMargin: fa(i),
      threshold: ua(i)
    }, l = new IntersectionObserver((u) => {
      u.forEach((f) => {
        f.isIntersecting !== (n === "leave") && (o(), i.includes("once") && l.disconnect());
      });
    }, c);
    l.observe(t), a(() => {
      l.disconnect();
    });
  }));
}
function ua(e) {
  if (e.includes("full"))
    return 0.99;
  if (e.includes("half"))
    return 0.5;
  if (!e.includes("threshold"))
    return 0;
  let t = e[e.indexOf("threshold") + 1];
  return t === "100" ? 1 : t === "0" ? 0 : +`.${t}`;
}
function da(e) {
  let t = e.match(/^(-?[0-9]+)(px|%)?$/);
  return t ? t[1] + (t[2] || "px") : void 0;
}
function fa(e) {
  const t = "margin", n = "0px 0px 0px 0px", r = e.indexOf(t);
  if (r === -1)
    return n;
  let i = [];
  for (let s = 1; s < 5; s++)
    i.push(da(e[r + s] || ""));
  return i = i.filter((s) => s !== void 0), i.length ? i.join(" ").trim() : n;
}
var ha = la, $r = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], Ke = /* @__PURE__ */ $r.join(","), Fr = typeof Element > "u", ne = Fr ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, Ct = !Fr && Element.prototype.getRootNode ? function(e) {
  return e.getRootNode();
} : function(e) {
  return e.ownerDocument;
}, Mr = function(t, n, r) {
  var i = Array.prototype.slice.apply(t.querySelectorAll(Ke));
  return n && ne.call(t, Ke) && i.unshift(t), i = i.filter(r), i;
}, Dr = function e(t, n, r) {
  for (var i = [], s = Array.from(t); s.length; ) {
    var a = s.shift();
    if (a.tagName === "SLOT") {
      var o = a.assignedElements(), c = o.length ? o : a.children, l = e(c, !0, r);
      r.flatten ? i.push.apply(i, l) : i.push({
        scope: a,
        candidates: l
      });
    } else {
      var u = ne.call(a, Ke);
      u && r.filter(a) && (n || !t.includes(a)) && i.push(a);
      var f = a.shadowRoot || // check for an undisclosed shadow
      typeof r.getShadowRoot == "function" && r.getShadowRoot(a), h = !r.shadowRootFilter || r.shadowRootFilter(a);
      if (f && h) {
        var b = e(f === !0 ? a.children : f.children, !0, r);
        r.flatten ? i.push.apply(i, b) : i.push({
          scope: a,
          candidates: b
        });
      } else
        s.unshift.apply(s, a.children);
    }
  }
  return i;
}, Pr = function(t, n) {
  return t.tabIndex < 0 && (n || /^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || t.isContentEditable) && isNaN(parseInt(t.getAttribute("tabindex"), 10)) ? 0 : t.tabIndex;
}, pa = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, zr = function(t) {
  return t.tagName === "INPUT";
}, ga = function(t) {
  return zr(t) && t.type === "hidden";
}, va = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, ba = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, ma = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || Ct(t), r = function(o) {
    return n.querySelectorAll('input[type="radio"][name="' + o + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var s = ba(i, t.form);
  return !s || s === t;
}, _a = function(t) {
  return zr(t) && t.type === "radio";
}, ya = function(t) {
  return _a(t) && !ma(t);
}, fn = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, wa = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var s = ne.call(t, "details>summary:first-of-type"), a = s ? t.parentElement : t;
  if (ne.call(a, "details:not([open]) *"))
    return !0;
  var o = Ct(t).host, c = o?.ownerDocument.contains(o) || t.ownerDocument.contains(t);
  if (!r || r === "full") {
    if (typeof i == "function") {
      for (var l = t; t; ) {
        var u = t.parentElement, f = Ct(t);
        if (u && !u.shadowRoot && i(u) === !0)
          return fn(t);
        t.assignedSlot ? t = t.assignedSlot : !u && f !== t.ownerDocument ? t = f.host : t = u;
      }
      t = l;
    }
    if (c)
      return !t.getClientRects().length;
  } else if (r === "non-zero-area")
    return fn(t);
  return !1;
}, xa = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return ne.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, Ve = function(t, n) {
  return !(n.disabled || ga(n) || wa(n, t) || // For a details element with a summary, the summary element gets the focus
  va(n) || xa(n));
}, It = function(t, n) {
  return !(ya(n) || Pr(n) < 0 || !Ve(t, n));
}, Ea = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, Sa = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, s) {
    var a = !!i.scope, o = a ? i.scope : i, c = Pr(o, a), l = a ? e(i.candidates) : o;
    c === 0 ? a ? n.push.apply(n, l) : n.push(o) : r.push({
      documentOrder: s,
      tabIndex: c,
      item: i,
      isScope: a,
      content: l
    });
  }), r.sort(pa).reduce(function(i, s) {
    return s.isScope ? i.push.apply(i, s.content) : i.push(s.content), i;
  }, []).concat(n);
}, Ca = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = Dr([t], n.includeContainer, {
    filter: It.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: Ea
  }) : r = Mr(t, n.includeContainer, It.bind(null, n)), Sa(r);
}, Br = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = Dr([t], n.includeContainer, {
    filter: Ve.bind(null, n),
    flatten: !0,
    getShadowRoot: n.getShadowRoot
  }) : r = Mr(t, n.includeContainer, Ve.bind(null, n)), r;
}, Fe = function(t, n) {
  if (n = n || {}, !t)
    throw new Error("No node provided");
  return ne.call(t, Ke) === !1 ? !1 : It(n, t);
}, Ia = /* @__PURE__ */ $r.concat("iframe").join(","), ze = function(t, n) {
  if (n = n || {}, !t)
    throw new Error("No node provided");
  return ne.call(t, Ia) === !1 ? !1 : Ve(n, t);
};
function hn(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hn(Object(n), !0).forEach(function(r) {
      Ta(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hn(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ta(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var gn = /* @__PURE__ */ function() {
  var e = [];
  return {
    activateTrap: function(n) {
      if (e.length > 0) {
        var r = e[e.length - 1];
        r !== n && r.pause();
      }
      var i = e.indexOf(n);
      i === -1 || e.splice(i, 1), e.push(n);
    },
    deactivateTrap: function(n) {
      var r = e.indexOf(n);
      r !== -1 && e.splice(r, 1), e.length > 0 && e[e.length - 1].unpause();
    }
  };
}(), Oa = function(t) {
  return t.tagName && t.tagName.toLowerCase() === "input" && typeof t.select == "function";
}, Aa = function(t) {
  return t.key === "Escape" || t.key === "Esc" || t.keyCode === 27;
}, Na = function(t) {
  return t.key === "Tab" || t.keyCode === 9;
}, vn = function(t) {
  return setTimeout(t, 0);
}, bn = function(t, n) {
  var r = -1;
  return t.every(function(i, s) {
    return n(i) ? (r = s, !1) : !0;
  }), r;
}, ve = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
    r[i - 1] = arguments[i];
  return typeof t == "function" ? t.apply(void 0, r) : t;
}, Me = function(t) {
  return t.target.shadowRoot && typeof t.composedPath == "function" ? t.composedPath()[0] : t.target;
}, Ra = function(t, n) {
  var r = n?.document || document, i = pn({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0
  }, n), s = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  }, a, o = function(d, p, v) {
    return d && d[p] !== void 0 ? d[p] : i[v || p];
  }, c = function(d) {
    return s.containerGroups.findIndex(function(p) {
      var v = p.container, E = p.tabbableNodes;
      return v.contains(d) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      E.find(function(S) {
        return S === d;
      });
    });
  }, l = function(d) {
    var p = i[d];
    if (typeof p == "function") {
      for (var v = arguments.length, E = new Array(v > 1 ? v - 1 : 0), S = 1; S < v; S++)
        E[S - 1] = arguments[S];
      p = p.apply(void 0, E);
    }
    if (p === !0 && (p = void 0), !p) {
      if (p === void 0 || p === !1)
        return p;
      throw new Error("`".concat(d, "` was specified but was not a node, or did not return a node"));
    }
    var A = p;
    if (typeof p == "string" && (A = r.querySelector(p), !A))
      throw new Error("`".concat(d, "` as selector refers to no known node"));
    return A;
  }, u = function() {
    var d = l("initialFocus");
    if (d === !1)
      return !1;
    if (d === void 0)
      if (c(r.activeElement) >= 0)
        d = r.activeElement;
      else {
        var p = s.tabbableGroups[0], v = p && p.firstTabbableNode;
        d = v || l("fallbackFocus");
      }
    if (!d)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return d;
  }, f = function() {
    if (s.containerGroups = s.containers.map(function(d) {
      var p = Ca(d, i.tabbableOptions), v = Br(d, i.tabbableOptions);
      return {
        container: d,
        tabbableNodes: p,
        focusableNodes: v,
        firstTabbableNode: p.length > 0 ? p[0] : null,
        lastTabbableNode: p.length > 0 ? p[p.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(S) {
          var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, $ = v.findIndex(function(F) {
            return F === S;
          });
          if (!($ < 0))
            return A ? v.slice($ + 1).find(function(F) {
              return Fe(F, i.tabbableOptions);
            }) : v.slice(0, $).reverse().find(function(F) {
              return Fe(F, i.tabbableOptions);
            });
        }
      };
    }), s.tabbableGroups = s.containerGroups.filter(function(d) {
      return d.tabbableNodes.length > 0;
    }), s.tabbableGroups.length <= 0 && !l("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
  }, h = function _(d) {
    if (d !== !1 && d !== r.activeElement) {
      if (!d || !d.focus) {
        _(u());
        return;
      }
      d.focus({
        preventScroll: !!i.preventScroll
      }), s.mostRecentlyFocusedNode = d, Oa(d) && d.select();
    }
  }, b = function(d) {
    var p = l("setReturnFocus", d);
    return p || (p === !1 ? !1 : d);
  }, T = function(d) {
    var p = Me(d);
    if (!(c(p) >= 0)) {
      if (ve(i.clickOutsideDeactivates, d)) {
        a.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: i.returnFocusOnDeactivate && !ze(p, i.tabbableOptions)
        });
        return;
      }
      ve(i.allowOutsideClick, d) || d.preventDefault();
    }
  }, k = function(d) {
    var p = Me(d), v = c(p) >= 0;
    v || p instanceof Document ? v && (s.mostRecentlyFocusedNode = p) : (d.stopImmediatePropagation(), h(s.mostRecentlyFocusedNode || u()));
  }, g = function(d) {
    var p = Me(d);
    f();
    var v = null;
    if (s.tabbableGroups.length > 0) {
      var E = c(p), S = E >= 0 ? s.containerGroups[E] : void 0;
      if (E < 0)
        d.shiftKey ? v = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : v = s.tabbableGroups[0].firstTabbableNode;
      else if (d.shiftKey) {
        var A = bn(s.tabbableGroups, function(fe) {
          var nt = fe.firstTabbableNode;
          return p === nt;
        });
        if (A < 0 && (S.container === p || ze(p, i.tabbableOptions) && !Fe(p, i.tabbableOptions) && !S.nextTabbableNode(p, !1)) && (A = E), A >= 0) {
          var $ = A === 0 ? s.tabbableGroups.length - 1 : A - 1, F = s.tabbableGroups[$];
          v = F.lastTabbableNode;
        }
      } else {
        var q = bn(s.tabbableGroups, function(fe) {
          var nt = fe.lastTabbableNode;
          return p === nt;
        });
        if (q < 0 && (S.container === p || ze(p, i.tabbableOptions) && !Fe(p, i.tabbableOptions) && !S.nextTabbableNode(p)) && (q = E), q >= 0) {
          var Ae = q === s.tabbableGroups.length - 1 ? 0 : q + 1, tt = s.tabbableGroups[Ae];
          v = tt.firstTabbableNode;
        }
      }
    } else
      v = l("fallbackFocus");
    v && (d.preventDefault(), h(v));
  }, m = function(d) {
    if (Aa(d) && ve(i.escapeDeactivates, d) !== !1) {
      d.preventDefault(), a.deactivate();
      return;
    }
    if (Na(d)) {
      g(d);
      return;
    }
  }, w = function(d) {
    var p = Me(d);
    c(p) >= 0 || ve(i.clickOutsideDeactivates, d) || ve(i.allowOutsideClick, d) || (d.preventDefault(), d.stopImmediatePropagation());
  }, I = function() {
    if (s.active)
      return gn.activateTrap(a), s.delayInitialFocusTimer = i.delayInitialFocus ? vn(function() {
        h(u());
      }) : h(u()), r.addEventListener("focusin", k, !0), r.addEventListener("mousedown", T, {
        capture: !0,
        passive: !1
      }), r.addEventListener("touchstart", T, {
        capture: !0,
        passive: !1
      }), r.addEventListener("click", w, {
        capture: !0,
        passive: !1
      }), r.addEventListener("keydown", m, {
        capture: !0,
        passive: !1
      }), a;
  }, N = function() {
    if (s.active)
      return r.removeEventListener("focusin", k, !0), r.removeEventListener("mousedown", T, !0), r.removeEventListener("touchstart", T, !0), r.removeEventListener("click", w, !0), r.removeEventListener("keydown", m, !0), a;
  };
  return a = {
    get active() {
      return s.active;
    },
    get paused() {
      return s.paused;
    },
    activate: function(d) {
      if (s.active)
        return this;
      var p = o(d, "onActivate"), v = o(d, "onPostActivate"), E = o(d, "checkCanFocusTrap");
      E || f(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = r.activeElement, p && p();
      var S = function() {
        E && f(), I(), v && v();
      };
      return E ? (E(s.containers.concat()).then(S, S), this) : (S(), this);
    },
    deactivate: function(d) {
      if (!s.active)
        return this;
      var p = pn({
        onDeactivate: i.onDeactivate,
        onPostDeactivate: i.onPostDeactivate,
        checkCanReturnFocus: i.checkCanReturnFocus
      }, d);
      clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, N(), s.active = !1, s.paused = !1, gn.deactivateTrap(a);
      var v = o(p, "onDeactivate"), E = o(p, "onPostDeactivate"), S = o(p, "checkCanReturnFocus"), A = o(p, "returnFocus", "returnFocusOnDeactivate");
      v && v();
      var $ = function() {
        vn(function() {
          A && h(b(s.nodeFocusedBeforeActivation)), E && E();
        });
      };
      return A && S ? (S(b(s.nodeFocusedBeforeActivation)).then($, $), this) : ($(), this);
    },
    pause: function() {
      return s.paused || !s.active ? this : (s.paused = !0, N(), this);
    },
    unpause: function() {
      return !s.paused || !s.active ? this : (s.paused = !1, f(), I(), this);
    },
    updateContainerElements: function(d) {
      var p = [].concat(d).filter(Boolean);
      return s.containers = p.map(function(v) {
        return typeof v == "string" ? r.querySelector(v) : v;
      }), s.active && f(), this;
    }
  }, a.updateContainerElements(t), a;
};
function ka(e) {
  let t, n;
  window.addEventListener("focusin", () => {
    t = n, n = document.activeElement;
  }), e.magic("focus", (r) => {
    let i = r;
    return {
      __noscroll: !1,
      __wrapAround: !1,
      within(s) {
        return i = s, this;
      },
      withoutScrolling() {
        return this.__noscroll = !0, this;
      },
      noscroll() {
        return this.__noscroll = !0, this;
      },
      withWrapAround() {
        return this.__wrapAround = !0, this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(s) {
        return ze(s);
      },
      previouslyFocused() {
        return t;
      },
      lastFocused() {
        return t;
      },
      focused() {
        return n;
      },
      focusables() {
        return Array.isArray(i) ? i : Br(i, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(s) {
        let a = this.all();
        return a[0] && a[0].isSameNode(s);
      },
      isLast(s) {
        let a = this.all();
        return a.length && a.slice(-1)[0].isSameNode(s);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let s = this.all(), a = document.activeElement;
        if (s.indexOf(a) !== -1)
          return this.__wrapAround && s.indexOf(a) === s.length - 1 ? s[0] : s[s.indexOf(a) + 1];
      },
      getPrevious() {
        let s = this.all(), a = document.activeElement;
        if (s.indexOf(a) !== -1)
          return this.__wrapAround && s.indexOf(a) === 0 ? s.slice(-1)[0] : s[s.indexOf(a) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(s) {
        s && setTimeout(() => {
          s.hasAttribute("tabindex") || s.setAttribute("tabindex", "0"), s.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  }), e.directive("trap", e.skipDuringClone(
    (r, { expression: i, modifiers: s }, { effect: a, evaluateLater: o, cleanup: c }) => {
      let l = o(i), u = !1, f = {
        escapeDeactivates: !1,
        allowOutsideClick: !0,
        fallbackFocus: () => r
      };
      if (s.includes("noautofocus"))
        f.initialFocus = !1;
      else {
        let g = r.querySelector("[autofocus]");
        g && (f.initialFocus = g);
      }
      let h = Ra(r, f), b = () => {
      }, T = () => {
      };
      const k = () => {
        b(), b = () => {
        }, T(), T = () => {
        }, h.deactivate({
          returnFocus: !s.includes("noreturn")
        });
      };
      a(() => l((g) => {
        u !== g && (g && !u && (s.includes("noscroll") && (T = La()), s.includes("inert") && (b = mn(r)), setTimeout(() => {
          h.activate();
        }, 15)), !g && u && k(), u = !!g);
      })), c(k);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (r, { expression: i, modifiers: s }, { evaluate: a }) => {
      s.includes("inert") && a(i) && mn(r);
    }
  ));
}
function mn(e) {
  let t = [];
  return jr(e, (n) => {
    let r = n.hasAttribute("aria-hidden");
    n.setAttribute("aria-hidden", "true"), t.push(() => r || n.removeAttribute("aria-hidden"));
  }), () => {
    for (; t.length; )
      t.pop()();
  };
}
function jr(e, t) {
  e.isSameNode(document.body) || !e.parentNode || Array.from(e.parentNode.children).forEach((n) => {
    n.isSameNode(e) ? jr(e.parentNode, t) : t(n);
  });
}
function La() {
  let e = document.documentElement.style.overflow, t = document.documentElement.style.paddingRight, n = window.innerWidth - document.documentElement.clientWidth;
  return document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${n}px`, () => {
    document.documentElement.style.overflow = e, document.documentElement.style.paddingRight = t;
  };
}
var $a = ka;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function Fa(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ma(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function Da(e, t, n) {
  return t && Ma(e.prototype, t), e;
}
var Pa = Object.defineProperty, B = function(e, t) {
  return Pa(e, "name", { value: t, configurable: !0 });
}, za = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`, Ba = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`, ja = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, Wa = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, Ha = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`, Ya = B(function(e) {
  return new DOMParser().parseFromString(e, "text/html").body.childNodes[0];
}, "stringToHTML"), be = B(function(e) {
  var t = new DOMParser().parseFromString(e, "application/xml");
  return document.importNode(t.documentElement, !0).outerHTML;
}, "getSvgNode"), y = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, W = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, _n = { OUTLINE: "outline", FILLED: "filled" }, ct = { FADE: "fade", SLIDE: "slide" }, me = { CLOSE: be(za), SUCCESS: be(Wa), ERROR: be(Ba), WARNING: be(Ha), INFO: be(ja) }, yn = B(function(e) {
  e.wrapper.classList.add(y.NOTIFY_FADE), setTimeout(function() {
    e.wrapper.classList.add(y.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), wn = B(function(e) {
  e.wrapper.classList.remove(y.NOTIFY_FADE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "fadeOut"), Ka = B(function(e) {
  e.wrapper.classList.add(y.NOTIFY_SLIDE), setTimeout(function() {
    e.wrapper.classList.add(y.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), Va = B(function(e) {
  e.wrapper.classList.remove(y.NOTIFY_SLIDE_IN), setTimeout(function() {
    e.wrapper.remove();
  }, e.speed);
}, "slideOut"), Wr = function() {
  function e(t) {
    var n = this;
    Fa(this, e), this.notifyOut = B(function(fe) {
      fe(n);
    }, "notifyOut");
    var r = t.notificationsGap, i = r === void 0 ? 20 : r, s = t.notificationsPadding, a = s === void 0 ? 20 : s, o = t.status, c = o === void 0 ? "success" : o, l = t.effect, u = l === void 0 ? ct.FADE : l, f = t.type, h = f === void 0 ? "outline" : f, b = t.title, T = t.text, k = t.showIcon, g = k === void 0 ? !0 : k, m = t.customIcon, w = m === void 0 ? "" : m, I = t.customClass, N = I === void 0 ? "" : I, _ = t.speed, d = _ === void 0 ? 500 : _, p = t.showCloseButton, v = p === void 0 ? !0 : p, E = t.autoclose, S = E === void 0 ? !0 : E, A = t.autotimeout, $ = A === void 0 ? 3e3 : A, F = t.position, q = F === void 0 ? "right top" : F, Ae = t.customWrapper, tt = Ae === void 0 ? "" : Ae;
    if (this.customWrapper = tt, this.status = c, this.title = b, this.text = T, this.showIcon = g, this.customIcon = w, this.customClass = N, this.speed = d, this.effect = u, this.showCloseButton = v, this.autoclose = S, this.autotimeout = $, this.notificationsGap = i, this.notificationsPadding = a, this.type = h, this.position = q, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  return Da(e, [{ key: "checkRequirements", value: function() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function() {
    var n = document.querySelector(".".concat(y.CONTAINER));
    n ? this.container = n : (this.container = document.createElement("div"), this.container.classList.add(y.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function() {
    this.container.classList[this.position === "center" ? "add" : "remove"](y.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](y.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](y.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](y.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](y.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](y.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](y.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function() {
    var n = this, r = document.createElement("div");
    r.classList.add(y.NOTIFY_CLOSE), r.innerHTML = me.CLOSE, this.wrapper.appendChild(r), r.addEventListener("click", function() {
      n.close();
    });
  } }, { key: "setWrapper", value: function() {
    var n = this;
    switch (this.customWrapper ? this.wrapper = Ya(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(y.NOTIFY), this.type) {
      case _n.OUTLINE:
        this.wrapper.classList.add(y.NOTIFY_OUTLINE);
        break;
      case _n.FILLED:
        this.wrapper.classList.add(y.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(y.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case W.SUCCESS:
        this.wrapper.classList.add(y.NOTIFY_SUCCESS);
        break;
      case W.ERROR:
        this.wrapper.classList.add(y.NOTIFY_ERROR);
        break;
      case W.WARNING:
        this.wrapper.classList.add(y.NOTIFY_WARNING);
        break;
      case W.INFO:
        this.wrapper.classList.add(y.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(y.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(r) {
      n.wrapper.classList.add(r);
    });
  } }, { key: "setContent", value: function() {
    var n = document.createElement("div");
    n.classList.add(y.NOTIFY_CONTENT);
    var r, i;
    this.title && (r = document.createElement("div"), r.classList.add(y.NOTIFY_TITLE), r.textContent = this.title.trim(), this.showCloseButton || (r.style.paddingRight = "0")), this.text && (i = document.createElement("div"), i.classList.add(y.NOTIFY_TEXT), i.innerHTML = this.text.trim(), this.title || (i.style.marginTop = "0")), this.wrapper.appendChild(n), this.title && n.appendChild(r), this.text && n.appendChild(i);
  } }, { key: "setIcon", value: function() {
    var n = B(function(i) {
      switch (i) {
        case W.SUCCESS:
          return me.SUCCESS;
        case W.ERROR:
          return me.ERROR;
        case W.WARNING:
          return me.WARNING;
        case W.INFO:
          return me.INFO;
      }
    }, "computedIcon"), r = document.createElement("div");
    r.classList.add(y.NOTIFY_ICON), r.innerHTML = this.customIcon || n(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(r);
  } }, { key: "setObserver", value: function() {
    var n = this, r = new IntersectionObserver(function(i) {
      if (i[0].intersectionRatio <= 0) n.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      r.observe(n.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function(t) {
    t(this);
  } }, { key: "autoClose", value: function() {
    var n = this;
    setTimeout(function() {
      n.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function() {
    switch (this.effect) {
      case ct.FADE:
        this.selectedNotifyInEffect = yn, this.selectedNotifyOutEffect = wn;
        break;
      case ct.SLIDE:
        this.selectedNotifyInEffect = Ka, this.selectedNotifyOutEffect = Va;
        break;
      default:
        this.selectedNotifyInEffect = yn, this.selectedNotifyOutEffect = wn;
    }
  } }]), e;
}();
B(Wr, "Notify");
var Hr = Wr;
globalThis.Notify = Hr;
const Yr = ["success", "error", "warning", "info"], Kr = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
], Vr = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: !0,
  autotimeout: 4e3,
  position: "right top"
};
function _e(e = {}) {
  const t = {
    ...Vr,
    ...e
  };
  Yr.includes(t.status) || (console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`), t.status = "info"), Kr.includes(t.position) || (console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`), t.position = "right top"), new Hr(t);
}
const qa = {
  custom: _e,
  success(e, t = "Success", n = {}) {
    _e({
      status: "success",
      title: t,
      text: e,
      ...n
    });
  },
  error(e, t = "Error", n = {}) {
    _e({
      status: "error",
      title: t,
      text: e,
      ...n
    });
  },
  warning(e, t = "Warning", n = {}) {
    _e({
      status: "warning",
      title: t,
      text: e,
      ...n
    });
  },
  info(e, t = "Info", n = {}) {
    _e({
      status: "info",
      title: t,
      text: e,
      ...n
    });
  },
  setDefaults(e = {}) {
    Object.assign(Vr, e);
  },
  get allowedStatuses() {
    return [...Yr];
  },
  get allowedPositions() {
    return [...Kr];
  }
}, Tt = function() {
}, Ce = {}, qe = {}, Ie = {};
function Ua(e, t) {
  e = Array.isArray(e) ? e : [e];
  const n = [];
  let r = e.length, i = r, s, a, o, c;
  for (s = function(l, u) {
    u.length && n.push(l), i--, i || t(n);
  }; r--; ) {
    if (a = e[r], o = qe[a], o) {
      s(a, o);
      continue;
    }
    c = Ie[a] = Ie[a] || [], c.push(s);
  }
}
function qr(e, t) {
  if (!e) return;
  const n = Ie[e];
  if (qe[e] = t, !!n)
    for (; n.length; )
      n[0](e, t), n.splice(0, 1);
}
function Ot(e, t) {
  typeof e == "function" && (e = { success: e }), t.length ? (e.error || Tt)(t) : (e.success || Tt)(e);
}
function Ga(e, t, n, r, i, s, a, o) {
  let c = e.type[0];
  if (o)
    try {
      n.sheet.cssText.length || (c = "e");
    } catch (l) {
      l.code !== 18 && (c = "e");
    }
  if (c === "e") {
    if (s += 1, s < a)
      return Ur(t, r, i, s);
  } else if (n.rel === "preload" && n.as === "style") {
    n.rel = "stylesheet";
    return;
  }
  r(t, c, e.defaultPrevented);
}
function Ur(e, t, n, r) {
  const i = document, s = n.async, a = (n.numRetries || 0) + 1, o = n.before || Tt, c = e.replace(/[\?|#].*$/, ""), l = e.replace(/^(css|img|module|nomodule)!/, "");
  let u, f, h;
  if (r = r || 0, /(^css!|\.css$)/.test(c))
    h = i.createElement("link"), h.rel = "stylesheet", h.href = l, u = "hideFocus" in h, u && h.relList && (u = 0, h.rel = "preload", h.as = "style"), n.inlineStyleNonce && h.setAttribute("nonce", n.inlineStyleNonce);
  else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(c))
    h = i.createElement("img"), h.src = l;
  else if (h = i.createElement("script"), h.src = l, h.async = s === void 0 ? !0 : s, n.inlineScriptNonce && h.setAttribute("nonce", n.inlineScriptNonce), f = "noModule" in h, /^module!/.test(c)) {
    if (!f) return t(e, "l");
    h.type = "module";
  } else if (/^nomodule!/.test(c) && f)
    return t(e, "l");
  const b = function(T) {
    Ga(T, e, h, t, n, r, a, u);
  };
  h.addEventListener("load", b, { once: !0 }), h.addEventListener("error", b, { once: !0 }), o(e, h) !== !1 && i.head.appendChild(h);
}
function Za(e, t, n) {
  e = Array.isArray(e) ? e : [e];
  let r = e.length, i = [];
  function s(a, o, c) {
    if (o === "e" && i.push(a), o === "b")
      if (c) i.push(a);
      else return;
    r--, r || t(i);
  }
  for (let a = 0; a < e.length; a++)
    Ur(e[a], s, n);
}
function H(e, t, n) {
  let r, i;
  if (t && typeof t == "string" && t.trim && (r = t.trim()), i = (r ? n : t) || {}, r) {
    if (r in Ce)
      throw "LoadJS";
    Ce[r] = !0;
  }
  function s(a, o) {
    Za(e, function(c) {
      Ot(i, c), a && Ot({ success: a, error: o }, c), qr(r, c);
    }, i);
  }
  if (i.returnPromise)
    return new Promise(s);
  s();
}
H.ready = function(t, n) {
  return Ua(t, function(r) {
    Ot(n, r);
  }), H;
};
H.done = function(t) {
  qr(t, []);
};
H.reset = function() {
  Object.keys(Ce).forEach((t) => delete Ce[t]), Object.keys(qe).forEach((t) => delete qe[t]), Object.keys(Ie).forEach((t) => delete Ie[t]);
};
H.isDefined = function(t) {
  return t in Ce;
};
function Ja(e) {
  e.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: !1,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function Xa(e) {
  e.data("rzAccordionSection", () => ({
    open: !1,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true", this.sectionId = this.$el.dataset.sectionId, this.expandedClass = this.$el.dataset.expandedClass;
      const t = this;
      typeof this.selected < "u" && typeof this.allowMultiple < "u" ? this.$watch("selected", (n, r) => {
        n !== t.sectionId && !t.allowMultiple && (t.open = !1);
      }) : console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId, this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function Qa(e) {
  e.data("rzAlert", () => ({
    showAlert: !0,
    dismiss() {
      this.showAlert = !1;
    }
  }));
}
function eo(e) {
  e.data("rzBrowser", () => ({
    screenSize: "",
    setDesktopScreenSize() {
      this.screenSize = "";
    },
    setTabletScreenSize() {
      this.screenSize = "max-w-2xl";
    },
    setPhoneScreenSize() {
      this.screenSize = "max-w-sm";
    },
    // Get CSS classes for browser border based on screen size
    getBrowserBorderCss() {
      return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
    },
    // Get CSS classes for desktop screen button styling
    getDesktopScreenCss() {
      return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for tablet screen button styling
    getTabletScreenCss() {
      return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for phone screen button styling
    getPhoneScreenCss() {
      return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    }
  }));
}
function to(e) {
  e.data("rzCheckboxGroupItem", () => ({
    checkbox: null,
    isChecked: !1,
    init() {
      this.checkbox = this.$refs.chk, this.isChecked = this.checkbox.checked;
    },
    toggleCheckbox() {
      this.isChecked = this.checkbox.checked;
    },
    getIconCss() {
      return this.isChecked ? "" : "hidden";
    }
  }));
}
function no(e, t) {
  e.data("rzCodeViewer", () => ({
    expand: !1,
    border: !0,
    copied: !1,
    copyTitle: "Copy",
    // Default title
    copiedTitle: "Copied!",
    // Default title
    init() {
      const n = JSON.parse(this.$el.dataset.assets), r = this.$el.dataset.codeid, i = this.$el.dataset.nonce;
      this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle, this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle, t(n, {
        success: function() {
          const s = document.getElementById(r);
          window.hljs && s && window.hljs.highlightElement(s);
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, i);
    },
    // Function to check if code is NOT copied (for x-show)
    notCopied() {
      return !this.copied;
    },
    // Function to reset the copied state (e.g., on blur)
    disableCopied() {
      this.copied = !1;
    },
    // Function to toggle the expand state
    toggleExpand() {
      this.expand = !this.expand;
    },
    // Function to copy code to clipboard
    copyHTML() {
      navigator.clipboard.writeText(this.$refs.codeBlock.textContent), this.copied = !this.copied;
    },
    // Get the title for the copy button (copy/copied)
    getCopiedTitle() {
      return this.copied ? this.copiedTitle : this.copyTitle;
    },
    // Get CSS classes for the copy button based on copied state
    getCopiedCss() {
      return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
    },
    // Get CSS classes for the code container based on expand state
    getExpandCss() {
      return [this.expand ? "" : "max-h-60"];
    },
    // Get CSS classes for the expand button icon based on expand state
    getExpandButtonCss() {
      return this.expand ? "rotate-180" : "rotate-0";
    }
  }));
}
function ro(e, t) {
  e.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const n = this.$el.dataset.config, r = document.getElementById(this.$el.dataset.uid + "-input");
      if (n) {
        const a = JSON.parse(n);
        a && (this.options = a.options || {}, this.placeholder = a.placeholder || "", this.prependText = a.prependText || "");
      }
      const i = JSON.parse(this.$el.dataset.assets), s = this.$el.dataset.nonce;
      t(i, {
        success: function() {
          window.flatpickr && r && window.flatpickr(r, this.options);
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, s);
    }
  }));
}
function io(e) {
  e.data("rzDropdown", () => ({
    dropdownEl: null,
    anchorCss: "",
    dropdownOpen: !1,
    openedWithKeyboard: !1,
    init() {
      this.dropdownEl = this.$el, this.anchorCss = this.getAnchorCss();
    },
    toggleDropdown() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !this.dropdownOpen;
    },
    openDropdown() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !0, this.openedWithKeyboard = !1;
    },
    openWithKeyboard() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !0, this.openedWithKeyboard = !0, this.focusWrapNext();
    },
    closeDropdown() {
      this.dropdownOpen = !1, this.openedWithKeyboard = !1;
    },
    focusWrapNext() {
      this.$focus.wrap().next();
    },
    focusWrapPrevious() {
      this.$focus.wrap().previous();
    },
    // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
    getAnchorCss() {
      let n = (this.dropdownEl.getAttribute("data-anchor") || "").replace(/-/g, "").toLowerCase();
      const r = {
        topstart: "bottom-full right-0 mb-2 origin-bottom-right",
        topcenter: "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
        topend: "bottom-full left-0 mb-2 origin-bottom-left",
        start: "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
        end: "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
        bottomstart: "right-0 mt-2 origin-top-right",
        bottomcenter: "-translate-x-1/2 mt-2 origin-top",
        bottomend: "left-0 mt-2 origin-top-left"
      };
      let i = r[n] || "";
      const s = this.dropdownEl.getBoundingClientRect();
      let a = document.createElement("div");
      a.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;", this.dropdownEl.appendChild(a);
      const o = this.dropdownEl.querySelector('[role="menu"]');
      if (!o)
        return i;
      let c = o.cloneNode(!0);
      c.style.transition = "none", c.style.transform = "none", c.style.opacity = "1", c.style.display = "block", a.appendChild(c);
      let l = c.getBoundingClientRect();
      a.parentNode.removeChild(a);
      const u = 8;
      let f = !1;
      if (n.startsWith("top") ? s.top < l.height + u && (f = !0) : n.startsWith("bottom") ? s.bottom + l.height + u > window.innerHeight && (f = !0) : n === "start" ? s.left < l.width + u && (f = !0) : n === "end" && s.right + l.width + u > window.innerWidth && (f = !0), f) {
        let b = {
          topstart: "bottomstart",
          topcenter: "bottomcenter",
          topend: "bottomend",
          bottomstart: "topstart",
          bottomcenter: "topcenter",
          bottomend: "topend",
          start: "end",
          end: "start"
        }[n] || n;
        i = r[b] || i;
      }
      return i;
    }
  }));
}
function so(e) {
  e.data("rzDarkModeToggle", () => ({
    mode: "light",
    applyTheme: null,
    init() {
      const t = typeof window < "u" && "localStorage" in window, n = ["light", "dark", "auto"], r = window.matchMedia("(prefers-color-scheme: dark)").matches;
      let i = "auto";
      t && (i = localStorage.getItem("darkMode") ?? "auto", n.includes(i) || (i = "light")), t && localStorage.setItem("darkMode", i), this.applyTheme = () => {
        document.documentElement.classList.toggle(
          "dark",
          i === "dark" || i === "auto" && r
        );
      }, this.applyTheme(), window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
    },
    // Returns true if dark mode should be active
    isDark() {
      const t = window.matchMedia("(prefers-color-scheme: dark)").matches;
      return localStorage.getItem("darkMode"), this.mode === "dark" || this.mode === "auto" && t;
    },
    // Returns true if light mode should be active
    isLight() {
      return !this.isDark();
    },
    // Toggle the dark mode setting and dispatch a custom event
    toggle() {
      let t = localStorage.getItem("darkMode");
      const n = window.matchMedia("(prefers-color-scheme: dark)").matches;
      t === "light" ? t = "dark" : t === "dark" ? t = "light" : t === "auto" && (t = n ? "light" : "dark"), this.mode = t, localStorage.setItem("darkMode", t);
      const r = t === "dark" || t === "auto" && n;
      document.documentElement.classList.toggle("dark", r);
      const i = new CustomEvent("darkModeToggle", {
        detail: { darkMode: r }
      });
      window.dispatchEvent(i);
    },
    destroy() {
      this.applyTheme && window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
    }
  }));
}
function ao(e) {
  e.data("rzEmbeddedPreview", () => ({
    iframe: null,
    onDarkModeToggle: null,
    init() {
      try {
        this.iframe = this.$refs.iframe;
        const t = this.debounce(() => {
          this.resizeIframe(this.iframe);
        }, 50);
        this.resizeIframe(this.iframe), new ResizeObserver((i) => {
          for (let s of i)
            t();
        }).observe(this.iframe);
        const r = this.iframe;
        this.onDarkModeToggle = (i) => {
          r.contentWindow.postMessage(i.detail, "*");
        }, window.addEventListener("darkModeToggle", this.onDarkModeToggle);
      } catch {
        console.error("Cannot access iframe content");
      }
    },
    // Adjusts the iframe height based on its content
    resizeIframe(t) {
      if (t)
        try {
          const n = t.contentDocument || t.contentWindow?.document;
          if (n) {
            const r = n.body;
            if (!r)
              setInterval(() => {
                this.resizeIframe(t);
              }, 150);
            else {
              const i = r.scrollHeight + 15;
              t.style.height = i + "px";
            }
          }
        } catch (n) {
          console.error("Error resizing iframe:", n);
        }
    },
    // Debounce helper to limit function calls
    debounce(t, n = 300) {
      let r;
      return (...i) => {
        clearTimeout(r), r = setTimeout(() => {
          t.apply(this, i);
        }, n);
      };
    },
    destroy() {
      window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
    }
  }));
}
function oo(e) {
  e.data("rzEmpty", () => {
  });
}
function co(e) {
  e.data("rzHeading", () => ({
    observer: null,
    headingId: "",
    init() {
      this.headingId = this.$el.dataset.alpineRoot;
      const t = this;
      if (typeof this.setCurrentHeading == "function") {
        const n = (i, s) => {
          i.forEach((a) => {
            a.isIntersecting && t.setCurrentHeading(t.headingId);
          });
        }, r = { threshold: 0.5 };
        this.observer = new IntersectionObserver(n, r), this.observer.observe(this.$el);
      } else
        console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
    },
    destroy() {
      this.observer != null && this.observer.disconnect();
    }
  }));
}
function lo(e, t) {
  e.data("rzMarkdown", () => ({
    init() {
      const n = JSON.parse(this.$el.dataset.assets), r = this.$el.dataset.nonce;
      t(n, {
        success: function() {
          window.hljs.highlightAll();
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, r);
    }
  }));
}
function uo(e) {
  e.data("rzModal", () => ({
    modalOpen: !1,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: !0,
    closeOnClickOutside: !0,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "", this.bodyId = this.$el.dataset.bodyId || "", this.footerId = this.$el.dataset.footerId || "", this.nonce = this.$el.dataset.nonce || "", this.eventTriggerName = this.$el.dataset.eventTriggerName || "", this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName, this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false", this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false", this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: !0
      })), this.eventTriggerName && (this._openListener = (t) => {
        this.openModal(t);
      }, window.addEventListener(this.eventTriggerName, this._openListener)), this._closeEventListener = (t) => {
        this.modalOpen && this.closeModalInternally("event");
      }, window.addEventListener(this.closeEventName, this._closeEventListener), this._escapeListener = (t) => {
        this.modalOpen && this.closeOnEscape && t.key === "Escape" && this.closeModalInternally("escape");
      }, window.addEventListener("keydown", this._escapeListener), this.$watch("modalOpen", (t) => {
        const n = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", t);
        const r = document.body.offsetWidth - n;
        document.body.style.setProperty("--page-scrollbar-width", `${r}px`), t ? this.$nextTick(() => {
          this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(), this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        }) : this.$nextTick(() => {
          this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        });
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      this._openListener && this.eventTriggerName && window.removeEventListener(this.eventTriggerName, this._openListener), this._closeEventListener && window.removeEventListener(this.closeEventName, this._closeEventListener), this._escapeListener && window.removeEventListener("keydown", this._escapeListener), document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px");
    },
    openModal(t = null) {
      const n = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(n), n.defaultPrevented || (this.modalOpen = !0);
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(t = "unknown") {
      const n = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason: t },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(n), n.defaultPrevented || (document.activeElement?.blur && document.activeElement.blur(), this.modalOpen = !1, document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px"));
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      this.closeOnClickOutside && this.closeModalInternally("backdrop");
    }
  }));
}
function fo(e) {
  e.data("rzPrependInput", () => ({
    prependContainer: null,
    textInput: null,
    init() {
      this.prependContainer = this.$refs.prependContainer, this.textInput = this.$refs.textInput;
      let t = this;
      setTimeout(() => {
        t.updatePadding();
      }, 50), window.addEventListener("resize", this.updatePadding);
    },
    destroy() {
      window.removeEventListener("resize", this.updatePadding);
    },
    updatePadding() {
      const t = this.prependContainer, n = this.textInput;
      if (!t || !n) {
        n && n.classList.remove("text-transparent");
        return;
      }
      const i = t.offsetWidth + 10;
      n.style.paddingLeft = i + "px", n.classList.remove("text-transparent");
    }
  }));
}
function ho(e) {
  e.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const t = this.$el;
      this.currentVal = parseInt(t.getAttribute("data-current-val")) || 0, this.minVal = parseInt(t.getAttribute("data-min-val")) || 0, this.maxVal = parseInt(t.getAttribute("data-max-val")) || 100, this.label = t.getAttribute("data-label"), this.calculatePercentage(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuemin", this.minVal), t.setAttribute("aria-valuemax", this.maxVal), t.setAttribute("aria-valuetext", `${this.percentage}%`), this.updateProgressBar(), new ResizeObserver((r) => {
        this.updateProgressBar();
      }).observe(t), this.$watch("currentVal", () => {
        this.calculatePercentage(), this.updateProgressBar(), t.setAttribute("aria-valuenow", this.currentVal), t.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      this.maxVal === this.minVal ? this.percentage = 0 : this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
    },
    buildLabel() {
      var t = this.label || "{percent}%";
      return this.calculatePercentage(), t.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const t = this.$refs.progressBar, n = this.$refs.progressBarLabel, r = this.$refs.innerLabel;
      n && t && r && (r.innerText = this.buildLabel(), n.clientWidth > t.clientWidth ? n.style.left = t.clientWidth + 10 + "px" : n.style.left = t.clientWidth / 2 - n.clientWidth / 2 + "px");
    },
    getLabelCss() {
      const t = this.$refs.progressBarLabel, n = this.$refs.progressBar;
      return t && n && t.clientWidth > n.clientWidth ? "text-foreground dark:text-foreground" : "";
    },
    updateProgressBar() {
      const t = this.$refs.progressBar;
      t && (t.style.width = `${this.percentage}%`, this.buildInsideLabelPosition());
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(t) {
      this.currentVal = t;
    },
    increment(t = 1) {
      this.currentVal = Math.min(this.currentVal + t, this.maxVal);
    },
    decrement(t = 1) {
      this.currentVal = Math.max(this.currentVal - t, this.minVal);
    }
  }));
}
function po(e) {
  e.data("rzQuickReferenceContainer", () => ({
    headings: [],
    // Array of heading IDs
    currentHeadingId: "",
    // ID of the currently highlighted heading
    // Initializes the component with headings and the initial current heading from data attributes.
    init() {
      this.headings = JSON.parse(this.$el.dataset.headings || "[]"), this.currentHeadingId = this.$el.dataset.currentheadingid || "";
    },
    // Handles click events on quick reference links.
    handleHeadingClick() {
      const t = this.$el.dataset.headingid;
      window.requestAnimationFrame(() => {
        this.currentHeadingId = t;
      });
    },
    // Sets the current heading ID based on intersection observer events from rzHeading.
    setCurrentHeading(t) {
      this.headings.includes(t) && (this.currentHeadingId = t);
    },
    // Provides CSS classes for a link based on whether it's the current heading.
    // Returns an object suitable for :class binding.
    getSelectedCss() {
      const t = this.$el.dataset.headingid;
      return {
        "font-bold": this.currentHeadingId === t
        // Apply 'font-bold' if current
      };
    },
    // Determines the value for the aria-current attribute.
    getSelectedAriaCurrent() {
      const t = this.$el.dataset.headingid;
      return this.currentHeadingId === t ? "true" : null;
    }
  }));
}
function go(e) {
  e.data("rzTabs", () => ({
    buttonRef: null,
    tabSelected: "",
    tabButton: null,
    init() {
      this.buttonRef = document.getElementById(this.$el.dataset.buttonref), this.tabSelected = this.$el.dataset.tabselected, this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']"), this.tabRepositionMarker(this.tabButton);
    },
    tabButtonClicked(t) {
      t instanceof Event && (t = t.target), this.tabSelected = t.dataset.name, this.tabRepositionMarker(t), t.focus();
    },
    tabRepositionMarker(t) {
      this.tabButton = t, this.$refs.tabMarker.style.width = t.offsetWidth + "px", this.$refs.tabMarker.style.height = t.offsetHeight + "px", this.$refs.tabMarker.style.left = t.offsetLeft + "px", setTimeout(() => {
        this.$refs.tabMarker.style.opacity = 1;
      }, 150);
    },
    // Get the CSS classes for the tab content panel based on selection
    getTabContentCss() {
      return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
    },
    tabContentActive(t) {
      return t = t ?? this.$el, this.tabSelected === t.dataset.name;
    },
    tabButtonActive(t) {
      return t = t ?? this.$el, this.tabSelected === t.dataset.name;
    },
    // Get the value for the aria-selected attribute
    getTabButtonAriaSelected() {
      return this.tabSelected === this.$el.dataset.name ? "true" : "false";
    },
    // Get the CSS classes for the tab button text color based on selection
    getSelectedTabTextColorCss() {
      const t = this.$el.dataset.selectedtextcolor ?? "";
      return this.tabSelected === this.$el.dataset.name ? t : "";
    },
    handleResize() {
      this.tabRepositionMarker(this.tabButton);
    },
    handleKeyDown(t) {
      const n = t.key, r = Array.from(this.buttonRef.querySelectorAll("[role='tab']")), i = r.findIndex((a) => this.tabSelected === a.dataset.name);
      let s = i;
      n === "ArrowRight" ? (s = (i + 1) % r.length, t.preventDefault()) : n === "ArrowLeft" ? (s = (i - 1 + r.length) % r.length, t.preventDefault()) : n === "Home" ? (s = 0, t.preventDefault()) : n === "End" && (s = r.length - 1, t.preventDefault()), s !== i && this.tabButtonClicked(r[s]);
    }
  }));
}
function vo(e) {
  e.data("rzSidebar", () => ({
    showSidebar: !1,
    isSidebarHidden() {
      return !this.showSidebar;
    },
    toggleSidebar() {
      this.showSidebar = !this.showSidebar;
    },
    hideSidebar() {
      this.showSidebar = !1;
    },
    // Return translation classes based on sidebar state for smooth slide-in/out
    getSidebarTranslation() {
      return this.showSidebar ? "translate-x-0" : "-translate-x-60";
    }
  }));
}
function bo(e) {
  e.data("rzSidebarLinkItem", () => ({
    isExpanded: !1,
    chevronExpandedClass: "",
    chevronCollapsedClass: "",
    init() {
      this.isExpanded = this.$el.dataset.expanded === "true", this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass, this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
    },
    isCollapsed() {
      return !this.isExpanded;
    },
    toggleExpanded() {
      this.isExpanded = !this.isExpanded;
    },
    hideSidebar() {
      const t = this.$el.closest('[x-data^="rzSidebar"]');
      if (t) {
        let n = e.$data(t);
        n.showSidebar = !1;
      } else
        console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
    },
    getExpandedClass() {
      return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
    },
    // Get the value for the aria-expanded attribute
    getAriaExpanded() {
      return this.isExpanded ? "true" : "false";
    }
  }));
}
async function mo(e) {
  e = [...e].sort();
  const t = e.join("|"), r = new TextEncoder().encode(t), i = await crypto.subtle.digest("SHA-256", r);
  return Array.from(new Uint8Array(i)).map((a) => a.toString(16).padStart(2, "0")).join("");
}
function Be(e, t, n) {
  mo(e).then((r) => {
    H.isDefined(r) || H(
      e,
      r,
      {
        async: !1,
        inlineScriptNonce: n,
        inlineStyleNonce: n
      }
    ), H.ready([r], t);
  });
}
function _o(e) {
  Ja(e), Xa(e), Qa(e), eo(e), to(e), no(e, Be), ro(e, Be), io(e), so(e), ao(e), oo(e), co(e), lo(e, Be), uo(e), fo(e), ho(e), po(e), go(e), vo(e), bo(e);
}
function yo(e) {
  if (typeof Alpine > "u" || typeof Alpine.$data != "function") {
    console.error(
      "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
    );
    return;
  }
  let t = null, n = null;
  if (typeof e == "string") {
    if (!e) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return;
    }
    if (n = e, t = document.getElementById(n), !t) {
      console.warn(`Rizzy.$data: Rizzy component with ID "${n}" not found in the DOM.`);
      return;
    }
  } else if (e instanceof Element) {
    if (t = e, !t.id) {
      console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
      return;
    }
    n = t.id;
  } else {
    console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
    return;
  }
  const r = `[data-alpine-root="${n}"]`;
  let i = null;
  if (t.matches(r) ? i = t : i = t.querySelector(r), !i) {
    console.warn(
      `Rizzy.$data: Could not locate the designated Alpine root element using selector "${r}" on or inside the wrapper element (ID: #${n}). Verify the 'data-alpine-root' attribute placement.`
    );
    return;
  }
  const s = Alpine.$data(i);
  if (s === void 0) {
    const a = `${i.tagName.toLowerCase()}${i.id ? "#" + i.id : ""}${i.classList.length ? "." + Array.from(i.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located designated Alpine root (${a}) via 'data-alpine-root="${n}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
    );
  }
  return s;
}
ie.plugin(ca);
ie.plugin(ha);
ie.plugin($a);
_o(ie);
const wo = {
  Alpine: ie,
  require: Be,
  toast: qa,
  $data: yo
};
window.Alpine = ie;
window.Rizzy = { ...window.Rizzy || {}, ...wo };
ie.start();
export {
  wo as default
};
</file>

<file path="wwwroot/js/rizzyui-csp.min.umd.js">
(function(q,U){typeof exports=="object"&&typeof module<"u"?module.exports=U():typeof define=="function"&&define.amd?define(U):(q=typeof globalThis<"u"?globalThis:q||self,q.RizzyUICsp=U())})(this,function(){"use strict";var q=!1,U=!1,G=[],rt=-1;function Zr(e){Jr(e)}function Jr(e){G.includes(e)||G.push(e),Qr()}function Xr(e){let t=G.indexOf(e);t!==-1&&t>rt&&G.splice(t,1)}function Qr(){!U&&!q&&(q=!0,queueMicrotask(ei))}function ei(){q=!1,U=!0;for(let e=0;e<G.length;e++)G[e](),rt=e;G.length=0,rt=-1,U=!1}var ae,Z,ce,Zt,it=!0;function ti(e){it=!1,e(),it=!0}function ni(e){ae=e.reactive,ce=e.release,Z=t=>e.effect(t,{scheduler:n=>{it?Zr(n):n()}}),Zt=e.raw}function Jt(e){Z=e}function ri(e){let t=()=>{};return[r=>{let i=Z(r);return e._x_effects||(e._x_effects=new Set,e._x_runEffects=()=>{e._x_effects.forEach(s=>s())}),e._x_effects.add(i),t=()=>{i!==void 0&&(e._x_effects.delete(i),ce(i))},i},()=>{t()}]}function Xt(e,t){let n=!0,r,i=Z(()=>{let s=e();JSON.stringify(s),n?r=s:queueMicrotask(()=>{t(s,r),r=s}),n=!1});return()=>ce(i)}var Qt=[],en=[],tn=[];function ii(e){tn.push(e)}function st(e,t){typeof t=="function"?(e._x_cleanups||(e._x_cleanups=[]),e._x_cleanups.push(t)):(t=e,en.push(t))}function nn(e){Qt.push(e)}function rn(e,t,n){e._x_attributeCleanups||(e._x_attributeCleanups={}),e._x_attributeCleanups[t]||(e._x_attributeCleanups[t]=[]),e._x_attributeCleanups[t].push(n)}function sn(e,t){e._x_attributeCleanups&&Object.entries(e._x_attributeCleanups).forEach(([n,r])=>{(t===void 0||t.includes(n))&&(r.forEach(i=>i()),delete e._x_attributeCleanups[n])})}function si(e){for(e._x_effects?.forEach(Xr);e._x_cleanups?.length;)e._x_cleanups.pop()()}var ot=new MutationObserver(ut),at=!1;function ct(){ot.observe(document,{subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0}),at=!0}function on(){oi(),ot.disconnect(),at=!1}var pe=[];function oi(){let e=ot.takeRecords();pe.push(()=>e.length>0&&ut(e));let t=pe.length;queueMicrotask(()=>{if(pe.length===t)for(;pe.length>0;)pe.shift()()})}function C(e){if(!at)return e();on();let t=e();return ct(),t}var lt=!1,Re=[];function ai(){lt=!0}function ci(){lt=!1,ut(Re),Re=[]}function ut(e){if(lt){Re=Re.concat(e);return}let t=[],n=new Set,r=new Map,i=new Map;for(let s=0;s<e.length;s++)if(!e[s].target._x_ignoreMutationObserver&&(e[s].type==="childList"&&(e[s].removedNodes.forEach(o=>{o.nodeType===1&&o._x_marker&&n.add(o)}),e[s].addedNodes.forEach(o=>{if(o.nodeType===1){if(n.has(o)){n.delete(o);return}o._x_marker||t.push(o)}})),e[s].type==="attributes")){let o=e[s].target,a=e[s].attributeName,c=e[s].oldValue,l=()=>{r.has(o)||r.set(o,[]),r.get(o).push({name:a,value:o.getAttribute(a)})},u=()=>{i.has(o)||i.set(o,[]),i.get(o).push(a)};o.hasAttribute(a)&&c===null?l():o.hasAttribute(a)?(u(),l()):u()}i.forEach((s,o)=>{sn(o,s)}),r.forEach((s,o)=>{Qt.forEach(a=>a(o,s))});for(let s of n)t.some(o=>o.contains(s))||en.forEach(o=>o(s));for(let s of t)s.isConnected&&tn.forEach(o=>o(s));t=null,n=null,r=null,i=null}function an(e){return le(J(e))}function ge(e,t,n){return e._x_dataStack=[t,...J(n||e)],()=>{e._x_dataStack=e._x_dataStack.filter(r=>r!==t)}}function J(e){return e._x_dataStack?e._x_dataStack:typeof ShadowRoot=="function"&&e instanceof ShadowRoot?J(e.host):e.parentNode?J(e.parentNode):[]}function le(e){return new Proxy({objects:e},li)}var li={ownKeys({objects:e}){return Array.from(new Set(e.flatMap(t=>Object.keys(t))))},has({objects:e},t){return t==Symbol.unscopables?!1:e.some(n=>Object.prototype.hasOwnProperty.call(n,t)||Reflect.has(n,t))},get({objects:e},t,n){return t=="toJSON"?ui:Reflect.get(e.find(r=>Reflect.has(r,t))||{},t,n)},set({objects:e},t,n,r){const i=e.find(o=>Object.prototype.hasOwnProperty.call(o,t))||e[e.length-1],s=Object.getOwnPropertyDescriptor(i,t);return s?.set&&s?.get?s.set.call(r,n)||!0:Reflect.set(i,t,n)}};function ui(){return Reflect.ownKeys(this).reduce((t,n)=>(t[n]=Reflect.get(this,n),t),{})}function cn(e){let t=r=>typeof r=="object"&&!Array.isArray(r)&&r!==null,n=(r,i="")=>{Object.entries(Object.getOwnPropertyDescriptors(r)).forEach(([s,{value:o,enumerable:a}])=>{if(a===!1||o===void 0||typeof o=="object"&&o!==null&&o.__v_skip)return;let c=i===""?s:`${i}.${s}`;typeof o=="object"&&o!==null&&o._x_interceptor?r[s]=o.initialize(e,c,s):t(o)&&o!==r&&!(o instanceof Element)&&n(o,c)})};return n(e)}function ln(e,t=()=>{}){let n={initialValue:void 0,_x_interceptor:!0,initialize(r,i,s){return e(this.initialValue,()=>di(r,i),o=>dt(r,i,o),i,s)}};return t(n),r=>{if(typeof r=="object"&&r!==null&&r._x_interceptor){let i=n.initialize.bind(n);n.initialize=(s,o,a)=>{let c=r.initialize(s,o,a);return n.initialValue=c,i(s,o,a)}}else n.initialValue=r;return n}}function di(e,t){return t.split(".").reduce((n,r)=>n[r],e)}function dt(e,t,n){if(typeof t=="string"&&(t=t.split(".")),t.length===1)e[t[0]]=n;else{if(t.length===0)throw error;return e[t[0]]||(e[t[0]]={}),dt(e[t[0]],t.slice(1),n)}}var un={};function $(e,t){un[e]=t}function ke(e,t){let n=fi(t);return Object.entries(un).forEach(([r,i])=>{Object.defineProperty(e,`$${r}`,{get(){return i(t,n)},enumerable:!1})}),e}function fi(e){let[t,n]=bn(e),r={interceptor:ln,...t};return st(e,n),r}function dn(e,t,n,...r){try{return n(...r)}catch(i){ve(i,e,t)}}function ve(e,t,n=void 0){e=Object.assign(e??{message:"No error message given."},{el:t,expression:n}),console.warn(`Alpine Expression Error: ${e.message}
${n?'Expression: "'+n+`"
`:""}`,t),setTimeout(()=>{throw e},0)}var Le=!0;function fn(e){let t=Le;Le=!1;let n=e();return Le=t,n}function X(e,t,n={}){let r;return R(e,t)(i=>r=i,n),r}function R(...e){return hn(...e)}var hn=pi;function hi(e){hn=e}function pi(e,t){let n={};ke(n,e);let r=[n,...J(e)],i=typeof t=="function"?pn(r,t):vi(r,t,e);return dn.bind(null,e,t,i)}function pn(e,t){return(n=()=>{},{scope:r={},params:i=[]}={})=>{let s=t.apply(le([r,...e]),i);be(n,s)}}var ft={};function gi(e,t){if(ft[e])return ft[e];let n=Object.getPrototypeOf(async function(){}).constructor,r=/^[\n\s]*if.*\(.*\)/.test(e.trim())||/^(let|const)\s/.test(e.trim())?`(async()=>{ ${e} })()`:e,s=(()=>{try{let o=new n(["__self","scope"],`with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`);return Object.defineProperty(o,"name",{value:`[Alpine] ${e}`}),o}catch(o){return ve(o,t,e),Promise.resolve()}})();return ft[e]=s,s}function vi(e,t,n){let r=gi(t,n);return(i=()=>{},{scope:s={},params:o=[]}={})=>{r.result=void 0,r.finished=!1;let a=le([s,...e]);if(typeof r=="function"){let c=r(r,a).catch(l=>ve(l,n,t));r.finished?(be(i,r.result,a,o,n),r.result=void 0):c.then(l=>{be(i,l,a,o,n)}).catch(l=>ve(l,n,t)).finally(()=>r.result=void 0)}}}function be(e,t,n,r,i){if(Le&&typeof t=="function"){let s=t.apply(n,r);s instanceof Promise?s.then(o=>be(e,o,n,r)).catch(o=>ve(o,i,t)):e(s)}else typeof t=="object"&&t instanceof Promise?t.then(s=>e(s)):e(t)}var ht="x-";function ue(e=""){return ht+e}function bi(e){ht=e}var $e={};function O(e,t){return $e[e]=t,{before(n){if(!$e[n]){console.warn(String.raw`Cannot find directive \`${n}\`. \`${e}\` will use the default order of execution`);return}const r=Q.indexOf(n);Q.splice(r>=0?r:Q.indexOf("DEFAULT"),0,e)}}}function mi(e){return Object.keys($e).includes(e)}function pt(e,t,n){if(t=Array.from(t),e._x_virtualDirectives){let s=Object.entries(e._x_virtualDirectives).map(([a,c])=>({name:a,value:c})),o=gn(s);s=s.map(a=>o.find(c=>c.name===a.name)?{name:`x-bind:${a.name}`,value:`"${a.value}"`}:a),t=t.concat(s)}let r={};return t.map(yn((s,o)=>r[s]=o)).filter(xn).map(wi(r,n)).sort(xi).map(s=>yi(e,s))}function gn(e){return Array.from(e).map(yn()).filter(t=>!xn(t))}var gt=!1,me=new Map,vn=Symbol();function _i(e){gt=!0;let t=Symbol();vn=t,me.set(t,[]);let n=()=>{for(;me.get(t).length;)me.get(t).shift()();me.delete(t)},r=()=>{gt=!1,n()};e(n),r()}function bn(e){let t=[],n=a=>t.push(a),[r,i]=ri(e);return t.push(i),[{Alpine:we,effect:r,cleanup:n,evaluateLater:R.bind(R,e),evaluate:X.bind(X,e)},()=>t.forEach(a=>a())]}function yi(e,t){let n=()=>{},r=$e[t.type]||n,[i,s]=bn(e);rn(e,t.original,s);let o=()=>{e._x_ignore||e._x_ignoreSelf||(r.inline&&r.inline(e,t,i),r=r.bind(r,e,t,i),gt?me.get(vn).push(r):r())};return o.runCleanups=s,o}var mn=(e,t)=>({name:n,value:r})=>(n.startsWith(e)&&(n=n.replace(e,t)),{name:n,value:r}),_n=e=>e;function yn(e=()=>{}){return({name:t,value:n})=>{let{name:r,value:i}=wn.reduce((s,o)=>o(s),{name:t,value:n});return r!==t&&e(r,t),{name:r,value:i}}}var wn=[];function vt(e){wn.push(e)}function xn({name:e}){return En().test(e)}var En=()=>new RegExp(`^${ht}([^:^.]+)\\b`);function wi(e,t){return({name:n,value:r})=>{let i=n.match(En()),s=n.match(/:([a-zA-Z0-9\-_:]+)/),o=n.match(/\.[^.\]]+(?=[^\]]*$)/g)||[],a=t||e[n]||n;return{type:i?i[1]:null,value:s?s[1]:null,modifiers:o.map(c=>c.replace(".","")),expression:r,original:a}}}var bt="DEFAULT",Q=["ignore","ref","data","id","anchor","bind","init","for","model","modelable","transition","show","if",bt,"teleport"];function xi(e,t){let n=Q.indexOf(e.type)===-1?bt:e.type,r=Q.indexOf(t.type)===-1?bt:t.type;return Q.indexOf(n)-Q.indexOf(r)}function _e(e,t,n={}){e.dispatchEvent(new CustomEvent(t,{detail:n,bubbles:!0,composed:!0,cancelable:!0}))}function ee(e,t){if(typeof ShadowRoot=="function"&&e instanceof ShadowRoot){Array.from(e.children).forEach(i=>ee(i,t));return}let n=!1;if(t(e,()=>n=!0),n)return;let r=e.firstElementChild;for(;r;)ee(r,t),r=r.nextElementSibling}function L(e,...t){console.warn(`Alpine Warning: ${e}`,...t)}var Sn=!1;function Ei(){Sn&&L("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems."),Sn=!0,document.body||L("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"),_e(document,"alpine:init"),_e(document,"alpine:initializing"),ct(),ii(t=>z(t,ee)),st(t=>fe(t)),nn((t,n)=>{pt(t,n).forEach(r=>r())});let e=t=>!Fe(t.parentElement,!0);Array.from(document.querySelectorAll(Tn().join(","))).filter(e).forEach(t=>{z(t)}),_e(document,"alpine:initialized"),setTimeout(()=>{Ti()})}var mt=[],Cn=[];function In(){return mt.map(e=>e())}function Tn(){return mt.concat(Cn).map(e=>e())}function On(e){mt.push(e)}function An(e){Cn.push(e)}function Fe(e,t=!1){return de(e,n=>{if((t?Tn():In()).some(i=>n.matches(i)))return!0})}function de(e,t){if(e){if(t(e))return e;if(e._x_teleportBack&&(e=e._x_teleportBack),!!e.parentElement)return de(e.parentElement,t)}}function Si(e){return In().some(t=>e.matches(t))}var Nn=[];function Ci(e){Nn.push(e)}var Ii=1;function z(e,t=ee,n=()=>{}){de(e,r=>r._x_ignore)||_i(()=>{t(e,(r,i)=>{r._x_marker||(n(r,i),Nn.forEach(s=>s(r,i)),pt(r,r.attributes).forEach(s=>s()),r._x_ignore||(r._x_marker=Ii++),r._x_ignore&&i())})})}function fe(e,t=ee){t(e,n=>{si(n),sn(n),delete n._x_marker})}function Ti(){[["ui","dialog",["[x-dialog], [x-popover]"]],["anchor","anchor",["[x-anchor]"]],["sort","sort",["[x-sort]"]]].forEach(([t,n,r])=>{mi(n)||r.some(i=>{if(document.querySelector(i))return L(`found "${i}", but missing ${t} plugin`),!0})})}var _t=[],yt=!1;function wt(e=()=>{}){return queueMicrotask(()=>{yt||setTimeout(()=>{xt()})}),new Promise(t=>{_t.push(()=>{e(),t()})})}function xt(){for(yt=!1;_t.length;)_t.shift()()}function Oi(){yt=!0}function Et(e,t){return Array.isArray(t)?Rn(e,t.join(" ")):typeof t=="object"&&t!==null?Ai(e,t):typeof t=="function"?Et(e,t()):Rn(e,t)}function Rn(e,t){let n=i=>i.split(" ").filter(s=>!e.classList.contains(s)).filter(Boolean),r=i=>(e.classList.add(...i),()=>{e.classList.remove(...i)});return t=t===!0?t="":t||"",r(n(t))}function Ai(e,t){let n=a=>a.split(" ").filter(Boolean),r=Object.entries(t).flatMap(([a,c])=>c?n(a):!1).filter(Boolean),i=Object.entries(t).flatMap(([a,c])=>c?!1:n(a)).filter(Boolean),s=[],o=[];return i.forEach(a=>{e.classList.contains(a)&&(e.classList.remove(a),o.push(a))}),r.forEach(a=>{e.classList.contains(a)||(e.classList.add(a),s.push(a))}),()=>{o.forEach(a=>e.classList.add(a)),s.forEach(a=>e.classList.remove(a))}}function Me(e,t){return typeof t=="object"&&t!==null?Ni(e,t):Ri(e,t)}function Ni(e,t){let n={};return Object.entries(t).forEach(([r,i])=>{n[r]=e.style[r],r.startsWith("--")||(r=ki(r)),e.style.setProperty(r,i)}),setTimeout(()=>{e.style.length===0&&e.removeAttribute("style")}),()=>{Me(e,n)}}function Ri(e,t){let n=e.getAttribute("style",t);return e.setAttribute("style",t),()=>{e.setAttribute("style",n||"")}}function ki(e){return e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function St(e,t=()=>{}){let n=!1;return function(){n?t.apply(this,arguments):(n=!0,e.apply(this,arguments))}}O("transition",(e,{value:t,modifiers:n,expression:r},{evaluate:i})=>{typeof r=="function"&&(r=i(r)),r!==!1&&(!r||typeof r=="boolean"?$i(e,n,t):Li(e,r,t))});function Li(e,t,n){kn(e,Et,""),{enter:i=>{e._x_transition.enter.during=i},"enter-start":i=>{e._x_transition.enter.start=i},"enter-end":i=>{e._x_transition.enter.end=i},leave:i=>{e._x_transition.leave.during=i},"leave-start":i=>{e._x_transition.leave.start=i},"leave-end":i=>{e._x_transition.leave.end=i}}[n](t)}function $i(e,t,n){kn(e,Me);let r=!t.includes("in")&&!t.includes("out")&&!n,i=r||t.includes("in")||["enter"].includes(n),s=r||t.includes("out")||["leave"].includes(n);t.includes("in")&&!r&&(t=t.filter((m,w)=>w<t.indexOf("out"))),t.includes("out")&&!r&&(t=t.filter((m,w)=>w>t.indexOf("out")));let o=!t.includes("opacity")&&!t.includes("scale"),a=o||t.includes("opacity"),c=o||t.includes("scale"),l=a?0:1,u=c?ye(t,"scale",95)/100:1,f=ye(t,"delay",0)/1e3,h=ye(t,"origin","center"),b="opacity, transform",T=ye(t,"duration",150)/1e3,k=ye(t,"duration",75)/1e3,g="cubic-bezier(0.4, 0.0, 0.2, 1)";i&&(e._x_transition.enter.during={transformOrigin:h,transitionDelay:`${f}s`,transitionProperty:b,transitionDuration:`${T}s`,transitionTimingFunction:g},e._x_transition.enter.start={opacity:l,transform:`scale(${u})`},e._x_transition.enter.end={opacity:1,transform:"scale(1)"}),s&&(e._x_transition.leave.during={transformOrigin:h,transitionDelay:`${f}s`,transitionProperty:b,transitionDuration:`${k}s`,transitionTimingFunction:g},e._x_transition.leave.start={opacity:1,transform:"scale(1)"},e._x_transition.leave.end={opacity:l,transform:`scale(${u})`})}function kn(e,t,n={}){e._x_transition||(e._x_transition={enter:{during:n,start:n,end:n},leave:{during:n,start:n,end:n},in(r=()=>{},i=()=>{}){Ct(e,t,{during:this.enter.during,start:this.enter.start,end:this.enter.end},r,i)},out(r=()=>{},i=()=>{}){Ct(e,t,{during:this.leave.during,start:this.leave.start,end:this.leave.end},r,i)}})}window.Element.prototype._x_toggleAndCascadeWithTransitions=function(e,t,n,r){const i=document.visibilityState==="visible"?requestAnimationFrame:setTimeout;let s=()=>i(n);if(t){e._x_transition&&(e._x_transition.enter||e._x_transition.leave)?e._x_transition.enter&&(Object.entries(e._x_transition.enter.during).length||Object.entries(e._x_transition.enter.start).length||Object.entries(e._x_transition.enter.end).length)?e._x_transition.in(n):s():e._x_transition?e._x_transition.in(n):s();return}e._x_hidePromise=e._x_transition?new Promise((o,a)=>{e._x_transition.out(()=>{},()=>o(r)),e._x_transitioning&&e._x_transitioning.beforeCancel(()=>a({isFromCancelledTransition:!0}))}):Promise.resolve(r),queueMicrotask(()=>{let o=Ln(e);o?(o._x_hideChildren||(o._x_hideChildren=[]),o._x_hideChildren.push(e)):i(()=>{let a=c=>{let l=Promise.all([c._x_hidePromise,...(c._x_hideChildren||[]).map(a)]).then(([u])=>u?.());return delete c._x_hidePromise,delete c._x_hideChildren,l};a(e).catch(c=>{if(!c.isFromCancelledTransition)throw c})})})};function Ln(e){let t=e.parentNode;if(t)return t._x_hidePromise?t:Ln(t)}function Ct(e,t,{during:n,start:r,end:i}={},s=()=>{},o=()=>{}){if(e._x_transitioning&&e._x_transitioning.cancel(),Object.keys(n).length===0&&Object.keys(r).length===0&&Object.keys(i).length===0){s(),o();return}let a,c,l;Fi(e,{start(){a=t(e,r)},during(){c=t(e,n)},before:s,end(){a(),l=t(e,i)},after:o,cleanup(){c(),l()}})}function Fi(e,t){let n,r,i,s=St(()=>{C(()=>{n=!0,r||t.before(),i||(t.end(),xt()),t.after(),e.isConnected&&t.cleanup(),delete e._x_transitioning})});e._x_transitioning={beforeCancels:[],beforeCancel(o){this.beforeCancels.push(o)},cancel:St(function(){for(;this.beforeCancels.length;)this.beforeCancels.shift()();s()}),finish:s},C(()=>{t.start(),t.during()}),Oi(),requestAnimationFrame(()=>{if(n)return;let o=Number(getComputedStyle(e).transitionDuration.replace(/,.*/,"").replace("s",""))*1e3,a=Number(getComputedStyle(e).transitionDelay.replace(/,.*/,"").replace("s",""))*1e3;o===0&&(o=Number(getComputedStyle(e).animationDuration.replace("s",""))*1e3),C(()=>{t.before()}),r=!0,requestAnimationFrame(()=>{n||(C(()=>{t.end()}),xt(),setTimeout(e._x_transitioning.finish,o+a),i=!0)})})}function ye(e,t,n){if(e.indexOf(t)===-1)return n;const r=e[e.indexOf(t)+1];if(!r||t==="scale"&&isNaN(r))return n;if(t==="duration"||t==="delay"){let i=r.match(/([0-9]+)ms/);if(i)return i[1]}return t==="origin"&&["top","right","left","center","bottom"].includes(e[e.indexOf(t)+2])?[r,e[e.indexOf(t)+2]].join(" "):r}var B=!1;function W(e,t=()=>{}){return(...n)=>B?t(...n):e(...n)}function Mi(e){return(...t)=>B&&e(...t)}var $n=[];function De(e){$n.push(e)}function Di(e,t){$n.forEach(n=>n(e,t)),B=!0,Fn(()=>{z(t,(n,r)=>{r(n,()=>{})})}),B=!1}var It=!1;function Pi(e,t){t._x_dataStack||(t._x_dataStack=e._x_dataStack),B=!0,It=!0,Fn(()=>{zi(t)}),B=!1,It=!1}function zi(e){let t=!1;z(e,(r,i)=>{ee(r,(s,o)=>{if(t&&Si(s))return o();t=!0,i(s,o)})})}function Fn(e){let t=Z;Jt((n,r)=>{let i=t(n);return ce(i),()=>{}}),e(),Jt(t)}function Mn(e,t,n,r=[]){switch(e._x_bindings||(e._x_bindings=ae({})),e._x_bindings[t]=n,t=r.includes("camel")?qi(t):t,t){case"value":ji(e,n);break;case"style":Wi(e,n);break;case"class":Bi(e,n);break;case"selected":case"checked":Hi(e,t,n);break;default:Dn(e,t,n);break}}function ji(e,t){if(Bn(e))e.attributes.value===void 0&&(e.value=t),window.fromModel&&(typeof t=="boolean"?e.checked=Pe(e.value)===t:e.checked=Pn(e.value,t));else if(Tt(e))Number.isInteger(t)?e.value=t:!Array.isArray(t)&&typeof t!="boolean"&&![null,void 0].includes(t)?e.value=String(t):Array.isArray(t)?e.checked=t.some(n=>Pn(n,e.value)):e.checked=!!t;else if(e.tagName==="SELECT")Vi(e,t);else{if(e.value===t)return;e.value=t===void 0?"":t}}function Bi(e,t){e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedClasses=Et(e,t)}function Wi(e,t){e._x_undoAddedStyles&&e._x_undoAddedStyles(),e._x_undoAddedStyles=Me(e,t)}function Hi(e,t,n){Dn(e,t,n),Ki(e,t,n)}function Dn(e,t,n){[null,void 0,!1].includes(n)&&Gi(t)?e.removeAttribute(t):(zn(t)&&(n=t),Yi(e,t,n))}function Yi(e,t,n){e.getAttribute(t)!=n&&e.setAttribute(t,n)}function Ki(e,t,n){e[t]!==n&&(e[t]=n)}function Vi(e,t){const n=[].concat(t).map(r=>r+"");Array.from(e.options).forEach(r=>{r.selected=n.includes(r.value)})}function qi(e){return e.toLowerCase().replace(/-(\w)/g,(t,n)=>n.toUpperCase())}function Pn(e,t){return e==t}function Pe(e){return[1,"1","true","on","yes",!0].includes(e)?!0:[0,"0","false","off","no",!1].includes(e)?!1:e?!!e:null}var Ui=new Set(["allowfullscreen","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","inert","ismap","itemscope","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected","shadowrootclonable","shadowrootdelegatesfocus","shadowrootserializable"]);function zn(e){return Ui.has(e)}function Gi(e){return!["aria-pressed","aria-checked","aria-expanded","aria-selected"].includes(e)}function Zi(e,t,n){return e._x_bindings&&e._x_bindings[t]!==void 0?e._x_bindings[t]:jn(e,t,n)}function Ji(e,t,n,r=!0){if(e._x_bindings&&e._x_bindings[t]!==void 0)return e._x_bindings[t];if(e._x_inlineBindings&&e._x_inlineBindings[t]!==void 0){let i=e._x_inlineBindings[t];return i.extract=r,fn(()=>X(e,i.expression))}return jn(e,t,n)}function jn(e,t,n){let r=e.getAttribute(t);return r===null?typeof n=="function"?n():n:r===""?!0:zn(t)?!![t,"true"].includes(r):r}function Tt(e){return e.type==="checkbox"||e.localName==="ui-checkbox"||e.localName==="ui-switch"}function Bn(e){return e.type==="radio"||e.localName==="ui-radio"}function Wn(e,t){var n;return function(){var r=this,i=arguments,s=function(){n=null,e.apply(r,i)};clearTimeout(n),n=setTimeout(s,t)}}function Hn(e,t){let n;return function(){let r=this,i=arguments;n||(e.apply(r,i),n=!0,setTimeout(()=>n=!1,t))}}function Yn({get:e,set:t},{get:n,set:r}){let i=!0,s,o=Z(()=>{let a=e(),c=n();if(i)r(Ot(a)),i=!1;else{let l=JSON.stringify(a),u=JSON.stringify(c);l!==s?r(Ot(a)):l!==u&&t(Ot(c))}s=JSON.stringify(e()),JSON.stringify(n())});return()=>{ce(o)}}function Ot(e){return typeof e=="object"?JSON.parse(JSON.stringify(e)):e}function Xi(e){(Array.isArray(e)?e:[e]).forEach(n=>n(we))}var te={},Kn=!1;function Qi(e,t){if(Kn||(te=ae(te),Kn=!0),t===void 0)return te[e];te[e]=t,cn(te[e]),typeof t=="object"&&t!==null&&t.hasOwnProperty("init")&&typeof t.init=="function"&&te[e].init()}function es(){return te}var Vn={};function ts(e,t){let n=typeof t!="function"?()=>t:t;return e instanceof Element?qn(e,n()):(Vn[e]=n,()=>{})}function ns(e){return Object.entries(Vn).forEach(([t,n])=>{Object.defineProperty(e,t,{get(){return(...r)=>n(...r)}})}),e}function qn(e,t,n){let r=[];for(;r.length;)r.pop()();let i=Object.entries(t).map(([o,a])=>({name:o,value:a})),s=gn(i);return i=i.map(o=>s.find(a=>a.name===o.name)?{name:`x-bind:${o.name}`,value:`"${o.value}"`}:o),pt(e,i,n).map(o=>{r.push(o.runCleanups),o()}),()=>{for(;r.length;)r.pop()()}}var Un={};function rs(e,t){Un[e]=t}function is(e,t){return Object.entries(Un).forEach(([n,r])=>{Object.defineProperty(e,n,{get(){return(...i)=>r.bind(t)(...i)},enumerable:!1})}),e}var ss={get reactive(){return ae},get release(){return ce},get effect(){return Z},get raw(){return Zt},version:"3.14.9",flushAndStopDeferringMutations:ci,dontAutoEvaluateFunctions:fn,disableEffectScheduling:ti,startObservingMutations:ct,stopObservingMutations:on,setReactivityEngine:ni,onAttributeRemoved:rn,onAttributesAdded:nn,closestDataStack:J,skipDuringClone:W,onlyDuringClone:Mi,addRootSelector:On,addInitSelector:An,interceptClone:De,addScopeToNode:ge,deferMutations:ai,mapAttributes:vt,evaluateLater:R,interceptInit:Ci,setEvaluator:hi,mergeProxies:le,extractProp:Ji,findClosest:de,onElRemoved:st,closestRoot:Fe,destroyTree:fe,interceptor:ln,transition:Ct,setStyles:Me,mutateDom:C,directive:O,entangle:Yn,throttle:Hn,debounce:Wn,evaluate:X,initTree:z,nextTick:wt,prefixed:ue,prefix:bi,plugin:Xi,magic:$,store:Qi,start:Ei,clone:Pi,cloneNode:Di,bound:Zi,$data:an,watch:Xt,walk:ee,data:rs,bind:ts},we=ss;function os(e,t){let n=as(e);if(typeof t=="function")return pn(n,t);let r=cs(e,t,n);return dn.bind(null,e,t,r)}function as(e){let t={};return ke(t,e),[t,...J(e)]}function cs(e,t,n){return(r=()=>{},{scope:i={},params:s=[]}={})=>{let o=le([i,...n]),a=t.split(".").reduce((c,l)=>(c[l]===void 0&&ls(e,t),c[l]),o);be(r,a,o,s)}}function ls(e,t){console.warn(`Alpine Error: Alpine is unable to interpret the following expression using the CSP-friendly build:
"${t}"
Read more about the Alpine's CSP-friendly build restrictions here: https://alpinejs.dev/advanced/csp
`,e)}function us(e,t){const n=Object.create(null),r=e.split(",");for(let i=0;i<r.length;i++)n[r[i]]=!0;return i=>!!n[i]}var ds=Object.freeze({}),fs=Object.prototype.hasOwnProperty,ze=(e,t)=>fs.call(e,t),ne=Array.isArray,xe=e=>Gn(e)==="[object Map]",hs=e=>typeof e=="string",At=e=>typeof e=="symbol",je=e=>e!==null&&typeof e=="object",ps=Object.prototype.toString,Gn=e=>ps.call(e),Zn=e=>Gn(e).slice(8,-1),Nt=e=>hs(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,gs=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},vs=gs(e=>e.charAt(0).toUpperCase()+e.slice(1)),Jn=(e,t)=>e!==t&&(e===e||t===t),Rt=new WeakMap,Ee=[],P,re=Symbol("iterate"),kt=Symbol("Map key iterate");function bs(e){return e&&e._isEffect===!0}function ms(e,t=ds){bs(e)&&(e=e.raw);const n=ws(e,t);return t.lazy||n(),n}function _s(e){e.active&&(Xn(e),e.options.onStop&&e.options.onStop(),e.active=!1)}var ys=0;function ws(e,t){const n=function(){if(!n.active)return e();if(!Ee.includes(n)){Xn(n);try{return Es(),Ee.push(n),P=n,e()}finally{Ee.pop(),Qn(),P=Ee[Ee.length-1]}}};return n.id=ys++,n.allowRecurse=!!t.allowRecurse,n._isEffect=!0,n.active=!0,n.raw=e,n.deps=[],n.options=t,n}function Xn(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}var he=!0,Lt=[];function xs(){Lt.push(he),he=!1}function Es(){Lt.push(he),he=!0}function Qn(){const e=Lt.pop();he=e===void 0?!0:e}function F(e,t,n){if(!he||P===void 0)return;let r=Rt.get(e);r||Rt.set(e,r=new Map);let i=r.get(n);i||r.set(n,i=new Set),i.has(P)||(i.add(P),P.deps.push(i),P.options.onTrack&&P.options.onTrack({effect:P,target:e,type:t,key:n}))}function H(e,t,n,r,i,s){const o=Rt.get(e);if(!o)return;const a=new Set,c=u=>{u&&u.forEach(f=>{(f!==P||f.allowRecurse)&&a.add(f)})};if(t==="clear")o.forEach(c);else if(n==="length"&&ne(e))o.forEach((u,f)=>{(f==="length"||f>=r)&&c(u)});else switch(n!==void 0&&c(o.get(n)),t){case"add":ne(e)?Nt(n)&&c(o.get("length")):(c(o.get(re)),xe(e)&&c(o.get(kt)));break;case"delete":ne(e)||(c(o.get(re)),xe(e)&&c(o.get(kt)));break;case"set":xe(e)&&c(o.get(re));break}const l=u=>{u.options.onTrigger&&u.options.onTrigger({effect:u,target:e,key:n,type:t,newValue:r,oldValue:i,oldTarget:s}),u.options.scheduler?u.options.scheduler(u):u()};a.forEach(l)}var Ss=us("__proto__,__v_isRef,__isVue"),er=new Set(Object.getOwnPropertyNames(Symbol).map(e=>Symbol[e]).filter(At)),Cs=nr(),Is=nr(!0),tr=Ts();function Ts(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...n){const r=x(this);for(let s=0,o=this.length;s<o;s++)F(r,"get",s+"");const i=r[t](...n);return i===-1||i===!1?r[t](...n.map(x)):i}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...n){xs();const r=x(this)[t].apply(this,n);return Qn(),r}}),e}function nr(e=!1,t=!1){return function(r,i,s){if(i==="__v_isReactive")return!e;if(i==="__v_isReadonly")return e;if(i==="__v_raw"&&s===(e?t?Bs:ur:t?js:lr).get(r))return r;const o=ne(r);if(!e&&o&&ze(tr,i))return Reflect.get(tr,i,s);const a=Reflect.get(r,i,s);return(At(i)?er.has(i):Ss(i))||(e||F(r,"get",i),t)?a:Pt(a)?!o||!Nt(i)?a.value:a:je(a)?e?dr(a):Dt(a):a}}var Os=As();function As(e=!1){return function(n,r,i,s){let o=n[r];if(!e&&(i=x(i),o=x(o),!ne(n)&&Pt(o)&&!Pt(i)))return o.value=i,!0;const a=ne(n)&&Nt(r)?Number(r)<n.length:ze(n,r),c=Reflect.set(n,r,i,s);return n===x(s)&&(a?Jn(i,o)&&H(n,"set",r,i,o):H(n,"add",r,i)),c}}function Ns(e,t){const n=ze(e,t),r=e[t],i=Reflect.deleteProperty(e,t);return i&&n&&H(e,"delete",t,void 0,r),i}function Rs(e,t){const n=Reflect.has(e,t);return(!At(t)||!er.has(t))&&F(e,"has",t),n}function ks(e){return F(e,"iterate",ne(e)?"length":re),Reflect.ownKeys(e)}var Ls={get:Cs,set:Os,deleteProperty:Ns,has:Rs,ownKeys:ks},$s={get:Is,set(e,t){return console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`,e),!0},deleteProperty(e,t){return console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`,e),!0}},$t=e=>je(e)?Dt(e):e,Ft=e=>je(e)?dr(e):e,Mt=e=>e,Be=e=>Reflect.getPrototypeOf(e);function We(e,t,n=!1,r=!1){e=e.__v_raw;const i=x(e),s=x(t);t!==s&&!n&&F(i,"get",t),!n&&F(i,"get",s);const{has:o}=Be(i),a=r?Mt:n?Ft:$t;if(o.call(i,t))return a(e.get(t));if(o.call(i,s))return a(e.get(s));e!==i&&e.get(t)}function He(e,t=!1){const n=this.__v_raw,r=x(n),i=x(e);return e!==i&&!t&&F(r,"has",e),!t&&F(r,"has",i),e===i?n.has(e):n.has(e)||n.has(i)}function Ye(e,t=!1){return e=e.__v_raw,!t&&F(x(e),"iterate",re),Reflect.get(e,"size",e)}function rr(e){e=x(e);const t=x(this);return Be(t).has.call(t,e)||(t.add(e),H(t,"add",e,e)),this}function ir(e,t){t=x(t);const n=x(this),{has:r,get:i}=Be(n);let s=r.call(n,e);s?cr(n,r,e):(e=x(e),s=r.call(n,e));const o=i.call(n,e);return n.set(e,t),s?Jn(t,o)&&H(n,"set",e,t,o):H(n,"add",e,t),this}function sr(e){const t=x(this),{has:n,get:r}=Be(t);let i=n.call(t,e);i?cr(t,n,e):(e=x(e),i=n.call(t,e));const s=r?r.call(t,e):void 0,o=t.delete(e);return i&&H(t,"delete",e,void 0,s),o}function or(){const e=x(this),t=e.size!==0,n=xe(e)?new Map(e):new Set(e),r=e.clear();return t&&H(e,"clear",void 0,void 0,n),r}function Ke(e,t){return function(r,i){const s=this,o=s.__v_raw,a=x(o),c=t?Mt:e?Ft:$t;return!e&&F(a,"iterate",re),o.forEach((l,u)=>r.call(i,c(l),c(u),s))}}function Ve(e,t,n){return function(...r){const i=this.__v_raw,s=x(i),o=xe(s),a=e==="entries"||e===Symbol.iterator&&o,c=e==="keys"&&o,l=i[e](...r),u=n?Mt:t?Ft:$t;return!t&&F(s,"iterate",c?kt:re),{next(){const{value:f,done:h}=l.next();return h?{value:f,done:h}:{value:a?[u(f[0]),u(f[1])]:u(f),done:h}},[Symbol.iterator](){return this}}}}function Y(e){return function(...t){{const n=t[0]?`on key "${t[0]}" `:"";console.warn(`${vs(e)} operation ${n}failed: target is readonly.`,x(this))}return e==="delete"?!1:this}}function Fs(){const e={get(s){return We(this,s)},get size(){return Ye(this)},has:He,add:rr,set:ir,delete:sr,clear:or,forEach:Ke(!1,!1)},t={get(s){return We(this,s,!1,!0)},get size(){return Ye(this)},has:He,add:rr,set:ir,delete:sr,clear:or,forEach:Ke(!1,!0)},n={get(s){return We(this,s,!0)},get size(){return Ye(this,!0)},has(s){return He.call(this,s,!0)},add:Y("add"),set:Y("set"),delete:Y("delete"),clear:Y("clear"),forEach:Ke(!0,!1)},r={get(s){return We(this,s,!0,!0)},get size(){return Ye(this,!0)},has(s){return He.call(this,s,!0)},add:Y("add"),set:Y("set"),delete:Y("delete"),clear:Y("clear"),forEach:Ke(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{e[s]=Ve(s,!1,!1),n[s]=Ve(s,!0,!1),t[s]=Ve(s,!1,!0),r[s]=Ve(s,!0,!0)}),[e,n,t,r]}var[Ms,Ds,xa,Ea]=Fs();function ar(e,t){const n=e?Ds:Ms;return(r,i,s)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?r:Reflect.get(ze(n,i)&&i in r?n:r,i,s)}var Ps={get:ar(!1)},zs={get:ar(!0)};function cr(e,t,n){const r=x(n);if(r!==n&&t.call(e,r)){const i=Zn(e);console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}var lr=new WeakMap,js=new WeakMap,ur=new WeakMap,Bs=new WeakMap;function Ws(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Hs(e){return e.__v_skip||!Object.isExtensible(e)?0:Ws(Zn(e))}function Dt(e){return e&&e.__v_isReadonly?e:fr(e,!1,Ls,Ps,lr)}function dr(e){return fr(e,!0,$s,zs,ur)}function fr(e,t,n,r,i){if(!je(e))return console.warn(`value cannot be made reactive: ${String(e)}`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=i.get(e);if(s)return s;const o=Hs(e);if(o===0)return e;const a=new Proxy(e,o===2?r:n);return i.set(e,a),a}function x(e){return e&&x(e.__v_raw)||e}function Pt(e){return!!(e&&e.__v_isRef===!0)}$("nextTick",()=>wt),$("dispatch",e=>_e.bind(_e,e)),$("watch",(e,{evaluateLater:t,cleanup:n})=>(r,i)=>{let s=t(r),a=Xt(()=>{let c;return s(l=>c=l),c},i);n(a)}),$("store",es),$("data",e=>an(e)),$("root",e=>Fe(e)),$("refs",e=>(e._x_refs_proxy||(e._x_refs_proxy=le(Ys(e))),e._x_refs_proxy));function Ys(e){let t=[];return de(e,n=>{n._x_refs&&t.push(n._x_refs)}),t}var zt={};function hr(e){return zt[e]||(zt[e]=0),++zt[e]}function Ks(e,t){return de(e,n=>{if(n._x_ids&&n._x_ids[t])return!0})}function Vs(e,t){e._x_ids||(e._x_ids={}),e._x_ids[t]||(e._x_ids[t]=hr(t))}$("id",(e,{cleanup:t})=>(n,r=null)=>{let i=`${n}${r?`-${r}`:""}`;return qs(e,i,t,()=>{let s=Ks(e,n),o=s?s._x_ids[n]:hr(n);return r?`${n}-${o}-${r}`:`${n}-${o}`})}),De((e,t)=>{e._x_id&&(t._x_id=e._x_id)});function qs(e,t,n,r){if(e._x_id||(e._x_id={}),e._x_id[t])return e._x_id[t];let i=r();return e._x_id[t]=i,n(()=>{delete e._x_id[t]}),i}$("el",e=>e),pr("Focus","focus","focus"),pr("Persist","persist","persist");function pr(e,t,n){$(t,r=>L(`You can't use [$${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`,r))}O("modelable",(e,{expression:t},{effect:n,evaluateLater:r,cleanup:i})=>{let s=r(t),o=()=>{let u;return s(f=>u=f),u},a=r(`${t} = __placeholder`),c=u=>a(()=>{},{scope:{__placeholder:u}}),l=o();c(l),queueMicrotask(()=>{if(!e._x_model)return;e._x_removeModelListeners.default();let u=e._x_model.get,f=e._x_model.set,h=Yn({get(){return u()},set(b){f(b)}},{get(){return o()},set(b){c(b)}});i(h)})}),O("teleport",(e,{modifiers:t,expression:n},{cleanup:r})=>{e.tagName.toLowerCase()!=="template"&&L("x-teleport can only be used on a <template> tag",e);let i=gr(n),s=e.content.cloneNode(!0).firstElementChild;e._x_teleport=s,s._x_teleportBack=e,e.setAttribute("data-teleport-template",!0),s.setAttribute("data-teleport-target",!0),e._x_forwardEvents&&e._x_forwardEvents.forEach(a=>{s.addEventListener(a,c=>{c.stopPropagation(),e.dispatchEvent(new c.constructor(c.type,c))})}),ge(s,{},e);let o=(a,c,l)=>{l.includes("prepend")?c.parentNode.insertBefore(a,c):l.includes("append")?c.parentNode.insertBefore(a,c.nextSibling):c.appendChild(a)};C(()=>{o(s,i,t),W(()=>{z(s)})()}),e._x_teleportPutBack=()=>{let a=gr(n);C(()=>{o(e._x_teleport,a,t)})},r(()=>C(()=>{s.remove(),fe(s)}))});var Us=document.createElement("div");function gr(e){let t=W(()=>document.querySelector(e),()=>Us)();return t||L(`Cannot find x-teleport element for selector: "${e}"`),t}var vr=()=>{};vr.inline=(e,{modifiers:t},{cleanup:n})=>{t.includes("self")?e._x_ignoreSelf=!0:e._x_ignore=!0,n(()=>{t.includes("self")?delete e._x_ignoreSelf:delete e._x_ignore})},O("ignore",vr),O("effect",W((e,{expression:t},{effect:n})=>{n(R(e,t))}));function jt(e,t,n,r){let i=e,s=c=>r(c),o={},a=(c,l)=>u=>l(c,u);if(n.includes("dot")&&(t=Gs(t)),n.includes("camel")&&(t=Zs(t)),n.includes("passive")&&(o.passive=!0),n.includes("capture")&&(o.capture=!0),n.includes("window")&&(i=window),n.includes("document")&&(i=document),n.includes("debounce")){let c=n[n.indexOf("debounce")+1]||"invalid-wait",l=qe(c.split("ms")[0])?Number(c.split("ms")[0]):250;s=Wn(s,l)}if(n.includes("throttle")){let c=n[n.indexOf("throttle")+1]||"invalid-wait",l=qe(c.split("ms")[0])?Number(c.split("ms")[0]):250;s=Hn(s,l)}return n.includes("prevent")&&(s=a(s,(c,l)=>{l.preventDefault(),c(l)})),n.includes("stop")&&(s=a(s,(c,l)=>{l.stopPropagation(),c(l)})),n.includes("once")&&(s=a(s,(c,l)=>{c(l),i.removeEventListener(t,s,o)})),(n.includes("away")||n.includes("outside"))&&(i=document,s=a(s,(c,l)=>{e.contains(l.target)||l.target.isConnected!==!1&&(e.offsetWidth<1&&e.offsetHeight<1||e._x_isShown!==!1&&c(l))})),n.includes("self")&&(s=a(s,(c,l)=>{l.target===e&&c(l)})),(Xs(t)||br(t))&&(s=a(s,(c,l)=>{Qs(l,n)||c(l)})),i.addEventListener(t,s,o),()=>{i.removeEventListener(t,s,o)}}function Gs(e){return e.replace(/-/g,".")}function Zs(e){return e.toLowerCase().replace(/-(\w)/g,(t,n)=>n.toUpperCase())}function qe(e){return!Array.isArray(e)&&!isNaN(e)}function Js(e){return[" ","_"].includes(e)?e:e.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[_\s]/,"-").toLowerCase()}function Xs(e){return["keydown","keyup"].includes(e)}function br(e){return["contextmenu","click","mouse"].some(t=>e.includes(t))}function Qs(e,t){let n=t.filter(s=>!["window","document","prevent","stop","once","capture","self","away","outside","passive"].includes(s));if(n.includes("debounce")){let s=n.indexOf("debounce");n.splice(s,qe((n[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(n.includes("throttle")){let s=n.indexOf("throttle");n.splice(s,qe((n[s+1]||"invalid-wait").split("ms")[0])?2:1)}if(n.length===0||n.length===1&&mr(e.key).includes(n[0]))return!1;const i=["ctrl","shift","alt","meta","cmd","super"].filter(s=>n.includes(s));return n=n.filter(s=>!i.includes(s)),!(i.length>0&&i.filter(o=>((o==="cmd"||o==="super")&&(o="meta"),e[`${o}Key`])).length===i.length&&(br(e.type)||mr(e.key).includes(n[0])))}function mr(e){if(!e)return[];e=Js(e);let t={ctrl:"control",slash:"/",space:" ",spacebar:" ",cmd:"meta",esc:"escape",up:"arrow-up",down:"arrow-down",left:"arrow-left",right:"arrow-right",period:".",comma:",",equal:"=",minus:"-",underscore:"_"};return t[e]=e,Object.keys(t).map(n=>{if(t[n]===e)return n}).filter(n=>n)}O("model",(e,{modifiers:t,expression:n},{effect:r,cleanup:i})=>{let s=e;t.includes("parent")&&(s=e.parentNode);let o=R(s,n),a;typeof n=="string"?a=R(s,`${n} = __placeholder`):typeof n=="function"&&typeof n()=="string"?a=R(s,`${n()} = __placeholder`):a=()=>{};let c=()=>{let h;return o(b=>h=b),_r(h)?h.get():h},l=h=>{let b;o(T=>b=T),_r(b)?b.set(h):a(()=>{},{scope:{__placeholder:h}})};typeof n=="string"&&e.type==="radio"&&C(()=>{e.hasAttribute("name")||e.setAttribute("name",n)});var u=e.tagName.toLowerCase()==="select"||["checkbox","radio"].includes(e.type)||t.includes("lazy")?"change":"input";let f=B?()=>{}:jt(e,u,t,h=>{l(Bt(e,t,h,c()))});if(t.includes("fill")&&([void 0,null,""].includes(c())||Tt(e)&&Array.isArray(c())||e.tagName.toLowerCase()==="select"&&e.multiple)&&l(Bt(e,t,{target:e},c())),e._x_removeModelListeners||(e._x_removeModelListeners={}),e._x_removeModelListeners.default=f,i(()=>e._x_removeModelListeners.default()),e.form){let h=jt(e.form,"reset",[],b=>{wt(()=>e._x_model&&e._x_model.set(Bt(e,t,{target:e},c())))});i(()=>h())}e._x_model={get(){return c()},set(h){l(h)}},e._x_forceModelUpdate=h=>{h===void 0&&typeof n=="string"&&n.match(/\./)&&(h=""),window.fromModel=!0,C(()=>Mn(e,"value",h)),delete window.fromModel},r(()=>{let h=c();t.includes("unintrusive")&&document.activeElement.isSameNode(e)||e._x_forceModelUpdate(h)})});function Bt(e,t,n,r){return C(()=>{if(n instanceof CustomEvent&&n.detail!==void 0)return n.detail!==null&&n.detail!==void 0?n.detail:n.target.value;if(Tt(e))if(Array.isArray(r)){let i=null;return t.includes("number")?i=Wt(n.target.value):t.includes("boolean")?i=Pe(n.target.value):i=n.target.value,n.target.checked?r.includes(i)?r:r.concat([i]):r.filter(s=>!eo(s,i))}else return n.target.checked;else{if(e.tagName.toLowerCase()==="select"&&e.multiple)return t.includes("number")?Array.from(n.target.selectedOptions).map(i=>{let s=i.value||i.text;return Wt(s)}):t.includes("boolean")?Array.from(n.target.selectedOptions).map(i=>{let s=i.value||i.text;return Pe(s)}):Array.from(n.target.selectedOptions).map(i=>i.value||i.text);{let i;return Bn(e)?n.target.checked?i=n.target.value:i=r:i=n.target.value,t.includes("number")?Wt(i):t.includes("boolean")?Pe(i):t.includes("trim")?i.trim():i}}})}function Wt(e){let t=e?parseFloat(e):null;return to(t)?t:e}function eo(e,t){return e==t}function to(e){return!Array.isArray(e)&&!isNaN(e)}function _r(e){return e!==null&&typeof e=="object"&&typeof e.get=="function"&&typeof e.set=="function"}O("cloak",e=>queueMicrotask(()=>C(()=>e.removeAttribute(ue("cloak"))))),An(()=>`[${ue("init")}]`),O("init",W((e,{expression:t},{evaluate:n})=>typeof t=="string"?!!t.trim()&&n(t,{},!1):n(t,{},!1))),O("text",(e,{expression:t},{effect:n,evaluateLater:r})=>{let i=r(t);n(()=>{i(s=>{C(()=>{e.textContent=s})})})}),O("html",(e,{expression:t},{effect:n,evaluateLater:r})=>{let i=r(t);n(()=>{i(s=>{C(()=>{e.innerHTML=s,e._x_ignoreSelf=!0,z(e),delete e._x_ignoreSelf})})})}),vt(mn(":",_n(ue("bind:"))));var yr=(e,{value:t,modifiers:n,expression:r,original:i},{effect:s,cleanup:o})=>{if(!t){let c={};ns(c),R(e,r)(u=>{qn(e,u,i)},{scope:c});return}if(t==="key")return no(e,r);if(e._x_inlineBindings&&e._x_inlineBindings[t]&&e._x_inlineBindings[t].extract)return;let a=R(e,r);s(()=>a(c=>{c===void 0&&typeof r=="string"&&r.match(/\./)&&(c=""),C(()=>Mn(e,t,c,n))})),o(()=>{e._x_undoAddedClasses&&e._x_undoAddedClasses(),e._x_undoAddedStyles&&e._x_undoAddedStyles()})};yr.inline=(e,{value:t,modifiers:n,expression:r})=>{t&&(e._x_inlineBindings||(e._x_inlineBindings={}),e._x_inlineBindings[t]={expression:r,extract:!1})},O("bind",yr);function no(e,t){e._x_keyExpression=t}On(()=>`[${ue("data")}]`),O("data",(e,{expression:t},{cleanup:n})=>{if(ro(e))return;t=t===""?"{}":t;let r={};ke(r,e);let i={};is(i,r);let s=X(e,t,{scope:i});(s===void 0||s===!0)&&(s={}),ke(s,e);let o=ae(s);cn(o);let a=ge(e,o);o.init&&X(e,o.init),n(()=>{o.destroy&&X(e,o.destroy),a()})}),De((e,t)=>{e._x_dataStack&&(t._x_dataStack=e._x_dataStack,t.setAttribute("data-has-alpine-state",!0))});function ro(e){return B?It?!0:e.hasAttribute("data-has-alpine-state"):!1}O("show",(e,{modifiers:t,expression:n},{effect:r})=>{let i=R(e,n);e._x_doHide||(e._x_doHide=()=>{C(()=>{e.style.setProperty("display","none",t.includes("important")?"important":void 0)})}),e._x_doShow||(e._x_doShow=()=>{C(()=>{e.style.length===1&&e.style.display==="none"?e.removeAttribute("style"):e.style.removeProperty("display")})});let s=()=>{e._x_doHide(),e._x_isShown=!1},o=()=>{e._x_doShow(),e._x_isShown=!0},a=()=>setTimeout(o),c=St(f=>f?o():s(),f=>{typeof e._x_toggleAndCascadeWithTransitions=="function"?e._x_toggleAndCascadeWithTransitions(e,f,o,s):f?a():s()}),l,u=!0;r(()=>i(f=>{!u&&f===l||(t.includes("immediate")&&(f?a():s()),c(f),l=f,u=!1)}))}),O("for",(e,{expression:t},{effect:n,cleanup:r})=>{let i=so(t),s=R(e,i.items),o=R(e,e._x_keyExpression||"index");e._x_prevKeys=[],e._x_lookup={},n(()=>io(e,i,s,o)),r(()=>{Object.values(e._x_lookup).forEach(a=>C(()=>{fe(a),a.remove()})),delete e._x_prevKeys,delete e._x_lookup})});function io(e,t,n,r){let i=o=>typeof o=="object"&&!Array.isArray(o),s=e;n(o=>{oo(o)&&o>=0&&(o=Array.from(Array(o).keys(),g=>g+1)),o===void 0&&(o=[]);let a=e._x_lookup,c=e._x_prevKeys,l=[],u=[];if(i(o))o=Object.entries(o).map(([g,m])=>{let w=wr(t,m,g,o);r(I=>{u.includes(I)&&L("Duplicate key on x-for",e),u.push(I)},{scope:{index:g,...w}}),l.push(w)});else for(let g=0;g<o.length;g++){let m=wr(t,o[g],g,o);r(w=>{u.includes(w)&&L("Duplicate key on x-for",e),u.push(w)},{scope:{index:g,...m}}),l.push(m)}let f=[],h=[],b=[],T=[];for(let g=0;g<c.length;g++){let m=c[g];u.indexOf(m)===-1&&b.push(m)}c=c.filter(g=>!b.includes(g));let k="template";for(let g=0;g<u.length;g++){let m=u[g],w=c.indexOf(m);if(w===-1)c.splice(g,0,m),f.push([k,g]);else if(w!==g){let I=c.splice(g,1)[0],N=c.splice(w-1,1)[0];c.splice(g,0,N),c.splice(w,0,I),h.push([I,N])}else T.push(m);k=m}for(let g=0;g<b.length;g++){let m=b[g];m in a&&(C(()=>{fe(a[m]),a[m].remove()}),delete a[m])}for(let g=0;g<h.length;g++){let[m,w]=h[g],I=a[m],N=a[w],y=document.createElement("div");C(()=>{N||L('x-for ":key" is undefined or invalid',s,w,a),N.after(y),I.after(N),N._x_currentIfEl&&N.after(N._x_currentIfEl),y.before(I),I._x_currentIfEl&&I.after(I._x_currentIfEl),y.remove()}),N._x_refreshXForScope(l[u.indexOf(w)])}for(let g=0;g<f.length;g++){let[m,w]=f[g],I=m==="template"?s:a[m];I._x_currentIfEl&&(I=I._x_currentIfEl);let N=l[w],y=u[w],d=document.importNode(s.content,!0).firstElementChild,p=ae(N);ge(d,p,s),d._x_refreshXForScope=v=>{Object.entries(v).forEach(([E,S])=>{p[E]=S})},C(()=>{I.after(d),W(()=>z(d))()}),typeof y=="object"&&L("x-for key cannot be an object, it must be a string or an integer",s),a[y]=d}for(let g=0;g<T.length;g++)a[T[g]]._x_refreshXForScope(l[u.indexOf(T[g])]);s._x_prevKeys=u})}function so(e){let t=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,n=/^\s*\(|\)\s*$/g,r=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,i=e.match(r);if(!i)return;let s={};s.items=i[2].trim();let o=i[1].replace(n,"").trim(),a=o.match(t);return a?(s.item=o.replace(t,"").trim(),s.index=a[1].trim(),a[2]&&(s.collection=a[2].trim())):s.item=o,s}function wr(e,t,n,r){let i={};return/^\[.*\]$/.test(e.item)&&Array.isArray(t)?e.item.replace("[","").replace("]","").split(",").map(o=>o.trim()).forEach((o,a)=>{i[o]=t[a]}):/^\{.*\}$/.test(e.item)&&!Array.isArray(t)&&typeof t=="object"?e.item.replace("{","").replace("}","").split(",").map(o=>o.trim()).forEach(o=>{i[o]=t[o]}):i[e.item]=t,e.index&&(i[e.index]=n),e.collection&&(i[e.collection]=r),i}function oo(e){return!Array.isArray(e)&&!isNaN(e)}function xr(){}xr.inline=(e,{expression:t},{cleanup:n})=>{let r=Fe(e);r._x_refs||(r._x_refs={}),r._x_refs[t]=e,n(()=>delete r._x_refs[t])},O("ref",xr),O("if",(e,{expression:t},{effect:n,cleanup:r})=>{e.tagName.toLowerCase()!=="template"&&L("x-if can only be used on a <template> tag",e);let i=R(e,t),s=()=>{if(e._x_currentIfEl)return e._x_currentIfEl;let a=e.content.cloneNode(!0).firstElementChild;return ge(a,{},e),C(()=>{e.after(a),W(()=>z(a))()}),e._x_currentIfEl=a,e._x_undoIf=()=>{C(()=>{fe(a),a.remove()}),delete e._x_currentIfEl},a},o=()=>{e._x_undoIf&&(e._x_undoIf(),delete e._x_undoIf)};n(()=>i(a=>{a?s():o()})),r(()=>e._x_undoIf&&e._x_undoIf())}),O("id",(e,{expression:t},{evaluate:n})=>{n(t).forEach(i=>Vs(e,i))}),De((e,t)=>{e._x_ids&&(t._x_ids=e._x_ids)}),vt(mn("@",_n(ue("on:")))),O("on",W((e,{value:t,modifiers:n,expression:r},{cleanup:i})=>{let s=r?R(e,r):()=>{};e.tagName.toLowerCase()==="template"&&(e._x_forwardEvents||(e._x_forwardEvents=[]),e._x_forwardEvents.includes(t)||e._x_forwardEvents.push(t));let o=jt(e,t,n,a=>{s(()=>{},{scope:{$event:a},params:[a]})});i(()=>o())})),Ue("Collapse","collapse","collapse"),Ue("Intersect","intersect","intersect"),Ue("Focus","trap","focus"),Ue("Mask","mask","mask");function Ue(e,t,n){O(t,r=>L(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`,r))}we.setEvaluator(os),we.setReactivityEngine({reactive:Dt,effect:ms,release:_s,raw:x});var ao=we,ie=ao;function co(e){e.directive("collapse",t),t.inline=(n,{modifiers:r})=>{r.includes("min")&&(n._x_doShow=()=>{},n._x_doHide=()=>{})};function t(n,{modifiers:r}){let i=Er(r,"duration",250)/1e3,s=Er(r,"min",0),o=!r.includes("min");n._x_isShown||(n.style.height=`${s}px`),!n._x_isShown&&o&&(n.hidden=!0),n._x_isShown||(n.style.overflow="hidden");let a=(l,u)=>{let f=e.setStyles(l,u);return u.height?()=>{}:f},c={transitionProperty:"height",transitionDuration:`${i}s`,transitionTimingFunction:"cubic-bezier(0.4, 0.0, 0.2, 1)"};n._x_transition={in(l=()=>{},u=()=>{}){o&&(n.hidden=!1),o&&(n.style.display=null);let f=n.getBoundingClientRect().height;n.style.height="auto";let h=n.getBoundingClientRect().height;f===h&&(f=s),e.transition(n,e.setStyles,{during:c,start:{height:f+"px"},end:{height:h+"px"}},()=>n._x_isShown=!0,()=>{Math.abs(n.getBoundingClientRect().height-h)<1&&(n.style.overflow=null)})},out(l=()=>{},u=()=>{}){let f=n.getBoundingClientRect().height;e.transition(n,a,{during:c,start:{height:f+"px"},end:{height:s+"px"}},()=>n.style.overflow="hidden",()=>{n._x_isShown=!1,n.style.height==`${s}px`&&o&&(n.style.display="none",n.hidden=!0)})}}}}function Er(e,t,n){if(e.indexOf(t)===-1)return n;const r=e[e.indexOf(t)+1];if(!r)return n;if(t==="duration"){let i=r.match(/([0-9]+)ms/);if(i)return i[1]}if(t==="min"){let i=r.match(/([0-9]+)px/);if(i)return i[1]}return r}var lo=co;function uo(e){e.directive("intersect",e.skipDuringClone((t,{value:n,expression:r,modifiers:i},{evaluateLater:s,cleanup:o})=>{let a=s(r),c={rootMargin:po(i),threshold:fo(i)},l=new IntersectionObserver(u=>{u.forEach(f=>{f.isIntersecting!==(n==="leave")&&(a(),i.includes("once")&&l.disconnect())})},c);l.observe(t),o(()=>{l.disconnect()})}))}function fo(e){if(e.includes("full"))return .99;if(e.includes("half"))return .5;if(!e.includes("threshold"))return 0;let t=e[e.indexOf("threshold")+1];return t==="100"?1:t==="0"?0:+`.${t}`}function ho(e){let t=e.match(/^(-?[0-9]+)(px|%)?$/);return t?t[1]+(t[2]||"px"):void 0}function po(e){const t="margin",n="0px 0px 0px 0px",r=e.indexOf(t);if(r===-1)return n;let i=[];for(let s=1;s<5;s++)i.push(ho(e[r+s]||""));return i=i.filter(s=>s!==void 0),i.length?i.join(" ").trim():n}var go=uo,Sr=["input","select","textarea","a[href]","button","[tabindex]:not(slot)","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])',"details>summary:first-of-type","details"],Ge=Sr.join(","),Cr=typeof Element>"u",se=Cr?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,Ht=!Cr&&Element.prototype.getRootNode?function(e){return e.getRootNode()}:function(e){return e.ownerDocument},Ir=function(t,n,r){var i=Array.prototype.slice.apply(t.querySelectorAll(Ge));return n&&se.call(t,Ge)&&i.unshift(t),i=i.filter(r),i},Tr=function e(t,n,r){for(var i=[],s=Array.from(t);s.length;){var o=s.shift();if(o.tagName==="SLOT"){var a=o.assignedElements(),c=a.length?a:o.children,l=e(c,!0,r);r.flatten?i.push.apply(i,l):i.push({scope:o,candidates:l})}else{var u=se.call(o,Ge);u&&r.filter(o)&&(n||!t.includes(o))&&i.push(o);var f=o.shadowRoot||typeof r.getShadowRoot=="function"&&r.getShadowRoot(o),h=!r.shadowRootFilter||r.shadowRootFilter(o);if(f&&h){var b=e(f===!0?o.children:f.children,!0,r);r.flatten?i.push.apply(i,b):i.push({scope:o,candidates:b})}else s.unshift.apply(s,o.children)}}return i},Or=function(t,n){return t.tabIndex<0&&(n||/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName)||t.isContentEditable)&&isNaN(parseInt(t.getAttribute("tabindex"),10))?0:t.tabIndex},vo=function(t,n){return t.tabIndex===n.tabIndex?t.documentOrder-n.documentOrder:t.tabIndex-n.tabIndex},Ar=function(t){return t.tagName==="INPUT"},bo=function(t){return Ar(t)&&t.type==="hidden"},mo=function(t){var n=t.tagName==="DETAILS"&&Array.prototype.slice.apply(t.children).some(function(r){return r.tagName==="SUMMARY"});return n},_o=function(t,n){for(var r=0;r<t.length;r++)if(t[r].checked&&t[r].form===n)return t[r]},yo=function(t){if(!t.name)return!0;var n=t.form||Ht(t),r=function(a){return n.querySelectorAll('input[type="radio"][name="'+a+'"]')},i;if(typeof window<"u"&&typeof window.CSS<"u"&&typeof window.CSS.escape=="function")i=r(window.CSS.escape(t.name));else try{i=r(t.name)}catch(o){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",o.message),!1}var s=_o(i,t.form);return!s||s===t},wo=function(t){return Ar(t)&&t.type==="radio"},xo=function(t){return wo(t)&&!yo(t)},Nr=function(t){var n=t.getBoundingClientRect(),r=n.width,i=n.height;return r===0&&i===0},Eo=function(t,n){var r=n.displayCheck,i=n.getShadowRoot;if(getComputedStyle(t).visibility==="hidden")return!0;var s=se.call(t,"details>summary:first-of-type"),o=s?t.parentElement:t;if(se.call(o,"details:not([open]) *"))return!0;var a=Ht(t).host,c=a?.ownerDocument.contains(a)||t.ownerDocument.contains(t);if(!r||r==="full"){if(typeof i=="function"){for(var l=t;t;){var u=t.parentElement,f=Ht(t);if(u&&!u.shadowRoot&&i(u)===!0)return Nr(t);t.assignedSlot?t=t.assignedSlot:!u&&f!==t.ownerDocument?t=f.host:t=u}t=l}if(c)return!t.getClientRects().length}else if(r==="non-zero-area")return Nr(t);return!1},So=function(t){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))for(var n=t.parentElement;n;){if(n.tagName==="FIELDSET"&&n.disabled){for(var r=0;r<n.children.length;r++){var i=n.children.item(r);if(i.tagName==="LEGEND")return se.call(n,"fieldset[disabled] *")?!0:!i.contains(t)}return!0}n=n.parentElement}return!1},Ze=function(t,n){return!(n.disabled||bo(n)||Eo(n,t)||mo(n)||So(n))},Yt=function(t,n){return!(xo(n)||Or(n)<0||!Ze(t,n))},Co=function(t){var n=parseInt(t.getAttribute("tabindex"),10);return!!(isNaN(n)||n>=0)},Io=function e(t){var n=[],r=[];return t.forEach(function(i,s){var o=!!i.scope,a=o?i.scope:i,c=Or(a,o),l=o?e(i.candidates):a;c===0?o?n.push.apply(n,l):n.push(a):r.push({documentOrder:s,tabIndex:c,item:i,isScope:o,content:l})}),r.sort(vo).reduce(function(i,s){return s.isScope?i.push.apply(i,s.content):i.push(s.content),i},[]).concat(n)},To=function(t,n){n=n||{};var r;return n.getShadowRoot?r=Tr([t],n.includeContainer,{filter:Yt.bind(null,n),flatten:!1,getShadowRoot:n.getShadowRoot,shadowRootFilter:Co}):r=Ir(t,n.includeContainer,Yt.bind(null,n)),Io(r)},Rr=function(t,n){n=n||{};var r;return n.getShadowRoot?r=Tr([t],n.includeContainer,{filter:Ze.bind(null,n),flatten:!0,getShadowRoot:n.getShadowRoot}):r=Ir(t,n.includeContainer,Ze.bind(null,n)),r},Je=function(t,n){if(n=n||{},!t)throw new Error("No node provided");return se.call(t,Ge)===!1?!1:Yt(n,t)},Oo=Sr.concat("iframe").join(","),Xe=function(t,n){if(n=n||{},!t)throw new Error("No node provided");return se.call(t,Oo)===!1?!1:Ze(n,t)};function kr(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable})),n.push.apply(n,r)}return n}function Lr(e){for(var t=1;t<arguments.length;t++){var n=arguments[t]!=null?arguments[t]:{};t%2?kr(Object(n),!0).forEach(function(r){Ao(e,r,n[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):kr(Object(n)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))})}return e}function Ao(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var $r=function(){var e=[];return{activateTrap:function(n){if(e.length>0){var r=e[e.length-1];r!==n&&r.pause()}var i=e.indexOf(n);i===-1||e.splice(i,1),e.push(n)},deactivateTrap:function(n){var r=e.indexOf(n);r!==-1&&e.splice(r,1),e.length>0&&e[e.length-1].unpause()}}}(),No=function(t){return t.tagName&&t.tagName.toLowerCase()==="input"&&typeof t.select=="function"},Ro=function(t){return t.key==="Escape"||t.key==="Esc"||t.keyCode===27},ko=function(t){return t.key==="Tab"||t.keyCode===9},Fr=function(t){return setTimeout(t,0)},Mr=function(t,n){var r=-1;return t.every(function(i,s){return n(i)?(r=s,!1):!0}),r},Se=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];return typeof t=="function"?t.apply(void 0,r):t},Qe=function(t){return t.target.shadowRoot&&typeof t.composedPath=="function"?t.composedPath()[0]:t.target},Lo=function(t,n){var r=n?.document||document,i=Lr({returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0},n),s={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0},o,a=function(d,p,v){return d&&d[p]!==void 0?d[p]:i[v||p]},c=function(d){return s.containerGroups.findIndex(function(p){var v=p.container,E=p.tabbableNodes;return v.contains(d)||E.find(function(S){return S===d})})},l=function(d){var p=i[d];if(typeof p=="function"){for(var v=arguments.length,E=new Array(v>1?v-1:0),S=1;S<v;S++)E[S-1]=arguments[S];p=p.apply(void 0,E)}if(p===!0&&(p=void 0),!p){if(p===void 0||p===!1)return p;throw new Error("`".concat(d,"` was specified but was not a node, or did not return a node"))}var A=p;if(typeof p=="string"&&(A=r.querySelector(p),!A))throw new Error("`".concat(d,"` as selector refers to no known node"));return A},u=function(){var d=l("initialFocus");if(d===!1)return!1;if(d===void 0)if(c(r.activeElement)>=0)d=r.activeElement;else{var p=s.tabbableGroups[0],v=p&&p.firstTabbableNode;d=v||l("fallbackFocus")}if(!d)throw new Error("Your focus-trap needs to have at least one focusable element");return d},f=function(){if(s.containerGroups=s.containers.map(function(d){var p=To(d,i.tabbableOptions),v=Rr(d,i.tabbableOptions);return{container:d,tabbableNodes:p,focusableNodes:v,firstTabbableNode:p.length>0?p[0]:null,lastTabbableNode:p.length>0?p[p.length-1]:null,nextTabbableNode:function(S){var A=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,M=v.findIndex(function(D){return D===S});if(!(M<0))return A?v.slice(M+1).find(function(D){return Je(D,i.tabbableOptions)}):v.slice(0,M).reverse().find(function(D){return Je(D,i.tabbableOptions)})}}}),s.tabbableGroups=s.containerGroups.filter(function(d){return d.tabbableNodes.length>0}),s.tabbableGroups.length<=0&&!l("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")},h=function y(d){if(d!==!1&&d!==r.activeElement){if(!d||!d.focus){y(u());return}d.focus({preventScroll:!!i.preventScroll}),s.mostRecentlyFocusedNode=d,No(d)&&d.select()}},b=function(d){var p=l("setReturnFocus",d);return p||(p===!1?!1:d)},T=function(d){var p=Qe(d);if(!(c(p)>=0)){if(Se(i.clickOutsideDeactivates,d)){o.deactivate({returnFocus:i.returnFocusOnDeactivate&&!Xe(p,i.tabbableOptions)});return}Se(i.allowOutsideClick,d)||d.preventDefault()}},k=function(d){var p=Qe(d),v=c(p)>=0;v||p instanceof Document?v&&(s.mostRecentlyFocusedNode=p):(d.stopImmediatePropagation(),h(s.mostRecentlyFocusedNode||u()))},g=function(d){var p=Qe(d);f();var v=null;if(s.tabbableGroups.length>0){var E=c(p),S=E>=0?s.containerGroups[E]:void 0;if(E<0)d.shiftKey?v=s.tabbableGroups[s.tabbableGroups.length-1].lastTabbableNode:v=s.tabbableGroups[0].firstTabbableNode;else if(d.shiftKey){var A=Mr(s.tabbableGroups,function(Ne){var Gt=Ne.firstTabbableNode;return p===Gt});if(A<0&&(S.container===p||Xe(p,i.tabbableOptions)&&!Je(p,i.tabbableOptions)&&!S.nextTabbableNode(p,!1))&&(A=E),A>=0){var M=A===0?s.tabbableGroups.length-1:A-1,D=s.tabbableGroups[M];v=D.lastTabbableNode}}else{var oe=Mr(s.tabbableGroups,function(Ne){var Gt=Ne.lastTabbableNode;return p===Gt});if(oe<0&&(S.container===p||Xe(p,i.tabbableOptions)&&!Je(p,i.tabbableOptions)&&!S.nextTabbableNode(p))&&(oe=E),oe>=0){var nt=oe===s.tabbableGroups.length-1?0:oe+1,Ut=s.tabbableGroups[nt];v=Ut.firstTabbableNode}}}else v=l("fallbackFocus");v&&(d.preventDefault(),h(v))},m=function(d){if(Ro(d)&&Se(i.escapeDeactivates,d)!==!1){d.preventDefault(),o.deactivate();return}if(ko(d)){g(d);return}},w=function(d){var p=Qe(d);c(p)>=0||Se(i.clickOutsideDeactivates,d)||Se(i.allowOutsideClick,d)||(d.preventDefault(),d.stopImmediatePropagation())},I=function(){if(s.active)return $r.activateTrap(o),s.delayInitialFocusTimer=i.delayInitialFocus?Fr(function(){h(u())}):h(u()),r.addEventListener("focusin",k,!0),r.addEventListener("mousedown",T,{capture:!0,passive:!1}),r.addEventListener("touchstart",T,{capture:!0,passive:!1}),r.addEventListener("click",w,{capture:!0,passive:!1}),r.addEventListener("keydown",m,{capture:!0,passive:!1}),o},N=function(){if(s.active)return r.removeEventListener("focusin",k,!0),r.removeEventListener("mousedown",T,!0),r.removeEventListener("touchstart",T,!0),r.removeEventListener("click",w,!0),r.removeEventListener("keydown",m,!0),o};return o={get active(){return s.active},get paused(){return s.paused},activate:function(d){if(s.active)return this;var p=a(d,"onActivate"),v=a(d,"onPostActivate"),E=a(d,"checkCanFocusTrap");E||f(),s.active=!0,s.paused=!1,s.nodeFocusedBeforeActivation=r.activeElement,p&&p();var S=function(){E&&f(),I(),v&&v()};return E?(E(s.containers.concat()).then(S,S),this):(S(),this)},deactivate:function(d){if(!s.active)return this;var p=Lr({onDeactivate:i.onDeactivate,onPostDeactivate:i.onPostDeactivate,checkCanReturnFocus:i.checkCanReturnFocus},d);clearTimeout(s.delayInitialFocusTimer),s.delayInitialFocusTimer=void 0,N(),s.active=!1,s.paused=!1,$r.deactivateTrap(o);var v=a(p,"onDeactivate"),E=a(p,"onPostDeactivate"),S=a(p,"checkCanReturnFocus"),A=a(p,"returnFocus","returnFocusOnDeactivate");v&&v();var M=function(){Fr(function(){A&&h(b(s.nodeFocusedBeforeActivation)),E&&E()})};return A&&S?(S(b(s.nodeFocusedBeforeActivation)).then(M,M),this):(M(),this)},pause:function(){return s.paused||!s.active?this:(s.paused=!0,N(),this)},unpause:function(){return!s.paused||!s.active?this:(s.paused=!1,f(),I(),this)},updateContainerElements:function(d){var p=[].concat(d).filter(Boolean);return s.containers=p.map(function(v){return typeof v=="string"?r.querySelector(v):v}),s.active&&f(),this}},o.updateContainerElements(t),o};function $o(e){let t,n;window.addEventListener("focusin",()=>{t=n,n=document.activeElement}),e.magic("focus",r=>{let i=r;return{__noscroll:!1,__wrapAround:!1,within(s){return i=s,this},withoutScrolling(){return this.__noscroll=!0,this},noscroll(){return this.__noscroll=!0,this},withWrapAround(){return this.__wrapAround=!0,this},wrap(){return this.withWrapAround()},focusable(s){return Xe(s)},previouslyFocused(){return t},lastFocused(){return t},focused(){return n},focusables(){return Array.isArray(i)?i:Rr(i,{displayCheck:"none"})},all(){return this.focusables()},isFirst(s){let o=this.all();return o[0]&&o[0].isSameNode(s)},isLast(s){let o=this.all();return o.length&&o.slice(-1)[0].isSameNode(s)},getFirst(){return this.all()[0]},getLast(){return this.all().slice(-1)[0]},getNext(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===s.length-1?s[0]:s[s.indexOf(o)+1]},getPrevious(){let s=this.all(),o=document.activeElement;if(s.indexOf(o)!==-1)return this.__wrapAround&&s.indexOf(o)===0?s.slice(-1)[0]:s[s.indexOf(o)-1]},first(){this.focus(this.getFirst())},last(){this.focus(this.getLast())},next(){this.focus(this.getNext())},previous(){this.focus(this.getPrevious())},prev(){return this.previous()},focus(s){s&&setTimeout(()=>{s.hasAttribute("tabindex")||s.setAttribute("tabindex","0"),s.focus({preventScroll:this.__noscroll})})}}}),e.directive("trap",e.skipDuringClone((r,{expression:i,modifiers:s},{effect:o,evaluateLater:a,cleanup:c})=>{let l=a(i),u=!1,f={escapeDeactivates:!1,allowOutsideClick:!0,fallbackFocus:()=>r};if(s.includes("noautofocus"))f.initialFocus=!1;else{let g=r.querySelector("[autofocus]");g&&(f.initialFocus=g)}let h=Lo(r,f),b=()=>{},T=()=>{};const k=()=>{b(),b=()=>{},T(),T=()=>{},h.deactivate({returnFocus:!s.includes("noreturn")})};o(()=>l(g=>{u!==g&&(g&&!u&&(s.includes("noscroll")&&(T=Fo()),s.includes("inert")&&(b=Dr(r)),setTimeout(()=>{h.activate()},15)),!g&&u&&k(),u=!!g)})),c(k)},(r,{expression:i,modifiers:s},{evaluate:o})=>{s.includes("inert")&&o(i)&&Dr(r)}))}function Dr(e){let t=[];return Pr(e,n=>{let r=n.hasAttribute("aria-hidden");n.setAttribute("aria-hidden","true"),t.push(()=>r||n.removeAttribute("aria-hidden"))}),()=>{for(;t.length;)t.pop()()}}function Pr(e,t){e.isSameNode(document.body)||!e.parentNode||Array.from(e.parentNode.children).forEach(n=>{n.isSameNode(e)?Pr(e.parentNode,t):t(n)})}function Fo(){let e=document.documentElement.style.overflow,t=document.documentElement.style.paddingRight,n=window.innerWidth-document.documentElement.clientWidth;return document.documentElement.style.overflow="hidden",document.documentElement.style.paddingRight=`${n}px`,()=>{document.documentElement.style.overflow=e,document.documentElement.style.paddingRight=t}}var Mo=$o;/*! Bundled license information:
  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)
  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  */function Do(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Po(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function zo(e,t,n){return t&&Po(e.prototype,t),e}var jo=Object.defineProperty,j=function(e,t){return jo(e,"name",{value:t,configurable:!0})},Bo=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`,Wo=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`,Ho=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,Yo=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,Ko=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`,Vo=j(function(e){return new DOMParser().parseFromString(e,"text/html").body.childNodes[0]},"stringToHTML"),Ce=j(function(e){var t=new DOMParser().parseFromString(e,"application/xml");return document.importNode(t.documentElement,!0).outerHTML},"getSvgNode"),_={CONTAINER:"sn-notifications-container",NOTIFY:"sn-notify",NOTIFY_CONTENT:"sn-notify-content",NOTIFY_ICON:"sn-notify-icon",NOTIFY_CLOSE:"sn-notify-close",NOTIFY_TITLE:"sn-notify-title",NOTIFY_TEXT:"sn-notify-text",IS_X_CENTER:"sn-is-x-center",IS_Y_CENTER:"sn-is-y-center",IS_CENTER:"sn-is-center",IS_LEFT:"sn-is-left",IS_RIGHT:"sn-is-right",IS_TOP:"sn-is-top",IS_BOTTOM:"sn-is-bottom",NOTIFY_OUTLINE:"sn-notify-outline",NOTIFY_FILLED:"sn-notify-filled",NOTIFY_ERROR:"sn-notify-error",NOTIFY_WARNING:"sn-notify-warning",NOTIFY_SUCCESS:"sn-notify-success",NOTIFY_INFO:"sn-notify-info",NOTIFY_FADE:"sn-notify-fade",NOTIFY_FADE_IN:"sn-notify-fade-in",NOTIFY_SLIDE:"sn-notify-slide",NOTIFY_SLIDE_IN:"sn-notify-slide-in",NOTIFY_AUTOCLOSE:"sn-notify-autoclose"},K={ERROR:"error",WARNING:"warning",SUCCESS:"success",INFO:"info"},zr={OUTLINE:"outline",FILLED:"filled"},Kt={FADE:"fade",SLIDE:"slide"},Ie={CLOSE:Ce(Bo),SUCCESS:Ce(Yo),ERROR:Ce(Wo),WARNING:Ce(Ko),INFO:Ce(Ho)},jr=j(function(e){e.wrapper.classList.add(_.NOTIFY_FADE),setTimeout(function(){e.wrapper.classList.add(_.NOTIFY_FADE_IN)},100)},"fadeIn"),Br=j(function(e){e.wrapper.classList.remove(_.NOTIFY_FADE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"fadeOut"),qo=j(function(e){e.wrapper.classList.add(_.NOTIFY_SLIDE),setTimeout(function(){e.wrapper.classList.add(_.NOTIFY_SLIDE_IN)},100)},"slideIn"),Uo=j(function(e){e.wrapper.classList.remove(_.NOTIFY_SLIDE_IN),setTimeout(function(){e.wrapper.remove()},e.speed)},"slideOut"),Wr=function(){function e(t){var n=this;Do(this,e),this.notifyOut=j(function(Ne){Ne(n)},"notifyOut");var r=t.notificationsGap,i=r===void 0?20:r,s=t.notificationsPadding,o=s===void 0?20:s,a=t.status,c=a===void 0?"success":a,l=t.effect,u=l===void 0?Kt.FADE:l,f=t.type,h=f===void 0?"outline":f,b=t.title,T=t.text,k=t.showIcon,g=k===void 0?!0:k,m=t.customIcon,w=m===void 0?"":m,I=t.customClass,N=I===void 0?"":I,y=t.speed,d=y===void 0?500:y,p=t.showCloseButton,v=p===void 0?!0:p,E=t.autoclose,S=E===void 0?!0:E,A=t.autotimeout,M=A===void 0?3e3:A,D=t.position,oe=D===void 0?"right top":D,nt=t.customWrapper,Ut=nt===void 0?"":nt;if(this.customWrapper=Ut,this.status=c,this.title=b,this.text=T,this.showIcon=g,this.customIcon=w,this.customClass=N,this.speed=d,this.effect=u,this.showCloseButton=v,this.autoclose=S,this.autotimeout=M,this.notificationsGap=i,this.notificationsPadding=o,this.type=h,this.position=oe,!this.checkRequirements()){console.error("You must specify 'title' or 'text' at least.");return}this.setContainer(),this.setWrapper(),this.setPosition(),this.showIcon&&this.setIcon(),this.showCloseButton&&this.setCloseButton(),this.setContent(),this.container.prepend(this.wrapper),this.setEffect(),this.notifyIn(this.selectedNotifyInEffect),this.autoclose&&this.autoClose(),this.setObserver()}return zo(e,[{key:"checkRequirements",value:function(){return!!(this.title||this.text)}},{key:"setContainer",value:function(){var n=document.querySelector(".".concat(_.CONTAINER));n?this.container=n:(this.container=document.createElement("div"),this.container.classList.add(_.CONTAINER),document.body.appendChild(this.container)),this.notificationsPadding&&this.container.style.setProperty("--sn-notifications-padding","".concat(this.notificationsPadding,"px")),this.notificationsGap&&this.container.style.setProperty("--sn-notifications-gap","".concat(this.notificationsGap,"px"))}},{key:"setPosition",value:function(){this.container.classList[this.position==="center"?"add":"remove"](_.IS_CENTER),this.container.classList[this.position.includes("left")?"add":"remove"](_.IS_LEFT),this.container.classList[this.position.includes("right")?"add":"remove"](_.IS_RIGHT),this.container.classList[this.position.includes("top")?"add":"remove"](_.IS_TOP),this.container.classList[this.position.includes("bottom")?"add":"remove"](_.IS_BOTTOM),this.container.classList[this.position.includes("x-center")?"add":"remove"](_.IS_X_CENTER),this.container.classList[this.position.includes("y-center")?"add":"remove"](_.IS_Y_CENTER)}},{key:"setCloseButton",value:function(){var n=this,r=document.createElement("div");r.classList.add(_.NOTIFY_CLOSE),r.innerHTML=Ie.CLOSE,this.wrapper.appendChild(r),r.addEventListener("click",function(){n.close()})}},{key:"setWrapper",value:function(){var n=this;switch(this.customWrapper?this.wrapper=Vo(this.customWrapper):this.wrapper=document.createElement("div"),this.wrapper.style.setProperty("--sn-notify-transition-duration","".concat(this.speed,"ms")),this.wrapper.classList.add(_.NOTIFY),this.type){case zr.OUTLINE:this.wrapper.classList.add(_.NOTIFY_OUTLINE);break;case zr.FILLED:this.wrapper.classList.add(_.NOTIFY_FILLED);break;default:this.wrapper.classList.add(_.NOTIFY_OUTLINE)}switch(this.status){case K.SUCCESS:this.wrapper.classList.add(_.NOTIFY_SUCCESS);break;case K.ERROR:this.wrapper.classList.add(_.NOTIFY_ERROR);break;case K.WARNING:this.wrapper.classList.add(_.NOTIFY_WARNING);break;case K.INFO:this.wrapper.classList.add(_.NOTIFY_INFO);break}this.autoclose&&(this.wrapper.classList.add(_.NOTIFY_AUTOCLOSE),this.wrapper.style.setProperty("--sn-notify-autoclose-timeout","".concat(this.autotimeout+this.speed,"ms"))),this.customClass&&this.customClass.split(" ").forEach(function(r){n.wrapper.classList.add(r)})}},{key:"setContent",value:function(){var n=document.createElement("div");n.classList.add(_.NOTIFY_CONTENT);var r,i;this.title&&(r=document.createElement("div"),r.classList.add(_.NOTIFY_TITLE),r.textContent=this.title.trim(),this.showCloseButton||(r.style.paddingRight="0")),this.text&&(i=document.createElement("div"),i.classList.add(_.NOTIFY_TEXT),i.innerHTML=this.text.trim(),this.title||(i.style.marginTop="0")),this.wrapper.appendChild(n),this.title&&n.appendChild(r),this.text&&n.appendChild(i)}},{key:"setIcon",value:function(){var n=j(function(i){switch(i){case K.SUCCESS:return Ie.SUCCESS;case K.ERROR:return Ie.ERROR;case K.WARNING:return Ie.WARNING;case K.INFO:return Ie.INFO}},"computedIcon"),r=document.createElement("div");r.classList.add(_.NOTIFY_ICON),r.innerHTML=this.customIcon||n(this.status),(this.status||this.customIcon)&&this.wrapper.appendChild(r)}},{key:"setObserver",value:function(){var n=this,r=new IntersectionObserver(function(i){if(i[0].intersectionRatio<=0)n.close();else return},{threshold:0});setTimeout(function(){r.observe(n.wrapper)},this.speed)}},{key:"notifyIn",value:function(t){t(this)}},{key:"autoClose",value:function(){var n=this;setTimeout(function(){n.close()},this.autotimeout+this.speed)}},{key:"close",value:function(){this.notifyOut(this.selectedNotifyOutEffect)}},{key:"setEffect",value:function(){switch(this.effect){case Kt.FADE:this.selectedNotifyInEffect=jr,this.selectedNotifyOutEffect=Br;break;case Kt.SLIDE:this.selectedNotifyInEffect=qo,this.selectedNotifyOutEffect=Uo;break;default:this.selectedNotifyInEffect=jr,this.selectedNotifyOutEffect=Br}}}]),e}();j(Wr,"Notify");var Hr=Wr;globalThis.Notify=Hr;const Yr=["success","error","warning","info"],Kr=["right top","top right","right bottom","bottom right","left top","top left","left bottom","bottom left","center top","x-center top","center bottom","x-center bottom","left center","left y-center","y-center left","right center","right y-center","y-center right","top center","top x-center","bottom center","bottom x-center","center"],Vr={status:"info",title:"Notification",text:"",effect:"fade",speed:300,autoclose:!0,autotimeout:4e3,position:"right top"};function Te(e={}){const t={...Vr,...e};Yr.includes(t.status)||(console.warn(`Invalid status '${t.status}' passed to Toast. Defaulting to 'info'.`),t.status="info"),Kr.includes(t.position)||(console.warn(`Invalid position '${t.position}' passed to Toast. Defaulting to 'right top'.`),t.position="right top"),new Hr(t)}const Go={custom:Te,success(e,t="Success",n={}){Te({status:"success",title:t,text:e,...n})},error(e,t="Error",n={}){Te({status:"error",title:t,text:e,...n})},warning(e,t="Warning",n={}){Te({status:"warning",title:t,text:e,...n})},info(e,t="Info",n={}){Te({status:"info",title:t,text:e,...n})},setDefaults(e={}){Object.assign(Vr,e)},get allowedStatuses(){return[...Yr]},get allowedPositions(){return[...Kr]}},Vt=function(){},Oe={},et={},Ae={};function Zo(e,t){e=Array.isArray(e)?e:[e];const n=[];let r=e.length,i=r,s,o,a,c;for(s=function(l,u){u.length&&n.push(l),i--,i||t(n)};r--;){if(o=e[r],a=et[o],a){s(o,a);continue}c=Ae[o]=Ae[o]||[],c.push(s)}}function qr(e,t){if(!e)return;const n=Ae[e];if(et[e]=t,!!n)for(;n.length;)n[0](e,t),n.splice(0,1)}function qt(e,t){typeof e=="function"&&(e={success:e}),t.length?(e.error||Vt)(t):(e.success||Vt)(e)}function Jo(e,t,n,r,i,s,o,a){let c=e.type[0];if(a)try{n.sheet.cssText.length||(c="e")}catch(l){l.code!==18&&(c="e")}if(c==="e"){if(s+=1,s<o)return Ur(t,r,i,s)}else if(n.rel==="preload"&&n.as==="style"){n.rel="stylesheet";return}r(t,c,e.defaultPrevented)}function Ur(e,t,n,r){const i=document,s=n.async,o=(n.numRetries||0)+1,a=n.before||Vt,c=e.replace(/[\?|#].*$/,""),l=e.replace(/^(css|img|module|nomodule)!/,"");let u,f,h;if(r=r||0,/(^css!|\.css$)/.test(c))h=i.createElement("link"),h.rel="stylesheet",h.href=l,u="hideFocus"in h,u&&h.relList&&(u=0,h.rel="preload",h.as="style"),n.inlineStyleNonce&&h.setAttribute("nonce",n.inlineStyleNonce);else if(/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(c))h=i.createElement("img"),h.src=l;else if(h=i.createElement("script"),h.src=l,h.async=s===void 0?!0:s,n.inlineScriptNonce&&h.setAttribute("nonce",n.inlineScriptNonce),f="noModule"in h,/^module!/.test(c)){if(!f)return t(e,"l");h.type="module"}else if(/^nomodule!/.test(c)&&f)return t(e,"l");const b=function(T){Jo(T,e,h,t,n,r,o,u)};h.addEventListener("load",b,{once:!0}),h.addEventListener("error",b,{once:!0}),a(e,h)!==!1&&i.head.appendChild(h)}function Xo(e,t,n){e=Array.isArray(e)?e:[e];let r=e.length,i=[];function s(o,a,c){if(a==="e"&&i.push(o),a==="b")if(c)i.push(o);else return;r--,r||t(i)}for(let o=0;o<e.length;o++)Ur(e[o],s,n)}function V(e,t,n){let r,i;if(t&&typeof t=="string"&&t.trim&&(r=t.trim()),i=(r?n:t)||{},r){if(r in Oe)throw"LoadJS";Oe[r]=!0}function s(o,a){Xo(e,function(c){qt(i,c),o&&qt({success:o,error:a},c),qr(r,c)},i)}if(i.returnPromise)return new Promise(s);s()}V.ready=function(t,n){return Zo(t,function(r){qt(n,r)}),V},V.done=function(t){qr(t,[])},V.reset=function(){Object.keys(Oe).forEach(t=>delete Oe[t]),Object.keys(et).forEach(t=>delete et[t]),Object.keys(Ae).forEach(t=>delete Ae[t])},V.isDefined=function(t){return t in Oe};function Qo(e){e.data("rzAccordion",()=>({selected:"",allowMultiple:!1,init(){this.allowMultiple=this.$el.dataset.multiple==="true"},destroy(){}}))}function ea(e){e.data("rzAccordionSection",()=>({open:!1,sectionId:"",expandedClass:"",init(){this.open=this.$el.dataset.isOpen==="true",this.sectionId=this.$el.dataset.sectionId,this.expandedClass=this.$el.dataset.expandedClass;const t=this;typeof this.selected<"u"&&typeof this.allowMultiple<"u"?this.$watch("selected",(n,r)=>{n!==t.sectionId&&!t.allowMultiple&&(t.open=!1)}):console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.")},destroy(){},toggle(){this.selected=this.sectionId,this.open=!this.open},getExpandedCss(){return this.open?this.expandedClass:""},getAriaExpanded(){return this.open?"true":"false"}}))}function ta(e){e.data("rzAlert",()=>({showAlert:!0,dismiss(){this.showAlert=!1}}))}function na(e){e.data("rzBrowser",()=>({screenSize:"",setDesktopScreenSize(){this.screenSize=""},setTabletScreenSize(){this.screenSize="max-w-2xl"},setPhoneScreenSize(){this.screenSize="max-w-sm"},getBrowserBorderCss(){return[this.screenSize,this.screenSize===""?"border-none":"border-x"]},getDesktopScreenCss(){return[this.screenSize===""?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getTabletScreenCss(){return[this.screenSize==="max-w-2xl"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getPhoneScreenCss(){return[this.screenSize==="max-w-sm"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]}}))}function ra(e){e.data("rzCheckboxGroupItem",()=>({checkbox:null,isChecked:!1,init(){this.checkbox=this.$refs.chk,this.isChecked=this.checkbox.checked},toggleCheckbox(){this.isChecked=this.checkbox.checked},getIconCss(){return this.isChecked?"":"hidden"}}))}function ia(e,t){e.data("rzCodeViewer",()=>({expand:!1,border:!0,copied:!1,copyTitle:"Copy",copiedTitle:"Copied!",init(){const n=JSON.parse(this.$el.dataset.assets),r=this.$el.dataset.codeid,i=this.$el.dataset.nonce;this.copyTitle=this.$el.dataset.copyTitle||this.copyTitle,this.copiedTitle=this.$el.dataset.copiedTitle||this.copiedTitle,t(n,{success:function(){const s=document.getElementById(r);window.hljs&&s&&window.hljs.highlightElement(s)},error:function(){console.error("Failed to load Highlight.js")}},i)},notCopied(){return!this.copied},disableCopied(){this.copied=!1},toggleExpand(){this.expand=!this.expand},copyHTML(){navigator.clipboard.writeText(this.$refs.codeBlock.textContent),this.copied=!this.copied},getCopiedTitle(){return this.copied?this.copiedTitle:this.copyTitle},getCopiedCss(){return[this.copied?"focus-visible:outline-success":"focus-visible:outline-foreground"]},getExpandCss(){return[this.expand?"":"max-h-60"]},getExpandButtonCss(){return this.expand?"rotate-180":"rotate-0"}}))}function sa(e,t){e.data("rzDateEdit",()=>({options:{},placeholder:"",prependText:"",init(){const n=this.$el.dataset.config,r=document.getElementById(this.$el.dataset.uid+"-input");if(n){const o=JSON.parse(n);o&&(this.options=o.options||{},this.placeholder=o.placeholder||"",this.prependText=o.prependText||"")}const i=JSON.parse(this.$el.dataset.assets),s=this.$el.dataset.nonce;t(i,{success:function(){window.flatpickr&&r&&window.flatpickr(r,this.options)},error:function(){console.error("Failed to load Flatpickr assets.")}},s)}}))}function oa(e){e.data("rzDropdown",()=>({dropdownEl:null,anchorCss:"",dropdownOpen:!1,openedWithKeyboard:!1,init(){this.dropdownEl=this.$el,this.anchorCss=this.getAnchorCss()},toggleDropdown(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!this.dropdownOpen},openDropdown(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!0,this.openedWithKeyboard=!1},openWithKeyboard(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!0,this.openedWithKeyboard=!0,this.focusWrapNext()},closeDropdown(){this.dropdownOpen=!1,this.openedWithKeyboard=!1},focusWrapNext(){this.$focus.wrap().next()},focusWrapPrevious(){this.$focus.wrap().previous()},getAnchorCss(){let n=(this.dropdownEl.getAttribute("data-anchor")||"").replace(/-/g,"").toLowerCase();const r={topstart:"bottom-full right-0 mb-2 origin-bottom-right",topcenter:"left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",topend:"bottom-full left-0 mb-2 origin-bottom-left",start:"right-full top-1/2 -translate-y-1/2 me-2 origin-right",end:"left-full top-1/2 -translate-y-1/2 ms-2 origin-left",bottomstart:"right-0 mt-2 origin-top-right",bottomcenter:"-translate-x-1/2 mt-2 origin-top",bottomend:"left-0 mt-2 origin-top-left"};let i=r[n]||"";const s=this.dropdownEl.getBoundingClientRect();let o=document.createElement("div");o.style.cssText="position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;",this.dropdownEl.appendChild(o);const a=this.dropdownEl.querySelector('[role="menu"]');if(!a)return i;let c=a.cloneNode(!0);c.style.transition="none",c.style.transform="none",c.style.opacity="1",c.style.display="block",o.appendChild(c);let l=c.getBoundingClientRect();o.parentNode.removeChild(o);const u=8;let f=!1;if(n.startsWith("top")?s.top<l.height+u&&(f=!0):n.startsWith("bottom")?s.bottom+l.height+u>window.innerHeight&&(f=!0):n==="start"?s.left<l.width+u&&(f=!0):n==="end"&&s.right+l.width+u>window.innerWidth&&(f=!0),f){let b={topstart:"bottomstart",topcenter:"bottomcenter",topend:"bottomend",bottomstart:"topstart",bottomcenter:"topcenter",bottomend:"topend",start:"end",end:"start"}[n]||n;i=r[b]||i}return i}}))}function aa(e){e.data("rzDarkModeToggle",()=>({mode:"light",applyTheme:null,init(){const t=typeof window<"u"&&"localStorage"in window,n=["light","dark","auto"],r=window.matchMedia("(prefers-color-scheme: dark)").matches;let i="auto";t&&(i=localStorage.getItem("darkMode")??"auto",n.includes(i)||(i="light")),t&&localStorage.setItem("darkMode",i),this.applyTheme=()=>{document.documentElement.classList.toggle("dark",i==="dark"||i==="auto"&&r)},this.applyTheme(),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",this.applyTheme)},isDark(){const t=window.matchMedia("(prefers-color-scheme: dark)").matches;return localStorage.getItem("darkMode"),this.mode==="dark"||this.mode==="auto"&&t},isLight(){return!this.isDark()},toggle(){let t=localStorage.getItem("darkMode");const n=window.matchMedia("(prefers-color-scheme: dark)").matches;t==="light"?t="dark":t==="dark"?t="light":t==="auto"&&(t=n?"light":"dark"),this.mode=t,localStorage.setItem("darkMode",t);const r=t==="dark"||t==="auto"&&n;document.documentElement.classList.toggle("dark",r);const i=new CustomEvent("darkModeToggle",{detail:{darkMode:r}});window.dispatchEvent(i)},destroy(){this.applyTheme&&window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change",this.applyTheme)}}))}function ca(e){e.data("rzEmbeddedPreview",()=>({iframe:null,onDarkModeToggle:null,init(){try{this.iframe=this.$refs.iframe;const t=this.debounce(()=>{this.resizeIframe(this.iframe)},50);this.resizeIframe(this.iframe),new ResizeObserver(i=>{for(let s of i)t()}).observe(this.iframe);const r=this.iframe;this.onDarkModeToggle=i=>{r.contentWindow.postMessage(i.detail,"*")},window.addEventListener("darkModeToggle",this.onDarkModeToggle)}catch{console.error("Cannot access iframe content")}},resizeIframe(t){if(t)try{const n=t.contentDocument||t.contentWindow?.document;if(n){const r=n.body;if(!r)setInterval(()=>{this.resizeIframe(t)},150);else{const i=r.scrollHeight+15;t.style.height=i+"px"}}}catch(n){console.error("Error resizing iframe:",n)}},debounce(t,n=300){let r;return(...i)=>{clearTimeout(r),r=setTimeout(()=>{t.apply(this,i)},n)}},destroy(){window.removeEventListener("darkModeToggle",this.onDarkModeToggle)}}))}function la(e){e.data("rzEmpty",()=>{})}function ua(e){e.data("rzHeading",()=>({observer:null,headingId:"",init(){this.headingId=this.$el.dataset.alpineRoot;const t=this;if(typeof this.setCurrentHeading=="function"){const n=(i,s)=>{i.forEach(o=>{o.isIntersecting&&t.setCurrentHeading(t.headingId)})},r={threshold:.5};this.observer=new IntersectionObserver(n,r),this.observer.observe(this.$el)}else console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.")},destroy(){this.observer!=null&&this.observer.disconnect()}}))}function da(e,t){e.data("rzMarkdown",()=>({init(){const n=JSON.parse(this.$el.dataset.assets),r=this.$el.dataset.nonce;t(n,{success:function(){window.hljs.highlightAll()},error:function(){console.error("Failed to load Highlight.js")}},r)}}))}function fa(e){e.data("rzModal",()=>({modalOpen:!1,eventTriggerName:"",closeEventName:"rz:modal-close",closeOnEscape:!0,closeOnClickOutside:!0,modalId:"",bodyId:"",footerId:"",nonce:"",_escapeListener:null,_openListener:null,_closeEventListener:null,init(){this.modalId=this.$el.dataset.modalId||"",this.bodyId=this.$el.dataset.bodyId||"",this.footerId=this.$el.dataset.footerId||"",this.nonce=this.$el.dataset.nonce||"",this.eventTriggerName=this.$el.dataset.eventTriggerName||"",this.closeEventName=this.$el.dataset.closeEventName||this.closeEventName,this.closeOnEscape=this.$el.dataset.closeOnEscape!=="false",this.closeOnClickOutside=this.$el.dataset.closeOnClickOutside!=="false",this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized",{detail:{modalId:this.modalId,bodyId:this.bodyId,footerId:this.footerId},bubbles:!0})),this.eventTriggerName&&(this._openListener=t=>{this.openModal(t)},window.addEventListener(this.eventTriggerName,this._openListener)),this._closeEventListener=t=>{this.modalOpen&&this.closeModalInternally("event")},window.addEventListener(this.closeEventName,this._closeEventListener),this._escapeListener=t=>{this.modalOpen&&this.closeOnEscape&&t.key==="Escape"&&this.closeModalInternally("escape")},window.addEventListener("keydown",this._escapeListener),this.$watch("modalOpen",t=>{const n=document.body.offsetWidth;document.body.classList.toggle("overflow-hidden",t);const r=document.body.offsetWidth-n;document.body.style.setProperty("--page-scrollbar-width",`${r}px`),t?this.$nextTick(()=>{this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(),this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open",{detail:{modalId:this.modalId},bubbles:!0}))}):this.$nextTick(()=>{this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close",{detail:{modalId:this.modalId},bubbles:!0}))})})},notModalOpen(){return!this.modalOpen},destroy(){this._openListener&&this.eventTriggerName&&window.removeEventListener(this.eventTriggerName,this._openListener),this._closeEventListener&&window.removeEventListener(this.closeEventName,this._closeEventListener),this._escapeListener&&window.removeEventListener("keydown",this._escapeListener),document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px")},openModal(t=null){const n=new CustomEvent("rz:modal-before-open",{detail:{modalId:this.modalId,originalEvent:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(n),n.defaultPrevented||(this.modalOpen=!0)},closeModalInternally(t="unknown"){const n=new CustomEvent("rz:modal-before-close",{detail:{modalId:this.modalId,reason:t},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(n),n.defaultPrevented||(document.activeElement?.blur&&document.activeElement.blur(),this.modalOpen=!1,document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px"))},closeModal(){this.closeModalInternally("button")},handleClickOutside(){this.closeOnClickOutside&&this.closeModalInternally("backdrop")}}))}function ha(e){e.data("rzPrependInput",()=>({prependContainer:null,textInput:null,init(){this.prependContainer=this.$refs.prependContainer,this.textInput=this.$refs.textInput;let t=this;setTimeout(()=>{t.updatePadding()},50),window.addEventListener("resize",this.updatePadding)},destroy(){window.removeEventListener("resize",this.updatePadding)},updatePadding(){const t=this.prependContainer,n=this.textInput;if(!t||!n){n&&n.classList.remove("text-transparent");return}const i=t.offsetWidth+10;n.style.paddingLeft=i+"px",n.classList.remove("text-transparent")}}))}function pa(e){e.data("rzProgress",()=>({currentVal:0,minVal:0,maxVal:100,percentage:0,label:"",init(){const t=this.$el;this.currentVal=parseInt(t.getAttribute("data-current-val"))||0,this.minVal=parseInt(t.getAttribute("data-min-val"))||0,this.maxVal=parseInt(t.getAttribute("data-max-val"))||100,this.label=t.getAttribute("data-label"),this.calculatePercentage(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuemin",this.minVal),t.setAttribute("aria-valuemax",this.maxVal),t.setAttribute("aria-valuetext",`${this.percentage}%`),this.updateProgressBar(),new ResizeObserver(r=>{this.updateProgressBar()}).observe(t),this.$watch("currentVal",()=>{this.calculatePercentage(),this.updateProgressBar(),t.setAttribute("aria-valuenow",this.currentVal),t.setAttribute("aria-valuetext",`${this.percentage}%`)})},calculatePercentage(){this.maxVal===this.minVal?this.percentage=0:this.percentage=Math.min(Math.max((this.currentVal-this.minVal)/(this.maxVal-this.minVal)*100,0),100)},buildLabel(){var t=this.label||"{percent}%";return this.calculatePercentage(),t.replace("{percent}",this.percentage)},buildInsideLabelPosition(){const t=this.$refs.progressBar,n=this.$refs.progressBarLabel,r=this.$refs.innerLabel;n&&t&&r&&(r.innerText=this.buildLabel(),n.clientWidth>t.clientWidth?n.style.left=t.clientWidth+10+"px":n.style.left=t.clientWidth/2-n.clientWidth/2+"px")},getLabelCss(){const t=this.$refs.progressBarLabel,n=this.$refs.progressBar;return t&&n&&t.clientWidth>n.clientWidth?"text-foreground dark:text-foreground":""},updateProgressBar(){const t=this.$refs.progressBar;t&&(t.style.width=`${this.percentage}%`,this.buildInsideLabelPosition())},setProgress(t){this.currentVal=t},increment(t=1){this.currentVal=Math.min(this.currentVal+t,this.maxVal)},decrement(t=1){this.currentVal=Math.max(this.currentVal-t,this.minVal)}}))}function ga(e){e.data("rzQuickReferenceContainer",()=>({headings:[],currentHeadingId:"",init(){this.headings=JSON.parse(this.$el.dataset.headings||"[]"),this.currentHeadingId=this.$el.dataset.currentheadingid||""},handleHeadingClick(){const t=this.$el.dataset.headingid;window.requestAnimationFrame(()=>{this.currentHeadingId=t})},setCurrentHeading(t){this.headings.includes(t)&&(this.currentHeadingId=t)},getSelectedCss(){const t=this.$el.dataset.headingid;return{"font-bold":this.currentHeadingId===t}},getSelectedAriaCurrent(){const t=this.$el.dataset.headingid;return this.currentHeadingId===t?"true":null}}))}function va(e){e.data("rzTabs",()=>({buttonRef:null,tabSelected:"",tabButton:null,init(){this.buttonRef=document.getElementById(this.$el.dataset.buttonref),this.tabSelected=this.$el.dataset.tabselected,this.tabButton=this.buttonRef.querySelector("[data-name='"+this.tabSelected+"']"),this.tabRepositionMarker(this.tabButton)},tabButtonClicked(t){t instanceof Event&&(t=t.target),this.tabSelected=t.dataset.name,this.tabRepositionMarker(t),t.focus()},tabRepositionMarker(t){this.tabButton=t,this.$refs.tabMarker.style.width=t.offsetWidth+"px",this.$refs.tabMarker.style.height=t.offsetHeight+"px",this.$refs.tabMarker.style.left=t.offsetLeft+"px",setTimeout(()=>{this.$refs.tabMarker.style.opacity=1},150)},getTabContentCss(){return this.tabSelected===this.$el.dataset.name?"":"hidden"},tabContentActive(t){return t=t??this.$el,this.tabSelected===t.dataset.name},tabButtonActive(t){return t=t??this.$el,this.tabSelected===t.dataset.name},getTabButtonAriaSelected(){return this.tabSelected===this.$el.dataset.name?"true":"false"},getSelectedTabTextColorCss(){const t=this.$el.dataset.selectedtextcolor??"";return this.tabSelected===this.$el.dataset.name?t:""},handleResize(){this.tabRepositionMarker(this.tabButton)},handleKeyDown(t){const n=t.key,r=Array.from(this.buttonRef.querySelectorAll("[role='tab']")),i=r.findIndex(o=>this.tabSelected===o.dataset.name);let s=i;n==="ArrowRight"?(s=(i+1)%r.length,t.preventDefault()):n==="ArrowLeft"?(s=(i-1+r.length)%r.length,t.preventDefault()):n==="Home"?(s=0,t.preventDefault()):n==="End"&&(s=r.length-1,t.preventDefault()),s!==i&&this.tabButtonClicked(r[s])}}))}function ba(e){e.data("rzSidebar",()=>({showSidebar:!1,isSidebarHidden(){return!this.showSidebar},toggleSidebar(){this.showSidebar=!this.showSidebar},hideSidebar(){this.showSidebar=!1},getSidebarTranslation(){return this.showSidebar?"translate-x-0":"-translate-x-60"}}))}function ma(e){e.data("rzSidebarLinkItem",()=>({isExpanded:!1,chevronExpandedClass:"",chevronCollapsedClass:"",init(){this.isExpanded=this.$el.dataset.expanded==="true",this.chevronExpandedClass=this.$el.dataset.chevronExpandedClass,this.chevronCollapsedClass=this.$el.dataset.chevronCollapsedClass},isCollapsed(){return!this.isExpanded},toggleExpanded(){this.isExpanded=!this.isExpanded},hideSidebar(){const t=this.$el.closest('[x-data^="rzSidebar"]');if(t){let n=e.$data(t);n.showSidebar=!1}else console.warn("Parent sidebar context not found or 'showSidebar' is not defined.")},getExpandedClass(){return this.isExpanded?this.chevronExpandedClass:this.chevronCollapsedClass},getAriaExpanded(){return this.isExpanded?"true":"false"}}))}async function _a(e){e=[...e].sort();const t=e.join("|"),r=new TextEncoder().encode(t),i=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(i)).map(o=>o.toString(16).padStart(2,"0")).join("")}function tt(e,t,n){_a(e).then(r=>{V.isDefined(r)||V(e,r,{async:!1,inlineScriptNonce:n,inlineStyleNonce:n}),V.ready([r],t)})}function ya(e){Qo(e),ea(e),ta(e),na(e),ra(e),ia(e,tt),sa(e,tt),oa(e),aa(e),ca(e),la(e),ua(e),da(e,tt),fa(e),ha(e),pa(e),ga(e),va(e),ba(e),ma(e)}function wa(e){if(typeof Alpine>"u"||typeof Alpine.$data!="function"){console.error("$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use.");return}let t=null,n=null;if(typeof e=="string"){if(!e){console.warn("Rizzy.$data: Invalid componentId provided (empty string).");return}if(n=e,t=document.getElementById(n),!t){console.warn(`Rizzy.$data: Rizzy component with ID "${n}" not found in the DOM.`);return}}else if(e instanceof Element){if(t=e,!t.id){console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");return}n=t.id}else{console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");return}const r=`[data-alpine-root="${n}"]`;let i=null;if(t.matches(r)?i=t:i=t.querySelector(r),!i){console.warn(`Rizzy.$data: Could not locate the designated Alpine root element using selector "${r}" on or inside the wrapper element (ID: #${n}). Verify the 'data-alpine-root' attribute placement.`);return}const s=Alpine.$data(i);if(s===void 0){const o=`${i.tagName.toLowerCase()}${i.id?"#"+i.id:""}${i.classList.length?"."+Array.from(i.classList).join("."):""}`;console.warn(`Rizzy.$data: Located designated Alpine root (${o}) via 'data-alpine-root="${n}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`)}return s}ie.plugin(lo),ie.plugin(go),ie.plugin(Mo),ya(ie);const Gr={Alpine:ie,require:tt,toast:Go,$data:wa};return window.Alpine=ie,window.Rizzy={...window.Rizzy||{},...Gr},ie.start(),Gr});
</file>

<file path="wwwroot/js/rizzyui-csp.umd.js">
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.RizzyUICsp = factory());
})(this, function() {
  "use strict";
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1 && index > lastFlushedIndex)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i2 = 0; i2 < queue.length; i2++) {
      queue[i2]();
      lastFlushedIndex = i2;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i2) => i2());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i2) => i2());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    el._x_effects?.forEach(dequeueJob);
    while (el._x_cleanups?.length)
      el._x_cleanups.pop()();
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = [];
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < mutations.length; i2++) {
      if (mutations[i2].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i2].type === "childList") {
        mutations[i2].removedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (!node._x_marker)
            return;
          removedNodes.add(node);
        });
        mutations[i2].addedNodes.forEach((node) => {
          if (node.nodeType !== 1)
            return;
          if (removedNodes.has(node)) {
            removedNodes.delete(node);
            return;
          }
          if (node._x_marker)
            return;
          addedNodes.push(node);
        });
      }
      if (mutations[i2].type === "attributes") {
        let el = mutations[i2].target;
        let name = mutations[i2].attributeName;
        let oldValue = mutations[i2].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i2) => i2(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.some((i2) => i2.contains(node)))
        continue;
      onElRemoveds.forEach((i2) => i2(node));
    }
    for (let node of addedNodes) {
      if (!node.isConnected)
        continue;
      onElAddeds.forEach((i2) => i2(node));
    }
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i2) => i2 !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i2) => Object.keys(i2)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Reflect.has(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return descriptor.set.call(thisProxy, value) || true;
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }
  function initInterceptors(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        if (typeof value === "object" && value !== null && value.__v_skip)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    let memoizedUtilities = getUtilities(el);
    Object.entries(magics).forEach(([name, callback]) => {
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, memoizedUtilities);
        },
        enumerable: false
      });
    });
    return obj;
  }
  function getUtilities(el) {
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    let utils = { interceptor, ...utilities };
    onElRemoved(el, cleanup2);
    return utils;
  }
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e2) {
      handleError(e2, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}
${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i2) => runIfTypeOfFunction(receiver, i2, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i2) => receiver(i2));
    } else {
      receiver(value);
    }
  }
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directiveExists(name) {
    return Object.keys(directiveHandlers).includes(name);
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i2) => i2());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i2) => i2;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i2) => i2.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a2, b) {
    let typeA = directiveOrder.indexOf(a2.type) === -1 ? DEFAULT : a2.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
    setTimeout(() => {
      warnAboutMissingPlugins();
    });
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors2 = [];
  function interceptInit(callback) {
    initInterceptors2.push(callback);
  }
  var markerDispenser = 1;
  function initTree(el, walker = walk, intercept = () => {
  }) {
    if (findClosest(el, (i2) => i2._x_ignore))
      return;
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        if (el2._x_marker)
          return;
        intercept(el2, skip);
        initInterceptors2.forEach((i2) => i2(el2, skip));
        directives(el2, el2.attributes).forEach((handle) => handle());
        if (!el2._x_ignore)
          el2._x_marker = markerDispenser++;
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root, walker = walk) {
    walker(root, (el) => {
      cleanupElement(el);
      cleanupAttributes(el);
      delete el._x_marker;
    });
  }
  function warnAboutMissingPlugins() {
    let pluginDirectives = [
      ["ui", "dialog", ["[x-dialog], [x-popover]"]],
      ["anchor", "anchor", ["[x-anchor]"]],
      ["sort", "sort", ["[x-sort]"]]
    ];
    pluginDirectives.forEach(([plugin2, directive2, selectors]) => {
      if (directiveExists(directive2))
        return;
      selectors.some((selector) => {
        if (document.querySelector(selector)) {
          warn(`found "${selector}", but missing ${plugin2} plugin`);
          return true;
        }
      });
    });
  }
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let missingClasses = (classString2) => classString2.split(" ").filter((i2) => !el.classList.contains(i2)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i2) => {
      if (el.classList.contains(i2)) {
        el.classList.remove(i2);
        removed.push(i2);
      }
    });
    forAdd.forEach((i2) => {
      if (!el.classList.contains(i2)) {
        el.classList.add(i2);
        added.push(i2);
      }
    });
    return () => {
      removed.forEach((i2) => el.classList.add(i2));
      added.forEach((i2) => el.classList.remove(i2));
    };
  }
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i2, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue$1(modifiers, "scale", 95) / 100 : 1;
    let delay2 = modifierValue$1(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue$1(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue$1(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue$1(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay2}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i2]) => i2?.());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e2) => {
            if (!e2.isFromCancelledTransition)
              throw e2;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay2 = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay2);
        reachedEnd = true;
      });
    });
  }
  function modifierValue$1(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function onlyDuringClone(callback) {
    return (...args) => isCloning && callback(...args);
  }
  var interceptors = [];
  function interceptClone(callback) {
    interceptors.push(callback);
  }
  function cloneNode(from, to) {
    interceptors.forEach((i2) => i2(from, to));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to, (el, callback) => {
        callback(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (isRadio$1(el)) {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (isCheckbox(el)) {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  var booleanAttributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected",
    "shadowrootclonable",
    "shadowrootdelegatesfocus",
    "shadowrootserializable"
  ]);
  function isBooleanAttr(attrName) {
    return booleanAttributes.has(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }
  function isCheckbox(el) {
    return el.type === "checkbox" || el.localName === "ui-checkbox" || el.localName === "ui-switch";
  }
  function isRadio$1(el) {
    return el.type === "radio" || el.localName === "ui-radio";
  }
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else ;
      }
      outerHash = JSON.stringify(outerGet());
      JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }
  function plugin(callback) {
    let callbacks = Array.isArray(callback) ? callback : [callback];
    callbacks.forEach((i2) => i2(alpine_default));
  }
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    initInterceptors(stores[name]);
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
  }
  function getStores() {
    return stores;
  }
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }
  var Alpine$1 = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.14.9",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine$1;
  function cspEvaluator(el, expression) {
    let dataStack = generateDataStack(el);
    if (typeof expression === "function") {
      return generateEvaluatorFromFunction(dataStack, expression);
    }
    let evaluator = generateEvaluator(el, expression, dataStack);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateDataStack(el) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    return [overriddenMagics, ...closestDataStack(el)];
  }
  function generateEvaluator(el, expression, dataStack) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let completeScope = mergeProxies([scope2, ...dataStack]);
      let evaluatedExpression = expression.split(".").reduce(
        (currentScope, currentExpression) => {
          if (currentScope[currentExpression] === void 0) {
            throwExpressionError(el, expression);
          }
          return currentScope[currentExpression];
        },
        completeScope
      );
      runIfTypeOfFunction(receiver, evaluatedExpression, completeScope, params);
    };
  }
  function throwExpressionError(el, expression) {
    console.warn(
      `Alpine Error: Alpine is unable to interpret the following expression using the CSP-friendly build:
"${expression}"
Read more about the Alpine's CSP-friendly build restrictions here: https://alpinejs.dev/advanced/csp
`,
      el
    );
  }
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i2 = 0; i2 < list.length; i2++) {
      map[list[i2]] = true;
    }
    return (val) => !!map[val];
  }
  var EMPTY_OBJ = Object.freeze({});
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol("iterate");
  var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i2 = 0; i2 < deps.length; i2++) {
        deps[i2].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
          track(arr, "get", i2 + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys$1(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys: ownKeys$1
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v2) => Reflect.getPrototypeOf(v2);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = isMap(target) ? new Map(target) : new Set(target);
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r2) {
    return Boolean(r2 && r2.__v_isRef === true);
  }
  magic("nextTick", () => nextTick);
  magic("dispatch", (el) => dispatch.bind(dispatch, el));
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i2) => value = i2);
      return value;
    };
    let unwatch = watch(getter, callback);
    cleanup2(unwatch);
  });
  magic("store", getStores);
  magic("data", (el) => scope(el));
  magic("root", (el) => closestRoot(el));
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    findClosest(el, (i2) => {
      if (i2._x_refs)
        refObjects.push(i2._x_refs);
    });
    return refObjects;
  }
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id}-${key}` : `${name}-${id}`;
    });
  });
  interceptClone((from, to) => {
    if (from._x_id) {
      to._x_id = from._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }
  magic("el", (el) => el);
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i2) => result = i2);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone2.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e2) => {
          e2.stopPropagation();
          el.dispatchEvent(new e2.constructor(e2.type, e2));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    let placeInDom = (clone3, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone3, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone3, target2.nextSibling);
      } else {
        target2.appendChild(clone3);
      }
    };
    mutateDom(() => {
      placeInDom(clone2, target, modifiers);
      skipDuringClone(() => {
        initTree(clone2);
      })();
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(
      () => mutateDom(() => {
        clone2.remove();
        destroyTree(clone2);
      })
    );
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);
  directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
    effect3(evaluateLater(el, expression));
  }));
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler4 = (e2) => callback(e2);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e2) => wrapper(callback2, e2);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.preventDefault();
        next(e2);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.stopPropagation();
        next(e2);
      });
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        next(e2);
        listenerTarget.removeEventListener(event, handler4, options);
      });
    }
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (el.contains(e2.target))
          return;
        if (e2.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e2);
      });
    }
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e2) => {
        e2.target === el && next(e2);
      });
    if (isKeyEvent(event) || isClickEvent(event)) {
      handler4 = wrapHandler(handler4, (next, e2) => {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers)) {
          return;
        }
        next(e2);
      });
    }
    listenerTarget.addEventListener(event, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isClickEvent(event) {
    return ["contextmenu", "click", "mouse"].some((i2) => event.includes(i2));
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e2, modifiers) {
    let keyModifiers = modifiers.filter((i2) => {
      return !["window", "document", "prevent", "stop", "once", "capture", "self", "away", "outside", "passive"].includes(i2);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e2.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i2) => !selectedSystemKeyModifiers.includes(i2));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e2[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (isClickEvent(e2.type))
          return false;
        if (keyToModifiers(e2.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "comma": ",",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener = isCloning ? () => {
    } : on(el, event, modifiers, (e2) => {
      setValue(getInputValue(el, modifiers, e2, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === "select" && el.multiple) {
        setValue(
          getInputValue(el, modifiers, { target: el }, getValue())
        );
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e2) => {
        nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect3(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event, currentValue) {
    return mutateDom(() => {
      if (event instanceof CustomEvent && event.detail !== void 0)
        return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
      else if (isCheckbox(el)) {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event.target.value);
          } else {
            newValue = event.target.value;
          }
          return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        let newValue;
        if (isRadio$1(el)) {
          if (event.target.checked) {
            newValue = event.target.value;
          } else {
            newValue = currentValue;
          }
        } else {
          newValue = event.target.value;
        }
        if (modifiers.includes("number")) {
          return safeParseNumber(newValue);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(newValue);
        } else if (modifiers.includes("trim")) {
          return newValue.trim();
        } else {
          return newValue;
        }
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
    cleanup2(() => {
      el._x_undoAddedClasses && el._x_undoAddedClasses();
      el._x_undoAddedStyles && el._x_undoAddedStyles();
    });
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  });
  interceptClone((from, to) => {
    if (from._x_dataStack) {
      to._x_dataStack = from._x_dataStack;
      to.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => mutateDom(
        () => {
          destroyTree(el2);
          el2.remove();
        }
      ));
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i2) => typeof i2 === "object" && !Array.isArray(i2);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i2) => i2 + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => {
            if (keys.includes(value2))
              warn("Duplicate key on x-for", el);
            keys.push(value2);
          }, { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i2 = 0; i2 < items.length; i2++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i2], i2, items);
          evaluateKey((value) => {
            if (keys.includes(value))
              warn("Duplicate key on x-for", el);
            keys.push(value);
          }, { scope: { index: i2, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i2 = 0; i2 < prevKeys.length; i2++) {
        let key = prevKeys[i2];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i2 = 0; i2 < keys.length; i2++) {
        let key = keys[i2];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i2, 0, key);
          adds.push([lastKey, i2]);
        } else if (prevIndex !== i2) {
          let keyInSpot = prevKeys.splice(i2, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i2, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i2 = 0; i2 < removes.length; i2++) {
        let key = removes[i2];
        if (!(key in lookup))
          continue;
        mutateDom(() => {
          destroyTree(lookup[key]);
          lookup[key].remove();
        });
        delete lookup[key];
      }
      for (let i2 = 0; i2 < moves.length; i2++) {
        let [keyInSpot, keyForSpot] = moves[i2];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl, keyForSpot, lookup);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i2 = 0; i2 < adds.length; i2++) {
        let [lastKey2, index] = adds[i2];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone2, reactiveScope, templateEl);
        clone2._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone2);
          skipDuringClone(() => initTree(clone2))();
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i2 = 0; i2 < sames.length; i2++) {
        lookup[sames[i2]]._x_refreshXForScope(scopes[keys.indexOf(sames[i2])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i2) => i2.trim());
      names.forEach((name, i2) => {
        scopeVariables[name] = item[i2];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i2) => i2.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        skipDuringClone(() => initTree(clone2))();
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        mutateDom(() => {
          destroyTree(clone2);
          clone2.remove();
        });
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from, to) => {
    if (from._x_ids) {
      to._x_ids = from._x_ids;
    }
  });
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e2) => {
      evaluate2(() => {
      }, { scope: { "$event": e2 }, params: [e2] });
    });
    cleanup2(() => removeListener());
  }));
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }
  alpine_default.setEvaluator(cspEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default$3 = alpine_default;
  var module_default$3 = src_default$3;
  function src_default$2(Alpine2) {
    Alpine2.directive("collapse", collapse);
    collapse.inline = (el, { modifiers }) => {
      if (!modifiers.includes("min"))
        return;
      el._x_doShow = () => {
      };
      el._x_doHide = () => {
      };
    };
    function collapse(el, { modifiers }) {
      let duration = modifierValue(modifiers, "duration", 250) / 1e3;
      let floor = modifierValue(modifiers, "min", 0);
      let fullyHide = !modifiers.includes("min");
      if (!el._x_isShown)
        el.style.height = `${floor}px`;
      if (!el._x_isShown && fullyHide)
        el.hidden = true;
      if (!el._x_isShown)
        el.style.overflow = "hidden";
      let setFunction = (el2, styles) => {
        let revertFunction = Alpine2.setStyles(el2, styles);
        return styles.height ? () => {
        } : revertFunction;
      };
      let transitionStyles = {
        transitionProperty: "height",
        transitionDuration: `${duration}s`,
        transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
      };
      el._x_transition = {
        in(before = () => {
        }, after = () => {
        }) {
          if (fullyHide)
            el.hidden = false;
          if (fullyHide)
            el.style.display = null;
          let current = el.getBoundingClientRect().height;
          el.style.height = "auto";
          let full = el.getBoundingClientRect().height;
          if (current === full) {
            current = floor;
          }
          Alpine2.transition(el, Alpine2.setStyles, {
            during: transitionStyles,
            start: { height: current + "px" },
            end: { height: full + "px" }
          }, () => el._x_isShown = true, () => {
            if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
              el.style.overflow = null;
            }
          });
        },
        out(before = () => {
        }, after = () => {
        }) {
          let full = el.getBoundingClientRect().height;
          Alpine2.transition(el, setFunction, {
            during: transitionStyles,
            start: { height: full + "px" },
            end: { height: floor + "px" }
          }, () => el.style.overflow = "hidden", () => {
            el._x_isShown = false;
            if (el.style.height == `${floor}px` && fullyHide) {
              el.style.display = "none";
              el.hidden = true;
            }
          });
        }
      };
    }
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "min") {
      let match = rawValue.match(/([0-9]+)px/);
      if (match)
        return match[1];
    }
    return rawValue;
  }
  var module_default$2 = src_default$2;
  function src_default$1(Alpine2) {
    Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
      let evaluate2 = evaluateLater2(expression);
      let options = {
        rootMargin: getRootMargin(modifiers),
        threshold: getThreshold(modifiers)
      };
      let observer2 = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting === (value === "leave"))
            return;
          evaluate2();
          modifiers.includes("once") && observer2.disconnect();
        });
      }, options);
      observer2.observe(el);
      cleanup2(() => {
        observer2.disconnect();
      });
    }));
  }
  function getThreshold(modifiers) {
    if (modifiers.includes("full"))
      return 0.99;
    if (modifiers.includes("half"))
      return 0.5;
    if (!modifiers.includes("threshold"))
      return 0;
    let threshold = modifiers[modifiers.indexOf("threshold") + 1];
    if (threshold === "100")
      return 1;
    if (threshold === "0")
      return 0;
    return Number(`.${threshold}`);
  }
  function getLengthValue(rawValue) {
    let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
    return match ? match[1] + (match[2] || "px") : void 0;
  }
  function getRootMargin(modifiers) {
    const key = "margin";
    const fallback = "0px 0px 0px 0px";
    const index = modifiers.indexOf(key);
    if (index === -1)
      return fallback;
    let values = [];
    for (let i2 = 1; i2 < 5; i2++) {
      values.push(getLengthValue(modifiers[index + i2] || ""));
    }
    values = values.filter((v2) => v2 !== void 0);
    return values.length ? values.join(" ").trim() : fallback;
  }
  var module_default$1 = src_default$1;
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
    return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r2;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === "full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (nodeIsAttached) {
        return !node.getClientRects().length;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = /* @__PURE__ */ function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e2) {
    return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e2) {
    return e2.key === "Tab" || e2.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i2) {
      if (fn(value)) {
        idx = i2;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event) {
    return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2, config.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e2) {
      var target = getActualTarget(e2);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e2.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e2) {
      var target = getActualTarget(e2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e2.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e2.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e2.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e2) {
      if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
        e2.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e2)) {
        checkTab(e2);
        return;
      }
    };
    var checkClick = function checkClick2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };
  function src_default(Alpine2) {
    let lastFocused;
    let currentFocused;
    window.addEventListener("focusin", () => {
      lastFocused = currentFocused;
      currentFocused = document.activeElement;
    });
    Alpine2.magic("focus", (el) => {
      let within = el;
      return {
        __noscroll: false,
        __wrapAround: false,
        within(el2) {
          within = el2;
          return this;
        },
        withoutScrolling() {
          this.__noscroll = true;
          return this;
        },
        noscroll() {
          this.__noscroll = true;
          return this;
        },
        withWrapAround() {
          this.__wrapAround = true;
          return this;
        },
        wrap() {
          return this.withWrapAround();
        },
        focusable(el2) {
          return isFocusable(el2);
        },
        previouslyFocused() {
          return lastFocused;
        },
        lastFocused() {
          return lastFocused;
        },
        focused() {
          return currentFocused;
        },
        focusables() {
          if (Array.isArray(within))
            return within;
          return focusable(within, { displayCheck: "none" });
        },
        all() {
          return this.focusables();
        },
        isFirst(el2) {
          let els = this.all();
          return els[0] && els[0].isSameNode(el2);
        },
        isLast(el2) {
          let els = this.all();
          return els.length && els.slice(-1)[0].isSameNode(el2);
        },
        getFirst() {
          return this.all()[0];
        },
        getLast() {
          return this.all().slice(-1)[0];
        },
        getNext() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
            return list[0];
          }
          return list[list.indexOf(current) + 1];
        },
        getPrevious() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === 0) {
            return list.slice(-1)[0];
          }
          return list[list.indexOf(current) - 1];
        },
        first() {
          this.focus(this.getFirst());
        },
        last() {
          this.focus(this.getLast());
        },
        next() {
          this.focus(this.getNext());
        },
        previous() {
          this.focus(this.getPrevious());
        },
        prev() {
          return this.previous();
        },
        focus(el2) {
          if (!el2)
            return;
          setTimeout(() => {
            if (!el2.hasAttribute("tabindex"))
              el2.setAttribute("tabindex", "0");
            el2.focus({ preventScroll: this.__noscroll });
          });
        }
      };
    });
    Alpine2.directive("trap", Alpine2.skipDuringClone(
      (el, { expression, modifiers }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
        let evaluator = evaluateLater2(expression);
        let oldValue = false;
        let options = {
          escapeDeactivates: false,
          allowOutsideClick: true,
          fallbackFocus: () => el
        };
        if (modifiers.includes("noautofocus")) {
          options.initialFocus = false;
        } else {
          let autofocusEl = el.querySelector("[autofocus]");
          if (autofocusEl)
            options.initialFocus = autofocusEl;
        }
        let trap = createFocusTrap(el, options);
        let undoInert = () => {
        };
        let undoDisableScrolling = () => {
        };
        const releaseFocus = () => {
          undoInert();
          undoInert = () => {
          };
          undoDisableScrolling();
          undoDisableScrolling = () => {
          };
          trap.deactivate({
            returnFocus: !modifiers.includes("noreturn")
          });
        };
        effect3(() => evaluator((value) => {
          if (oldValue === value)
            return;
          if (value && !oldValue) {
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            if (modifiers.includes("inert"))
              undoInert = setInert(el);
            setTimeout(() => {
              trap.activate();
            }, 15);
          }
          if (!value && oldValue) {
            releaseFocus();
          }
          oldValue = !!value;
        }));
        cleanup2(releaseFocus);
      },
      // When cloning, we only want to add aria-hidden attributes to the
      // DOM and not try to actually trap, as trapping can mess with the
      // live DOM and isn't just isolated to the cloned DOM.
      (el, { expression, modifiers }, { evaluate: evaluate2 }) => {
        if (modifiers.includes("inert") && evaluate2(expression))
          setInert(el);
      }
    ));
  }
  function setInert(el) {
    let undos = [];
    crawlSiblingsUp(el, (sibling) => {
      let cache = sibling.hasAttribute("aria-hidden");
      sibling.setAttribute("aria-hidden", "true");
      undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
    });
    return () => {
      while (undos.length)
        undos.pop()();
    };
  }
  function crawlSiblingsUp(el, callback) {
    if (el.isSameNode(document.body) || !el.parentNode)
      return;
    Array.from(el.parentNode.children).forEach((sibling) => {
      if (sibling.isSameNode(el)) {
        crawlSiblingsUp(el.parentNode, callback);
      } else {
        callback(sibling);
      }
    });
  }
  function disableScrolling() {
    let overflow = document.documentElement.style.overflow;
    let paddingRight = document.documentElement.style.paddingRight;
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden";
    document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
    return () => {
      document.documentElement.style.overflow = overflow;
      document.documentElement.style.paddingRight = paddingRight;
    };
  }
  var module_default = src_default;
  /*! Bundled license information:
    tabbable/dist/index.esm.js:
      (*!
      * tabbable 5.3.3
      * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
      *)
    focus-trap/dist/focus-trap.esm.js:
      (*!
      * focus-trap 6.9.4
      * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
      *)
    */
  function t(t2, e2) {
    if (!(t2 instanceof e2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function e(t2, e2) {
    for (var s2 = 0; s2 < e2.length; s2++) {
      var i2 = e2[s2];
      i2.enumerable = i2.enumerable || false;
      i2.configurable = true;
      if ("value" in i2) i2.writable = true;
      Object.defineProperty(t2, i2.key, i2);
    }
  }
  function s(t2, s2, i2) {
    if (s2) e(t2.prototype, s2);
    return t2;
  }
  var i = Object.defineProperty;
  var n = function(t2, e2) {
    return i(t2, "name", { value: e2, configurable: true });
  };
  var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
  var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
  var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var h = n(function(t2) {
    return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
  }, "stringToHTML"), d = n(function(t2) {
    var e2 = new DOMParser().parseFromString(t2, "application/xml");
    return document.importNode(e2.documentElement, true).outerHTML;
  }, "getSvgNode");
  var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
  var N = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
    }, 100);
  }, "fadeIn"), O = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "fadeOut"), T = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
    }, 100);
  }, "slideIn"), E = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "slideOut");
  var m = function() {
    function e2(s2) {
      var i2 = this;
      t(this, e2);
      this.notifyOut = n(function(t2) {
        t2(i2);
      }, "notifyOut");
      var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
      if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
        console.error("You must specify 'title' or 'text' at least.");
        return;
      }
      this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
    }
    s(e2, [{ key: "checkRequirements", value: function t2() {
      return !!(this.title || this.text);
    } }, { key: "setContainer", value: function t2() {
      var t3 = document.querySelector(".".concat(u.CONTAINER));
      t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
    } }, { key: "setPosition", value: function t2() {
      this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
    } }, { key: "setCloseButton", value: function t2() {
      var t3 = this;
      var e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
        t3.close();
      });
    } }, { key: "setWrapper", value: function t2() {
      var t3 = this;
      switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
        case p.OUTLINE:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
          break;
        case p.FILLED:
          this.wrapper.classList.add(u.NOTIFY_FILLED);
          break;
        default:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
      }
      switch (this.status) {
        case f.SUCCESS:
          this.wrapper.classList.add(u.NOTIFY_SUCCESS);
          break;
        case f.ERROR:
          this.wrapper.classList.add(u.NOTIFY_ERROR);
          break;
        case f.WARNING:
          this.wrapper.classList.add(u.NOTIFY_WARNING);
          break;
        case f.INFO:
          this.wrapper.classList.add(u.NOTIFY_INFO);
          break;
      }
      this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
        t3.wrapper.classList.add(e3);
      });
    } }, { key: "setContent", value: function t2() {
      var t3 = document.createElement("div");
      t3.classList.add(u.NOTIFY_CONTENT);
      var e3, s2;
      this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
    } }, { key: "setIcon", value: function t2() {
      var t3 = n(function(t4) {
        switch (t4) {
          case f.SUCCESS:
            return v.SUCCESS;
          case f.ERROR:
            return v.ERROR;
          case f.WARNING:
            return v.WARNING;
          case f.INFO:
            return v.INFO;
        }
      }, "computedIcon"), e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
    } }, { key: "setObserver", value: function t2() {
      var t3 = this;
      var e3 = new IntersectionObserver(function(e4) {
        if (e4[0].intersectionRatio <= 0) t3.close();
        else return;
      }, { threshold: 0 });
      setTimeout(function() {
        e3.observe(t3.wrapper);
      }, this.speed);
    } }, { key: "notifyIn", value: function t2(t2) {
      t2(this);
    } }, { key: "autoClose", value: function t2() {
      var t3 = this;
      setTimeout(function() {
        t3.close();
      }, this.autotimeout + this.speed);
    } }, { key: "close", value: function t2() {
      this.notifyOut(this.selectedNotifyOutEffect);
    } }, { key: "setEffect", value: function t2() {
      switch (this.effect) {
        case I.FADE:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
          break;
        case I.SLIDE:
          this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
          break;
        default:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
      }
    } }]);
    return e2;
  }();
  n(m, "Notify");
  var w = m;
  globalThis.Notify = w;
  const allowedStatuses = ["success", "error", "warning", "info"];
  const allowedPositions = [
    // Standard Corners
    "right top",
    "top right",
    "right bottom",
    "bottom right",
    "left top",
    "top left",
    "left bottom",
    "bottom left",
    // Centered Horizontally
    "center top",
    "x-center top",
    "center bottom",
    "x-center bottom",
    // Centered Vertically
    "left center",
    "left y-center",
    "y-center left",
    "right center",
    "right y-center",
    "y-center right",
    // Aliases for Centered Horizontally (already covered but good for robustness)
    "top center",
    "top x-center",
    "bottom center",
    "bottom x-center",
    // Absolute Center
    "center"
  ];
  const defaultConfig = {
    status: "info",
    title: "Notification",
    text: "",
    effect: "fade",
    speed: 300,
    autoclose: true,
    autotimeout: 4e3,
    position: "right top"
  };
  function renderToast(options = {}) {
    const config = {
      ...defaultConfig,
      ...options
    };
    if (!allowedStatuses.includes(config.status)) {
      console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
      config.status = "info";
    }
    if (!allowedPositions.includes(config.position)) {
      console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
      config.position = "right top";
    }
    new w(config);
  }
  const Toast = {
    custom: renderToast,
    success(text, title = "Success", options = {}) {
      renderToast({
        status: "success",
        title,
        text,
        ...options
      });
    },
    error(text, title = "Error", options = {}) {
      renderToast({
        status: "error",
        title,
        text,
        ...options
      });
    },
    warning(text, title = "Warning", options = {}) {
      renderToast({
        status: "warning",
        title,
        text,
        ...options
      });
    },
    info(text, title = "Info", options = {}) {
      renderToast({
        status: "info",
        title,
        text,
        ...options
      });
    },
    setDefaults(newDefaults = {}) {
      Object.assign(defaultConfig, newDefaults);
    },
    get allowedStatuses() {
      return [...allowedStatuses];
    },
    get allowedPositions() {
      return [...allowedPositions];
    }
  };
  const devnull = function() {
  }, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
  function subscribe(bundleIds, callbackFn) {
    bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
    const depsNotFound = [];
    let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
    fn = function(bundleId2, pathsNotFound) {
      if (pathsNotFound.length) depsNotFound.push(bundleId2);
      numWaiting--;
      if (!numWaiting) callbackFn(depsNotFound);
    };
    while (i2--) {
      bundleId = bundleIds[i2];
      r2 = bundleResultCache[bundleId];
      if (r2) {
        fn(bundleId, r2);
        continue;
      }
      q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
      q.push(fn);
    }
  }
  function publish(bundleId, pathsNotFound) {
    if (!bundleId) return;
    const q = bundleCallbackQueue[bundleId];
    bundleResultCache[bundleId] = pathsNotFound;
    if (!q) return;
    while (q.length) {
      q[0](bundleId, pathsNotFound);
      q.splice(0, 1);
    }
  }
  function executeCallbacks(args, depsNotFound) {
    if (typeof args === "function") args = { success: args };
    if (depsNotFound.length) (args.error || devnull)(depsNotFound);
    else (args.success || devnull)(args);
  }
  function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
    let result = ev.type[0];
    if (isLegacyIECss) {
      try {
        if (!e2.sheet.cssText.length) result = "e";
      } catch (x) {
        if (x.code !== 18) result = "e";
      }
    }
    if (result === "e") {
      numTries += 1;
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e2.rel === "preload" && e2.as === "style") {
      e2.rel = "stylesheet";
      return;
    }
    callbackFn(path, result, ev.defaultPrevented);
  }
  function loadFile(path, callbackFn, args, numTries) {
    const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
    let isLegacyIECss, hasModuleSupport, e2;
    numTries = numTries || 0;
    if (/(^css!|\.css$)/.test(pathname)) {
      e2 = doc.createElement("link");
      e2.rel = "stylesheet";
      e2.href = pathStripped;
      isLegacyIECss = "hideFocus" in e2;
      if (isLegacyIECss && e2.relList) {
        isLegacyIECss = 0;
        e2.rel = "preload";
        e2.as = "style";
      }
      if (args.inlineStyleNonce) {
        e2.setAttribute("nonce", args.inlineStyleNonce);
      }
    } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
      e2 = doc.createElement("img");
      e2.src = pathStripped;
    } else {
      e2 = doc.createElement("script");
      e2.src = pathStripped;
      e2.async = async === void 0 ? true : async;
      if (args.inlineScriptNonce) {
        e2.setAttribute("nonce", args.inlineScriptNonce);
      }
      hasModuleSupport = "noModule" in e2;
      if (/^module!/.test(pathname)) {
        if (!hasModuleSupport) return callbackFn(path, "l");
        e2.type = "module";
      } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
        return callbackFn(path, "l");
      }
    }
    const onEvent = function(ev) {
      handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
    };
    e2.addEventListener("load", onEvent, { once: true });
    e2.addEventListener("error", onEvent, { once: true });
    if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
  }
  function loadFiles(paths, callbackFn, args) {
    paths = Array.isArray(paths) ? paths : [paths];
    let numWaiting = paths.length, pathsNotFound = [];
    function fn(path, result, defaultPrevented) {
      if (result === "e") pathsNotFound.push(path);
      if (result === "b") {
        if (defaultPrevented) pathsNotFound.push(path);
        else return;
      }
      numWaiting--;
      if (!numWaiting) callbackFn(pathsNotFound);
    }
    for (let i2 = 0; i2 < paths.length; i2++) {
      loadFile(paths[i2], fn, args);
    }
  }
  function loadjs(paths, arg1, arg2) {
    let bundleId, args;
    if (arg1 && typeof arg1 === "string" && arg1.trim) {
      bundleId = arg1.trim();
    }
    args = (bundleId ? arg2 : arg1) || {};
    if (bundleId) {
      if (bundleId in bundleIdCache) {
        throw "LoadJS";
      } else {
        bundleIdCache[bundleId] = true;
      }
    }
    function loadFn(resolve, reject) {
      loadFiles(paths, function(pathsNotFound) {
        executeCallbacks(args, pathsNotFound);
        if (resolve) {
          executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
        }
        publish(bundleId, pathsNotFound);
      }, args);
    }
    if (args.returnPromise) {
      return new Promise(loadFn);
    } else {
      loadFn();
    }
  }
  loadjs.ready = function ready(deps, args) {
    subscribe(deps, function(depsNotFound) {
      executeCallbacks(args, depsNotFound);
    });
    return loadjs;
  };
  loadjs.done = function done(bundleId) {
    publish(bundleId, []);
  };
  loadjs.reset = function reset() {
    Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
    Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
    Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
  };
  loadjs.isDefined = function isDefined(bundleId) {
    return bundleId in bundleIdCache;
  };
  function registerRzAccordion(Alpine2) {
    Alpine2.data("rzAccordion", () => ({
      selected: "",
      // ID of the currently selected/opened section (if not allowMultiple)
      allowMultiple: false,
      // Whether multiple sections can be open
      init() {
        this.allowMultiple = this.$el.dataset.multiple === "true";
      },
      destroy() {
      }
    }));
  }
  function registerRzAccordionSection(Alpine2) {
    Alpine2.data("rzAccordionSection", () => ({
      open: false,
      sectionId: "",
      expandedClass: "",
      init() {
        this.open = this.$el.dataset.isOpen === "true";
        this.sectionId = this.$el.dataset.sectionId;
        this.expandedClass = this.$el.dataset.expandedClass;
        const self2 = this;
        if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
          this.$watch("selected", (value, oldValue) => {
            if (value !== self2.sectionId && !self2.allowMultiple) {
              self2.open = false;
            }
          });
        } else {
          console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
        }
      },
      destroy() {
      },
      // Toggle the section's open state and update the parent's 'selected' state.
      toggle() {
        this.selected = this.sectionId;
        this.open = !this.open;
      },
      // Get the CSS classes for the expanded/collapsed chevron icon.
      getExpandedCss() {
        return this.open ? this.expandedClass : "";
      },
      // Get the value for aria-expanded attribute based on the 'open' state.
      getAriaExpanded() {
        return this.open ? "true" : "false";
      }
    }));
  }
  function registerRzAlert(Alpine2) {
    Alpine2.data("rzAlert", () => {
      return {
        showAlert: true,
        dismiss() {
          this.showAlert = false;
        }
      };
    });
  }
  function registerRzBrowser(Alpine2) {
    Alpine2.data("rzBrowser", () => {
      return {
        screenSize: "",
        setDesktopScreenSize() {
          this.screenSize = "";
        },
        setTabletScreenSize() {
          this.screenSize = "max-w-2xl";
        },
        setPhoneScreenSize() {
          this.screenSize = "max-w-sm";
        },
        // Get CSS classes for browser border based on screen size
        getBrowserBorderCss() {
          return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
        },
        // Get CSS classes for desktop screen button styling
        getDesktopScreenCss() {
          return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for tablet screen button styling
        getTabletScreenCss() {
          return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for phone screen button styling
        getPhoneScreenCss() {
          return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        }
      };
    });
  }
  function registerRzCheckboxGroupItem(Alpine2) {
    Alpine2.data("rzCheckboxGroupItem", () => {
      return {
        checkbox: null,
        isChecked: false,
        init() {
          this.checkbox = this.$refs.chk;
          this.isChecked = this.checkbox.checked;
        },
        toggleCheckbox() {
          this.isChecked = this.checkbox.checked;
        },
        getIconCss() {
          return this.isChecked ? "" : "hidden";
        }
      };
    });
  }
  function registerRzCodeViewer(Alpine2, require) {
    Alpine2.data("rzCodeViewer", () => {
      return {
        expand: false,
        border: true,
        copied: false,
        copyTitle: "Copy",
        // Default title
        copiedTitle: "Copied!",
        // Default title
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const codeId = this.$el.dataset.codeid;
          const nonce = this.$el.dataset.nonce;
          this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
          this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
          require(assets, {
            success: function() {
              const codeBlock = document.getElementById(codeId);
              if (window.hljs && codeBlock) {
                window.hljs.highlightElement(codeBlock);
              }
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        },
        // Function to check if code is NOT copied (for x-show)
        notCopied() {
          return !this.copied;
        },
        // Function to reset the copied state (e.g., on blur)
        disableCopied() {
          this.copied = false;
        },
        // Function to toggle the expand state
        toggleExpand() {
          this.expand = !this.expand;
        },
        // Function to copy code to clipboard
        copyHTML() {
          navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
          this.copied = !this.copied;
        },
        // Get the title for the copy button (copy/copied)
        getCopiedTitle() {
          return this.copied ? this.copiedTitle : this.copyTitle;
        },
        // Get CSS classes for the copy button based on copied state
        getCopiedCss() {
          return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
        },
        // Get CSS classes for the code container based on expand state
        getExpandCss() {
          return [this.expand ? "" : "max-h-60"];
        },
        // Get CSS classes for the expand button icon based on expand state
        getExpandButtonCss() {
          return this.expand ? "rotate-180" : "rotate-0";
        }
      };
    });
  }
  function registerRzDateEdit(Alpine2, require) {
    Alpine2.data("rzDateEdit", () => ({
      options: {},
      placeholder: "",
      prependText: "",
      init() {
        const cfgString = this.$el.dataset.config;
        const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
        if (cfgString) {
          const parsed = JSON.parse(cfgString);
          if (parsed) {
            this.options = parsed.options || {};
            this.placeholder = parsed.placeholder || "";
            this.prependText = parsed.prependText || "";
          }
        }
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require(assets, {
          success: function() {
            if (window.flatpickr && inputElem) {
              window.flatpickr(inputElem, this.options);
            }
          },
          error: function() {
            console.error("Failed to load Flatpickr assets.");
          }
        }, nonce);
      }
    }));
  }
  function registerRzDropdown(Alpine2) {
    Alpine2.data("rzDropdown", () => ({
      dropdownEl: null,
      anchorCss: "",
      dropdownOpen: false,
      openedWithKeyboard: false,
      init() {
        this.dropdownEl = this.$el;
        this.anchorCss = this.getAnchorCss();
      },
      toggleDropdown() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = !this.dropdownOpen;
      },
      openDropdown() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = true;
        this.openedWithKeyboard = false;
      },
      openWithKeyboard() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = true;
        this.openedWithKeyboard = true;
        this.focusWrapNext();
      },
      closeDropdown() {
        this.dropdownOpen = false;
        this.openedWithKeyboard = false;
      },
      focusWrapNext() {
        this.$focus.wrap().next();
      },
      focusWrapPrevious() {
        this.$focus.wrap().previous();
      },
      // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
      getAnchorCss() {
        let defaultAnchorRaw = this.dropdownEl.getAttribute("data-anchor") || "";
        let defaultAnchor = defaultAnchorRaw.replace(/-/g, "").toLowerCase();
        const anchorClasses = {
          "topstart": "bottom-full right-0 mb-2 origin-bottom-right",
          "topcenter": "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
          "topend": "bottom-full left-0 mb-2 origin-bottom-left",
          "start": "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
          "end": "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
          "bottomstart": "right-0 mt-2 origin-top-right",
          "bottomcenter": "-translate-x-1/2 mt-2 origin-top",
          "bottomend": "left-0 mt-2 origin-top-left"
        };
        let cssClasses = anchorClasses[defaultAnchor] || "";
        const triggerRect = this.dropdownEl.getBoundingClientRect();
        let tempContainer = document.createElement("div");
        tempContainer.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;";
        this.dropdownEl.appendChild(tempContainer);
        const originalMenu = this.dropdownEl.querySelector('[role="menu"]');
        if (!originalMenu) {
          return cssClasses;
        }
        let clone2 = originalMenu.cloneNode(true);
        clone2.style.transition = "none";
        clone2.style.transform = "none";
        clone2.style.opacity = "1";
        clone2.style.display = "block";
        tempContainer.appendChild(clone2);
        let cloneRect = clone2.getBoundingClientRect();
        tempContainer.parentNode.removeChild(tempContainer);
        const margin = 8;
        let wouldClip = false;
        if (defaultAnchor.startsWith("top")) {
          if (triggerRect.top < cloneRect.height + margin) {
            wouldClip = true;
          }
        } else if (defaultAnchor.startsWith("bottom")) {
          if (triggerRect.bottom + cloneRect.height + margin > window.innerHeight) {
            wouldClip = true;
          }
        } else if (defaultAnchor === "start") {
          if (triggerRect.left < cloneRect.width + margin) {
            wouldClip = true;
          }
        } else if (defaultAnchor === "end") {
          if (triggerRect.right + cloneRect.width + margin > window.innerWidth) {
            wouldClip = true;
          }
        }
        if (wouldClip) {
          const fallbackMapping = {
            "topstart": "bottomstart",
            "topcenter": "bottomcenter",
            "topend": "bottomend",
            "bottomstart": "topstart",
            "bottomcenter": "topcenter",
            "bottomend": "topend",
            "start": "end",
            "end": "start"
          };
          let fallbackAnchor = fallbackMapping[defaultAnchor] || defaultAnchor;
          cssClasses = anchorClasses[fallbackAnchor] || cssClasses;
        }
        return cssClasses;
      }
    }));
  }
  function registerRzDarkModeToggle(Alpine2) {
    Alpine2.data("rzDarkModeToggle", () => ({
      mode: "light",
      applyTheme: null,
      init() {
        const hasLocalStorage = typeof window !== "undefined" && "localStorage" in window;
        const allowedModes = ["light", "dark", "auto"];
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        let storedMode = "auto";
        if (hasLocalStorage) {
          storedMode = localStorage.getItem("darkMode") ?? "auto";
          if (!allowedModes.includes(storedMode)) {
            storedMode = "light";
          }
        }
        if (hasLocalStorage) {
          localStorage.setItem("darkMode", storedMode);
        }
        this.applyTheme = () => {
          document.documentElement.classList.toggle(
            "dark",
            storedMode === "dark" || storedMode === "auto" && prefersDark
          );
        };
        this.applyTheme();
        window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
      },
      // Returns true if dark mode should be active
      isDark() {
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        localStorage.getItem("darkMode");
        return this.mode === "dark" || this.mode === "auto" && prefersDark;
      },
      // Returns true if light mode should be active
      isLight() {
        return !this.isDark();
      },
      // Toggle the dark mode setting and dispatch a custom event
      toggle() {
        let storedMode = localStorage.getItem("darkMode");
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        if (storedMode === "light")
          storedMode = "dark";
        else if (storedMode === "dark")
          storedMode = "light";
        else if (storedMode === "auto") {
          storedMode = prefersDark ? "light" : "dark";
        }
        this.mode = storedMode;
        localStorage.setItem("darkMode", storedMode);
        const isDark = storedMode === "dark" || storedMode === "auto" && prefersDark;
        document.documentElement.classList.toggle("dark", isDark);
        const darkModeEvent = new CustomEvent("darkModeToggle", {
          detail: { darkMode: isDark }
        });
        window.dispatchEvent(darkModeEvent);
      },
      destroy() {
        if (this.applyTheme) {
          window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
        }
      }
    }));
  }
  function registerRzEmbeddedPreview(Alpine2) {
    Alpine2.data("rzEmbeddedPreview", () => {
      return {
        iframe: null,
        onDarkModeToggle: null,
        init() {
          try {
            this.iframe = this.$refs.iframe;
            const resize = this.debounce(() => {
              this.resizeIframe(this.iframe);
            }, 50);
            this.resizeIframe(this.iframe);
            const resizeObserver = new ResizeObserver((entries) => {
              for (let entry of entries) {
                resize();
              }
            });
            resizeObserver.observe(this.iframe);
            const iframe = this.iframe;
            this.onDarkModeToggle = (event) => {
              iframe.contentWindow.postMessage(event.detail, "*");
            };
            window.addEventListener("darkModeToggle", this.onDarkModeToggle);
          } catch (error2) {
            console.error("Cannot access iframe content");
          }
        },
        // Adjusts the iframe height based on its content
        resizeIframe(iframe) {
          if (iframe) {
            try {
              const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDocument) {
                const iframeBody = iframeDocument.body;
                if (!iframeBody) {
                  setInterval(() => {
                    this.resizeIframe(iframe);
                  }, 150);
                } else {
                  const newHeight = iframeBody.scrollHeight + 15;
                  iframe.style.height = newHeight + "px";
                }
              }
            } catch (error2) {
              console.error("Error resizing iframe:", error2);
            }
          }
        },
        // Debounce helper to limit function calls
        debounce(func, timeout = 300) {
          let timer;
          return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
              func.apply(this, args);
            }, timeout);
          };
        },
        destroy() {
          window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
        }
      };
    });
  }
  function registerRzEmpty(Alpine2) {
    Alpine2.data("rzEmpty", () => {
    });
  }
  function registerRzHeading(Alpine2) {
    Alpine2.data("rzHeading", () => {
      return {
        observer: null,
        headingId: "",
        init() {
          this.headingId = this.$el.dataset.alpineRoot;
          const self2 = this;
          if (typeof this.setCurrentHeading === "function") {
            const callback = (entries, observer2) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  self2.setCurrentHeading(self2.headingId);
                }
              });
            };
            const options = { threshold: 0.5 };
            this.observer = new IntersectionObserver(callback, options);
            this.observer.observe(this.$el);
          } else {
            console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
          }
        },
        destroy() {
          if (this.observer != null)
            this.observer.disconnect();
        }
      };
    });
  }
  function registerRzMarkdown(Alpine2, require) {
    Alpine2.data("rzMarkdown", () => {
      return {
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const nonce = this.$el.dataset.nonce;
          require(assets, {
            success: function() {
              window.hljs.highlightAll();
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        }
      };
    });
  }
  function registerRzModal(Alpine2) {
    Alpine2.data("rzModal", () => ({
      modalOpen: false,
      // Main state variable
      eventTriggerName: "",
      closeEventName: "rz:modal-close",
      // Default value, corresponds to Constants.Events.ModalClose
      closeOnEscape: true,
      closeOnClickOutside: true,
      modalId: "",
      bodyId: "",
      footerId: "",
      nonce: "",
      _escapeListener: null,
      _openListener: null,
      _closeEventListener: null,
      init() {
        this.modalId = this.$el.dataset.modalId || "";
        this.bodyId = this.$el.dataset.bodyId || "";
        this.footerId = this.$el.dataset.footerId || "";
        this.nonce = this.$el.dataset.nonce || "";
        this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
        this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
        this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
        this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
        this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
          detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
          bubbles: true
        }));
        if (this.eventTriggerName) {
          this._openListener = (e2) => {
            this.openModal(e2);
          };
          window.addEventListener(this.eventTriggerName, this._openListener);
        }
        this._closeEventListener = (event) => {
          if (this.modalOpen) {
            this.closeModalInternally("event");
          }
        };
        window.addEventListener(this.closeEventName, this._closeEventListener);
        this._escapeListener = (e2) => {
          if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
            this.closeModalInternally("escape");
          }
        };
        window.addEventListener("keydown", this._escapeListener);
        this.$watch("modalOpen", (value) => {
          const currentWidth = document.body.offsetWidth;
          document.body.classList.toggle("overflow-hidden", value);
          const scrollBarWidth = document.body.offsetWidth - currentWidth;
          document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
          if (value) {
            this.$nextTick(() => {
              const dialogElement = this.$el.querySelector('[role="document"]');
              const focusable2 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
              focusable2?.focus();
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          } else {
            this.$nextTick(() => {
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          }
        });
      },
      notModalOpen() {
        return !this.modalOpen;
      },
      destroy() {
        if (this._openListener && this.eventTriggerName) {
          window.removeEventListener(this.eventTriggerName, this._openListener);
        }
        if (this._closeEventListener) {
          window.removeEventListener(this.closeEventName, this._closeEventListener);
        }
        if (this._escapeListener) {
          window.removeEventListener("keydown", this._escapeListener);
        }
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      },
      openModal(event = null) {
        const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
          detail: { modalId: this.modalId, originalEvent: event },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeOpenEvent);
        if (!beforeOpenEvent.defaultPrevented) {
          this.modalOpen = true;
        }
      },
      // Internal close function called by button, escape, backdrop, event
      closeModalInternally(reason = "unknown") {
        const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
          detail: { modalId: this.modalId, reason },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeCloseEvent);
        if (!beforeCloseEvent.defaultPrevented) {
          document.activeElement?.blur && document.activeElement.blur();
          this.modalOpen = false;
          document.body.classList.remove("overflow-hidden");
          document.body.style.setProperty("--page-scrollbar-width", `0px`);
        }
      },
      // Called only by the explicit close button in the template
      closeModal() {
        this.closeModalInternally("button");
      },
      // Method called by x-on:click.outside on the dialog element
      handleClickOutside() {
        if (this.closeOnClickOutside) {
          this.closeModalInternally("backdrop");
        }
      }
    }));
  }
  function registerRzPrependInput(Alpine2) {
    Alpine2.data("rzPrependInput", () => {
      return {
        prependContainer: null,
        textInput: null,
        init() {
          this.prependContainer = this.$refs.prependContainer;
          this.textInput = this.$refs.textInput;
          let self2 = this;
          setTimeout(() => {
            self2.updatePadding();
          }, 50);
          window.addEventListener("resize", this.updatePadding);
        },
        destroy() {
          window.removeEventListener("resize", this.updatePadding);
        },
        updatePadding() {
          const prependDiv = this.prependContainer;
          const inputElem = this.textInput;
          if (!prependDiv || !inputElem) {
            if (inputElem) {
              inputElem.classList.remove("text-transparent");
            }
            return;
          }
          const prependWidth = prependDiv.offsetWidth;
          const leftPadding = prependWidth + 10;
          inputElem.style.paddingLeft = leftPadding + "px";
          inputElem.classList.remove("text-transparent");
        }
      };
    });
  }
  function registerRzProgress(Alpine2) {
    Alpine2.data("rzProgress", () => ({
      currentVal: 0,
      minVal: 0,
      maxVal: 100,
      percentage: 0,
      label: "",
      init() {
        const element = this.$el;
        this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
        this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
        this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
        this.label = element.getAttribute("data-label");
        this.calculatePercentage();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuemin", this.minVal);
        element.setAttribute("aria-valuemax", this.maxVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
        this.updateProgressBar();
        const resizeObserver = new ResizeObserver((entries) => {
          this.updateProgressBar();
        });
        resizeObserver.observe(element);
        this.$watch("currentVal", () => {
          this.calculatePercentage();
          this.updateProgressBar();
          element.setAttribute("aria-valuenow", this.currentVal);
          element.setAttribute("aria-valuetext", `${this.percentage}%`);
        });
      },
      calculatePercentage() {
        if (this.maxVal === this.minVal) {
          this.percentage = 0;
        } else {
          this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
        }
      },
      buildLabel() {
        var label = this.label || "{percent}%";
        this.calculatePercentage();
        return label.replace("{percent}", this.percentage);
      },
      buildInsideLabelPosition() {
        const progressBar = this.$refs.progressBar;
        const barLabel = this.$refs.progressBarLabel;
        const innerLabel = this.$refs.innerLabel;
        if (barLabel && progressBar && innerLabel) {
          innerLabel.innerText = this.buildLabel();
          if (barLabel.clientWidth > progressBar.clientWidth) {
            barLabel.style.left = progressBar.clientWidth + 10 + "px";
          } else {
            barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
          }
        }
      },
      getLabelCss() {
        const barLabel = this.$refs.progressBarLabel;
        const progressBar = this.$refs.progressBar;
        if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
          return "text-foreground dark:text-foreground";
        }
        return "";
      },
      updateProgressBar() {
        const progressBar = this.$refs.progressBar;
        if (progressBar) {
          progressBar.style.width = `${this.percentage}%`;
          this.buildInsideLabelPosition();
        }
      },
      // Methods to set, increment, or decrement the progress value
      setProgress(value) {
        this.currentVal = value;
      },
      increment(val = 1) {
        this.currentVal = Math.min(this.currentVal + val, this.maxVal);
      },
      decrement(val = 1) {
        this.currentVal = Math.max(this.currentVal - val, this.minVal);
      }
    }));
  }
  function registerRzQuickReferenceContainer(Alpine2) {
    Alpine2.data("rzQuickReferenceContainer", () => {
      return {
        headings: [],
        // Array of heading IDs
        currentHeadingId: "",
        // ID of the currently highlighted heading
        // Initializes the component with headings and the initial current heading from data attributes.
        init() {
          this.headings = JSON.parse(this.$el.dataset.headings || "[]");
          this.currentHeadingId = this.$el.dataset.currentheadingid || "";
        },
        // Handles click events on quick reference links.
        handleHeadingClick() {
          const id = this.$el.dataset.headingid;
          window.requestAnimationFrame(() => {
            this.currentHeadingId = id;
          });
        },
        // Sets the current heading ID based on intersection observer events from rzHeading.
        setCurrentHeading(id) {
          if (this.headings.includes(id)) {
            this.currentHeadingId = id;
          }
        },
        // Provides CSS classes for a link based on whether it's the current heading.
        // Returns an object suitable for :class binding.
        getSelectedCss() {
          const id = this.$el.dataset.headingid;
          return {
            "font-bold": this.currentHeadingId === id
            // Apply 'font-bold' if current
          };
        },
        // Determines the value for the aria-current attribute.
        getSelectedAriaCurrent() {
          const id = this.$el.dataset.headingid;
          return this.currentHeadingId === id ? "true" : null;
        }
      };
    });
  }
  function registerRzTabs(Alpine2) {
    Alpine2.data("rzTabs", () => {
      return {
        buttonRef: null,
        tabSelected: "",
        tabButton: null,
        init() {
          this.buttonRef = document.getElementById(this.$el.dataset.buttonref);
          this.tabSelected = this.$el.dataset.tabselected;
          this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']");
          this.tabRepositionMarker(this.tabButton);
        },
        tabButtonClicked(tabButton) {
          if (tabButton instanceof Event)
            tabButton = tabButton.target;
          this.tabSelected = tabButton.dataset.name;
          this.tabRepositionMarker(tabButton);
          tabButton.focus();
        },
        tabRepositionMarker(tabButton) {
          this.tabButton = tabButton;
          this.$refs.tabMarker.style.width = tabButton.offsetWidth + "px";
          this.$refs.tabMarker.style.height = tabButton.offsetHeight + "px";
          this.$refs.tabMarker.style.left = tabButton.offsetLeft + "px";
          setTimeout(() => {
            this.$refs.tabMarker.style.opacity = 1;
          }, 150);
        },
        // Get the CSS classes for the tab content panel based on selection
        getTabContentCss() {
          return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
        },
        tabContentActive(tabContent) {
          tabContent = tabContent ?? this.$el;
          return this.tabSelected === tabContent.dataset.name;
        },
        tabButtonActive(tabButton) {
          tabButton = tabButton ?? this.$el;
          return this.tabSelected === tabButton.dataset.name;
        },
        // Get the value for the aria-selected attribute
        getTabButtonAriaSelected() {
          return this.tabSelected === this.$el.dataset.name ? "true" : "false";
        },
        // Get the CSS classes for the tab button text color based on selection
        getSelectedTabTextColorCss() {
          const color = this.$el.dataset.selectedtextcolor ?? "";
          return this.tabSelected === this.$el.dataset.name ? color : "";
        },
        handleResize() {
          this.tabRepositionMarker(this.tabButton);
        },
        handleKeyDown(event) {
          const key = event.key;
          const tabButtons = Array.from(this.buttonRef.querySelectorAll("[role='tab']"));
          const currentIndex = tabButtons.findIndex((button) => this.tabSelected === button.dataset.name);
          let newIndex = currentIndex;
          if (key === "ArrowRight") {
            newIndex = (currentIndex + 1) % tabButtons.length;
            event.preventDefault();
          } else if (key === "ArrowLeft") {
            newIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;
            event.preventDefault();
          } else if (key === "Home") {
            newIndex = 0;
            event.preventDefault();
          } else if (key === "End") {
            newIndex = tabButtons.length - 1;
            event.preventDefault();
          }
          if (newIndex !== currentIndex) {
            this.tabButtonClicked(tabButtons[newIndex]);
          }
        }
      };
    });
  }
  function registerRzSidebar(Alpine2) {
    Alpine2.data("rzSidebar", () => {
      return {
        showSidebar: false,
        isSidebarHidden() {
          return !this.showSidebar;
        },
        toggleSidebar() {
          this.showSidebar = !this.showSidebar;
        },
        hideSidebar() {
          this.showSidebar = false;
        },
        // Return translation classes based on sidebar state for smooth slide-in/out
        getSidebarTranslation() {
          return this.showSidebar ? "translate-x-0" : "-translate-x-60";
        }
      };
    });
  }
  function registerRzSidebarLinkItem(Alpine2) {
    Alpine2.data("rzSidebarLinkItem", () => {
      return {
        isExpanded: false,
        chevronExpandedClass: "",
        chevronCollapsedClass: "",
        init() {
          this.isExpanded = this.$el.dataset.expanded === "true";
          this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass;
          this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
        },
        isCollapsed() {
          return !this.isExpanded;
        },
        toggleExpanded() {
          this.isExpanded = !this.isExpanded;
        },
        hideSidebar() {
          const sidebarScope = this.$el.closest('[x-data^="rzSidebar"]');
          if (sidebarScope) {
            let data2 = Alpine2.$data(sidebarScope);
            data2.showSidebar = false;
          } else {
            console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
          }
        },
        getExpandedClass() {
          return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
        },
        // Get the value for the aria-expanded attribute
        getAriaExpanded() {
          return this.isExpanded ? "true" : "false";
        }
      };
    });
  }
  async function generateBundleId(paths) {
    paths = [...paths].sort();
    const joinedPaths = paths.join("|");
    const encoder = new TextEncoder();
    const data2 = encoder.encode(joinedPaths);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data2);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  function rizzyRequire(paths, callbackFn, nonce) {
    generateBundleId(paths).then((bundleId) => {
      if (!loadjs.isDefined(bundleId)) {
        loadjs(
          paths,
          bundleId,
          {
            async: false,
            inlineScriptNonce: nonce,
            inlineStyleNonce: nonce
          }
        );
      }
      loadjs.ready([bundleId], callbackFn);
    });
  }
  function registerComponents(Alpine2) {
    registerRzAccordion(Alpine2);
    registerRzAccordionSection(Alpine2);
    registerRzAlert(Alpine2);
    registerRzBrowser(Alpine2);
    registerRzCheckboxGroupItem(Alpine2);
    registerRzCodeViewer(Alpine2, rizzyRequire);
    registerRzDateEdit(Alpine2, rizzyRequire);
    registerRzDropdown(Alpine2);
    registerRzDarkModeToggle(Alpine2);
    registerRzEmbeddedPreview(Alpine2);
    registerRzEmpty(Alpine2);
    registerRzHeading(Alpine2);
    registerRzMarkdown(Alpine2, rizzyRequire);
    registerRzModal(Alpine2);
    registerRzPrependInput(Alpine2);
    registerRzProgress(Alpine2);
    registerRzQuickReferenceContainer(Alpine2);
    registerRzTabs(Alpine2);
    registerRzSidebar(Alpine2);
    registerRzSidebarLinkItem(Alpine2);
  }
  function $data(idOrElement) {
    if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
      console.error(
        "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
      );
      return void 0;
    }
    let outerElement = null;
    let componentId = null;
    if (typeof idOrElement === "string") {
      if (!idOrElement) {
        console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
        return void 0;
      }
      componentId = idOrElement;
      outerElement = document.getElementById(componentId);
      if (!outerElement) {
        console.warn(`Rizzy.$data: Rizzy component with ID "${componentId}" not found in the DOM.`);
        return void 0;
      }
    } else if (idOrElement instanceof Element) {
      outerElement = idOrElement;
      if (!outerElement.id) {
        console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
        return void 0;
      }
      componentId = outerElement.id;
    } else {
      console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
      return void 0;
    }
    const alpineRootSelector = `[data-alpine-root="${componentId}"]`;
    let alpineRootElement = null;
    if (outerElement.matches(alpineRootSelector)) {
      alpineRootElement = outerElement;
    } else {
      alpineRootElement = outerElement.querySelector(alpineRootSelector);
    }
    if (!alpineRootElement) {
      console.warn(
        `Rizzy.$data: Could not locate the designated Alpine root element using selector "${alpineRootSelector}" on or inside the wrapper element (ID: #${componentId}). Verify the 'data-alpine-root' attribute placement.`
      );
      return void 0;
    }
    const alpineData = Alpine.$data(alpineRootElement);
    if (alpineData === void 0) {
      const targetDesc = `${alpineRootElement.tagName.toLowerCase()}${alpineRootElement.id ? "#" + alpineRootElement.id : ""}${alpineRootElement.classList.length ? "." + Array.from(alpineRootElement.classList).join(".") : ""}`;
      console.warn(
        `Rizzy.$data: Located designated Alpine root (${targetDesc}) via 'data-alpine-root="${componentId}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
      );
    }
    return alpineData;
  }
  module_default$3.plugin(module_default$2);
  module_default$3.plugin(module_default$1);
  module_default$3.plugin(module_default);
  registerComponents(module_default$3);
  const RizzyUI = {
    Alpine: module_default$3,
    require: rizzyRequire,
    toast: Toast,
    $data
  };
  window.Alpine = module_default$3;
  window.Rizzy = { ...window.Rizzy || {}, ...RizzyUI };
  module_default$3.start();
  return RizzyUI;
});
//# sourceMappingURL=rizzyui-csp.umd.js.map
</file>

<file path="wwwroot/js/rizzyui.es.js">
import Alpine$1 from "alpinejs";
function src_default$2(Alpine2) {
  Alpine2.directive("collapse", collapse);
  collapse.inline = (el, { modifiers }) => {
    if (!modifiers.includes("min"))
      return;
    el._x_doShow = () => {
    };
    el._x_doHide = () => {
    };
  };
  function collapse(el, { modifiers }) {
    let duration = modifierValue(modifiers, "duration", 250) / 1e3;
    let floor = modifierValue(modifiers, "min", 0);
    let fullyHide = !modifiers.includes("min");
    if (!el._x_isShown)
      el.style.height = `${floor}px`;
    if (!el._x_isShown && fullyHide)
      el.hidden = true;
    if (!el._x_isShown)
      el.style.overflow = "hidden";
    let setFunction = (el2, styles) => {
      let revertFunction = Alpine2.setStyles(el2, styles);
      return styles.height ? () => {
      } : revertFunction;
    };
    let transitionStyles = {
      transitionProperty: "height",
      transitionDuration: `${duration}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    el._x_transition = {
      in(before = () => {
      }, after = () => {
      }) {
        if (fullyHide)
          el.hidden = false;
        if (fullyHide)
          el.style.display = null;
        let current = el.getBoundingClientRect().height;
        el.style.height = "auto";
        let full = el.getBoundingClientRect().height;
        if (current === full) {
          current = floor;
        }
        Alpine2.transition(el, Alpine2.setStyles, {
          during: transitionStyles,
          start: { height: current + "px" },
          end: { height: full + "px" }
        }, () => el._x_isShown = true, () => {
          if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
            el.style.overflow = null;
          }
        });
      },
      out(before = () => {
      }, after = () => {
      }) {
        let full = el.getBoundingClientRect().height;
        Alpine2.transition(el, setFunction, {
          during: transitionStyles,
          start: { height: full + "px" },
          end: { height: floor + "px" }
        }, () => el.style.overflow = "hidden", () => {
          el._x_isShown = false;
          if (el.style.height == `${floor}px` && fullyHide) {
            el.style.display = "none";
            el.hidden = true;
          }
        });
      }
    };
  }
}
function modifierValue(modifiers, key, fallback) {
  if (modifiers.indexOf(key) === -1)
    return fallback;
  const rawValue = modifiers[modifiers.indexOf(key) + 1];
  if (!rawValue)
    return fallback;
  if (key === "duration") {
    let match = rawValue.match(/([0-9]+)ms/);
    if (match)
      return match[1];
  }
  if (key === "min") {
    let match = rawValue.match(/([0-9]+)px/);
    if (match)
      return match[1];
  }
  return rawValue;
}
var module_default$2 = src_default$2;
function src_default$1(Alpine2) {
  Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater, cleanup }) => {
    let evaluate = evaluateLater(expression);
    let options = {
      rootMargin: getRootMargin(modifiers),
      threshold: getThreshold(modifiers)
    };
    let observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting === (value === "leave"))
          return;
        evaluate();
        modifiers.includes("once") && observer.disconnect();
      });
    }, options);
    observer.observe(el);
    cleanup(() => {
      observer.disconnect();
    });
  }));
}
function getThreshold(modifiers) {
  if (modifiers.includes("full"))
    return 0.99;
  if (modifiers.includes("half"))
    return 0.5;
  if (!modifiers.includes("threshold"))
    return 0;
  let threshold = modifiers[modifiers.indexOf("threshold") + 1];
  if (threshold === "100")
    return 1;
  if (threshold === "0")
    return 0;
  return Number(`.${threshold}`);
}
function getLengthValue(rawValue) {
  let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
  return match ? match[1] + (match[2] || "px") : void 0;
}
function getRootMargin(modifiers) {
  const key = "margin";
  const fallback = "0px 0px 0px 0px";
  const index = modifiers.indexOf(key);
  if (index === -1)
    return fallback;
  let values = [];
  for (let i2 = 1; i2 < 5; i2++) {
    values.push(getLengthValue(modifiers[index + i2] || ""));
  }
  values = values.filter((v2) => v2 !== void 0);
  return values.length ? values.join(" ").trim() : fallback;
}
var module_default$1 = src_default$1;
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scope: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
  return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  var nodeRootHost = getRootNode(node).host;
  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
  if (!displayCheck || displayCheck === "full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (nodeIsAttached) {
      return !node.getClientRects().length;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scope;
    var element = isScope ? item.scope : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var activeFocusTraps = /* @__PURE__ */ function() {
  var trapQueue = [];
  return {
    activateTrap: function activateTrap(trap) {
      if (trapQueue.length > 0) {
        var activeTrap = trapQueue[trapQueue.length - 1];
        if (activeTrap !== trap) {
          activeTrap.pause();
        }
      }
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex === -1) {
        trapQueue.push(trap);
      } else {
        trapQueue.splice(trapIndex, 1);
        trapQueue.push(trap);
      }
    },
    deactivateTrap: function deactivateTrap(trap) {
      var trapIndex = trapQueue.indexOf(trap);
      if (trapIndex !== -1) {
        trapQueue.splice(trapIndex, 1);
      }
      if (trapQueue.length > 0) {
        trapQueue[trapQueue.length - 1].unpause();
      }
    }
  };
}();
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return e2.key === "Tab" || e2.keyCode === 9;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i2) {
    if (fn(value)) {
      idx = i2;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n2) {
            return n2 === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
            return isTabbable(n2, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e2) {
    var target = getActualTarget(e2);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e2.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkTab = function checkTab2(e2) {
    var target = getActualTarget(e2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (e2.shiftKey) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (e2.shiftKey) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      e2.preventDefault();
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(e2) {
    if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
      e2.preventDefault();
      trap.deactivate();
      return;
    }
    if (isTabEvent(e2)) {
      checkTab(e2);
      return;
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};
function src_default(Alpine2) {
  let lastFocused;
  let currentFocused;
  window.addEventListener("focusin", () => {
    lastFocused = currentFocused;
    currentFocused = document.activeElement;
  });
  Alpine2.magic("focus", (el) => {
    let within = el;
    return {
      __noscroll: false,
      __wrapAround: false,
      within(el2) {
        within = el2;
        return this;
      },
      withoutScrolling() {
        this.__noscroll = true;
        return this;
      },
      noscroll() {
        this.__noscroll = true;
        return this;
      },
      withWrapAround() {
        this.__wrapAround = true;
        return this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(el2) {
        return isFocusable(el2);
      },
      previouslyFocused() {
        return lastFocused;
      },
      lastFocused() {
        return lastFocused;
      },
      focused() {
        return currentFocused;
      },
      focusables() {
        if (Array.isArray(within))
          return within;
        return focusable(within, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(el2) {
        let els = this.all();
        return els[0] && els[0].isSameNode(el2);
      },
      isLast(el2) {
        let els = this.all();
        return els.length && els.slice(-1)[0].isSameNode(el2);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
          return list[0];
        }
        return list[list.indexOf(current) + 1];
      },
      getPrevious() {
        let list = this.all();
        let current = document.activeElement;
        if (list.indexOf(current) === -1)
          return;
        if (this.__wrapAround && list.indexOf(current) === 0) {
          return list.slice(-1)[0];
        }
        return list[list.indexOf(current) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(el2) {
        if (!el2)
          return;
        setTimeout(() => {
          if (!el2.hasAttribute("tabindex"))
            el2.setAttribute("tabindex", "0");
          el2.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  });
  Alpine2.directive("trap", Alpine2.skipDuringClone(
    (el, { expression, modifiers }, { effect, evaluateLater, cleanup }) => {
      let evaluator = evaluateLater(expression);
      let oldValue = false;
      let options = {
        escapeDeactivates: false,
        allowOutsideClick: true,
        fallbackFocus: () => el
      };
      if (modifiers.includes("noautofocus")) {
        options.initialFocus = false;
      } else {
        let autofocusEl = el.querySelector("[autofocus]");
        if (autofocusEl)
          options.initialFocus = autofocusEl;
      }
      let trap = createFocusTrap(el, options);
      let undoInert = () => {
      };
      let undoDisableScrolling = () => {
      };
      const releaseFocus = () => {
        undoInert();
        undoInert = () => {
        };
        undoDisableScrolling();
        undoDisableScrolling = () => {
        };
        trap.deactivate({
          returnFocus: !modifiers.includes("noreturn")
        });
      };
      effect(() => evaluator((value) => {
        if (oldValue === value)
          return;
        if (value && !oldValue) {
          if (modifiers.includes("noscroll"))
            undoDisableScrolling = disableScrolling();
          if (modifiers.includes("inert"))
            undoInert = setInert(el);
          setTimeout(() => {
            trap.activate();
          }, 15);
        }
        if (!value && oldValue) {
          releaseFocus();
        }
        oldValue = !!value;
      }));
      cleanup(releaseFocus);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (el, { expression, modifiers }, { evaluate }) => {
      if (modifiers.includes("inert") && evaluate(expression))
        setInert(el);
    }
  ));
}
function setInert(el) {
  let undos = [];
  crawlSiblingsUp(el, (sibling) => {
    let cache = sibling.hasAttribute("aria-hidden");
    sibling.setAttribute("aria-hidden", "true");
    undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
  });
  return () => {
    while (undos.length)
      undos.pop()();
  };
}
function crawlSiblingsUp(el, callback) {
  if (el.isSameNode(document.body) || !el.parentNode)
    return;
  Array.from(el.parentNode.children).forEach((sibling) => {
    if (sibling.isSameNode(el)) {
      crawlSiblingsUp(el.parentNode, callback);
    } else {
      callback(sibling);
    }
  });
}
function disableScrolling() {
  let overflow = document.documentElement.style.overflow;
  let paddingRight = document.documentElement.style.paddingRight;
  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.documentElement.style.overflow = "hidden";
  document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
  return () => {
    document.documentElement.style.overflow = overflow;
    document.documentElement.style.paddingRight = paddingRight;
  };
}
var module_default = src_default;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function t(t2, e2) {
  if (!(t2 instanceof e2)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function e(t2, e2) {
  for (var s2 = 0; s2 < e2.length; s2++) {
    var i2 = e2[s2];
    i2.enumerable = i2.enumerable || false;
    i2.configurable = true;
    if ("value" in i2) i2.writable = true;
    Object.defineProperty(t2, i2.key, i2);
  }
}
function s(t2, s2, i2) {
  if (s2) e(t2.prototype, s2);
  return t2;
}
var i = Object.defineProperty;
var n = function(t2, e2) {
  return i(t2, "name", { value: e2, configurable: true });
};
var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
var h = n(function(t2) {
  return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
}, "stringToHTML"), d = n(function(t2) {
  var e2 = new DOMParser().parseFromString(t2, "application/xml");
  return document.importNode(e2.documentElement, true).outerHTML;
}, "getSvgNode");
var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
var N = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), O = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "fadeOut"), T = n(function(t2) {
  t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), E = n(function(t2) {
  t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
    t2.wrapper.remove();
  }, t2.speed);
}, "slideOut");
var m = function() {
  function e2(s2) {
    var i2 = this;
    t(this, e2);
    this.notifyOut = n(function(t2) {
      t2(i2);
    }, "notifyOut");
    var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
    if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  s(e2, [{ key: "checkRequirements", value: function t2() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function t2() {
    var t3 = document.querySelector(".".concat(u.CONTAINER));
    t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function t2() {
    this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function t2() {
    var t3 = this;
    var e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
      t3.close();
    });
  } }, { key: "setWrapper", value: function t2() {
    var t3 = this;
    switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
      case p.OUTLINE:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
        break;
      case p.FILLED:
        this.wrapper.classList.add(u.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(u.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case f.SUCCESS:
        this.wrapper.classList.add(u.NOTIFY_SUCCESS);
        break;
      case f.ERROR:
        this.wrapper.classList.add(u.NOTIFY_ERROR);
        break;
      case f.WARNING:
        this.wrapper.classList.add(u.NOTIFY_WARNING);
        break;
      case f.INFO:
        this.wrapper.classList.add(u.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
      t3.wrapper.classList.add(e3);
    });
  } }, { key: "setContent", value: function t2() {
    var t3 = document.createElement("div");
    t3.classList.add(u.NOTIFY_CONTENT);
    var e3, s2;
    this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
  } }, { key: "setIcon", value: function t2() {
    var t3 = n(function(t4) {
      switch (t4) {
        case f.SUCCESS:
          return v.SUCCESS;
        case f.ERROR:
          return v.ERROR;
        case f.WARNING:
          return v.WARNING;
        case f.INFO:
          return v.INFO;
      }
    }, "computedIcon"), e3 = document.createElement("div");
    e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
  } }, { key: "setObserver", value: function t2() {
    var t3 = this;
    var e3 = new IntersectionObserver(function(e4) {
      if (e4[0].intersectionRatio <= 0) t3.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      e3.observe(t3.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function t2(t2) {
    t2(this);
  } }, { key: "autoClose", value: function t2() {
    var t3 = this;
    setTimeout(function() {
      t3.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function t2() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function t2() {
    switch (this.effect) {
      case I.FADE:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
        break;
      case I.SLIDE:
        this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
        break;
      default:
        this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
    }
  } }]);
  return e2;
}();
n(m, "Notify");
var w = m;
globalThis.Notify = w;
const allowedStatuses = ["success", "error", "warning", "info"];
const allowedPositions = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
];
const defaultConfig = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: true,
  autotimeout: 4e3,
  position: "right top"
};
function renderToast(options = {}) {
  const config = {
    ...defaultConfig,
    ...options
  };
  if (!allowedStatuses.includes(config.status)) {
    console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
    config.status = "info";
  }
  if (!allowedPositions.includes(config.position)) {
    console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
    config.position = "right top";
  }
  new w(config);
}
const Toast = {
  custom: renderToast,
  success(text, title = "Success", options = {}) {
    renderToast({
      status: "success",
      title,
      text,
      ...options
    });
  },
  error(text, title = "Error", options = {}) {
    renderToast({
      status: "error",
      title,
      text,
      ...options
    });
  },
  warning(text, title = "Warning", options = {}) {
    renderToast({
      status: "warning",
      title,
      text,
      ...options
    });
  },
  info(text, title = "Info", options = {}) {
    renderToast({
      status: "info",
      title,
      text,
      ...options
    });
  },
  setDefaults(newDefaults = {}) {
    Object.assign(defaultConfig, newDefaults);
  },
  get allowedStatuses() {
    return [...allowedStatuses];
  },
  get allowedPositions() {
    return [...allowedPositions];
  }
};
const devnull = function() {
}, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
function subscribe(bundleIds, callbackFn) {
  bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
  const depsNotFound = [];
  let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
  fn = function(bundleId2, pathsNotFound) {
    if (pathsNotFound.length) depsNotFound.push(bundleId2);
    numWaiting--;
    if (!numWaiting) callbackFn(depsNotFound);
  };
  while (i2--) {
    bundleId = bundleIds[i2];
    r2 = bundleResultCache[bundleId];
    if (r2) {
      fn(bundleId, r2);
      continue;
    }
    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
    q.push(fn);
  }
}
function publish(bundleId, pathsNotFound) {
  if (!bundleId) return;
  const q = bundleCallbackQueue[bundleId];
  bundleResultCache[bundleId] = pathsNotFound;
  if (!q) return;
  while (q.length) {
    q[0](bundleId, pathsNotFound);
    q.splice(0, 1);
  }
}
function executeCallbacks(args, depsNotFound) {
  if (typeof args === "function") args = { success: args };
  if (depsNotFound.length) (args.error || devnull)(depsNotFound);
  else (args.success || devnull)(args);
}
function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
  let result = ev.type[0];
  if (isLegacyIECss) {
    try {
      if (!e2.sheet.cssText.length) result = "e";
    } catch (x) {
      if (x.code !== 18) result = "e";
    }
  }
  if (result === "e") {
    numTries += 1;
    if (numTries < maxTries) {
      return loadFile(path, callbackFn, args, numTries);
    }
  } else if (e2.rel === "preload" && e2.as === "style") {
    e2.rel = "stylesheet";
    return;
  }
  callbackFn(path, result, ev.defaultPrevented);
}
function loadFile(path, callbackFn, args, numTries) {
  const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
  let isLegacyIECss, hasModuleSupport, e2;
  numTries = numTries || 0;
  if (/(^css!|\.css$)/.test(pathname)) {
    e2 = doc.createElement("link");
    e2.rel = "stylesheet";
    e2.href = pathStripped;
    isLegacyIECss = "hideFocus" in e2;
    if (isLegacyIECss && e2.relList) {
      isLegacyIECss = 0;
      e2.rel = "preload";
      e2.as = "style";
    }
    if (args.inlineStyleNonce) {
      e2.setAttribute("nonce", args.inlineStyleNonce);
    }
  } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
    e2 = doc.createElement("img");
    e2.src = pathStripped;
  } else {
    e2 = doc.createElement("script");
    e2.src = pathStripped;
    e2.async = async === void 0 ? true : async;
    if (args.inlineScriptNonce) {
      e2.setAttribute("nonce", args.inlineScriptNonce);
    }
    hasModuleSupport = "noModule" in e2;
    if (/^module!/.test(pathname)) {
      if (!hasModuleSupport) return callbackFn(path, "l");
      e2.type = "module";
    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
      return callbackFn(path, "l");
    }
  }
  const onEvent = function(ev) {
    handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
  };
  e2.addEventListener("load", onEvent, { once: true });
  e2.addEventListener("error", onEvent, { once: true });
  if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
}
function loadFiles(paths, callbackFn, args) {
  paths = Array.isArray(paths) ? paths : [paths];
  let numWaiting = paths.length, pathsNotFound = [];
  function fn(path, result, defaultPrevented) {
    if (result === "e") pathsNotFound.push(path);
    if (result === "b") {
      if (defaultPrevented) pathsNotFound.push(path);
      else return;
    }
    numWaiting--;
    if (!numWaiting) callbackFn(pathsNotFound);
  }
  for (let i2 = 0; i2 < paths.length; i2++) {
    loadFile(paths[i2], fn, args);
  }
}
function loadjs(paths, arg1, arg2) {
  let bundleId, args;
  if (arg1 && typeof arg1 === "string" && arg1.trim) {
    bundleId = arg1.trim();
  }
  args = (bundleId ? arg2 : arg1) || {};
  if (bundleId) {
    if (bundleId in bundleIdCache) {
      throw "LoadJS";
    } else {
      bundleIdCache[bundleId] = true;
    }
  }
  function loadFn(resolve, reject) {
    loadFiles(paths, function(pathsNotFound) {
      executeCallbacks(args, pathsNotFound);
      if (resolve) {
        executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
      }
      publish(bundleId, pathsNotFound);
    }, args);
  }
  if (args.returnPromise) {
    return new Promise(loadFn);
  } else {
    loadFn();
  }
}
loadjs.ready = function ready(deps, args) {
  subscribe(deps, function(depsNotFound) {
    executeCallbacks(args, depsNotFound);
  });
  return loadjs;
};
loadjs.done = function done(bundleId) {
  publish(bundleId, []);
};
loadjs.reset = function reset() {
  Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
  Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
  Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
};
loadjs.isDefined = function isDefined(bundleId) {
  return bundleId in bundleIdCache;
};
function registerRzAccordion(Alpine2) {
  Alpine2.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: false,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function registerRzAccordionSection(Alpine2) {
  Alpine2.data("rzAccordionSection", () => ({
    open: false,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true";
      this.sectionId = this.$el.dataset.sectionId;
      this.expandedClass = this.$el.dataset.expandedClass;
      const self = this;
      if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
        this.$watch("selected", (value, oldValue) => {
          if (value !== self.sectionId && !self.allowMultiple) {
            self.open = false;
          }
        });
      } else {
        console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
      }
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId;
      this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function registerRzAlert(Alpine2) {
  Alpine2.data("rzAlert", () => {
    return {
      showAlert: true,
      dismiss() {
        this.showAlert = false;
      }
    };
  });
}
function registerRzBrowser(Alpine2) {
  Alpine2.data("rzBrowser", () => {
    return {
      screenSize: "",
      setDesktopScreenSize() {
        this.screenSize = "";
      },
      setTabletScreenSize() {
        this.screenSize = "max-w-2xl";
      },
      setPhoneScreenSize() {
        this.screenSize = "max-w-sm";
      },
      // Get CSS classes for browser border based on screen size
      getBrowserBorderCss() {
        return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
      },
      // Get CSS classes for desktop screen button styling
      getDesktopScreenCss() {
        return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for tablet screen button styling
      getTabletScreenCss() {
        return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      },
      // Get CSS classes for phone screen button styling
      getPhoneScreenCss() {
        return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
      }
    };
  });
}
function registerRzCheckboxGroupItem(Alpine2) {
  Alpine2.data("rzCheckboxGroupItem", () => {
    return {
      checkbox: null,
      isChecked: false,
      init() {
        this.checkbox = this.$refs.chk;
        this.isChecked = this.checkbox.checked;
      },
      toggleCheckbox() {
        this.isChecked = this.checkbox.checked;
      },
      getIconCss() {
        return this.isChecked ? "" : "hidden";
      }
    };
  });
}
function registerRzCodeViewer(Alpine2, require2) {
  Alpine2.data("rzCodeViewer", () => {
    return {
      expand: false,
      border: true,
      copied: false,
      copyTitle: "Copy",
      // Default title
      copiedTitle: "Copied!",
      // Default title
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const codeId = this.$el.dataset.codeid;
        const nonce = this.$el.dataset.nonce;
        this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
        this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
        require2(assets, {
          success: function() {
            const codeBlock = document.getElementById(codeId);
            if (window.hljs && codeBlock) {
              window.hljs.highlightElement(codeBlock);
            }
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      },
      // Function to check if code is NOT copied (for x-show)
      notCopied() {
        return !this.copied;
      },
      // Function to reset the copied state (e.g., on blur)
      disableCopied() {
        this.copied = false;
      },
      // Function to toggle the expand state
      toggleExpand() {
        this.expand = !this.expand;
      },
      // Function to copy code to clipboard
      copyHTML() {
        navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
        this.copied = !this.copied;
      },
      // Get the title for the copy button (copy/copied)
      getCopiedTitle() {
        return this.copied ? this.copiedTitle : this.copyTitle;
      },
      // Get CSS classes for the copy button based on copied state
      getCopiedCss() {
        return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
      },
      // Get CSS classes for the code container based on expand state
      getExpandCss() {
        return [this.expand ? "" : "max-h-60"];
      },
      // Get CSS classes for the expand button icon based on expand state
      getExpandButtonCss() {
        return this.expand ? "rotate-180" : "rotate-0";
      }
    };
  });
}
function registerRzDateEdit(Alpine2, require2) {
  Alpine2.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const cfgString = this.$el.dataset.config;
      const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
      if (cfgString) {
        const parsed = JSON.parse(cfgString);
        if (parsed) {
          this.options = parsed.options || {};
          this.placeholder = parsed.placeholder || "";
          this.prependText = parsed.prependText || "";
        }
      }
      const assets = JSON.parse(this.$el.dataset.assets);
      const nonce = this.$el.dataset.nonce;
      require2(assets, {
        success: function() {
          if (window.flatpickr && inputElem) {
            window.flatpickr(inputElem, this.options);
          }
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, nonce);
    }
  }));
}
function registerRzDropdown(Alpine2) {
  Alpine2.data("rzDropdown", () => ({
    dropdownEl: null,
    anchorCss: "",
    dropdownOpen: false,
    openedWithKeyboard: false,
    init() {
      this.dropdownEl = this.$el;
      this.anchorCss = this.getAnchorCss();
    },
    toggleDropdown() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = !this.dropdownOpen;
    },
    openDropdown() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = true;
      this.openedWithKeyboard = false;
    },
    openWithKeyboard() {
      this.anchorCss = this.getAnchorCss();
      this.dropdownOpen = true;
      this.openedWithKeyboard = true;
      this.focusWrapNext();
    },
    closeDropdown() {
      this.dropdownOpen = false;
      this.openedWithKeyboard = false;
    },
    focusWrapNext() {
      this.$focus.wrap().next();
    },
    focusWrapPrevious() {
      this.$focus.wrap().previous();
    },
    // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
    getAnchorCss() {
      let defaultAnchorRaw = this.dropdownEl.getAttribute("data-anchor") || "";
      let defaultAnchor = defaultAnchorRaw.replace(/-/g, "").toLowerCase();
      const anchorClasses = {
        "topstart": "bottom-full right-0 mb-2 origin-bottom-right",
        "topcenter": "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
        "topend": "bottom-full left-0 mb-2 origin-bottom-left",
        "start": "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
        "end": "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
        "bottomstart": "right-0 mt-2 origin-top-right",
        "bottomcenter": "-translate-x-1/2 mt-2 origin-top",
        "bottomend": "left-0 mt-2 origin-top-left"
      };
      let cssClasses = anchorClasses[defaultAnchor] || "";
      const triggerRect = this.dropdownEl.getBoundingClientRect();
      let tempContainer = document.createElement("div");
      tempContainer.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;";
      this.dropdownEl.appendChild(tempContainer);
      const originalMenu = this.dropdownEl.querySelector('[role="menu"]');
      if (!originalMenu) {
        return cssClasses;
      }
      let clone = originalMenu.cloneNode(true);
      clone.style.transition = "none";
      clone.style.transform = "none";
      clone.style.opacity = "1";
      clone.style.display = "block";
      tempContainer.appendChild(clone);
      let cloneRect = clone.getBoundingClientRect();
      tempContainer.parentNode.removeChild(tempContainer);
      const margin = 8;
      let wouldClip = false;
      if (defaultAnchor.startsWith("top")) {
        if (triggerRect.top < cloneRect.height + margin) {
          wouldClip = true;
        }
      } else if (defaultAnchor.startsWith("bottom")) {
        if (triggerRect.bottom + cloneRect.height + margin > window.innerHeight) {
          wouldClip = true;
        }
      } else if (defaultAnchor === "start") {
        if (triggerRect.left < cloneRect.width + margin) {
          wouldClip = true;
        }
      } else if (defaultAnchor === "end") {
        if (triggerRect.right + cloneRect.width + margin > window.innerWidth) {
          wouldClip = true;
        }
      }
      if (wouldClip) {
        const fallbackMapping = {
          "topstart": "bottomstart",
          "topcenter": "bottomcenter",
          "topend": "bottomend",
          "bottomstart": "topstart",
          "bottomcenter": "topcenter",
          "bottomend": "topend",
          "start": "end",
          "end": "start"
        };
        let fallbackAnchor = fallbackMapping[defaultAnchor] || defaultAnchor;
        cssClasses = anchorClasses[fallbackAnchor] || cssClasses;
      }
      return cssClasses;
    }
  }));
}
function registerRzDarkModeToggle(Alpine2) {
  Alpine2.data("rzDarkModeToggle", () => ({
    mode: "light",
    applyTheme: null,
    init() {
      const hasLocalStorage = typeof window !== "undefined" && "localStorage" in window;
      const allowedModes = ["light", "dark", "auto"];
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      let storedMode = "auto";
      if (hasLocalStorage) {
        storedMode = localStorage.getItem("darkMode") ?? "auto";
        if (!allowedModes.includes(storedMode)) {
          storedMode = "light";
        }
      }
      if (hasLocalStorage) {
        localStorage.setItem("darkMode", storedMode);
      }
      this.applyTheme = () => {
        document.documentElement.classList.toggle(
          "dark",
          storedMode === "dark" || storedMode === "auto" && prefersDark
        );
      };
      this.applyTheme();
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
    },
    // Returns true if dark mode should be active
    isDark() {
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      localStorage.getItem("darkMode");
      return this.mode === "dark" || this.mode === "auto" && prefersDark;
    },
    // Returns true if light mode should be active
    isLight() {
      return !this.isDark();
    },
    // Toggle the dark mode setting and dispatch a custom event
    toggle() {
      let storedMode = localStorage.getItem("darkMode");
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (storedMode === "light")
        storedMode = "dark";
      else if (storedMode === "dark")
        storedMode = "light";
      else if (storedMode === "auto") {
        storedMode = prefersDark ? "light" : "dark";
      }
      this.mode = storedMode;
      localStorage.setItem("darkMode", storedMode);
      const isDark = storedMode === "dark" || storedMode === "auto" && prefersDark;
      document.documentElement.classList.toggle("dark", isDark);
      const darkModeEvent = new CustomEvent("darkModeToggle", {
        detail: { darkMode: isDark }
      });
      window.dispatchEvent(darkModeEvent);
    },
    destroy() {
      if (this.applyTheme) {
        window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
      }
    }
  }));
}
function registerRzEmbeddedPreview(Alpine2) {
  Alpine2.data("rzEmbeddedPreview", () => {
    return {
      iframe: null,
      onDarkModeToggle: null,
      init() {
        try {
          this.iframe = this.$refs.iframe;
          const resize = this.debounce(() => {
            this.resizeIframe(this.iframe);
          }, 50);
          this.resizeIframe(this.iframe);
          const resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
              resize();
            }
          });
          resizeObserver.observe(this.iframe);
          const iframe = this.iframe;
          this.onDarkModeToggle = (event) => {
            iframe.contentWindow.postMessage(event.detail, "*");
          };
          window.addEventListener("darkModeToggle", this.onDarkModeToggle);
        } catch (error) {
          console.error("Cannot access iframe content");
        }
      },
      // Adjusts the iframe height based on its content
      resizeIframe(iframe) {
        if (iframe) {
          try {
            const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
            if (iframeDocument) {
              const iframeBody = iframeDocument.body;
              if (!iframeBody) {
                setInterval(() => {
                  this.resizeIframe(iframe);
                }, 150);
              } else {
                const newHeight = iframeBody.scrollHeight + 15;
                iframe.style.height = newHeight + "px";
              }
            }
          } catch (error) {
            console.error("Error resizing iframe:", error);
          }
        }
      },
      // Debounce helper to limit function calls
      debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => {
            func.apply(this, args);
          }, timeout);
        };
      },
      destroy() {
        window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
      }
    };
  });
}
function registerRzEmpty(Alpine2) {
  Alpine2.data("rzEmpty", () => {
  });
}
function registerRzHeading(Alpine2) {
  Alpine2.data("rzHeading", () => {
    return {
      observer: null,
      headingId: "",
      init() {
        this.headingId = this.$el.dataset.alpineRoot;
        const self = this;
        if (typeof this.setCurrentHeading === "function") {
          const callback = (entries, observer) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                self.setCurrentHeading(self.headingId);
              }
            });
          };
          const options = { threshold: 0.5 };
          this.observer = new IntersectionObserver(callback, options);
          this.observer.observe(this.$el);
        } else {
          console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
        }
      },
      destroy() {
        if (this.observer != null)
          this.observer.disconnect();
      }
    };
  });
}
function registerRzMarkdown(Alpine2, require2) {
  Alpine2.data("rzMarkdown", () => {
    return {
      init() {
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require2(assets, {
          success: function() {
            window.hljs.highlightAll();
          },
          error: function() {
            console.error("Failed to load Highlight.js");
          }
        }, nonce);
      }
    };
  });
}
function registerRzModal(Alpine2) {
  Alpine2.data("rzModal", () => ({
    modalOpen: false,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: true,
    closeOnClickOutside: true,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "";
      this.bodyId = this.$el.dataset.bodyId || "";
      this.footerId = this.$el.dataset.footerId || "";
      this.nonce = this.$el.dataset.nonce || "";
      this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
      this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
      this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
      this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
      this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: true
      }));
      if (this.eventTriggerName) {
        this._openListener = (e2) => {
          this.openModal(e2);
        };
        window.addEventListener(this.eventTriggerName, this._openListener);
      }
      this._closeEventListener = (event) => {
        if (this.modalOpen) {
          this.closeModalInternally("event");
        }
      };
      window.addEventListener(this.closeEventName, this._closeEventListener);
      this._escapeListener = (e2) => {
        if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
          this.closeModalInternally("escape");
        }
      };
      window.addEventListener("keydown", this._escapeListener);
      this.$watch("modalOpen", (value) => {
        const currentWidth = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", value);
        const scrollBarWidth = document.body.offsetWidth - currentWidth;
        document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
        if (value) {
          this.$nextTick(() => {
            const dialogElement = this.$el.querySelector('[role="document"]');
            const focusable3 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
            focusable3?.focus();
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        } else {
          this.$nextTick(() => {
            this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
              detail: { modalId: this.modalId },
              bubbles: true
            }));
          });
        }
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      if (this._openListener && this.eventTriggerName) {
        window.removeEventListener(this.eventTriggerName, this._openListener);
      }
      if (this._closeEventListener) {
        window.removeEventListener(this.closeEventName, this._closeEventListener);
      }
      if (this._escapeListener) {
        window.removeEventListener("keydown", this._escapeListener);
      }
      document.body.classList.remove("overflow-hidden");
      document.body.style.setProperty("--page-scrollbar-width", `0px`);
    },
    openModal(event = null) {
      const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: event },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeOpenEvent);
      if (!beforeOpenEvent.defaultPrevented) {
        this.modalOpen = true;
      }
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(reason = "unknown") {
      const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason },
        bubbles: true,
        cancelable: true
      });
      this.$el.dispatchEvent(beforeCloseEvent);
      if (!beforeCloseEvent.defaultPrevented) {
        document.activeElement?.blur && document.activeElement.blur();
        this.modalOpen = false;
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      }
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      if (this.closeOnClickOutside) {
        this.closeModalInternally("backdrop");
      }
    }
  }));
}
function registerRzPrependInput(Alpine2) {
  Alpine2.data("rzPrependInput", () => {
    return {
      prependContainer: null,
      textInput: null,
      init() {
        this.prependContainer = this.$refs.prependContainer;
        this.textInput = this.$refs.textInput;
        let self = this;
        setTimeout(() => {
          self.updatePadding();
        }, 50);
        window.addEventListener("resize", this.updatePadding);
      },
      destroy() {
        window.removeEventListener("resize", this.updatePadding);
      },
      updatePadding() {
        const prependDiv = this.prependContainer;
        const inputElem = this.textInput;
        if (!prependDiv || !inputElem) {
          if (inputElem) {
            inputElem.classList.remove("text-transparent");
          }
          return;
        }
        const prependWidth = prependDiv.offsetWidth;
        const leftPadding = prependWidth + 10;
        inputElem.style.paddingLeft = leftPadding + "px";
        inputElem.classList.remove("text-transparent");
      }
    };
  });
}
function registerRzProgress(Alpine2) {
  Alpine2.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const element = this.$el;
      this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
      this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
      this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
      this.label = element.getAttribute("data-label");
      this.calculatePercentage();
      element.setAttribute("aria-valuenow", this.currentVal);
      element.setAttribute("aria-valuemin", this.minVal);
      element.setAttribute("aria-valuemax", this.maxVal);
      element.setAttribute("aria-valuetext", `${this.percentage}%`);
      this.updateProgressBar();
      const resizeObserver = new ResizeObserver((entries) => {
        this.updateProgressBar();
      });
      resizeObserver.observe(element);
      this.$watch("currentVal", () => {
        this.calculatePercentage();
        this.updateProgressBar();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      if (this.maxVal === this.minVal) {
        this.percentage = 0;
      } else {
        this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
      }
    },
    buildLabel() {
      var label = this.label || "{percent}%";
      this.calculatePercentage();
      return label.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const progressBar = this.$refs.progressBar;
      const barLabel = this.$refs.progressBarLabel;
      const innerLabel = this.$refs.innerLabel;
      if (barLabel && progressBar && innerLabel) {
        innerLabel.innerText = this.buildLabel();
        if (barLabel.clientWidth > progressBar.clientWidth) {
          barLabel.style.left = progressBar.clientWidth + 10 + "px";
        } else {
          barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
        }
      }
    },
    getLabelCss() {
      const barLabel = this.$refs.progressBarLabel;
      const progressBar = this.$refs.progressBar;
      if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
        return "text-foreground dark:text-foreground";
      }
      return "";
    },
    updateProgressBar() {
      const progressBar = this.$refs.progressBar;
      if (progressBar) {
        progressBar.style.width = `${this.percentage}%`;
        this.buildInsideLabelPosition();
      }
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(value) {
      this.currentVal = value;
    },
    increment(val = 1) {
      this.currentVal = Math.min(this.currentVal + val, this.maxVal);
    },
    decrement(val = 1) {
      this.currentVal = Math.max(this.currentVal - val, this.minVal);
    }
  }));
}
function registerRzQuickReferenceContainer(Alpine2) {
  Alpine2.data("rzQuickReferenceContainer", () => {
    return {
      headings: [],
      // Array of heading IDs
      currentHeadingId: "",
      // ID of the currently highlighted heading
      // Initializes the component with headings and the initial current heading from data attributes.
      init() {
        this.headings = JSON.parse(this.$el.dataset.headings || "[]");
        this.currentHeadingId = this.$el.dataset.currentheadingid || "";
      },
      // Handles click events on quick reference links.
      handleHeadingClick() {
        const id = this.$el.dataset.headingid;
        window.requestAnimationFrame(() => {
          this.currentHeadingId = id;
        });
      },
      // Sets the current heading ID based on intersection observer events from rzHeading.
      setCurrentHeading(id) {
        if (this.headings.includes(id)) {
          this.currentHeadingId = id;
        }
      },
      // Provides CSS classes for a link based on whether it's the current heading.
      // Returns an object suitable for :class binding.
      getSelectedCss() {
        const id = this.$el.dataset.headingid;
        return {
          "font-bold": this.currentHeadingId === id
          // Apply 'font-bold' if current
        };
      },
      // Determines the value for the aria-current attribute.
      getSelectedAriaCurrent() {
        const id = this.$el.dataset.headingid;
        return this.currentHeadingId === id ? "true" : null;
      }
    };
  });
}
function registerRzTabs(Alpine2) {
  Alpine2.data("rzTabs", () => {
    return {
      buttonRef: null,
      tabSelected: "",
      tabButton: null,
      init() {
        this.buttonRef = document.getElementById(this.$el.dataset.buttonref);
        this.tabSelected = this.$el.dataset.tabselected;
        this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']");
        this.tabRepositionMarker(this.tabButton);
      },
      tabButtonClicked(tabButton) {
        if (tabButton instanceof Event)
          tabButton = tabButton.target;
        this.tabSelected = tabButton.dataset.name;
        this.tabRepositionMarker(tabButton);
        tabButton.focus();
      },
      tabRepositionMarker(tabButton) {
        this.tabButton = tabButton;
        this.$refs.tabMarker.style.width = tabButton.offsetWidth + "px";
        this.$refs.tabMarker.style.height = tabButton.offsetHeight + "px";
        this.$refs.tabMarker.style.left = tabButton.offsetLeft + "px";
        setTimeout(() => {
          this.$refs.tabMarker.style.opacity = 1;
        }, 150);
      },
      // Get the CSS classes for the tab content panel based on selection
      getTabContentCss() {
        return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
      },
      tabContentActive(tabContent) {
        tabContent = tabContent ?? this.$el;
        return this.tabSelected === tabContent.dataset.name;
      },
      tabButtonActive(tabButton) {
        tabButton = tabButton ?? this.$el;
        return this.tabSelected === tabButton.dataset.name;
      },
      // Get the value for the aria-selected attribute
      getTabButtonAriaSelected() {
        return this.tabSelected === this.$el.dataset.name ? "true" : "false";
      },
      // Get the CSS classes for the tab button text color based on selection
      getSelectedTabTextColorCss() {
        const color = this.$el.dataset.selectedtextcolor ?? "";
        return this.tabSelected === this.$el.dataset.name ? color : "";
      },
      handleResize() {
        this.tabRepositionMarker(this.tabButton);
      },
      handleKeyDown(event) {
        const key = event.key;
        const tabButtons = Array.from(this.buttonRef.querySelectorAll("[role='tab']"));
        const currentIndex = tabButtons.findIndex((button) => this.tabSelected === button.dataset.name);
        let newIndex = currentIndex;
        if (key === "ArrowRight") {
          newIndex = (currentIndex + 1) % tabButtons.length;
          event.preventDefault();
        } else if (key === "ArrowLeft") {
          newIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;
          event.preventDefault();
        } else if (key === "Home") {
          newIndex = 0;
          event.preventDefault();
        } else if (key === "End") {
          newIndex = tabButtons.length - 1;
          event.preventDefault();
        }
        if (newIndex !== currentIndex) {
          this.tabButtonClicked(tabButtons[newIndex]);
        }
      }
    };
  });
}
function registerRzSidebar(Alpine2) {
  Alpine2.data("rzSidebar", () => {
    return {
      showSidebar: false,
      isSidebarHidden() {
        return !this.showSidebar;
      },
      toggleSidebar() {
        this.showSidebar = !this.showSidebar;
      },
      hideSidebar() {
        this.showSidebar = false;
      },
      // Return translation classes based on sidebar state for smooth slide-in/out
      getSidebarTranslation() {
        return this.showSidebar ? "translate-x-0" : "-translate-x-60";
      }
    };
  });
}
function registerRzSidebarLinkItem(Alpine2) {
  Alpine2.data("rzSidebarLinkItem", () => {
    return {
      isExpanded: false,
      chevronExpandedClass: "",
      chevronCollapsedClass: "",
      init() {
        this.isExpanded = this.$el.dataset.expanded === "true";
        this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass;
        this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
      },
      isCollapsed() {
        return !this.isExpanded;
      },
      toggleExpanded() {
        this.isExpanded = !this.isExpanded;
      },
      hideSidebar() {
        const sidebarScope = this.$el.closest('[x-data^="rzSidebar"]');
        if (sidebarScope) {
          let data = Alpine2.$data(sidebarScope);
          data.showSidebar = false;
        } else {
          console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
        }
      },
      getExpandedClass() {
        return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
      },
      // Get the value for the aria-expanded attribute
      getAriaExpanded() {
        return this.isExpanded ? "true" : "false";
      }
    };
  });
}
async function generateBundleId(paths) {
  paths = [...paths].sort();
  const joinedPaths = paths.join("|");
  const encoder = new TextEncoder();
  const data = encoder.encode(joinedPaths);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}
function rizzyRequire(paths, callbackFn, nonce) {
  generateBundleId(paths).then((bundleId) => {
    if (!loadjs.isDefined(bundleId)) {
      loadjs(
        paths,
        bundleId,
        {
          async: false,
          inlineScriptNonce: nonce,
          inlineStyleNonce: nonce
        }
      );
    }
    loadjs.ready([bundleId], callbackFn);
  });
}
function registerComponents(Alpine2) {
  registerRzAccordion(Alpine2);
  registerRzAccordionSection(Alpine2);
  registerRzAlert(Alpine2);
  registerRzBrowser(Alpine2);
  registerRzCheckboxGroupItem(Alpine2);
  registerRzCodeViewer(Alpine2, rizzyRequire);
  registerRzDateEdit(Alpine2, rizzyRequire);
  registerRzDropdown(Alpine2);
  registerRzDarkModeToggle(Alpine2);
  registerRzEmbeddedPreview(Alpine2);
  registerRzEmpty(Alpine2);
  registerRzHeading(Alpine2);
  registerRzMarkdown(Alpine2, rizzyRequire);
  registerRzModal(Alpine2);
  registerRzPrependInput(Alpine2);
  registerRzProgress(Alpine2);
  registerRzQuickReferenceContainer(Alpine2);
  registerRzTabs(Alpine2);
  registerRzSidebar(Alpine2);
  registerRzSidebarLinkItem(Alpine2);
}
function $data(idOrElement) {
  if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
    console.error(
      "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
    );
    return void 0;
  }
  let outerElement = null;
  let componentId = null;
  if (typeof idOrElement === "string") {
    if (!idOrElement) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return void 0;
    }
    componentId = idOrElement;
    outerElement = document.getElementById(componentId);
    if (!outerElement) {
      console.warn(`Rizzy.$data: Rizzy component with ID "${componentId}" not found in the DOM.`);
      return void 0;
    }
  } else if (idOrElement instanceof Element) {
    outerElement = idOrElement;
    if (!outerElement.id) {
      console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
      return void 0;
    }
    componentId = outerElement.id;
  } else {
    console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
    return void 0;
  }
  const alpineRootSelector = `[data-alpine-root="${componentId}"]`;
  let alpineRootElement = null;
  if (outerElement.matches(alpineRootSelector)) {
    alpineRootElement = outerElement;
  } else {
    alpineRootElement = outerElement.querySelector(alpineRootSelector);
  }
  if (!alpineRootElement) {
    console.warn(
      `Rizzy.$data: Could not locate the designated Alpine root element using selector "${alpineRootSelector}" on or inside the wrapper element (ID: #${componentId}). Verify the 'data-alpine-root' attribute placement.`
    );
    return void 0;
  }
  const alpineData = Alpine.$data(alpineRootElement);
  if (alpineData === void 0) {
    const targetDesc = `${alpineRootElement.tagName.toLowerCase()}${alpineRootElement.id ? "#" + alpineRootElement.id : ""}${alpineRootElement.classList.length ? "." + Array.from(alpineRootElement.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located designated Alpine root (${targetDesc}) via 'data-alpine-root="${componentId}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
    );
  }
  return alpineData;
}
Alpine$1.plugin(module_default$2);
Alpine$1.plugin(module_default$1);
Alpine$1.plugin(module_default);
registerComponents(Alpine$1);
const RizzyUI = {
  Alpine: Alpine$1,
  require: rizzyRequire,
  toast: Toast,
  $data
};
window.Alpine = Alpine$1;
window.Rizzy = { ...window.Rizzy || {}, ...RizzyUI };
Alpine$1.start();
export {
  RizzyUI as default
};
//# sourceMappingURL=rizzyui.es.js.map
</file>

<file path="wwwroot/js/rizzyui.min.es.js">
import F from "alpinejs";
function Re(i) {
  i.directive("collapse", e), e.inline = (t, { modifiers: n }) => {
    n.includes("min") && (t._x_doShow = () => {
    }, t._x_doHide = () => {
    });
  };
  function e(t, { modifiers: n }) {
    let r = se(n, "duration", 250) / 1e3, s = se(n, "min", 0), a = !n.includes("min");
    t._x_isShown || (t.style.height = `${s}px`), !t._x_isShown && a && (t.hidden = !0), t._x_isShown || (t.style.overflow = "hidden");
    let d = (u, p) => {
      let h = i.setStyles(u, p);
      return p.height ? () => {
      } : h;
    }, c = {
      transitionProperty: "height",
      transitionDuration: `${r}s`,
      transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
    };
    t._x_transition = {
      in(u = () => {
      }, p = () => {
      }) {
        a && (t.hidden = !1), a && (t.style.display = null);
        let h = t.getBoundingClientRect().height;
        t.style.height = "auto";
        let f = t.getBoundingClientRect().height;
        h === f && (h = s), i.transition(t, i.setStyles, {
          during: c,
          start: { height: h + "px" },
          end: { height: f + "px" }
        }, () => t._x_isShown = !0, () => {
          Math.abs(t.getBoundingClientRect().height - f) < 1 && (t.style.overflow = null);
        });
      },
      out(u = () => {
      }, p = () => {
      }) {
        let h = t.getBoundingClientRect().height;
        i.transition(t, d, {
          during: c,
          start: { height: h + "px" },
          end: { height: s + "px" }
        }, () => t.style.overflow = "hidden", () => {
          t._x_isShown = !1, t.style.height == `${s}px` && a && (t.style.display = "none", t.hidden = !0);
        });
      }
    };
  }
}
function se(i, e, t) {
  if (i.indexOf(e) === -1)
    return t;
  const n = i[i.indexOf(e) + 1];
  if (!n)
    return t;
  if (e === "duration") {
    let r = n.match(/([0-9]+)ms/);
    if (r)
      return r[1];
  }
  if (e === "min") {
    let r = n.match(/([0-9]+)px/);
    if (r)
      return r[1];
  }
  return n;
}
var Fe = Re;
function $e(i) {
  i.directive("intersect", i.skipDuringClone((e, { value: t, expression: n, modifiers: r }, { evaluateLater: s, cleanup: a }) => {
    let d = s(n), c = {
      rootMargin: ze(r),
      threshold: De(r)
    }, u = new IntersectionObserver((p) => {
      p.forEach((h) => {
        h.isIntersecting !== (t === "leave") && (d(), r.includes("once") && u.disconnect());
      });
    }, c);
    u.observe(e), a(() => {
      u.disconnect();
    });
  }));
}
function De(i) {
  if (i.includes("full"))
    return 0.99;
  if (i.includes("half"))
    return 0.5;
  if (!i.includes("threshold"))
    return 0;
  let e = i[i.indexOf("threshold") + 1];
  return e === "100" ? 1 : e === "0" ? 0 : +`.${e}`;
}
function Ae(i) {
  let e = i.match(/^(-?[0-9]+)(px|%)?$/);
  return e ? e[1] + (e[2] || "px") : void 0;
}
function ze(i) {
  const e = "margin", t = "0px 0px 0px 0px", n = i.indexOf(e);
  if (n === -1)
    return t;
  let r = [];
  for (let s = 1; s < 5; s++)
    r.push(Ae(i[n + s] || ""));
  return r = r.filter((s) => s !== void 0), r.length ? r.join(" ").trim() : t;
}
var _e = $e, be = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"], Z = /* @__PURE__ */ be.join(","), ge = typeof Element > "u", R = ge ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, te = !ge && Element.prototype.getRootNode ? function(i) {
  return i.getRootNode();
} : function(i) {
  return i.ownerDocument;
}, me = function(e, t, n) {
  var r = Array.prototype.slice.apply(e.querySelectorAll(Z));
  return t && R.call(e, Z) && r.unshift(e), r = r.filter(n), r;
}, we = function i(e, t, n) {
  for (var r = [], s = Array.from(e); s.length; ) {
    var a = s.shift();
    if (a.tagName === "SLOT") {
      var d = a.assignedElements(), c = d.length ? d : a.children, u = i(c, !0, n);
      n.flatten ? r.push.apply(r, u) : r.push({
        scope: a,
        candidates: u
      });
    } else {
      var p = R.call(a, Z);
      p && n.filter(a) && (t || !e.includes(a)) && r.push(a);
      var h = a.shadowRoot || // check for an undisclosed shadow
      typeof n.getShadowRoot == "function" && n.getShadowRoot(a), f = !n.shadowRootFilter || n.shadowRootFilter(a);
      if (h && f) {
        var E = i(h === !0 ? a.children : h.children, !0, n);
        n.flatten ? r.push.apply(r, E) : r.push({
          scope: a,
          candidates: E
        });
      } else
        s.unshift.apply(s, a.children);
    }
  }
  return r;
}, ye = function(e, t) {
  return e.tabIndex < 0 && (t || /^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || e.isContentEditable) && isNaN(parseInt(e.getAttribute("tabindex"), 10)) ? 0 : e.tabIndex;
}, Me = function(e, t) {
  return e.tabIndex === t.tabIndex ? e.documentOrder - t.documentOrder : e.tabIndex - t.tabIndex;
}, Ee = function(e) {
  return e.tagName === "INPUT";
}, Pe = function(e) {
  return Ee(e) && e.type === "hidden";
}, Be = function(e) {
  var t = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(n) {
    return n.tagName === "SUMMARY";
  });
  return t;
}, We = function(e, t) {
  for (var n = 0; n < e.length; n++)
    if (e[n].checked && e[n].form === t)
      return e[n];
}, Ye = function(e) {
  if (!e.name)
    return !0;
  var t = e.form || te(e), n = function(d) {
    return t.querySelectorAll('input[type="radio"][name="' + d + '"]');
  }, r;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    r = n(window.CSS.escape(e.name));
  else
    try {
      r = n(e.name);
    } catch (a) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message), !1;
    }
  var s = We(r, e.form);
  return !s || s === e;
}, He = function(e) {
  return Ee(e) && e.type === "radio";
}, Ve = function(e) {
  return He(e) && !Ye(e);
}, ae = function(e) {
  var t = e.getBoundingClientRect(), n = t.width, r = t.height;
  return n === 0 && r === 0;
}, je = function(e, t) {
  var n = t.displayCheck, r = t.getShadowRoot;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  var s = R.call(e, "details>summary:first-of-type"), a = s ? e.parentElement : e;
  if (R.call(a, "details:not([open]) *"))
    return !0;
  var d = te(e).host, c = d?.ownerDocument.contains(d) || e.ownerDocument.contains(e);
  if (!n || n === "full") {
    if (typeof r == "function") {
      for (var u = e; e; ) {
        var p = e.parentElement, h = te(e);
        if (p && !p.shadowRoot && r(p) === !0)
          return ae(e);
        e.assignedSlot ? e = e.assignedSlot : !p && h !== e.ownerDocument ? e = h.host : e = p;
      }
      e = u;
    }
    if (c)
      return !e.getClientRects().length;
  } else if (n === "non-zero-area")
    return ae(e);
  return !1;
}, Ge = function(e) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
    for (var t = e.parentElement; t; ) {
      if (t.tagName === "FIELDSET" && t.disabled) {
        for (var n = 0; n < t.children.length; n++) {
          var r = t.children.item(n);
          if (r.tagName === "LEGEND")
            return R.call(t, "fieldset[disabled] *") ? !0 : !r.contains(e);
        }
        return !0;
      }
      t = t.parentElement;
    }
  return !1;
}, K = function(e, t) {
  return !(t.disabled || Pe(t) || je(t, e) || // For a details element with a summary, the summary element gets the focus
  Be(t) || Ge(t));
}, ie = function(e, t) {
  return !(Ve(t) || ye(t) < 0 || !K(e, t));
}, Ue = function(e) {
  var t = parseInt(e.getAttribute("tabindex"), 10);
  return !!(isNaN(t) || t >= 0);
}, qe = function i(e) {
  var t = [], n = [];
  return e.forEach(function(r, s) {
    var a = !!r.scope, d = a ? r.scope : r, c = ye(d, a), u = a ? i(r.candidates) : d;
    c === 0 ? a ? t.push.apply(t, u) : t.push(d) : n.push({
      documentOrder: s,
      tabIndex: c,
      item: r,
      isScope: a,
      content: u
    });
  }), n.sort(Me).reduce(function(r, s) {
    return s.isScope ? r.push.apply(r, s.content) : r.push(s.content), r;
  }, []).concat(t);
}, Ze = function(e, t) {
  t = t || {};
  var n;
  return t.getShadowRoot ? n = we([e], t.includeContainer, {
    filter: ie.bind(null, t),
    flatten: !1,
    getShadowRoot: t.getShadowRoot,
    shadowRootFilter: Ue
  }) : n = me(e, t.includeContainer, ie.bind(null, t)), qe(n);
}, Ie = function(e, t) {
  t = t || {};
  var n;
  return t.getShadowRoot ? n = we([e], t.includeContainer, {
    filter: K.bind(null, t),
    flatten: !0,
    getShadowRoot: t.getShadowRoot
  }) : n = me(e, t.includeContainer, K.bind(null, t)), n;
}, j = function(e, t) {
  if (t = t || {}, !e)
    throw new Error("No node provided");
  return R.call(e, Z) === !1 ? !1 : ie(t, e);
}, Ke = /* @__PURE__ */ be.concat("iframe").join(","), U = function(e, t) {
  if (t = t || {}, !e)
    throw new Error("No node provided");
  return R.call(e, Ke) === !1 ? !1 : K(t, e);
};
function oe(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    e && (n = n.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function le(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oe(Object(t), !0).forEach(function(n) {
      Je(i, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : oe(Object(t)).forEach(function(n) {
      Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return i;
}
function Je(i, e, t) {
  return e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
var ce = /* @__PURE__ */ function() {
  var i = [];
  return {
    activateTrap: function(t) {
      if (i.length > 0) {
        var n = i[i.length - 1];
        n !== t && n.pause();
      }
      var r = i.indexOf(t);
      r === -1 || i.splice(r, 1), i.push(t);
    },
    deactivateTrap: function(t) {
      var n = i.indexOf(t);
      n !== -1 && i.splice(n, 1), i.length > 0 && i[i.length - 1].unpause();
    }
  };
}(), Xe = function(e) {
  return e.tagName && e.tagName.toLowerCase() === "input" && typeof e.select == "function";
}, Qe = function(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
}, et = function(e) {
  return e.key === "Tab" || e.keyCode === 9;
}, de = function(e) {
  return setTimeout(e, 0);
}, ue = function(e, t) {
  var n = -1;
  return e.every(function(r, s) {
    return t(r) ? (n = s, !1) : !0;
  }), n;
}, z = function(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return typeof e == "function" ? e.apply(void 0, n) : e;
}, G = function(e) {
  return e.target.shadowRoot && typeof e.composedPath == "function" ? e.composedPath()[0] : e.target;
}, tt = function(e, t) {
  var n = t?.document || document, r = le({
    returnFocusOnDeactivate: !0,
    escapeDeactivates: !0,
    delayInitialFocus: !0
  }, t), s = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: !1,
    paused: !1,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  }, a, d = function(o, l, v) {
    return o && o[l] !== void 0 ? o[l] : r[v || l];
  }, c = function(o) {
    return s.containerGroups.findIndex(function(l) {
      var v = l.container, m = l.tabbableNodes;
      return v.contains(o) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      m.find(function(w) {
        return w === o;
      });
    });
  }, u = function(o) {
    var l = r[o];
    if (typeof l == "function") {
      for (var v = arguments.length, m = new Array(v > 1 ? v - 1 : 0), w = 1; w < v; w++)
        m[w - 1] = arguments[w];
      l = l.apply(void 0, m);
    }
    if (l === !0 && (l = void 0), !l) {
      if (l === void 0 || l === !1)
        return l;
      throw new Error("`".concat(o, "` was specified but was not a node, or did not return a node"));
    }
    var y = l;
    if (typeof l == "string" && (y = n.querySelector(l), !y))
      throw new Error("`".concat(o, "` as selector refers to no known node"));
    return y;
  }, p = function() {
    var o = u("initialFocus");
    if (o === !1)
      return !1;
    if (o === void 0)
      if (c(n.activeElement) >= 0)
        o = n.activeElement;
      else {
        var l = s.tabbableGroups[0], v = l && l.firstTabbableNode;
        o = v || u("fallbackFocus");
      }
    if (!o)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return o;
  }, h = function() {
    if (s.containerGroups = s.containers.map(function(o) {
      var l = Ze(o, r.tabbableOptions), v = Ie(o, r.tabbableOptions);
      return {
        container: o,
        tabbableNodes: l,
        focusableNodes: v,
        firstTabbableNode: l.length > 0 ? l[0] : null,
        lastTabbableNode: l.length > 0 ? l[l.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(w) {
          var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, C = v.findIndex(function(S) {
            return S === w;
          });
          if (!(C < 0))
            return y ? v.slice(C + 1).find(function(S) {
              return j(S, r.tabbableOptions);
            }) : v.slice(0, C).reverse().find(function(S) {
              return j(S, r.tabbableOptions);
            });
        }
      };
    }), s.tabbableGroups = s.containerGroups.filter(function(o) {
      return o.tabbableNodes.length > 0;
    }), s.tabbableGroups.length <= 0 && !u("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
  }, f = function g(o) {
    if (o !== !1 && o !== n.activeElement) {
      if (!o || !o.focus) {
        g(p());
        return;
      }
      o.focus({
        preventScroll: !!r.preventScroll
      }), s.mostRecentlyFocusedNode = o, Xe(o) && o.select();
    }
  }, E = function(o) {
    var l = u("setReturnFocus", o);
    return l || (l === !1 ? !1 : o);
  }, I = function(o) {
    var l = G(o);
    if (!(c(l) >= 0)) {
      if (z(r.clickOutsideDeactivates, o)) {
        a.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: r.returnFocusOnDeactivate && !U(l, r.tabbableOptions)
        });
        return;
      }
      z(r.allowOutsideClick, o) || o.preventDefault();
    }
  }, N = function(o) {
    var l = G(o), v = c(l) >= 0;
    v || l instanceof Document ? v && (s.mostRecentlyFocusedNode = l) : (o.stopImmediatePropagation(), f(s.mostRecentlyFocusedNode || p()));
  }, T = function(o) {
    var l = G(o);
    h();
    var v = null;
    if (s.tabbableGroups.length > 0) {
      var m = c(l), w = m >= 0 ? s.containerGroups[m] : void 0;
      if (m < 0)
        o.shiftKey ? v = s.tabbableGroups[s.tabbableGroups.length - 1].lastTabbableNode : v = s.tabbableGroups[0].firstTabbableNode;
      else if (o.shiftKey) {
        var y = ue(s.tabbableGroups, function(A) {
          var Q = A.firstTabbableNode;
          return l === Q;
        });
        if (y < 0 && (w.container === l || U(l, r.tabbableOptions) && !j(l, r.tabbableOptions) && !w.nextTabbableNode(l, !1)) && (y = m), y >= 0) {
          var C = y === 0 ? s.tabbableGroups.length - 1 : y - 1, S = s.tabbableGroups[C];
          v = S.lastTabbableNode;
        }
      } else {
        var L = ue(s.tabbableGroups, function(A) {
          var Q = A.lastTabbableNode;
          return l === Q;
        });
        if (L < 0 && (w.container === l || U(l, r.tabbableOptions) && !j(l, r.tabbableOptions) && !w.nextTabbableNode(l)) && (L = m), L >= 0) {
          var V = L === s.tabbableGroups.length - 1 ? 0 : L + 1, X = s.tabbableGroups[V];
          v = X.firstTabbableNode;
        }
      }
    } else
      v = u("fallbackFocus");
    v && (o.preventDefault(), f(v));
  }, $ = function(o) {
    if (Qe(o) && z(r.escapeDeactivates, o) !== !1) {
      o.preventDefault(), a.deactivate();
      return;
    }
    if (et(o)) {
      T(o);
      return;
    }
  }, Y = function(o) {
    var l = G(o);
    c(l) >= 0 || z(r.clickOutsideDeactivates, o) || z(r.allowOutsideClick, o) || (o.preventDefault(), o.stopImmediatePropagation());
  }, D = function() {
    if (s.active)
      return ce.activateTrap(a), s.delayInitialFocusTimer = r.delayInitialFocus ? de(function() {
        f(p());
      }) : f(p()), n.addEventListener("focusin", N, !0), n.addEventListener("mousedown", I, {
        capture: !0,
        passive: !1
      }), n.addEventListener("touchstart", I, {
        capture: !0,
        passive: !1
      }), n.addEventListener("click", Y, {
        capture: !0,
        passive: !1
      }), n.addEventListener("keydown", $, {
        capture: !0,
        passive: !1
      }), a;
  }, H = function() {
    if (s.active)
      return n.removeEventListener("focusin", N, !0), n.removeEventListener("mousedown", I, !0), n.removeEventListener("touchstart", I, !0), n.removeEventListener("click", Y, !0), n.removeEventListener("keydown", $, !0), a;
  };
  return a = {
    get active() {
      return s.active;
    },
    get paused() {
      return s.paused;
    },
    activate: function(o) {
      if (s.active)
        return this;
      var l = d(o, "onActivate"), v = d(o, "onPostActivate"), m = d(o, "checkCanFocusTrap");
      m || h(), s.active = !0, s.paused = !1, s.nodeFocusedBeforeActivation = n.activeElement, l && l();
      var w = function() {
        m && h(), D(), v && v();
      };
      return m ? (m(s.containers.concat()).then(w, w), this) : (w(), this);
    },
    deactivate: function(o) {
      if (!s.active)
        return this;
      var l = le({
        onDeactivate: r.onDeactivate,
        onPostDeactivate: r.onPostDeactivate,
        checkCanReturnFocus: r.checkCanReturnFocus
      }, o);
      clearTimeout(s.delayInitialFocusTimer), s.delayInitialFocusTimer = void 0, H(), s.active = !1, s.paused = !1, ce.deactivateTrap(a);
      var v = d(l, "onDeactivate"), m = d(l, "onPostDeactivate"), w = d(l, "checkCanReturnFocus"), y = d(l, "returnFocus", "returnFocusOnDeactivate");
      v && v();
      var C = function() {
        de(function() {
          y && f(E(s.nodeFocusedBeforeActivation)), m && m();
        });
      };
      return y && w ? (w(E(s.nodeFocusedBeforeActivation)).then(C, C), this) : (C(), this);
    },
    pause: function() {
      return s.paused || !s.active ? this : (s.paused = !0, H(), this);
    },
    unpause: function() {
      return !s.paused || !s.active ? this : (s.paused = !1, h(), D(), this);
    },
    updateContainerElements: function(o) {
      var l = [].concat(o).filter(Boolean);
      return s.containers = l.map(function(v) {
        return typeof v == "string" ? n.querySelector(v) : v;
      }), s.active && h(), this;
    }
  }, a.updateContainerElements(e), a;
};
function it(i) {
  let e, t;
  window.addEventListener("focusin", () => {
    e = t, t = document.activeElement;
  }), i.magic("focus", (n) => {
    let r = n;
    return {
      __noscroll: !1,
      __wrapAround: !1,
      within(s) {
        return r = s, this;
      },
      withoutScrolling() {
        return this.__noscroll = !0, this;
      },
      noscroll() {
        return this.__noscroll = !0, this;
      },
      withWrapAround() {
        return this.__wrapAround = !0, this;
      },
      wrap() {
        return this.withWrapAround();
      },
      focusable(s) {
        return U(s);
      },
      previouslyFocused() {
        return e;
      },
      lastFocused() {
        return e;
      },
      focused() {
        return t;
      },
      focusables() {
        return Array.isArray(r) ? r : Ie(r, { displayCheck: "none" });
      },
      all() {
        return this.focusables();
      },
      isFirst(s) {
        let a = this.all();
        return a[0] && a[0].isSameNode(s);
      },
      isLast(s) {
        let a = this.all();
        return a.length && a.slice(-1)[0].isSameNode(s);
      },
      getFirst() {
        return this.all()[0];
      },
      getLast() {
        return this.all().slice(-1)[0];
      },
      getNext() {
        let s = this.all(), a = document.activeElement;
        if (s.indexOf(a) !== -1)
          return this.__wrapAround && s.indexOf(a) === s.length - 1 ? s[0] : s[s.indexOf(a) + 1];
      },
      getPrevious() {
        let s = this.all(), a = document.activeElement;
        if (s.indexOf(a) !== -1)
          return this.__wrapAround && s.indexOf(a) === 0 ? s.slice(-1)[0] : s[s.indexOf(a) - 1];
      },
      first() {
        this.focus(this.getFirst());
      },
      last() {
        this.focus(this.getLast());
      },
      next() {
        this.focus(this.getNext());
      },
      previous() {
        this.focus(this.getPrevious());
      },
      prev() {
        return this.previous();
      },
      focus(s) {
        s && setTimeout(() => {
          s.hasAttribute("tabindex") || s.setAttribute("tabindex", "0"), s.focus({ preventScroll: this.__noscroll });
        });
      }
    };
  }), i.directive("trap", i.skipDuringClone(
    (n, { expression: r, modifiers: s }, { effect: a, evaluateLater: d, cleanup: c }) => {
      let u = d(r), p = !1, h = {
        escapeDeactivates: !1,
        allowOutsideClick: !0,
        fallbackFocus: () => n
      };
      if (s.includes("noautofocus"))
        h.initialFocus = !1;
      else {
        let T = n.querySelector("[autofocus]");
        T && (h.initialFocus = T);
      }
      let f = tt(n, h), E = () => {
      }, I = () => {
      };
      const N = () => {
        E(), E = () => {
        }, I(), I = () => {
        }, f.deactivate({
          returnFocus: !s.includes("noreturn")
        });
      };
      a(() => u((T) => {
        p !== T && (T && !p && (s.includes("noscroll") && (I = nt()), s.includes("inert") && (E = he(n)), setTimeout(() => {
          f.activate();
        }, 15)), !T && p && N(), p = !!T);
      })), c(N);
    },
    // When cloning, we only want to add aria-hidden attributes to the
    // DOM and not try to actually trap, as trapping can mess with the
    // live DOM and isn't just isolated to the cloned DOM.
    (n, { expression: r, modifiers: s }, { evaluate: a }) => {
      s.includes("inert") && a(r) && he(n);
    }
  ));
}
function he(i) {
  let e = [];
  return Te(i, (t) => {
    let n = t.hasAttribute("aria-hidden");
    t.setAttribute("aria-hidden", "true"), e.push(() => n || t.removeAttribute("aria-hidden"));
  }), () => {
    for (; e.length; )
      e.pop()();
  };
}
function Te(i, e) {
  i.isSameNode(document.body) || !i.parentNode || Array.from(i.parentNode.children).forEach((t) => {
    t.isSameNode(i) ? Te(i.parentNode, e) : e(t);
  });
}
function nt() {
  let i = document.documentElement.style.overflow, e = document.documentElement.style.paddingRight, t = window.innerWidth - document.documentElement.clientWidth;
  return document.documentElement.style.overflow = "hidden", document.documentElement.style.paddingRight = `${t}px`, () => {
    document.documentElement.style.overflow = i, document.documentElement.style.paddingRight = e;
  };
}
var rt = it;
/*! Bundled license information:
tabbable/dist/index.esm.js:
  (*!
  * tabbable 5.3.3
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 6.9.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
function st(i, e) {
  if (!(i instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function at(i, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n);
  }
}
function ot(i, e, t) {
  return e && at(i.prototype, e), i;
}
var lt = Object.defineProperty, x = function(i, e) {
  return lt(i, "name", { value: e, configurable: !0 });
}, ct = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`, dt = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`, ut = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, ht = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`, ft = `<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`, pt = x(function(i) {
  return new DOMParser().parseFromString(i, "text/html").body.childNodes[0];
}, "stringToHTML"), _ = x(function(i) {
  var e = new DOMParser().parseFromString(i, "application/xml");
  return document.importNode(e.documentElement, !0).outerHTML;
}, "getSvgNode"), b = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, O = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, fe = { OUTLINE: "outline", FILLED: "filled" }, ee = { FADE: "fade", SLIDE: "slide" }, M = { CLOSE: _(ct), SUCCESS: _(ht), ERROR: _(dt), WARNING: _(ft), INFO: _(ut) }, pe = x(function(i) {
  i.wrapper.classList.add(b.NOTIFY_FADE), setTimeout(function() {
    i.wrapper.classList.add(b.NOTIFY_FADE_IN);
  }, 100);
}, "fadeIn"), ve = x(function(i) {
  i.wrapper.classList.remove(b.NOTIFY_FADE_IN), setTimeout(function() {
    i.wrapper.remove();
  }, i.speed);
}, "fadeOut"), vt = x(function(i) {
  i.wrapper.classList.add(b.NOTIFY_SLIDE), setTimeout(function() {
    i.wrapper.classList.add(b.NOTIFY_SLIDE_IN);
  }, 100);
}, "slideIn"), bt = x(function(i) {
  i.wrapper.classList.remove(b.NOTIFY_SLIDE_IN), setTimeout(function() {
    i.wrapper.remove();
  }, i.speed);
}, "slideOut"), Ce = function() {
  function i(e) {
    var t = this;
    st(this, i), this.notifyOut = x(function(A) {
      A(t);
    }, "notifyOut");
    var n = e.notificationsGap, r = n === void 0 ? 20 : n, s = e.notificationsPadding, a = s === void 0 ? 20 : s, d = e.status, c = d === void 0 ? "success" : d, u = e.effect, p = u === void 0 ? ee.FADE : u, h = e.type, f = h === void 0 ? "outline" : h, E = e.title, I = e.text, N = e.showIcon, T = N === void 0 ? !0 : N, $ = e.customIcon, Y = $ === void 0 ? "" : $, D = e.customClass, H = D === void 0 ? "" : D, g = e.speed, o = g === void 0 ? 500 : g, l = e.showCloseButton, v = l === void 0 ? !0 : l, m = e.autoclose, w = m === void 0 ? !0 : m, y = e.autotimeout, C = y === void 0 ? 3e3 : y, S = e.position, L = S === void 0 ? "right top" : S, V = e.customWrapper, X = V === void 0 ? "" : V;
    if (this.customWrapper = X, this.status = c, this.title = E, this.text = I, this.showIcon = T, this.customIcon = Y, this.customClass = H, this.speed = o, this.effect = p, this.showCloseButton = v, this.autoclose = w, this.autotimeout = C, this.notificationsGap = r, this.notificationsPadding = a, this.type = f, this.position = L, !this.checkRequirements()) {
      console.error("You must specify 'title' or 'text' at least.");
      return;
    }
    this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
  }
  return ot(i, [{ key: "checkRequirements", value: function() {
    return !!(this.title || this.text);
  } }, { key: "setContainer", value: function() {
    var t = document.querySelector(".".concat(b.CONTAINER));
    t ? this.container = t : (this.container = document.createElement("div"), this.container.classList.add(b.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
  } }, { key: "setPosition", value: function() {
    this.container.classList[this.position === "center" ? "add" : "remove"](b.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](b.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](b.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](b.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](b.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](b.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](b.IS_Y_CENTER);
  } }, { key: "setCloseButton", value: function() {
    var t = this, n = document.createElement("div");
    n.classList.add(b.NOTIFY_CLOSE), n.innerHTML = M.CLOSE, this.wrapper.appendChild(n), n.addEventListener("click", function() {
      t.close();
    });
  } }, { key: "setWrapper", value: function() {
    var t = this;
    switch (this.customWrapper ? this.wrapper = pt(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(b.NOTIFY), this.type) {
      case fe.OUTLINE:
        this.wrapper.classList.add(b.NOTIFY_OUTLINE);
        break;
      case fe.FILLED:
        this.wrapper.classList.add(b.NOTIFY_FILLED);
        break;
      default:
        this.wrapper.classList.add(b.NOTIFY_OUTLINE);
    }
    switch (this.status) {
      case O.SUCCESS:
        this.wrapper.classList.add(b.NOTIFY_SUCCESS);
        break;
      case O.ERROR:
        this.wrapper.classList.add(b.NOTIFY_ERROR);
        break;
      case O.WARNING:
        this.wrapper.classList.add(b.NOTIFY_WARNING);
        break;
      case O.INFO:
        this.wrapper.classList.add(b.NOTIFY_INFO);
        break;
    }
    this.autoclose && (this.wrapper.classList.add(b.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(n) {
      t.wrapper.classList.add(n);
    });
  } }, { key: "setContent", value: function() {
    var t = document.createElement("div");
    t.classList.add(b.NOTIFY_CONTENT);
    var n, r;
    this.title && (n = document.createElement("div"), n.classList.add(b.NOTIFY_TITLE), n.textContent = this.title.trim(), this.showCloseButton || (n.style.paddingRight = "0")), this.text && (r = document.createElement("div"), r.classList.add(b.NOTIFY_TEXT), r.innerHTML = this.text.trim(), this.title || (r.style.marginTop = "0")), this.wrapper.appendChild(t), this.title && t.appendChild(n), this.text && t.appendChild(r);
  } }, { key: "setIcon", value: function() {
    var t = x(function(r) {
      switch (r) {
        case O.SUCCESS:
          return M.SUCCESS;
        case O.ERROR:
          return M.ERROR;
        case O.WARNING:
          return M.WARNING;
        case O.INFO:
          return M.INFO;
      }
    }, "computedIcon"), n = document.createElement("div");
    n.classList.add(b.NOTIFY_ICON), n.innerHTML = this.customIcon || t(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(n);
  } }, { key: "setObserver", value: function() {
    var t = this, n = new IntersectionObserver(function(r) {
      if (r[0].intersectionRatio <= 0) t.close();
      else return;
    }, { threshold: 0 });
    setTimeout(function() {
      n.observe(t.wrapper);
    }, this.speed);
  } }, { key: "notifyIn", value: function(e) {
    e(this);
  } }, { key: "autoClose", value: function() {
    var t = this;
    setTimeout(function() {
      t.close();
    }, this.autotimeout + this.speed);
  } }, { key: "close", value: function() {
    this.notifyOut(this.selectedNotifyOutEffect);
  } }, { key: "setEffect", value: function() {
    switch (this.effect) {
      case ee.FADE:
        this.selectedNotifyInEffect = pe, this.selectedNotifyOutEffect = ve;
        break;
      case ee.SLIDE:
        this.selectedNotifyInEffect = vt, this.selectedNotifyOutEffect = bt;
        break;
      default:
        this.selectedNotifyInEffect = pe, this.selectedNotifyOutEffect = ve;
    }
  } }]), i;
}();
x(Ce, "Notify");
var Se = Ce;
globalThis.Notify = Se;
const xe = ["success", "error", "warning", "info"], Ne = [
  // Standard Corners
  "right top",
  "top right",
  "right bottom",
  "bottom right",
  "left top",
  "top left",
  "left bottom",
  "bottom left",
  // Centered Horizontally
  "center top",
  "x-center top",
  "center bottom",
  "x-center bottom",
  // Centered Vertically
  "left center",
  "left y-center",
  "y-center left",
  "right center",
  "right y-center",
  "y-center right",
  // Aliases for Centered Horizontally (already covered but good for robustness)
  "top center",
  "top x-center",
  "bottom center",
  "bottom x-center",
  // Absolute Center
  "center"
], Oe = {
  status: "info",
  title: "Notification",
  text: "",
  effect: "fade",
  speed: 300,
  autoclose: !0,
  autotimeout: 4e3,
  position: "right top"
};
function P(i = {}) {
  const e = {
    ...Oe,
    ...i
  };
  xe.includes(e.status) || (console.warn(`Invalid status '${e.status}' passed to Toast. Defaulting to 'info'.`), e.status = "info"), Ne.includes(e.position) || (console.warn(`Invalid position '${e.position}' passed to Toast. Defaulting to 'right top'.`), e.position = "right top"), new Se(e);
}
const gt = {
  custom: P,
  success(i, e = "Success", t = {}) {
    P({
      status: "success",
      title: e,
      text: i,
      ...t
    });
  },
  error(i, e = "Error", t = {}) {
    P({
      status: "error",
      title: e,
      text: i,
      ...t
    });
  },
  warning(i, e = "Warning", t = {}) {
    P({
      status: "warning",
      title: e,
      text: i,
      ...t
    });
  },
  info(i, e = "Info", t = {}) {
    P({
      status: "info",
      title: e,
      text: i,
      ...t
    });
  },
  setDefaults(i = {}) {
    Object.assign(Oe, i);
  },
  get allowedStatuses() {
    return [...xe];
  },
  get allowedPositions() {
    return [...Ne];
  }
}, ne = function() {
}, B = {}, J = {}, W = {};
function mt(i, e) {
  i = Array.isArray(i) ? i : [i];
  const t = [];
  let n = i.length, r = n, s, a, d, c;
  for (s = function(u, p) {
    p.length && t.push(u), r--, r || e(t);
  }; n--; ) {
    if (a = i[n], d = J[a], d) {
      s(a, d);
      continue;
    }
    c = W[a] = W[a] || [], c.push(s);
  }
}
function ke(i, e) {
  if (!i) return;
  const t = W[i];
  if (J[i] = e, !!t)
    for (; t.length; )
      t[0](i, e), t.splice(0, 1);
}
function re(i, e) {
  typeof i == "function" && (i = { success: i }), e.length ? (i.error || ne)(e) : (i.success || ne)(i);
}
function wt(i, e, t, n, r, s, a, d) {
  let c = i.type[0];
  if (d)
    try {
      t.sheet.cssText.length || (c = "e");
    } catch (u) {
      u.code !== 18 && (c = "e");
    }
  if (c === "e") {
    if (s += 1, s < a)
      return Le(e, n, r, s);
  } else if (t.rel === "preload" && t.as === "style") {
    t.rel = "stylesheet";
    return;
  }
  n(e, c, i.defaultPrevented);
}
function Le(i, e, t, n) {
  const r = document, s = t.async, a = (t.numRetries || 0) + 1, d = t.before || ne, c = i.replace(/[\?|#].*$/, ""), u = i.replace(/^(css|img|module|nomodule)!/, "");
  let p, h, f;
  if (n = n || 0, /(^css!|\.css$)/.test(c))
    f = r.createElement("link"), f.rel = "stylesheet", f.href = u, p = "hideFocus" in f, p && f.relList && (p = 0, f.rel = "preload", f.as = "style"), t.inlineStyleNonce && f.setAttribute("nonce", t.inlineStyleNonce);
  else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(c))
    f = r.createElement("img"), f.src = u;
  else if (f = r.createElement("script"), f.src = u, f.async = s === void 0 ? !0 : s, t.inlineScriptNonce && f.setAttribute("nonce", t.inlineScriptNonce), h = "noModule" in f, /^module!/.test(c)) {
    if (!h) return e(i, "l");
    f.type = "module";
  } else if (/^nomodule!/.test(c) && h)
    return e(i, "l");
  const E = function(I) {
    wt(I, i, f, e, t, n, a, p);
  };
  f.addEventListener("load", E, { once: !0 }), f.addEventListener("error", E, { once: !0 }), d(i, f) !== !1 && r.head.appendChild(f);
}
function yt(i, e, t) {
  i = Array.isArray(i) ? i : [i];
  let n = i.length, r = [];
  function s(a, d, c) {
    if (d === "e" && r.push(a), d === "b")
      if (c) r.push(a);
      else return;
    n--, n || e(r);
  }
  for (let a = 0; a < i.length; a++)
    Le(i[a], s, t);
}
function k(i, e, t) {
  let n, r;
  if (e && typeof e == "string" && e.trim && (n = e.trim()), r = (n ? t : e) || {}, n) {
    if (n in B)
      throw "LoadJS";
    B[n] = !0;
  }
  function s(a, d) {
    yt(i, function(c) {
      re(r, c), a && re({ success: a, error: d }, c), ke(n, c);
    }, r);
  }
  if (r.returnPromise)
    return new Promise(s);
  s();
}
k.ready = function(e, t) {
  return mt(e, function(n) {
    re(t, n);
  }), k;
};
k.done = function(e) {
  ke(e, []);
};
k.reset = function() {
  Object.keys(B).forEach((e) => delete B[e]), Object.keys(J).forEach((e) => delete J[e]), Object.keys(W).forEach((e) => delete W[e]);
};
k.isDefined = function(e) {
  return e in B;
};
function Et(i) {
  i.data("rzAccordion", () => ({
    selected: "",
    // ID of the currently selected/opened section (if not allowMultiple)
    allowMultiple: !1,
    // Whether multiple sections can be open
    init() {
      this.allowMultiple = this.$el.dataset.multiple === "true";
    },
    destroy() {
    }
  }));
}
function It(i) {
  i.data("rzAccordionSection", () => ({
    open: !1,
    sectionId: "",
    expandedClass: "",
    init() {
      this.open = this.$el.dataset.isOpen === "true", this.sectionId = this.$el.dataset.sectionId, this.expandedClass = this.$el.dataset.expandedClass;
      const e = this;
      typeof this.selected < "u" && typeof this.allowMultiple < "u" ? this.$watch("selected", (t, n) => {
        t !== e.sectionId && !e.allowMultiple && (e.open = !1);
      }) : console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
    },
    destroy() {
    },
    // Toggle the section's open state and update the parent's 'selected' state.
    toggle() {
      this.selected = this.sectionId, this.open = !this.open;
    },
    // Get the CSS classes for the expanded/collapsed chevron icon.
    getExpandedCss() {
      return this.open ? this.expandedClass : "";
    },
    // Get the value for aria-expanded attribute based on the 'open' state.
    getAriaExpanded() {
      return this.open ? "true" : "false";
    }
  }));
}
function Tt(i) {
  i.data("rzAlert", () => ({
    showAlert: !0,
    dismiss() {
      this.showAlert = !1;
    }
  }));
}
function Ct(i) {
  i.data("rzBrowser", () => ({
    screenSize: "",
    setDesktopScreenSize() {
      this.screenSize = "";
    },
    setTabletScreenSize() {
      this.screenSize = "max-w-2xl";
    },
    setPhoneScreenSize() {
      this.screenSize = "max-w-sm";
    },
    // Get CSS classes for browser border based on screen size
    getBrowserBorderCss() {
      return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
    },
    // Get CSS classes for desktop screen button styling
    getDesktopScreenCss() {
      return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for tablet screen button styling
    getTabletScreenCss() {
      return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    },
    // Get CSS classes for phone screen button styling
    getPhoneScreenCss() {
      return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
    }
  }));
}
function St(i) {
  i.data("rzCheckboxGroupItem", () => ({
    checkbox: null,
    isChecked: !1,
    init() {
      this.checkbox = this.$refs.chk, this.isChecked = this.checkbox.checked;
    },
    toggleCheckbox() {
      this.isChecked = this.checkbox.checked;
    },
    getIconCss() {
      return this.isChecked ? "" : "hidden";
    }
  }));
}
function xt(i, e) {
  i.data("rzCodeViewer", () => ({
    expand: !1,
    border: !0,
    copied: !1,
    copyTitle: "Copy",
    // Default title
    copiedTitle: "Copied!",
    // Default title
    init() {
      const t = JSON.parse(this.$el.dataset.assets), n = this.$el.dataset.codeid, r = this.$el.dataset.nonce;
      this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle, this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle, e(t, {
        success: function() {
          const s = document.getElementById(n);
          window.hljs && s && window.hljs.highlightElement(s);
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, r);
    },
    // Function to check if code is NOT copied (for x-show)
    notCopied() {
      return !this.copied;
    },
    // Function to reset the copied state (e.g., on blur)
    disableCopied() {
      this.copied = !1;
    },
    // Function to toggle the expand state
    toggleExpand() {
      this.expand = !this.expand;
    },
    // Function to copy code to clipboard
    copyHTML() {
      navigator.clipboard.writeText(this.$refs.codeBlock.textContent), this.copied = !this.copied;
    },
    // Get the title for the copy button (copy/copied)
    getCopiedTitle() {
      return this.copied ? this.copiedTitle : this.copyTitle;
    },
    // Get CSS classes for the copy button based on copied state
    getCopiedCss() {
      return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
    },
    // Get CSS classes for the code container based on expand state
    getExpandCss() {
      return [this.expand ? "" : "max-h-60"];
    },
    // Get CSS classes for the expand button icon based on expand state
    getExpandButtonCss() {
      return this.expand ? "rotate-180" : "rotate-0";
    }
  }));
}
function Nt(i, e) {
  i.data("rzDateEdit", () => ({
    options: {},
    placeholder: "",
    prependText: "",
    init() {
      const t = this.$el.dataset.config, n = document.getElementById(this.$el.dataset.uid + "-input");
      if (t) {
        const a = JSON.parse(t);
        a && (this.options = a.options || {}, this.placeholder = a.placeholder || "", this.prependText = a.prependText || "");
      }
      const r = JSON.parse(this.$el.dataset.assets), s = this.$el.dataset.nonce;
      e(r, {
        success: function() {
          window.flatpickr && n && window.flatpickr(n, this.options);
        },
        error: function() {
          console.error("Failed to load Flatpickr assets.");
        }
      }, s);
    }
  }));
}
function Ot(i) {
  i.data("rzDropdown", () => ({
    dropdownEl: null,
    anchorCss: "",
    dropdownOpen: !1,
    openedWithKeyboard: !1,
    init() {
      this.dropdownEl = this.$el, this.anchorCss = this.getAnchorCss();
    },
    toggleDropdown() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !this.dropdownOpen;
    },
    openDropdown() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !0, this.openedWithKeyboard = !1;
    },
    openWithKeyboard() {
      this.anchorCss = this.getAnchorCss(), this.dropdownOpen = !0, this.openedWithKeyboard = !0, this.focusWrapNext();
    },
    closeDropdown() {
      this.dropdownOpen = !1, this.openedWithKeyboard = !1;
    },
    focusWrapNext() {
      this.$focus.wrap().next();
    },
    focusWrapPrevious() {
      this.$focus.wrap().previous();
    },
    // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
    getAnchorCss() {
      let t = (this.dropdownEl.getAttribute("data-anchor") || "").replace(/-/g, "").toLowerCase();
      const n = {
        topstart: "bottom-full right-0 mb-2 origin-bottom-right",
        topcenter: "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
        topend: "bottom-full left-0 mb-2 origin-bottom-left",
        start: "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
        end: "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
        bottomstart: "right-0 mt-2 origin-top-right",
        bottomcenter: "-translate-x-1/2 mt-2 origin-top",
        bottomend: "left-0 mt-2 origin-top-left"
      };
      let r = n[t] || "";
      const s = this.dropdownEl.getBoundingClientRect();
      let a = document.createElement("div");
      a.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;", this.dropdownEl.appendChild(a);
      const d = this.dropdownEl.querySelector('[role="menu"]');
      if (!d)
        return r;
      let c = d.cloneNode(!0);
      c.style.transition = "none", c.style.transform = "none", c.style.opacity = "1", c.style.display = "block", a.appendChild(c);
      let u = c.getBoundingClientRect();
      a.parentNode.removeChild(a);
      const p = 8;
      let h = !1;
      if (t.startsWith("top") ? s.top < u.height + p && (h = !0) : t.startsWith("bottom") ? s.bottom + u.height + p > window.innerHeight && (h = !0) : t === "start" ? s.left < u.width + p && (h = !0) : t === "end" && s.right + u.width + p > window.innerWidth && (h = !0), h) {
        let E = {
          topstart: "bottomstart",
          topcenter: "bottomcenter",
          topend: "bottomend",
          bottomstart: "topstart",
          bottomcenter: "topcenter",
          bottomend: "topend",
          start: "end",
          end: "start"
        }[t] || t;
        r = n[E] || r;
      }
      return r;
    }
  }));
}
function kt(i) {
  i.data("rzDarkModeToggle", () => ({
    mode: "light",
    applyTheme: null,
    init() {
      const e = typeof window < "u" && "localStorage" in window, t = ["light", "dark", "auto"], n = window.matchMedia("(prefers-color-scheme: dark)").matches;
      let r = "auto";
      e && (r = localStorage.getItem("darkMode") ?? "auto", t.includes(r) || (r = "light")), e && localStorage.setItem("darkMode", r), this.applyTheme = () => {
        document.documentElement.classList.toggle(
          "dark",
          r === "dark" || r === "auto" && n
        );
      }, this.applyTheme(), window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
    },
    // Returns true if dark mode should be active
    isDark() {
      const e = window.matchMedia("(prefers-color-scheme: dark)").matches;
      return localStorage.getItem("darkMode"), this.mode === "dark" || this.mode === "auto" && e;
    },
    // Returns true if light mode should be active
    isLight() {
      return !this.isDark();
    },
    // Toggle the dark mode setting and dispatch a custom event
    toggle() {
      let e = localStorage.getItem("darkMode");
      const t = window.matchMedia("(prefers-color-scheme: dark)").matches;
      e === "light" ? e = "dark" : e === "dark" ? e = "light" : e === "auto" && (e = t ? "light" : "dark"), this.mode = e, localStorage.setItem("darkMode", e);
      const n = e === "dark" || e === "auto" && t;
      document.documentElement.classList.toggle("dark", n);
      const r = new CustomEvent("darkModeToggle", {
        detail: { darkMode: n }
      });
      window.dispatchEvent(r);
    },
    destroy() {
      this.applyTheme && window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
    }
  }));
}
function Lt(i) {
  i.data("rzEmbeddedPreview", () => ({
    iframe: null,
    onDarkModeToggle: null,
    init() {
      try {
        this.iframe = this.$refs.iframe;
        const e = this.debounce(() => {
          this.resizeIframe(this.iframe);
        }, 50);
        this.resizeIframe(this.iframe), new ResizeObserver((r) => {
          for (let s of r)
            e();
        }).observe(this.iframe);
        const n = this.iframe;
        this.onDarkModeToggle = (r) => {
          n.contentWindow.postMessage(r.detail, "*");
        }, window.addEventListener("darkModeToggle", this.onDarkModeToggle);
      } catch {
        console.error("Cannot access iframe content");
      }
    },
    // Adjusts the iframe height based on its content
    resizeIframe(e) {
      if (e)
        try {
          const t = e.contentDocument || e.contentWindow?.document;
          if (t) {
            const n = t.body;
            if (!n)
              setInterval(() => {
                this.resizeIframe(e);
              }, 150);
            else {
              const r = n.scrollHeight + 15;
              e.style.height = r + "px";
            }
          }
        } catch (t) {
          console.error("Error resizing iframe:", t);
        }
    },
    // Debounce helper to limit function calls
    debounce(e, t = 300) {
      let n;
      return (...r) => {
        clearTimeout(n), n = setTimeout(() => {
          e.apply(this, r);
        }, t);
      };
    },
    destroy() {
      window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
    }
  }));
}
function Rt(i) {
  i.data("rzEmpty", () => {
  });
}
function Ft(i) {
  i.data("rzHeading", () => ({
    observer: null,
    headingId: "",
    init() {
      this.headingId = this.$el.dataset.alpineRoot;
      const e = this;
      if (typeof this.setCurrentHeading == "function") {
        const t = (r, s) => {
          r.forEach((a) => {
            a.isIntersecting && e.setCurrentHeading(e.headingId);
          });
        }, n = { threshold: 0.5 };
        this.observer = new IntersectionObserver(t, n), this.observer.observe(this.$el);
      } else
        console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
    },
    destroy() {
      this.observer != null && this.observer.disconnect();
    }
  }));
}
function $t(i, e) {
  i.data("rzMarkdown", () => ({
    init() {
      const t = JSON.parse(this.$el.dataset.assets), n = this.$el.dataset.nonce;
      e(t, {
        success: function() {
          window.hljs.highlightAll();
        },
        error: function() {
          console.error("Failed to load Highlight.js");
        }
      }, n);
    }
  }));
}
function Dt(i) {
  i.data("rzModal", () => ({
    modalOpen: !1,
    // Main state variable
    eventTriggerName: "",
    closeEventName: "rz:modal-close",
    // Default value, corresponds to Constants.Events.ModalClose
    closeOnEscape: !0,
    closeOnClickOutside: !0,
    modalId: "",
    bodyId: "",
    footerId: "",
    nonce: "",
    _escapeListener: null,
    _openListener: null,
    _closeEventListener: null,
    init() {
      this.modalId = this.$el.dataset.modalId || "", this.bodyId = this.$el.dataset.bodyId || "", this.footerId = this.$el.dataset.footerId || "", this.nonce = this.$el.dataset.nonce || "", this.eventTriggerName = this.$el.dataset.eventTriggerName || "", this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName, this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false", this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false", this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
        detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
        bubbles: !0
      })), this.eventTriggerName && (this._openListener = (e) => {
        this.openModal(e);
      }, window.addEventListener(this.eventTriggerName, this._openListener)), this._closeEventListener = (e) => {
        this.modalOpen && this.closeModalInternally("event");
      }, window.addEventListener(this.closeEventName, this._closeEventListener), this._escapeListener = (e) => {
        this.modalOpen && this.closeOnEscape && e.key === "Escape" && this.closeModalInternally("escape");
      }, window.addEventListener("keydown", this._escapeListener), this.$watch("modalOpen", (e) => {
        const t = document.body.offsetWidth;
        document.body.classList.toggle("overflow-hidden", e);
        const n = document.body.offsetWidth - t;
        document.body.style.setProperty("--page-scrollbar-width", `${n}px`), e ? this.$nextTick(() => {
          this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(), this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        }) : this.$nextTick(() => {
          this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
            detail: { modalId: this.modalId },
            bubbles: !0
          }));
        });
      });
    },
    notModalOpen() {
      return !this.modalOpen;
    },
    destroy() {
      this._openListener && this.eventTriggerName && window.removeEventListener(this.eventTriggerName, this._openListener), this._closeEventListener && window.removeEventListener(this.closeEventName, this._closeEventListener), this._escapeListener && window.removeEventListener("keydown", this._escapeListener), document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px");
    },
    openModal(e = null) {
      const t = new CustomEvent("rz:modal-before-open", {
        detail: { modalId: this.modalId, originalEvent: e },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(t), t.defaultPrevented || (this.modalOpen = !0);
    },
    // Internal close function called by button, escape, backdrop, event
    closeModalInternally(e = "unknown") {
      const t = new CustomEvent("rz:modal-before-close", {
        detail: { modalId: this.modalId, reason: e },
        bubbles: !0,
        cancelable: !0
      });
      this.$el.dispatchEvent(t), t.defaultPrevented || (document.activeElement?.blur && document.activeElement.blur(), this.modalOpen = !1, document.body.classList.remove("overflow-hidden"), document.body.style.setProperty("--page-scrollbar-width", "0px"));
    },
    // Called only by the explicit close button in the template
    closeModal() {
      this.closeModalInternally("button");
    },
    // Method called by x-on:click.outside on the dialog element
    handleClickOutside() {
      this.closeOnClickOutside && this.closeModalInternally("backdrop");
    }
  }));
}
function At(i) {
  i.data("rzPrependInput", () => ({
    prependContainer: null,
    textInput: null,
    init() {
      this.prependContainer = this.$refs.prependContainer, this.textInput = this.$refs.textInput;
      let e = this;
      setTimeout(() => {
        e.updatePadding();
      }, 50), window.addEventListener("resize", this.updatePadding);
    },
    destroy() {
      window.removeEventListener("resize", this.updatePadding);
    },
    updatePadding() {
      const e = this.prependContainer, t = this.textInput;
      if (!e || !t) {
        t && t.classList.remove("text-transparent");
        return;
      }
      const r = e.offsetWidth + 10;
      t.style.paddingLeft = r + "px", t.classList.remove("text-transparent");
    }
  }));
}
function zt(i) {
  i.data("rzProgress", () => ({
    currentVal: 0,
    minVal: 0,
    maxVal: 100,
    percentage: 0,
    label: "",
    init() {
      const e = this.$el;
      this.currentVal = parseInt(e.getAttribute("data-current-val")) || 0, this.minVal = parseInt(e.getAttribute("data-min-val")) || 0, this.maxVal = parseInt(e.getAttribute("data-max-val")) || 100, this.label = e.getAttribute("data-label"), this.calculatePercentage(), e.setAttribute("aria-valuenow", this.currentVal), e.setAttribute("aria-valuemin", this.minVal), e.setAttribute("aria-valuemax", this.maxVal), e.setAttribute("aria-valuetext", `${this.percentage}%`), this.updateProgressBar(), new ResizeObserver((n) => {
        this.updateProgressBar();
      }).observe(e), this.$watch("currentVal", () => {
        this.calculatePercentage(), this.updateProgressBar(), e.setAttribute("aria-valuenow", this.currentVal), e.setAttribute("aria-valuetext", `${this.percentage}%`);
      });
    },
    calculatePercentage() {
      this.maxVal === this.minVal ? this.percentage = 0 : this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
    },
    buildLabel() {
      var e = this.label || "{percent}%";
      return this.calculatePercentage(), e.replace("{percent}", this.percentage);
    },
    buildInsideLabelPosition() {
      const e = this.$refs.progressBar, t = this.$refs.progressBarLabel, n = this.$refs.innerLabel;
      t && e && n && (n.innerText = this.buildLabel(), t.clientWidth > e.clientWidth ? t.style.left = e.clientWidth + 10 + "px" : t.style.left = e.clientWidth / 2 - t.clientWidth / 2 + "px");
    },
    getLabelCss() {
      const e = this.$refs.progressBarLabel, t = this.$refs.progressBar;
      return e && t && e.clientWidth > t.clientWidth ? "text-foreground dark:text-foreground" : "";
    },
    updateProgressBar() {
      const e = this.$refs.progressBar;
      e && (e.style.width = `${this.percentage}%`, this.buildInsideLabelPosition());
    },
    // Methods to set, increment, or decrement the progress value
    setProgress(e) {
      this.currentVal = e;
    },
    increment(e = 1) {
      this.currentVal = Math.min(this.currentVal + e, this.maxVal);
    },
    decrement(e = 1) {
      this.currentVal = Math.max(this.currentVal - e, this.minVal);
    }
  }));
}
function _t(i) {
  i.data("rzQuickReferenceContainer", () => ({
    headings: [],
    // Array of heading IDs
    currentHeadingId: "",
    // ID of the currently highlighted heading
    // Initializes the component with headings and the initial current heading from data attributes.
    init() {
      this.headings = JSON.parse(this.$el.dataset.headings || "[]"), this.currentHeadingId = this.$el.dataset.currentheadingid || "";
    },
    // Handles click events on quick reference links.
    handleHeadingClick() {
      const e = this.$el.dataset.headingid;
      window.requestAnimationFrame(() => {
        this.currentHeadingId = e;
      });
    },
    // Sets the current heading ID based on intersection observer events from rzHeading.
    setCurrentHeading(e) {
      this.headings.includes(e) && (this.currentHeadingId = e);
    },
    // Provides CSS classes for a link based on whether it's the current heading.
    // Returns an object suitable for :class binding.
    getSelectedCss() {
      const e = this.$el.dataset.headingid;
      return {
        "font-bold": this.currentHeadingId === e
        // Apply 'font-bold' if current
      };
    },
    // Determines the value for the aria-current attribute.
    getSelectedAriaCurrent() {
      const e = this.$el.dataset.headingid;
      return this.currentHeadingId === e ? "true" : null;
    }
  }));
}
function Mt(i) {
  i.data("rzTabs", () => ({
    buttonRef: null,
    tabSelected: "",
    tabButton: null,
    init() {
      this.buttonRef = document.getElementById(this.$el.dataset.buttonref), this.tabSelected = this.$el.dataset.tabselected, this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']"), this.tabRepositionMarker(this.tabButton);
    },
    tabButtonClicked(e) {
      e instanceof Event && (e = e.target), this.tabSelected = e.dataset.name, this.tabRepositionMarker(e), e.focus();
    },
    tabRepositionMarker(e) {
      this.tabButton = e, this.$refs.tabMarker.style.width = e.offsetWidth + "px", this.$refs.tabMarker.style.height = e.offsetHeight + "px", this.$refs.tabMarker.style.left = e.offsetLeft + "px", setTimeout(() => {
        this.$refs.tabMarker.style.opacity = 1;
      }, 150);
    },
    // Get the CSS classes for the tab content panel based on selection
    getTabContentCss() {
      return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
    },
    tabContentActive(e) {
      return e = e ?? this.$el, this.tabSelected === e.dataset.name;
    },
    tabButtonActive(e) {
      return e = e ?? this.$el, this.tabSelected === e.dataset.name;
    },
    // Get the value for the aria-selected attribute
    getTabButtonAriaSelected() {
      return this.tabSelected === this.$el.dataset.name ? "true" : "false";
    },
    // Get the CSS classes for the tab button text color based on selection
    getSelectedTabTextColorCss() {
      const e = this.$el.dataset.selectedtextcolor ?? "";
      return this.tabSelected === this.$el.dataset.name ? e : "";
    },
    handleResize() {
      this.tabRepositionMarker(this.tabButton);
    },
    handleKeyDown(e) {
      const t = e.key, n = Array.from(this.buttonRef.querySelectorAll("[role='tab']")), r = n.findIndex((a) => this.tabSelected === a.dataset.name);
      let s = r;
      t === "ArrowRight" ? (s = (r + 1) % n.length, e.preventDefault()) : t === "ArrowLeft" ? (s = (r - 1 + n.length) % n.length, e.preventDefault()) : t === "Home" ? (s = 0, e.preventDefault()) : t === "End" && (s = n.length - 1, e.preventDefault()), s !== r && this.tabButtonClicked(n[s]);
    }
  }));
}
function Pt(i) {
  i.data("rzSidebar", () => ({
    showSidebar: !1,
    isSidebarHidden() {
      return !this.showSidebar;
    },
    toggleSidebar() {
      this.showSidebar = !this.showSidebar;
    },
    hideSidebar() {
      this.showSidebar = !1;
    },
    // Return translation classes based on sidebar state for smooth slide-in/out
    getSidebarTranslation() {
      return this.showSidebar ? "translate-x-0" : "-translate-x-60";
    }
  }));
}
function Bt(i) {
  i.data("rzSidebarLinkItem", () => ({
    isExpanded: !1,
    chevronExpandedClass: "",
    chevronCollapsedClass: "",
    init() {
      this.isExpanded = this.$el.dataset.expanded === "true", this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass, this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
    },
    isCollapsed() {
      return !this.isExpanded;
    },
    toggleExpanded() {
      this.isExpanded = !this.isExpanded;
    },
    hideSidebar() {
      const e = this.$el.closest('[x-data^="rzSidebar"]');
      if (e) {
        let t = i.$data(e);
        t.showSidebar = !1;
      } else
        console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
    },
    getExpandedClass() {
      return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
    },
    // Get the value for the aria-expanded attribute
    getAriaExpanded() {
      return this.isExpanded ? "true" : "false";
    }
  }));
}
async function Wt(i) {
  i = [...i].sort();
  const e = i.join("|"), n = new TextEncoder().encode(e), r = await crypto.subtle.digest("SHA-256", n);
  return Array.from(new Uint8Array(r)).map((a) => a.toString(16).padStart(2, "0")).join("");
}
function q(i, e, t) {
  Wt(i).then((n) => {
    k.isDefined(n) || k(
      i,
      n,
      {
        async: !1,
        inlineScriptNonce: t,
        inlineStyleNonce: t
      }
    ), k.ready([n], e);
  });
}
function Yt(i) {
  Et(i), It(i), Tt(i), Ct(i), St(i), xt(i, q), Nt(i, q), Ot(i), kt(i), Lt(i), Rt(i), Ft(i), $t(i, q), Dt(i), At(i), zt(i), _t(i), Mt(i), Pt(i), Bt(i);
}
function Ht(i) {
  if (typeof Alpine > "u" || typeof Alpine.$data != "function") {
    console.error(
      "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
    );
    return;
  }
  let e = null, t = null;
  if (typeof i == "string") {
    if (!i) {
      console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
      return;
    }
    if (t = i, e = document.getElementById(t), !e) {
      console.warn(`Rizzy.$data: Rizzy component with ID "${t}" not found in the DOM.`);
      return;
    }
  } else if (i instanceof Element) {
    if (e = i, !e.id) {
      console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
      return;
    }
    t = e.id;
  } else {
    console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
    return;
  }
  const n = `[data-alpine-root="${t}"]`;
  let r = null;
  if (e.matches(n) ? r = e : r = e.querySelector(n), !r) {
    console.warn(
      `Rizzy.$data: Could not locate the designated Alpine root element using selector "${n}" on or inside the wrapper element (ID: #${t}). Verify the 'data-alpine-root' attribute placement.`
    );
    return;
  }
  const s = Alpine.$data(r);
  if (s === void 0) {
    const a = `${r.tagName.toLowerCase()}${r.id ? "#" + r.id : ""}${r.classList.length ? "." + Array.from(r.classList).join(".") : ""}`;
    console.warn(
      `Rizzy.$data: Located designated Alpine root (${a}) via 'data-alpine-root="${t}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
    );
  }
  return s;
}
F.plugin(Fe);
F.plugin(_e);
F.plugin(rt);
Yt(F);
const Vt = {
  Alpine: F,
  require: q,
  toast: gt,
  $data: Ht
};
window.Alpine = F;
window.Rizzy = { ...window.Rizzy || {}, ...Vt };
F.start();
export {
  Vt as default
};
</file>

<file path="wwwroot/js/rizzyui.min.umd.js">
(function(I,D){typeof exports=="object"&&typeof module<"u"?module.exports=D(require("alpinejs")):typeof define=="function"&&define.amd?define(["alpinejs"],D):(I=typeof globalThis<"u"?globalThis:I||self,I.RizzyUI=D(I.Alpine))})(this,function(I){"use strict";function D(i){i.directive("collapse",e),e.inline=(t,{modifiers:n})=>{n.includes("min")&&(t._x_doShow=()=>{},t._x_doHide=()=>{})};function e(t,{modifiers:n}){let r=ae(n,"duration",250)/1e3,s=ae(n,"min",0),a=!n.includes("min");t._x_isShown||(t.style.height=`${s}px`),!t._x_isShown&&a&&(t.hidden=!0),t._x_isShown||(t.style.overflow="hidden");let d=(u,p)=>{let h=i.setStyles(u,p);return p.height?()=>{}:h},c={transitionProperty:"height",transitionDuration:`${r}s`,transitionTimingFunction:"cubic-bezier(0.4, 0.0, 0.2, 1)"};t._x_transition={in(u=()=>{},p=()=>{}){a&&(t.hidden=!1),a&&(t.style.display=null);let h=t.getBoundingClientRect().height;t.style.height="auto";let f=t.getBoundingClientRect().height;h===f&&(h=s),i.transition(t,i.setStyles,{during:c,start:{height:h+"px"},end:{height:f+"px"}},()=>t._x_isShown=!0,()=>{Math.abs(t.getBoundingClientRect().height-f)<1&&(t.style.overflow=null)})},out(u=()=>{},p=()=>{}){let h=t.getBoundingClientRect().height;i.transition(t,d,{during:c,start:{height:h+"px"},end:{height:s+"px"}},()=>t.style.overflow="hidden",()=>{t._x_isShown=!1,t.style.height==`${s}px`&&a&&(t.style.display="none",t.hidden=!0)})}}}}function ae(i,e,t){if(i.indexOf(e)===-1)return t;const n=i[i.indexOf(e)+1];if(!n)return t;if(e==="duration"){let r=n.match(/([0-9]+)ms/);if(r)return r[1]}if(e==="min"){let r=n.match(/([0-9]+)px/);if(r)return r[1]}return n}var De=D;function $e(i){i.directive("intersect",i.skipDuringClone((e,{value:t,expression:n,modifiers:r},{evaluateLater:s,cleanup:a})=>{let d=s(n),c={rootMargin:_e(r),threshold:ze(r)},u=new IntersectionObserver(p=>{p.forEach(h=>{h.isIntersecting!==(t==="leave")&&(d(),r.includes("once")&&u.disconnect())})},c);u.observe(e),a(()=>{u.disconnect()})}))}function ze(i){if(i.includes("full"))return .99;if(i.includes("half"))return .5;if(!i.includes("threshold"))return 0;let e=i[i.indexOf("threshold")+1];return e==="100"?1:e==="0"?0:+`.${e}`}function Ae(i){let e=i.match(/^(-?[0-9]+)(px|%)?$/);return e?e[1]+(e[2]||"px"):void 0}function _e(i){const e="margin",t="0px 0px 0px 0px",n=i.indexOf(e);if(n===-1)return t;let r=[];for(let s=1;s<5;s++)r.push(Ae(i[n+s]||""));return r=r.filter(s=>s!==void 0),r.length?r.join(" ").trim():t}var Me=$e,oe=["input","select","textarea","a[href]","button","[tabindex]:not(slot)","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])',"details>summary:first-of-type","details"],H=oe.join(","),le=typeof Element>"u",R=le?function(){}:Element.prototype.matches||Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector,Q=!le&&Element.prototype.getRootNode?function(i){return i.getRootNode()}:function(i){return i.ownerDocument},ce=function(e,t,n){var r=Array.prototype.slice.apply(e.querySelectorAll(H));return t&&R.call(e,H)&&r.unshift(e),r=r.filter(n),r},de=function i(e,t,n){for(var r=[],s=Array.from(e);s.length;){var a=s.shift();if(a.tagName==="SLOT"){var d=a.assignedElements(),c=d.length?d:a.children,u=i(c,!0,n);n.flatten?r.push.apply(r,u):r.push({scope:a,candidates:u})}else{var p=R.call(a,H);p&&n.filter(a)&&(t||!e.includes(a))&&r.push(a);var h=a.shadowRoot||typeof n.getShadowRoot=="function"&&n.getShadowRoot(a),f=!n.shadowRootFilter||n.shadowRootFilter(a);if(h&&f){var E=i(h===!0?a.children:h.children,!0,n);n.flatten?r.push.apply(r,E):r.push({scope:a,candidates:E})}else s.unshift.apply(s,a.children)}}return r},ue=function(e,t){return e.tabIndex<0&&(t||/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName)||e.isContentEditable)&&isNaN(parseInt(e.getAttribute("tabindex"),10))?0:e.tabIndex},Pe=function(e,t){return e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex},he=function(e){return e.tagName==="INPUT"},Be=function(e){return he(e)&&e.type==="hidden"},We=function(e){var t=e.tagName==="DETAILS"&&Array.prototype.slice.apply(e.children).some(function(n){return n.tagName==="SUMMARY"});return t},Ye=function(e,t){for(var n=0;n<e.length;n++)if(e[n].checked&&e[n].form===t)return e[n]},He=function(e){if(!e.name)return!0;var t=e.form||Q(e),n=function(d){return t.querySelectorAll('input[type="radio"][name="'+d+'"]')},r;if(typeof window<"u"&&typeof window.CSS<"u"&&typeof window.CSS.escape=="function")r=n(window.CSS.escape(e.name));else try{r=n(e.name)}catch(a){return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",a.message),!1}var s=Ye(r,e.form);return!s||s===e},Ve=function(e){return he(e)&&e.type==="radio"},je=function(e){return Ve(e)&&!He(e)},fe=function(e){var t=e.getBoundingClientRect(),n=t.width,r=t.height;return n===0&&r===0},Ue=function(e,t){var n=t.displayCheck,r=t.getShadowRoot;if(getComputedStyle(e).visibility==="hidden")return!0;var s=R.call(e,"details>summary:first-of-type"),a=s?e.parentElement:e;if(R.call(a,"details:not([open]) *"))return!0;var d=Q(e).host,c=d?.ownerDocument.contains(d)||e.ownerDocument.contains(e);if(!n||n==="full"){if(typeof r=="function"){for(var u=e;e;){var p=e.parentElement,h=Q(e);if(p&&!p.shadowRoot&&r(p)===!0)return fe(e);e.assignedSlot?e=e.assignedSlot:!p&&h!==e.ownerDocument?e=h.host:e=p}e=u}if(c)return!e.getClientRects().length}else if(n==="non-zero-area")return fe(e);return!1},qe=function(e){if(/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))for(var t=e.parentElement;t;){if(t.tagName==="FIELDSET"&&t.disabled){for(var n=0;n<t.children.length;n++){var r=t.children.item(n);if(r.tagName==="LEGEND")return R.call(t,"fieldset[disabled] *")?!0:!r.contains(e)}return!0}t=t.parentElement}return!1},V=function(e,t){return!(t.disabled||Be(t)||Ue(t,e)||We(t)||qe(t))},ee=function(e,t){return!(je(t)||ue(t)<0||!V(e,t))},Ge=function(e){var t=parseInt(e.getAttribute("tabindex"),10);return!!(isNaN(t)||t>=0)},Ze=function i(e){var t=[],n=[];return e.forEach(function(r,s){var a=!!r.scope,d=a?r.scope:r,c=ue(d,a),u=a?i(r.candidates):d;c===0?a?t.push.apply(t,u):t.push(d):n.push({documentOrder:s,tabIndex:c,item:r,isScope:a,content:u})}),n.sort(Pe).reduce(function(r,s){return s.isScope?r.push.apply(r,s.content):r.push(s.content),r},[]).concat(t)},Ke=function(e,t){t=t||{};var n;return t.getShadowRoot?n=de([e],t.includeContainer,{filter:ee.bind(null,t),flatten:!1,getShadowRoot:t.getShadowRoot,shadowRootFilter:Ge}):n=ce(e,t.includeContainer,ee.bind(null,t)),Ze(n)},pe=function(e,t){t=t||{};var n;return t.getShadowRoot?n=de([e],t.includeContainer,{filter:V.bind(null,t),flatten:!0,getShadowRoot:t.getShadowRoot}):n=ce(e,t.includeContainer,V.bind(null,t)),n},j=function(e,t){if(t=t||{},!e)throw new Error("No node provided");return R.call(e,H)===!1?!1:ee(t,e)},Je=oe.concat("iframe").join(","),U=function(e,t){if(t=t||{},!e)throw new Error("No node provided");return R.call(e,Je)===!1?!1:V(t,e)};function ve(i,e){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(i);e&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(i,r).enumerable})),t.push.apply(t,n)}return t}function be(i){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?ve(Object(t),!0).forEach(function(n){Xe(i,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):ve(Object(t)).forEach(function(n){Object.defineProperty(i,n,Object.getOwnPropertyDescriptor(t,n))})}return i}function Xe(i,e,t){return e in i?Object.defineProperty(i,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):i[e]=t,i}var ge=function(){var i=[];return{activateTrap:function(t){if(i.length>0){var n=i[i.length-1];n!==t&&n.pause()}var r=i.indexOf(t);r===-1||i.splice(r,1),i.push(t)},deactivateTrap:function(t){var n=i.indexOf(t);n!==-1&&i.splice(n,1),i.length>0&&i[i.length-1].unpause()}}}(),Qe=function(e){return e.tagName&&e.tagName.toLowerCase()==="input"&&typeof e.select=="function"},et=function(e){return e.key==="Escape"||e.key==="Esc"||e.keyCode===27},tt=function(e){return e.key==="Tab"||e.keyCode===9},me=function(e){return setTimeout(e,0)},we=function(e,t){var n=-1;return e.every(function(r,s){return t(r)?(n=s,!1):!0}),n},$=function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return typeof e=="function"?e.apply(void 0,n):e},q=function(e){return e.target.shadowRoot&&typeof e.composedPath=="function"?e.composedPath()[0]:e.target},it=function(e,t){var n=t?.document||document,r=be({returnFocusOnDeactivate:!0,escapeDeactivates:!0,delayInitialFocus:!0},t),s={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:!1,paused:!1,delayInitialFocusTimer:void 0},a,d=function(o,l,v){return o&&o[l]!==void 0?o[l]:r[v||l]},c=function(o){return s.containerGroups.findIndex(function(l){var v=l.container,m=l.tabbableNodes;return v.contains(o)||m.find(function(w){return w===o})})},u=function(o){var l=r[o];if(typeof l=="function"){for(var v=arguments.length,m=new Array(v>1?v-1:0),w=1;w<v;w++)m[w-1]=arguments[w];l=l.apply(void 0,m)}if(l===!0&&(l=void 0),!l){if(l===void 0||l===!1)return l;throw new Error("`".concat(o,"` was specified but was not a node, or did not return a node"))}var y=l;if(typeof l=="string"&&(y=n.querySelector(l),!y))throw new Error("`".concat(o,"` as selector refers to no known node"));return y},p=function(){var o=u("initialFocus");if(o===!1)return!1;if(o===void 0)if(c(n.activeElement)>=0)o=n.activeElement;else{var l=s.tabbableGroups[0],v=l&&l.firstTabbableNode;o=v||u("fallbackFocus")}if(!o)throw new Error("Your focus-trap needs to have at least one focusable element");return o},h=function(){if(s.containerGroups=s.containers.map(function(o){var l=Ke(o,r.tabbableOptions),v=pe(o,r.tabbableOptions);return{container:o,tabbableNodes:l,focusableNodes:v,firstTabbableNode:l.length>0?l[0]:null,lastTabbableNode:l.length>0?l[l.length-1]:null,nextTabbableNode:function(w){var y=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,S=v.findIndex(function(x){return x===w});if(!(S<0))return y?v.slice(S+1).find(function(x){return j(x,r.tabbableOptions)}):v.slice(0,S).reverse().find(function(x){return j(x,r.tabbableOptions)})}}}),s.tabbableGroups=s.containerGroups.filter(function(o){return o.tabbableNodes.length>0}),s.tabbableGroups.length<=0&&!u("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")},f=function g(o){if(o!==!1&&o!==n.activeElement){if(!o||!o.focus){g(p());return}o.focus({preventScroll:!!r.preventScroll}),s.mostRecentlyFocusedNode=o,Qe(o)&&o.select()}},E=function(o){var l=u("setReturnFocus",o);return l||(l===!1?!1:o)},T=function(o){var l=q(o);if(!(c(l)>=0)){if($(r.clickOutsideDeactivates,o)){a.deactivate({returnFocus:r.returnFocusOnDeactivate&&!U(l,r.tabbableOptions)});return}$(r.allowOutsideClick,o)||o.preventDefault()}},L=function(o){var l=q(o),v=c(l)>=0;v||l instanceof Document?v&&(s.mostRecentlyFocusedNode=l):(o.stopImmediatePropagation(),f(s.mostRecentlyFocusedNode||p()))},C=function(o){var l=q(o);h();var v=null;if(s.tabbableGroups.length>0){var m=c(l),w=m>=0?s.containerGroups[m]:void 0;if(m<0)o.shiftKey?v=s.tabbableGroups[s.tabbableGroups.length-1].lastTabbableNode:v=s.tabbableGroups[0].firstTabbableNode;else if(o.shiftKey){var y=we(s.tabbableGroups,function(Y){var se=Y.firstTabbableNode;return l===se});if(y<0&&(w.container===l||U(l,r.tabbableOptions)&&!j(l,r.tabbableOptions)&&!w.nextTabbableNode(l,!1))&&(y=m),y>=0){var S=y===0?s.tabbableGroups.length-1:y-1,x=s.tabbableGroups[S];v=x.lastTabbableNode}}else{var F=we(s.tabbableGroups,function(Y){var se=Y.lastTabbableNode;return l===se});if(F<0&&(w.container===l||U(l,r.tabbableOptions)&&!j(l,r.tabbableOptions)&&!w.nextTabbableNode(l))&&(F=m),F>=0){var X=F===s.tabbableGroups.length-1?0:F+1,re=s.tabbableGroups[X];v=re.firstTabbableNode}}}else v=u("fallbackFocus");v&&(o.preventDefault(),f(v))},B=function(o){if(et(o)&&$(r.escapeDeactivates,o)!==!1){o.preventDefault(),a.deactivate();return}if(tt(o)){C(o);return}},K=function(o){var l=q(o);c(l)>=0||$(r.clickOutsideDeactivates,o)||$(r.allowOutsideClick,o)||(o.preventDefault(),o.stopImmediatePropagation())},W=function(){if(s.active)return ge.activateTrap(a),s.delayInitialFocusTimer=r.delayInitialFocus?me(function(){f(p())}):f(p()),n.addEventListener("focusin",L,!0),n.addEventListener("mousedown",T,{capture:!0,passive:!1}),n.addEventListener("touchstart",T,{capture:!0,passive:!1}),n.addEventListener("click",K,{capture:!0,passive:!1}),n.addEventListener("keydown",B,{capture:!0,passive:!1}),a},J=function(){if(s.active)return n.removeEventListener("focusin",L,!0),n.removeEventListener("mousedown",T,!0),n.removeEventListener("touchstart",T,!0),n.removeEventListener("click",K,!0),n.removeEventListener("keydown",B,!0),a};return a={get active(){return s.active},get paused(){return s.paused},activate:function(o){if(s.active)return this;var l=d(o,"onActivate"),v=d(o,"onPostActivate"),m=d(o,"checkCanFocusTrap");m||h(),s.active=!0,s.paused=!1,s.nodeFocusedBeforeActivation=n.activeElement,l&&l();var w=function(){m&&h(),W(),v&&v()};return m?(m(s.containers.concat()).then(w,w),this):(w(),this)},deactivate:function(o){if(!s.active)return this;var l=be({onDeactivate:r.onDeactivate,onPostDeactivate:r.onPostDeactivate,checkCanReturnFocus:r.checkCanReturnFocus},o);clearTimeout(s.delayInitialFocusTimer),s.delayInitialFocusTimer=void 0,J(),s.active=!1,s.paused=!1,ge.deactivateTrap(a);var v=d(l,"onDeactivate"),m=d(l,"onPostDeactivate"),w=d(l,"checkCanReturnFocus"),y=d(l,"returnFocus","returnFocusOnDeactivate");v&&v();var S=function(){me(function(){y&&f(E(s.nodeFocusedBeforeActivation)),m&&m()})};return y&&w?(w(E(s.nodeFocusedBeforeActivation)).then(S,S),this):(S(),this)},pause:function(){return s.paused||!s.active?this:(s.paused=!0,J(),this)},unpause:function(){return!s.paused||!s.active?this:(s.paused=!1,h(),W(),this)},updateContainerElements:function(o){var l=[].concat(o).filter(Boolean);return s.containers=l.map(function(v){return typeof v=="string"?n.querySelector(v):v}),s.active&&h(),this}},a.updateContainerElements(e),a};function nt(i){let e,t;window.addEventListener("focusin",()=>{e=t,t=document.activeElement}),i.magic("focus",n=>{let r=n;return{__noscroll:!1,__wrapAround:!1,within(s){return r=s,this},withoutScrolling(){return this.__noscroll=!0,this},noscroll(){return this.__noscroll=!0,this},withWrapAround(){return this.__wrapAround=!0,this},wrap(){return this.withWrapAround()},focusable(s){return U(s)},previouslyFocused(){return e},lastFocused(){return e},focused(){return t},focusables(){return Array.isArray(r)?r:pe(r,{displayCheck:"none"})},all(){return this.focusables()},isFirst(s){let a=this.all();return a[0]&&a[0].isSameNode(s)},isLast(s){let a=this.all();return a.length&&a.slice(-1)[0].isSameNode(s)},getFirst(){return this.all()[0]},getLast(){return this.all().slice(-1)[0]},getNext(){let s=this.all(),a=document.activeElement;if(s.indexOf(a)!==-1)return this.__wrapAround&&s.indexOf(a)===s.length-1?s[0]:s[s.indexOf(a)+1]},getPrevious(){let s=this.all(),a=document.activeElement;if(s.indexOf(a)!==-1)return this.__wrapAround&&s.indexOf(a)===0?s.slice(-1)[0]:s[s.indexOf(a)-1]},first(){this.focus(this.getFirst())},last(){this.focus(this.getLast())},next(){this.focus(this.getNext())},previous(){this.focus(this.getPrevious())},prev(){return this.previous()},focus(s){s&&setTimeout(()=>{s.hasAttribute("tabindex")||s.setAttribute("tabindex","0"),s.focus({preventScroll:this.__noscroll})})}}}),i.directive("trap",i.skipDuringClone((n,{expression:r,modifiers:s},{effect:a,evaluateLater:d,cleanup:c})=>{let u=d(r),p=!1,h={escapeDeactivates:!1,allowOutsideClick:!0,fallbackFocus:()=>n};if(s.includes("noautofocus"))h.initialFocus=!1;else{let C=n.querySelector("[autofocus]");C&&(h.initialFocus=C)}let f=it(n,h),E=()=>{},T=()=>{};const L=()=>{E(),E=()=>{},T(),T=()=>{},f.deactivate({returnFocus:!s.includes("noreturn")})};a(()=>u(C=>{p!==C&&(C&&!p&&(s.includes("noscroll")&&(T=rt()),s.includes("inert")&&(E=ye(n)),setTimeout(()=>{f.activate()},15)),!C&&p&&L(),p=!!C)})),c(L)},(n,{expression:r,modifiers:s},{evaluate:a})=>{s.includes("inert")&&a(r)&&ye(n)}))}function ye(i){let e=[];return Ee(i,t=>{let n=t.hasAttribute("aria-hidden");t.setAttribute("aria-hidden","true"),e.push(()=>n||t.removeAttribute("aria-hidden"))}),()=>{for(;e.length;)e.pop()()}}function Ee(i,e){i.isSameNode(document.body)||!i.parentNode||Array.from(i.parentNode.children).forEach(t=>{t.isSameNode(i)?Ee(i.parentNode,e):e(t)})}function rt(){let i=document.documentElement.style.overflow,e=document.documentElement.style.paddingRight,t=window.innerWidth-document.documentElement.clientWidth;return document.documentElement.style.overflow="hidden",document.documentElement.style.paddingRight=`${t}px`,()=>{document.documentElement.style.overflow=i,document.documentElement.style.paddingRight=e}}var st=nt;/*! Bundled license information:
  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)
  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  */function at(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")}function ot(i,e){for(var t=0;t<e.length;t++){var n=e[t];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(i,n.key,n)}}function lt(i,e,t){return e&&ot(i.prototype,e),i}var ct=Object.defineProperty,N=function(i,e){return ct(i,"name",{value:e,configurable:!0})},dt=`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r
</svg>\r
`,ut=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r
</svg>\r
`,ht=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,ft=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r
</svg>\r
`,pt=`<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r
  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r
</svg>\r
`,vt=N(function(i){return new DOMParser().parseFromString(i,"text/html").body.childNodes[0]},"stringToHTML"),z=N(function(i){var e=new DOMParser().parseFromString(i,"application/xml");return document.importNode(e.documentElement,!0).outerHTML},"getSvgNode"),b={CONTAINER:"sn-notifications-container",NOTIFY:"sn-notify",NOTIFY_CONTENT:"sn-notify-content",NOTIFY_ICON:"sn-notify-icon",NOTIFY_CLOSE:"sn-notify-close",NOTIFY_TITLE:"sn-notify-title",NOTIFY_TEXT:"sn-notify-text",IS_X_CENTER:"sn-is-x-center",IS_Y_CENTER:"sn-is-y-center",IS_CENTER:"sn-is-center",IS_LEFT:"sn-is-left",IS_RIGHT:"sn-is-right",IS_TOP:"sn-is-top",IS_BOTTOM:"sn-is-bottom",NOTIFY_OUTLINE:"sn-notify-outline",NOTIFY_FILLED:"sn-notify-filled",NOTIFY_ERROR:"sn-notify-error",NOTIFY_WARNING:"sn-notify-warning",NOTIFY_SUCCESS:"sn-notify-success",NOTIFY_INFO:"sn-notify-info",NOTIFY_FADE:"sn-notify-fade",NOTIFY_FADE_IN:"sn-notify-fade-in",NOTIFY_SLIDE:"sn-notify-slide",NOTIFY_SLIDE_IN:"sn-notify-slide-in",NOTIFY_AUTOCLOSE:"sn-notify-autoclose"},O={ERROR:"error",WARNING:"warning",SUCCESS:"success",INFO:"info"},Ie={OUTLINE:"outline",FILLED:"filled"},te={FADE:"fade",SLIDE:"slide"},A={CLOSE:z(dt),SUCCESS:z(ft),ERROR:z(ut),WARNING:z(pt),INFO:z(ht)},Te=N(function(i){i.wrapper.classList.add(b.NOTIFY_FADE),setTimeout(function(){i.wrapper.classList.add(b.NOTIFY_FADE_IN)},100)},"fadeIn"),Ce=N(function(i){i.wrapper.classList.remove(b.NOTIFY_FADE_IN),setTimeout(function(){i.wrapper.remove()},i.speed)},"fadeOut"),bt=N(function(i){i.wrapper.classList.add(b.NOTIFY_SLIDE),setTimeout(function(){i.wrapper.classList.add(b.NOTIFY_SLIDE_IN)},100)},"slideIn"),gt=N(function(i){i.wrapper.classList.remove(b.NOTIFY_SLIDE_IN),setTimeout(function(){i.wrapper.remove()},i.speed)},"slideOut"),Se=function(){function i(e){var t=this;at(this,i),this.notifyOut=N(function(Y){Y(t)},"notifyOut");var n=e.notificationsGap,r=n===void 0?20:n,s=e.notificationsPadding,a=s===void 0?20:s,d=e.status,c=d===void 0?"success":d,u=e.effect,p=u===void 0?te.FADE:u,h=e.type,f=h===void 0?"outline":h,E=e.title,T=e.text,L=e.showIcon,C=L===void 0?!0:L,B=e.customIcon,K=B===void 0?"":B,W=e.customClass,J=W===void 0?"":W,g=e.speed,o=g===void 0?500:g,l=e.showCloseButton,v=l===void 0?!0:l,m=e.autoclose,w=m===void 0?!0:m,y=e.autotimeout,S=y===void 0?3e3:y,x=e.position,F=x===void 0?"right top":x,X=e.customWrapper,re=X===void 0?"":X;if(this.customWrapper=re,this.status=c,this.title=E,this.text=T,this.showIcon=C,this.customIcon=K,this.customClass=J,this.speed=o,this.effect=p,this.showCloseButton=v,this.autoclose=w,this.autotimeout=S,this.notificationsGap=r,this.notificationsPadding=a,this.type=f,this.position=F,!this.checkRequirements()){console.error("You must specify 'title' or 'text' at least.");return}this.setContainer(),this.setWrapper(),this.setPosition(),this.showIcon&&this.setIcon(),this.showCloseButton&&this.setCloseButton(),this.setContent(),this.container.prepend(this.wrapper),this.setEffect(),this.notifyIn(this.selectedNotifyInEffect),this.autoclose&&this.autoClose(),this.setObserver()}return lt(i,[{key:"checkRequirements",value:function(){return!!(this.title||this.text)}},{key:"setContainer",value:function(){var t=document.querySelector(".".concat(b.CONTAINER));t?this.container=t:(this.container=document.createElement("div"),this.container.classList.add(b.CONTAINER),document.body.appendChild(this.container)),this.notificationsPadding&&this.container.style.setProperty("--sn-notifications-padding","".concat(this.notificationsPadding,"px")),this.notificationsGap&&this.container.style.setProperty("--sn-notifications-gap","".concat(this.notificationsGap,"px"))}},{key:"setPosition",value:function(){this.container.classList[this.position==="center"?"add":"remove"](b.IS_CENTER),this.container.classList[this.position.includes("left")?"add":"remove"](b.IS_LEFT),this.container.classList[this.position.includes("right")?"add":"remove"](b.IS_RIGHT),this.container.classList[this.position.includes("top")?"add":"remove"](b.IS_TOP),this.container.classList[this.position.includes("bottom")?"add":"remove"](b.IS_BOTTOM),this.container.classList[this.position.includes("x-center")?"add":"remove"](b.IS_X_CENTER),this.container.classList[this.position.includes("y-center")?"add":"remove"](b.IS_Y_CENTER)}},{key:"setCloseButton",value:function(){var t=this,n=document.createElement("div");n.classList.add(b.NOTIFY_CLOSE),n.innerHTML=A.CLOSE,this.wrapper.appendChild(n),n.addEventListener("click",function(){t.close()})}},{key:"setWrapper",value:function(){var t=this;switch(this.customWrapper?this.wrapper=vt(this.customWrapper):this.wrapper=document.createElement("div"),this.wrapper.style.setProperty("--sn-notify-transition-duration","".concat(this.speed,"ms")),this.wrapper.classList.add(b.NOTIFY),this.type){case Ie.OUTLINE:this.wrapper.classList.add(b.NOTIFY_OUTLINE);break;case Ie.FILLED:this.wrapper.classList.add(b.NOTIFY_FILLED);break;default:this.wrapper.classList.add(b.NOTIFY_OUTLINE)}switch(this.status){case O.SUCCESS:this.wrapper.classList.add(b.NOTIFY_SUCCESS);break;case O.ERROR:this.wrapper.classList.add(b.NOTIFY_ERROR);break;case O.WARNING:this.wrapper.classList.add(b.NOTIFY_WARNING);break;case O.INFO:this.wrapper.classList.add(b.NOTIFY_INFO);break}this.autoclose&&(this.wrapper.classList.add(b.NOTIFY_AUTOCLOSE),this.wrapper.style.setProperty("--sn-notify-autoclose-timeout","".concat(this.autotimeout+this.speed,"ms"))),this.customClass&&this.customClass.split(" ").forEach(function(n){t.wrapper.classList.add(n)})}},{key:"setContent",value:function(){var t=document.createElement("div");t.classList.add(b.NOTIFY_CONTENT);var n,r;this.title&&(n=document.createElement("div"),n.classList.add(b.NOTIFY_TITLE),n.textContent=this.title.trim(),this.showCloseButton||(n.style.paddingRight="0")),this.text&&(r=document.createElement("div"),r.classList.add(b.NOTIFY_TEXT),r.innerHTML=this.text.trim(),this.title||(r.style.marginTop="0")),this.wrapper.appendChild(t),this.title&&t.appendChild(n),this.text&&t.appendChild(r)}},{key:"setIcon",value:function(){var t=N(function(r){switch(r){case O.SUCCESS:return A.SUCCESS;case O.ERROR:return A.ERROR;case O.WARNING:return A.WARNING;case O.INFO:return A.INFO}},"computedIcon"),n=document.createElement("div");n.classList.add(b.NOTIFY_ICON),n.innerHTML=this.customIcon||t(this.status),(this.status||this.customIcon)&&this.wrapper.appendChild(n)}},{key:"setObserver",value:function(){var t=this,n=new IntersectionObserver(function(r){if(r[0].intersectionRatio<=0)t.close();else return},{threshold:0});setTimeout(function(){n.observe(t.wrapper)},this.speed)}},{key:"notifyIn",value:function(e){e(this)}},{key:"autoClose",value:function(){var t=this;setTimeout(function(){t.close()},this.autotimeout+this.speed)}},{key:"close",value:function(){this.notifyOut(this.selectedNotifyOutEffect)}},{key:"setEffect",value:function(){switch(this.effect){case te.FADE:this.selectedNotifyInEffect=Te,this.selectedNotifyOutEffect=Ce;break;case te.SLIDE:this.selectedNotifyInEffect=bt,this.selectedNotifyOutEffect=gt;break;default:this.selectedNotifyInEffect=Te,this.selectedNotifyOutEffect=Ce}}}]),i}();N(Se,"Notify");var xe=Se;globalThis.Notify=xe;const Ne=["success","error","warning","info"],Oe=["right top","top right","right bottom","bottom right","left top","top left","left bottom","bottom left","center top","x-center top","center bottom","x-center bottom","left center","left y-center","y-center left","right center","right y-center","y-center right","top center","top x-center","bottom center","bottom x-center","center"],ke={status:"info",title:"Notification",text:"",effect:"fade",speed:300,autoclose:!0,autotimeout:4e3,position:"right top"};function _(i={}){const e={...ke,...i};Ne.includes(e.status)||(console.warn(`Invalid status '${e.status}' passed to Toast. Defaulting to 'info'.`),e.status="info"),Oe.includes(e.position)||(console.warn(`Invalid position '${e.position}' passed to Toast. Defaulting to 'right top'.`),e.position="right top"),new xe(e)}const mt={custom:_,success(i,e="Success",t={}){_({status:"success",title:e,text:i,...t})},error(i,e="Error",t={}){_({status:"error",title:e,text:i,...t})},warning(i,e="Warning",t={}){_({status:"warning",title:e,text:i,...t})},info(i,e="Info",t={}){_({status:"info",title:e,text:i,...t})},setDefaults(i={}){Object.assign(ke,i)},get allowedStatuses(){return[...Ne]},get allowedPositions(){return[...Oe]}},ie=function(){},M={},G={},P={};function wt(i,e){i=Array.isArray(i)?i:[i];const t=[];let n=i.length,r=n,s,a,d,c;for(s=function(u,p){p.length&&t.push(u),r--,r||e(t)};n--;){if(a=i[n],d=G[a],d){s(a,d);continue}c=P[a]=P[a]||[],c.push(s)}}function Le(i,e){if(!i)return;const t=P[i];if(G[i]=e,!!t)for(;t.length;)t[0](i,e),t.splice(0,1)}function ne(i,e){typeof i=="function"&&(i={success:i}),e.length?(i.error||ie)(e):(i.success||ie)(i)}function yt(i,e,t,n,r,s,a,d){let c=i.type[0];if(d)try{t.sheet.cssText.length||(c="e")}catch(u){u.code!==18&&(c="e")}if(c==="e"){if(s+=1,s<a)return Re(e,n,r,s)}else if(t.rel==="preload"&&t.as==="style"){t.rel="stylesheet";return}n(e,c,i.defaultPrevented)}function Re(i,e,t,n){const r=document,s=t.async,a=(t.numRetries||0)+1,d=t.before||ie,c=i.replace(/[\?|#].*$/,""),u=i.replace(/^(css|img|module|nomodule)!/,"");let p,h,f;if(n=n||0,/(^css!|\.css$)/.test(c))f=r.createElement("link"),f.rel="stylesheet",f.href=u,p="hideFocus"in f,p&&f.relList&&(p=0,f.rel="preload",f.as="style"),t.inlineStyleNonce&&f.setAttribute("nonce",t.inlineStyleNonce);else if(/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(c))f=r.createElement("img"),f.src=u;else if(f=r.createElement("script"),f.src=u,f.async=s===void 0?!0:s,t.inlineScriptNonce&&f.setAttribute("nonce",t.inlineScriptNonce),h="noModule"in f,/^module!/.test(c)){if(!h)return e(i,"l");f.type="module"}else if(/^nomodule!/.test(c)&&h)return e(i,"l");const E=function(T){yt(T,i,f,e,t,n,a,p)};f.addEventListener("load",E,{once:!0}),f.addEventListener("error",E,{once:!0}),d(i,f)!==!1&&r.head.appendChild(f)}function Et(i,e,t){i=Array.isArray(i)?i:[i];let n=i.length,r=[];function s(a,d,c){if(d==="e"&&r.push(a),d==="b")if(c)r.push(a);else return;n--,n||e(r)}for(let a=0;a<i.length;a++)Re(i[a],s,t)}function k(i,e,t){let n,r;if(e&&typeof e=="string"&&e.trim&&(n=e.trim()),r=(n?t:e)||{},n){if(n in M)throw"LoadJS";M[n]=!0}function s(a,d){Et(i,function(c){ne(r,c),a&&ne({success:a,error:d},c),Le(n,c)},r)}if(r.returnPromise)return new Promise(s);s()}k.ready=function(e,t){return wt(e,function(n){ne(t,n)}),k},k.done=function(e){Le(e,[])},k.reset=function(){Object.keys(M).forEach(e=>delete M[e]),Object.keys(G).forEach(e=>delete G[e]),Object.keys(P).forEach(e=>delete P[e])},k.isDefined=function(e){return e in M};function It(i){i.data("rzAccordion",()=>({selected:"",allowMultiple:!1,init(){this.allowMultiple=this.$el.dataset.multiple==="true"},destroy(){}}))}function Tt(i){i.data("rzAccordionSection",()=>({open:!1,sectionId:"",expandedClass:"",init(){this.open=this.$el.dataset.isOpen==="true",this.sectionId=this.$el.dataset.sectionId,this.expandedClass=this.$el.dataset.expandedClass;const e=this;typeof this.selected<"u"&&typeof this.allowMultiple<"u"?this.$watch("selected",(t,n)=>{t!==e.sectionId&&!e.allowMultiple&&(e.open=!1)}):console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.")},destroy(){},toggle(){this.selected=this.sectionId,this.open=!this.open},getExpandedCss(){return this.open?this.expandedClass:""},getAriaExpanded(){return this.open?"true":"false"}}))}function Ct(i){i.data("rzAlert",()=>({showAlert:!0,dismiss(){this.showAlert=!1}}))}function St(i){i.data("rzBrowser",()=>({screenSize:"",setDesktopScreenSize(){this.screenSize=""},setTabletScreenSize(){this.screenSize="max-w-2xl"},setPhoneScreenSize(){this.screenSize="max-w-sm"},getBrowserBorderCss(){return[this.screenSize,this.screenSize===""?"border-none":"border-x"]},getDesktopScreenCss(){return[this.screenSize===""?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getTabletScreenCss(){return[this.screenSize==="max-w-2xl"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]},getPhoneScreenCss(){return[this.screenSize==="max-w-sm"?"text-foreground forced-color-adjust-auto dark:text-foreground":"opacity-60"]}}))}function xt(i){i.data("rzCheckboxGroupItem",()=>({checkbox:null,isChecked:!1,init(){this.checkbox=this.$refs.chk,this.isChecked=this.checkbox.checked},toggleCheckbox(){this.isChecked=this.checkbox.checked},getIconCss(){return this.isChecked?"":"hidden"}}))}function Nt(i,e){i.data("rzCodeViewer",()=>({expand:!1,border:!0,copied:!1,copyTitle:"Copy",copiedTitle:"Copied!",init(){const t=JSON.parse(this.$el.dataset.assets),n=this.$el.dataset.codeid,r=this.$el.dataset.nonce;this.copyTitle=this.$el.dataset.copyTitle||this.copyTitle,this.copiedTitle=this.$el.dataset.copiedTitle||this.copiedTitle,e(t,{success:function(){const s=document.getElementById(n);window.hljs&&s&&window.hljs.highlightElement(s)},error:function(){console.error("Failed to load Highlight.js")}},r)},notCopied(){return!this.copied},disableCopied(){this.copied=!1},toggleExpand(){this.expand=!this.expand},copyHTML(){navigator.clipboard.writeText(this.$refs.codeBlock.textContent),this.copied=!this.copied},getCopiedTitle(){return this.copied?this.copiedTitle:this.copyTitle},getCopiedCss(){return[this.copied?"focus-visible:outline-success":"focus-visible:outline-foreground"]},getExpandCss(){return[this.expand?"":"max-h-60"]},getExpandButtonCss(){return this.expand?"rotate-180":"rotate-0"}}))}function Ot(i,e){i.data("rzDateEdit",()=>({options:{},placeholder:"",prependText:"",init(){const t=this.$el.dataset.config,n=document.getElementById(this.$el.dataset.uid+"-input");if(t){const a=JSON.parse(t);a&&(this.options=a.options||{},this.placeholder=a.placeholder||"",this.prependText=a.prependText||"")}const r=JSON.parse(this.$el.dataset.assets),s=this.$el.dataset.nonce;e(r,{success:function(){window.flatpickr&&n&&window.flatpickr(n,this.options)},error:function(){console.error("Failed to load Flatpickr assets.")}},s)}}))}function kt(i){i.data("rzDropdown",()=>({dropdownEl:null,anchorCss:"",dropdownOpen:!1,openedWithKeyboard:!1,init(){this.dropdownEl=this.$el,this.anchorCss=this.getAnchorCss()},toggleDropdown(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!this.dropdownOpen},openDropdown(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!0,this.openedWithKeyboard=!1},openWithKeyboard(){this.anchorCss=this.getAnchorCss(),this.dropdownOpen=!0,this.openedWithKeyboard=!0,this.focusWrapNext()},closeDropdown(){this.dropdownOpen=!1,this.openedWithKeyboard=!1},focusWrapNext(){this.$focus.wrap().next()},focusWrapPrevious(){this.$focus.wrap().previous()},getAnchorCss(){let t=(this.dropdownEl.getAttribute("data-anchor")||"").replace(/-/g,"").toLowerCase();const n={topstart:"bottom-full right-0 mb-2 origin-bottom-right",topcenter:"left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",topend:"bottom-full left-0 mb-2 origin-bottom-left",start:"right-full top-1/2 -translate-y-1/2 me-2 origin-right",end:"left-full top-1/2 -translate-y-1/2 ms-2 origin-left",bottomstart:"right-0 mt-2 origin-top-right",bottomcenter:"-translate-x-1/2 mt-2 origin-top",bottomend:"left-0 mt-2 origin-top-left"};let r=n[t]||"";const s=this.dropdownEl.getBoundingClientRect();let a=document.createElement("div");a.style.cssText="position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;",this.dropdownEl.appendChild(a);const d=this.dropdownEl.querySelector('[role="menu"]');if(!d)return r;let c=d.cloneNode(!0);c.style.transition="none",c.style.transform="none",c.style.opacity="1",c.style.display="block",a.appendChild(c);let u=c.getBoundingClientRect();a.parentNode.removeChild(a);const p=8;let h=!1;if(t.startsWith("top")?s.top<u.height+p&&(h=!0):t.startsWith("bottom")?s.bottom+u.height+p>window.innerHeight&&(h=!0):t==="start"?s.left<u.width+p&&(h=!0):t==="end"&&s.right+u.width+p>window.innerWidth&&(h=!0),h){let E={topstart:"bottomstart",topcenter:"bottomcenter",topend:"bottomend",bottomstart:"topstart",bottomcenter:"topcenter",bottomend:"topend",start:"end",end:"start"}[t]||t;r=n[E]||r}return r}}))}function Lt(i){i.data("rzDarkModeToggle",()=>({mode:"light",applyTheme:null,init(){const e=typeof window<"u"&&"localStorage"in window,t=["light","dark","auto"],n=window.matchMedia("(prefers-color-scheme: dark)").matches;let r="auto";e&&(r=localStorage.getItem("darkMode")??"auto",t.includes(r)||(r="light")),e&&localStorage.setItem("darkMode",r),this.applyTheme=()=>{document.documentElement.classList.toggle("dark",r==="dark"||r==="auto"&&n)},this.applyTheme(),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",this.applyTheme)},isDark(){const e=window.matchMedia("(prefers-color-scheme: dark)").matches;return localStorage.getItem("darkMode"),this.mode==="dark"||this.mode==="auto"&&e},isLight(){return!this.isDark()},toggle(){let e=localStorage.getItem("darkMode");const t=window.matchMedia("(prefers-color-scheme: dark)").matches;e==="light"?e="dark":e==="dark"?e="light":e==="auto"&&(e=t?"light":"dark"),this.mode=e,localStorage.setItem("darkMode",e);const n=e==="dark"||e==="auto"&&t;document.documentElement.classList.toggle("dark",n);const r=new CustomEvent("darkModeToggle",{detail:{darkMode:n}});window.dispatchEvent(r)},destroy(){this.applyTheme&&window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change",this.applyTheme)}}))}function Rt(i){i.data("rzEmbeddedPreview",()=>({iframe:null,onDarkModeToggle:null,init(){try{this.iframe=this.$refs.iframe;const e=this.debounce(()=>{this.resizeIframe(this.iframe)},50);this.resizeIframe(this.iframe),new ResizeObserver(r=>{for(let s of r)e()}).observe(this.iframe);const n=this.iframe;this.onDarkModeToggle=r=>{n.contentWindow.postMessage(r.detail,"*")},window.addEventListener("darkModeToggle",this.onDarkModeToggle)}catch{console.error("Cannot access iframe content")}},resizeIframe(e){if(e)try{const t=e.contentDocument||e.contentWindow?.document;if(t){const n=t.body;if(!n)setInterval(()=>{this.resizeIframe(e)},150);else{const r=n.scrollHeight+15;e.style.height=r+"px"}}}catch(t){console.error("Error resizing iframe:",t)}},debounce(e,t=300){let n;return(...r)=>{clearTimeout(n),n=setTimeout(()=>{e.apply(this,r)},t)}},destroy(){window.removeEventListener("darkModeToggle",this.onDarkModeToggle)}}))}function Ft(i){i.data("rzEmpty",()=>{})}function Dt(i){i.data("rzHeading",()=>({observer:null,headingId:"",init(){this.headingId=this.$el.dataset.alpineRoot;const e=this;if(typeof this.setCurrentHeading=="function"){const t=(r,s)=>{r.forEach(a=>{a.isIntersecting&&e.setCurrentHeading(e.headingId)})},n={threshold:.5};this.observer=new IntersectionObserver(t,n),this.observer.observe(this.$el)}else console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.")},destroy(){this.observer!=null&&this.observer.disconnect()}}))}function $t(i,e){i.data("rzMarkdown",()=>({init(){const t=JSON.parse(this.$el.dataset.assets),n=this.$el.dataset.nonce;e(t,{success:function(){window.hljs.highlightAll()},error:function(){console.error("Failed to load Highlight.js")}},n)}}))}function zt(i){i.data("rzModal",()=>({modalOpen:!1,eventTriggerName:"",closeEventName:"rz:modal-close",closeOnEscape:!0,closeOnClickOutside:!0,modalId:"",bodyId:"",footerId:"",nonce:"",_escapeListener:null,_openListener:null,_closeEventListener:null,init(){this.modalId=this.$el.dataset.modalId||"",this.bodyId=this.$el.dataset.bodyId||"",this.footerId=this.$el.dataset.footerId||"",this.nonce=this.$el.dataset.nonce||"",this.eventTriggerName=this.$el.dataset.eventTriggerName||"",this.closeEventName=this.$el.dataset.closeEventName||this.closeEventName,this.closeOnEscape=this.$el.dataset.closeOnEscape!=="false",this.closeOnClickOutside=this.$el.dataset.closeOnClickOutside!=="false",this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized",{detail:{modalId:this.modalId,bodyId:this.bodyId,footerId:this.footerId},bubbles:!0})),this.eventTriggerName&&(this._openListener=e=>{this.openModal(e)},window.addEventListener(this.eventTriggerName,this._openListener)),this._closeEventListener=e=>{this.modalOpen&&this.closeModalInternally("event")},window.addEventListener(this.closeEventName,this._closeEventListener),this._escapeListener=e=>{this.modalOpen&&this.closeOnEscape&&e.key==="Escape"&&this.closeModalInternally("escape")},window.addEventListener("keydown",this._escapeListener),this.$watch("modalOpen",e=>{const t=document.body.offsetWidth;document.body.classList.toggle("overflow-hidden",e);const n=document.body.offsetWidth-t;document.body.style.setProperty("--page-scrollbar-width",`${n}px`),e?this.$nextTick(()=>{this.$el.querySelector('[role="document"]')?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`)?.focus(),this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open",{detail:{modalId:this.modalId},bubbles:!0}))}):this.$nextTick(()=>{this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close",{detail:{modalId:this.modalId},bubbles:!0}))})})},notModalOpen(){return!this.modalOpen},destroy(){this._openListener&&this.eventTriggerName&&window.removeEventListener(this.eventTriggerName,this._openListener),this._closeEventListener&&window.removeEventListener(this.closeEventName,this._closeEventListener),this._escapeListener&&window.removeEventListener("keydown",this._escapeListener),document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px")},openModal(e=null){const t=new CustomEvent("rz:modal-before-open",{detail:{modalId:this.modalId,originalEvent:e},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(t),t.defaultPrevented||(this.modalOpen=!0)},closeModalInternally(e="unknown"){const t=new CustomEvent("rz:modal-before-close",{detail:{modalId:this.modalId,reason:e},bubbles:!0,cancelable:!0});this.$el.dispatchEvent(t),t.defaultPrevented||(document.activeElement?.blur&&document.activeElement.blur(),this.modalOpen=!1,document.body.classList.remove("overflow-hidden"),document.body.style.setProperty("--page-scrollbar-width","0px"))},closeModal(){this.closeModalInternally("button")},handleClickOutside(){this.closeOnClickOutside&&this.closeModalInternally("backdrop")}}))}function At(i){i.data("rzPrependInput",()=>({prependContainer:null,textInput:null,init(){this.prependContainer=this.$refs.prependContainer,this.textInput=this.$refs.textInput;let e=this;setTimeout(()=>{e.updatePadding()},50),window.addEventListener("resize",this.updatePadding)},destroy(){window.removeEventListener("resize",this.updatePadding)},updatePadding(){const e=this.prependContainer,t=this.textInput;if(!e||!t){t&&t.classList.remove("text-transparent");return}const r=e.offsetWidth+10;t.style.paddingLeft=r+"px",t.classList.remove("text-transparent")}}))}function _t(i){i.data("rzProgress",()=>({currentVal:0,minVal:0,maxVal:100,percentage:0,label:"",init(){const e=this.$el;this.currentVal=parseInt(e.getAttribute("data-current-val"))||0,this.minVal=parseInt(e.getAttribute("data-min-val"))||0,this.maxVal=parseInt(e.getAttribute("data-max-val"))||100,this.label=e.getAttribute("data-label"),this.calculatePercentage(),e.setAttribute("aria-valuenow",this.currentVal),e.setAttribute("aria-valuemin",this.minVal),e.setAttribute("aria-valuemax",this.maxVal),e.setAttribute("aria-valuetext",`${this.percentage}%`),this.updateProgressBar(),new ResizeObserver(n=>{this.updateProgressBar()}).observe(e),this.$watch("currentVal",()=>{this.calculatePercentage(),this.updateProgressBar(),e.setAttribute("aria-valuenow",this.currentVal),e.setAttribute("aria-valuetext",`${this.percentage}%`)})},calculatePercentage(){this.maxVal===this.minVal?this.percentage=0:this.percentage=Math.min(Math.max((this.currentVal-this.minVal)/(this.maxVal-this.minVal)*100,0),100)},buildLabel(){var e=this.label||"{percent}%";return this.calculatePercentage(),e.replace("{percent}",this.percentage)},buildInsideLabelPosition(){const e=this.$refs.progressBar,t=this.$refs.progressBarLabel,n=this.$refs.innerLabel;t&&e&&n&&(n.innerText=this.buildLabel(),t.clientWidth>e.clientWidth?t.style.left=e.clientWidth+10+"px":t.style.left=e.clientWidth/2-t.clientWidth/2+"px")},getLabelCss(){const e=this.$refs.progressBarLabel,t=this.$refs.progressBar;return e&&t&&e.clientWidth>t.clientWidth?"text-foreground dark:text-foreground":""},updateProgressBar(){const e=this.$refs.progressBar;e&&(e.style.width=`${this.percentage}%`,this.buildInsideLabelPosition())},setProgress(e){this.currentVal=e},increment(e=1){this.currentVal=Math.min(this.currentVal+e,this.maxVal)},decrement(e=1){this.currentVal=Math.max(this.currentVal-e,this.minVal)}}))}function Mt(i){i.data("rzQuickReferenceContainer",()=>({headings:[],currentHeadingId:"",init(){this.headings=JSON.parse(this.$el.dataset.headings||"[]"),this.currentHeadingId=this.$el.dataset.currentheadingid||""},handleHeadingClick(){const e=this.$el.dataset.headingid;window.requestAnimationFrame(()=>{this.currentHeadingId=e})},setCurrentHeading(e){this.headings.includes(e)&&(this.currentHeadingId=e)},getSelectedCss(){const e=this.$el.dataset.headingid;return{"font-bold":this.currentHeadingId===e}},getSelectedAriaCurrent(){const e=this.$el.dataset.headingid;return this.currentHeadingId===e?"true":null}}))}function Pt(i){i.data("rzTabs",()=>({buttonRef:null,tabSelected:"",tabButton:null,init(){this.buttonRef=document.getElementById(this.$el.dataset.buttonref),this.tabSelected=this.$el.dataset.tabselected,this.tabButton=this.buttonRef.querySelector("[data-name='"+this.tabSelected+"']"),this.tabRepositionMarker(this.tabButton)},tabButtonClicked(e){e instanceof Event&&(e=e.target),this.tabSelected=e.dataset.name,this.tabRepositionMarker(e),e.focus()},tabRepositionMarker(e){this.tabButton=e,this.$refs.tabMarker.style.width=e.offsetWidth+"px",this.$refs.tabMarker.style.height=e.offsetHeight+"px",this.$refs.tabMarker.style.left=e.offsetLeft+"px",setTimeout(()=>{this.$refs.tabMarker.style.opacity=1},150)},getTabContentCss(){return this.tabSelected===this.$el.dataset.name?"":"hidden"},tabContentActive(e){return e=e??this.$el,this.tabSelected===e.dataset.name},tabButtonActive(e){return e=e??this.$el,this.tabSelected===e.dataset.name},getTabButtonAriaSelected(){return this.tabSelected===this.$el.dataset.name?"true":"false"},getSelectedTabTextColorCss(){const e=this.$el.dataset.selectedtextcolor??"";return this.tabSelected===this.$el.dataset.name?e:""},handleResize(){this.tabRepositionMarker(this.tabButton)},handleKeyDown(e){const t=e.key,n=Array.from(this.buttonRef.querySelectorAll("[role='tab']")),r=n.findIndex(a=>this.tabSelected===a.dataset.name);let s=r;t==="ArrowRight"?(s=(r+1)%n.length,e.preventDefault()):t==="ArrowLeft"?(s=(r-1+n.length)%n.length,e.preventDefault()):t==="Home"?(s=0,e.preventDefault()):t==="End"&&(s=n.length-1,e.preventDefault()),s!==r&&this.tabButtonClicked(n[s])}}))}function Bt(i){i.data("rzSidebar",()=>({showSidebar:!1,isSidebarHidden(){return!this.showSidebar},toggleSidebar(){this.showSidebar=!this.showSidebar},hideSidebar(){this.showSidebar=!1},getSidebarTranslation(){return this.showSidebar?"translate-x-0":"-translate-x-60"}}))}function Wt(i){i.data("rzSidebarLinkItem",()=>({isExpanded:!1,chevronExpandedClass:"",chevronCollapsedClass:"",init(){this.isExpanded=this.$el.dataset.expanded==="true",this.chevronExpandedClass=this.$el.dataset.chevronExpandedClass,this.chevronCollapsedClass=this.$el.dataset.chevronCollapsedClass},isCollapsed(){return!this.isExpanded},toggleExpanded(){this.isExpanded=!this.isExpanded},hideSidebar(){const e=this.$el.closest('[x-data^="rzSidebar"]');if(e){let t=i.$data(e);t.showSidebar=!1}else console.warn("Parent sidebar context not found or 'showSidebar' is not defined.")},getExpandedClass(){return this.isExpanded?this.chevronExpandedClass:this.chevronCollapsedClass},getAriaExpanded(){return this.isExpanded?"true":"false"}}))}async function Yt(i){i=[...i].sort();const e=i.join("|"),n=new TextEncoder().encode(e),r=await crypto.subtle.digest("SHA-256",n);return Array.from(new Uint8Array(r)).map(a=>a.toString(16).padStart(2,"0")).join("")}function Z(i,e,t){Yt(i).then(n=>{k.isDefined(n)||k(i,n,{async:!1,inlineScriptNonce:t,inlineStyleNonce:t}),k.ready([n],e)})}function Ht(i){It(i),Tt(i),Ct(i),St(i),xt(i),Nt(i,Z),Ot(i,Z),kt(i),Lt(i),Rt(i),Ft(i),Dt(i),$t(i,Z),zt(i),At(i),_t(i),Mt(i),Pt(i),Bt(i),Wt(i)}function Vt(i){if(typeof Alpine>"u"||typeof Alpine.$data!="function"){console.error("$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use.");return}let e=null,t=null;if(typeof i=="string"){if(!i){console.warn("Rizzy.$data: Invalid componentId provided (empty string).");return}if(t=i,e=document.getElementById(t),!e){console.warn(`Rizzy.$data: Rizzy component with ID "${t}" not found in the DOM.`);return}}else if(i instanceof Element){if(e=i,!e.id){console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");return}t=e.id}else{console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");return}const n=`[data-alpine-root="${t}"]`;let r=null;if(e.matches(n)?r=e:r=e.querySelector(n),!r){console.warn(`Rizzy.$data: Could not locate the designated Alpine root element using selector "${n}" on or inside the wrapper element (ID: #${t}). Verify the 'data-alpine-root' attribute placement.`);return}const s=Alpine.$data(r);if(s===void 0){const a=`${r.tagName.toLowerCase()}${r.id?"#"+r.id:""}${r.classList.length?"."+Array.from(r.classList).join("."):""}`;console.warn(`Rizzy.$data: Located designated Alpine root (${a}) via 'data-alpine-root="${t}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`)}return s}I.plugin(De),I.plugin(Me),I.plugin(st),Ht(I);const Fe={Alpine:I,require:Z,toast:mt,$data:Vt};return window.Alpine=I,window.Rizzy={...window.Rizzy||{},...Fe},I.start(),Fe});
</file>

<file path="wwwroot/js/rizzyui.umd.js">
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("alpinejs")) : typeof define === "function" && define.amd ? define(["alpinejs"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.RizzyUI = factory(global.Alpine));
})(this, function(Alpine$1) {
  "use strict";
  function src_default$2(Alpine2) {
    Alpine2.directive("collapse", collapse);
    collapse.inline = (el, { modifiers }) => {
      if (!modifiers.includes("min"))
        return;
      el._x_doShow = () => {
      };
      el._x_doHide = () => {
      };
    };
    function collapse(el, { modifiers }) {
      let duration = modifierValue(modifiers, "duration", 250) / 1e3;
      let floor = modifierValue(modifiers, "min", 0);
      let fullyHide = !modifiers.includes("min");
      if (!el._x_isShown)
        el.style.height = `${floor}px`;
      if (!el._x_isShown && fullyHide)
        el.hidden = true;
      if (!el._x_isShown)
        el.style.overflow = "hidden";
      let setFunction = (el2, styles) => {
        let revertFunction = Alpine2.setStyles(el2, styles);
        return styles.height ? () => {
        } : revertFunction;
      };
      let transitionStyles = {
        transitionProperty: "height",
        transitionDuration: `${duration}s`,
        transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
      };
      el._x_transition = {
        in(before = () => {
        }, after = () => {
        }) {
          if (fullyHide)
            el.hidden = false;
          if (fullyHide)
            el.style.display = null;
          let current = el.getBoundingClientRect().height;
          el.style.height = "auto";
          let full = el.getBoundingClientRect().height;
          if (current === full) {
            current = floor;
          }
          Alpine2.transition(el, Alpine2.setStyles, {
            during: transitionStyles,
            start: { height: current + "px" },
            end: { height: full + "px" }
          }, () => el._x_isShown = true, () => {
            if (Math.abs(el.getBoundingClientRect().height - full) < 1) {
              el.style.overflow = null;
            }
          });
        },
        out(before = () => {
        }, after = () => {
        }) {
          let full = el.getBoundingClientRect().height;
          Alpine2.transition(el, setFunction, {
            during: transitionStyles,
            start: { height: full + "px" },
            end: { height: floor + "px" }
          }, () => el.style.overflow = "hidden", () => {
            el._x_isShown = false;
            if (el.style.height == `${floor}px` && fullyHide) {
              el.style.display = "none";
              el.hidden = true;
            }
          });
        }
      };
    }
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "min") {
      let match = rawValue.match(/([0-9]+)px/);
      if (match)
        return match[1];
    }
    return rawValue;
  }
  var module_default$2 = src_default$2;
  function src_default$1(Alpine2) {
    Alpine2.directive("intersect", Alpine2.skipDuringClone((el, { value, expression, modifiers }, { evaluateLater, cleanup }) => {
      let evaluate = evaluateLater(expression);
      let options = {
        rootMargin: getRootMargin(modifiers),
        threshold: getThreshold(modifiers)
      };
      let observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting === (value === "leave"))
            return;
          evaluate();
          modifiers.includes("once") && observer.disconnect();
        });
      }, options);
      observer.observe(el);
      cleanup(() => {
        observer.disconnect();
      });
    }));
  }
  function getThreshold(modifiers) {
    if (modifiers.includes("full"))
      return 0.99;
    if (modifiers.includes("half"))
      return 0.5;
    if (!modifiers.includes("threshold"))
      return 0;
    let threshold = modifiers[modifiers.indexOf("threshold") + 1];
    if (threshold === "100")
      return 1;
    if (threshold === "0")
      return 0;
    return Number(`.${threshold}`);
  }
  function getLengthValue(rawValue) {
    let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
    return match ? match[1] + (match[2] || "px") : void 0;
  }
  function getRootMargin(modifiers) {
    const key = "margin";
    const fallback = "0px 0px 0px 0px";
    const index = modifiers.indexOf(key);
    if (index === -1)
      return fallback;
    let values = [];
    for (let i2 = 1; i2 < 5; i2++) {
      values.push(getLengthValue(modifiers[index + i2] || ""));
    }
    values = values.filter((v2) => v2 !== void 0);
    return values.length ? values.join(" ").trim() : fallback;
  }
  var module_default$1 = src_default$1;
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b) {
    return a2.tabIndex === b.tabIndex ? a2.documentOrder - b.documentOrder : a2.tabIndex - b.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r2;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === "full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (nodeIsAttached) {
        return !node.getClientRects().length;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = /* @__PURE__ */ function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e2) {
    return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e2) {
    return e2.key === "Tab" || e2.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i2) {
      if (fn(value)) {
        idx = i2;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event) {
    return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2, config.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e2) {
      var target = getActualTarget(e2);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e2.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e2) {
      var target = getActualTarget(e2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e2.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e2.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e2.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e2) {
      if (isEscapeEvent(e2) && valueOrHandler(config.escapeDeactivates, e2) !== false) {
        e2.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e2)) {
        checkTab(e2);
        return;
      }
    };
    var checkClick = function checkClick2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };
  function src_default(Alpine2) {
    let lastFocused;
    let currentFocused;
    window.addEventListener("focusin", () => {
      lastFocused = currentFocused;
      currentFocused = document.activeElement;
    });
    Alpine2.magic("focus", (el) => {
      let within = el;
      return {
        __noscroll: false,
        __wrapAround: false,
        within(el2) {
          within = el2;
          return this;
        },
        withoutScrolling() {
          this.__noscroll = true;
          return this;
        },
        noscroll() {
          this.__noscroll = true;
          return this;
        },
        withWrapAround() {
          this.__wrapAround = true;
          return this;
        },
        wrap() {
          return this.withWrapAround();
        },
        focusable(el2) {
          return isFocusable(el2);
        },
        previouslyFocused() {
          return lastFocused;
        },
        lastFocused() {
          return lastFocused;
        },
        focused() {
          return currentFocused;
        },
        focusables() {
          if (Array.isArray(within))
            return within;
          return focusable(within, { displayCheck: "none" });
        },
        all() {
          return this.focusables();
        },
        isFirst(el2) {
          let els = this.all();
          return els[0] && els[0].isSameNode(el2);
        },
        isLast(el2) {
          let els = this.all();
          return els.length && els.slice(-1)[0].isSameNode(el2);
        },
        getFirst() {
          return this.all()[0];
        },
        getLast() {
          return this.all().slice(-1)[0];
        },
        getNext() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
            return list[0];
          }
          return list[list.indexOf(current) + 1];
        },
        getPrevious() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === 0) {
            return list.slice(-1)[0];
          }
          return list[list.indexOf(current) - 1];
        },
        first() {
          this.focus(this.getFirst());
        },
        last() {
          this.focus(this.getLast());
        },
        next() {
          this.focus(this.getNext());
        },
        previous() {
          this.focus(this.getPrevious());
        },
        prev() {
          return this.previous();
        },
        focus(el2) {
          if (!el2)
            return;
          setTimeout(() => {
            if (!el2.hasAttribute("tabindex"))
              el2.setAttribute("tabindex", "0");
            el2.focus({ preventScroll: this.__noscroll });
          });
        }
      };
    });
    Alpine2.directive("trap", Alpine2.skipDuringClone(
      (el, { expression, modifiers }, { effect, evaluateLater, cleanup }) => {
        let evaluator = evaluateLater(expression);
        let oldValue = false;
        let options = {
          escapeDeactivates: false,
          allowOutsideClick: true,
          fallbackFocus: () => el
        };
        if (modifiers.includes("noautofocus")) {
          options.initialFocus = false;
        } else {
          let autofocusEl = el.querySelector("[autofocus]");
          if (autofocusEl)
            options.initialFocus = autofocusEl;
        }
        let trap = createFocusTrap(el, options);
        let undoInert = () => {
        };
        let undoDisableScrolling = () => {
        };
        const releaseFocus = () => {
          undoInert();
          undoInert = () => {
          };
          undoDisableScrolling();
          undoDisableScrolling = () => {
          };
          trap.deactivate({
            returnFocus: !modifiers.includes("noreturn")
          });
        };
        effect(() => evaluator((value) => {
          if (oldValue === value)
            return;
          if (value && !oldValue) {
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            if (modifiers.includes("inert"))
              undoInert = setInert(el);
            setTimeout(() => {
              trap.activate();
            }, 15);
          }
          if (!value && oldValue) {
            releaseFocus();
          }
          oldValue = !!value;
        }));
        cleanup(releaseFocus);
      },
      // When cloning, we only want to add aria-hidden attributes to the
      // DOM and not try to actually trap, as trapping can mess with the
      // live DOM and isn't just isolated to the cloned DOM.
      (el, { expression, modifiers }, { evaluate }) => {
        if (modifiers.includes("inert") && evaluate(expression))
          setInert(el);
      }
    ));
  }
  function setInert(el) {
    let undos = [];
    crawlSiblingsUp(el, (sibling) => {
      let cache = sibling.hasAttribute("aria-hidden");
      sibling.setAttribute("aria-hidden", "true");
      undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
    });
    return () => {
      while (undos.length)
        undos.pop()();
    };
  }
  function crawlSiblingsUp(el, callback) {
    if (el.isSameNode(document.body) || !el.parentNode)
      return;
    Array.from(el.parentNode.children).forEach((sibling) => {
      if (sibling.isSameNode(el)) {
        crawlSiblingsUp(el.parentNode, callback);
      } else {
        callback(sibling);
      }
    });
  }
  function disableScrolling() {
    let overflow = document.documentElement.style.overflow;
    let paddingRight = document.documentElement.style.paddingRight;
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden";
    document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
    return () => {
      document.documentElement.style.overflow = overflow;
      document.documentElement.style.paddingRight = paddingRight;
    };
  }
  var module_default = src_default;
  /*! Bundled license information:
    tabbable/dist/index.esm.js:
      (*!
      * tabbable 5.3.3
      * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
      *)
    focus-trap/dist/focus-trap.esm.js:
      (*!
      * focus-trap 6.9.4
      * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
      *)
    */
  function t(t2, e2) {
    if (!(t2 instanceof e2)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function e(t2, e2) {
    for (var s2 = 0; s2 < e2.length; s2++) {
      var i2 = e2[s2];
      i2.enumerable = i2.enumerable || false;
      i2.configurable = true;
      if ("value" in i2) i2.writable = true;
      Object.defineProperty(t2, i2.key, i2);
    }
  }
  function s(t2, s2, i2) {
    if (s2) e(t2.prototype, s2);
    return t2;
  }
  var i = Object.defineProperty;
  var n = function(t2, e2) {
    return i(t2, "name", { value: e2, configurable: true });
  };
  var o = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m8.94 8 4.2-4.193a.67.67 0 0 0-.947-.947L8 7.06l-4.193-4.2a.67.67 0 1 0-.947.947L7.06 8l-4.2 4.193a.667.667 0 0 0 .217 1.093.666.666 0 0 0 .73-.146L8 8.94l4.193 4.2a.666.666 0 0 0 1.094-.217.665.665 0 0 0-.147-.73L8.94 8Z" fill="currentColor"/>\r\n</svg>\r\n';
  var a = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24A10.667 10.667 0 0 1 5.333 16a10.56 10.56 0 0 1 2.254-6.533l14.946 14.946A10.56 10.56 0 0 1 16 26.667Zm8.413-4.134L9.467 7.587A10.56 10.56 0 0 1 16 5.333 10.667 10.667 0 0 1 26.667 16a10.56 10.56 0 0 1-2.254 6.533Z" fill="currentColor"/>\r\n</svg>\r\n';
  var r = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16 14.667A1.333 1.333 0 0 0 14.667 16v5.333a1.333 1.333 0 0 0 2.666 0V16A1.333 1.333 0 0 0 16 14.667Zm.507-5.227a1.333 1.333 0 0 0-1.014 0 1.334 1.334 0 0 0-.44.28 1.56 1.56 0 0 0-.28.44c-.075.158-.11.332-.106.507a1.332 1.332 0 0 0 .386.946c.13.118.279.213.44.28a1.334 1.334 0 0 0 1.84-1.226 1.4 1.4 0 0 0-.386-.947 1.334 1.334 0 0 0-.44-.28ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var c = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="m19.627 11.72-5.72 5.733-2.2-2.2a1.334 1.334 0 1 0-1.88 1.881l3.133 3.146a1.333 1.333 0 0 0 1.88 0l6.667-6.667a1.333 1.333 0 1 0-1.88-1.893ZM16 2.667a13.333 13.333 0 1 0 0 26.666 13.333 13.333 0 0 0 0-26.666Zm0 24a10.666 10.666 0 1 1 0-21.333 10.666 10.666 0 0 1 0 21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var l = '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n  <path d="M16.334 17.667a1.334 1.334 0 0 0 1.334-1.333v-5.333a1.333 1.333 0 0 0-2.665 0v5.333a1.333 1.333 0 0 0 1.33 1.333Zm-.508 5.227c.325.134.69.134 1.014 0 .165-.064.314-.159.44-.28a1.56 1.56 0 0 0 .28-.44c.076-.158.112-.332.107-.507a1.332 1.332 0 0 0-.387-.946 1.532 1.532 0 0 0-.44-.28 1.334 1.334 0 0 0-1.838 1.226 1.4 1.4 0 0 0 .385.947c.127.121.277.216.44.28Zm.508 6.773a13.333 13.333 0 1 0 0-26.667 13.333 13.333 0 0 0 0 26.667Zm0-24A10.667 10.667 0 1 1 16.54 27a10.667 10.667 0 0 1-.206-21.333Z" fill="currentColor"/>\r\n</svg>\r\n';
  var h = n(function(t2) {
    return new DOMParser().parseFromString(t2, "text/html").body.childNodes[0];
  }, "stringToHTML"), d = n(function(t2) {
    var e2 = new DOMParser().parseFromString(t2, "application/xml");
    return document.importNode(e2.documentElement, true).outerHTML;
  }, "getSvgNode");
  var u = { CONTAINER: "sn-notifications-container", NOTIFY: "sn-notify", NOTIFY_CONTENT: "sn-notify-content", NOTIFY_ICON: "sn-notify-icon", NOTIFY_CLOSE: "sn-notify-close", NOTIFY_TITLE: "sn-notify-title", NOTIFY_TEXT: "sn-notify-text", IS_X_CENTER: "sn-is-x-center", IS_Y_CENTER: "sn-is-y-center", IS_CENTER: "sn-is-center", IS_LEFT: "sn-is-left", IS_RIGHT: "sn-is-right", IS_TOP: "sn-is-top", IS_BOTTOM: "sn-is-bottom", NOTIFY_OUTLINE: "sn-notify-outline", NOTIFY_FILLED: "sn-notify-filled", NOTIFY_ERROR: "sn-notify-error", NOTIFY_WARNING: "sn-notify-warning", NOTIFY_SUCCESS: "sn-notify-success", NOTIFY_INFO: "sn-notify-info", NOTIFY_FADE: "sn-notify-fade", NOTIFY_FADE_IN: "sn-notify-fade-in", NOTIFY_SLIDE: "sn-notify-slide", NOTIFY_SLIDE_IN: "sn-notify-slide-in", NOTIFY_AUTOCLOSE: "sn-notify-autoclose" }, f = { ERROR: "error", WARNING: "warning", SUCCESS: "success", INFO: "info" }, p = { OUTLINE: "outline", FILLED: "filled" }, I = { FADE: "fade", SLIDE: "slide" }, v = { CLOSE: d(o), SUCCESS: d(c), ERROR: d(a), WARNING: d(l), INFO: d(r) };
  var N = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_FADE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_FADE_IN);
    }, 100);
  }, "fadeIn"), O = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_FADE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "fadeOut"), T = n(function(t2) {
    t2.wrapper.classList.add(u.NOTIFY_SLIDE), setTimeout(function() {
      t2.wrapper.classList.add(u.NOTIFY_SLIDE_IN);
    }, 100);
  }, "slideIn"), E = n(function(t2) {
    t2.wrapper.classList.remove(u.NOTIFY_SLIDE_IN), setTimeout(function() {
      t2.wrapper.remove();
    }, t2.speed);
  }, "slideOut");
  var m = function() {
    function e2(s2) {
      var i2 = this;
      t(this, e2);
      this.notifyOut = n(function(t2) {
        t2(i2);
      }, "notifyOut");
      var o2 = s2.notificationsGap, a2 = o2 === void 0 ? 20 : o2, r2 = s2.notificationsPadding, c2 = r2 === void 0 ? 20 : r2, l2 = s2.status, h2 = l2 === void 0 ? "success" : l2, d2 = s2.effect, u2 = d2 === void 0 ? I.FADE : d2, f2 = s2.type, p2 = f2 === void 0 ? "outline" : f2, v2 = s2.title, N2 = s2.text, O2 = s2.showIcon, T2 = O2 === void 0 ? true : O2, E2 = s2.customIcon, m2 = E2 === void 0 ? "" : E2, w2 = s2.customClass, y = w2 === void 0 ? "" : w2, L = s2.speed, C = L === void 0 ? 500 : L, F = s2.showCloseButton, _ = F === void 0 ? true : F, S = s2.autoclose, g = S === void 0 ? true : S, R = s2.autotimeout, Y = R === void 0 ? 3e3 : R, x = s2.position, A = x === void 0 ? "right top" : x, b = s2.customWrapper, k = b === void 0 ? "" : b;
      if (this.customWrapper = k, this.status = h2, this.title = v2, this.text = N2, this.showIcon = T2, this.customIcon = m2, this.customClass = y, this.speed = C, this.effect = u2, this.showCloseButton = _, this.autoclose = g, this.autotimeout = Y, this.notificationsGap = a2, this.notificationsPadding = c2, this.type = p2, this.position = A, !this.checkRequirements()) {
        console.error("You must specify 'title' or 'text' at least.");
        return;
      }
      this.setContainer(), this.setWrapper(), this.setPosition(), this.showIcon && this.setIcon(), this.showCloseButton && this.setCloseButton(), this.setContent(), this.container.prepend(this.wrapper), this.setEffect(), this.notifyIn(this.selectedNotifyInEffect), this.autoclose && this.autoClose(), this.setObserver();
    }
    s(e2, [{ key: "checkRequirements", value: function t2() {
      return !!(this.title || this.text);
    } }, { key: "setContainer", value: function t2() {
      var t3 = document.querySelector(".".concat(u.CONTAINER));
      t3 ? this.container = t3 : (this.container = document.createElement("div"), this.container.classList.add(u.CONTAINER), document.body.appendChild(this.container)), this.notificationsPadding && this.container.style.setProperty("--sn-notifications-padding", "".concat(this.notificationsPadding, "px")), this.notificationsGap && this.container.style.setProperty("--sn-notifications-gap", "".concat(this.notificationsGap, "px"));
    } }, { key: "setPosition", value: function t2() {
      this.container.classList[this.position === "center" ? "add" : "remove"](u.IS_CENTER), this.container.classList[this.position.includes("left") ? "add" : "remove"](u.IS_LEFT), this.container.classList[this.position.includes("right") ? "add" : "remove"](u.IS_RIGHT), this.container.classList[this.position.includes("top") ? "add" : "remove"](u.IS_TOP), this.container.classList[this.position.includes("bottom") ? "add" : "remove"](u.IS_BOTTOM), this.container.classList[this.position.includes("x-center") ? "add" : "remove"](u.IS_X_CENTER), this.container.classList[this.position.includes("y-center") ? "add" : "remove"](u.IS_Y_CENTER);
    } }, { key: "setCloseButton", value: function t2() {
      var t3 = this;
      var e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_CLOSE), e3.innerHTML = v.CLOSE, this.wrapper.appendChild(e3), e3.addEventListener("click", function() {
        t3.close();
      });
    } }, { key: "setWrapper", value: function t2() {
      var t3 = this;
      switch (this.customWrapper ? this.wrapper = h(this.customWrapper) : this.wrapper = document.createElement("div"), this.wrapper.style.setProperty("--sn-notify-transition-duration", "".concat(this.speed, "ms")), this.wrapper.classList.add(u.NOTIFY), this.type) {
        case p.OUTLINE:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
          break;
        case p.FILLED:
          this.wrapper.classList.add(u.NOTIFY_FILLED);
          break;
        default:
          this.wrapper.classList.add(u.NOTIFY_OUTLINE);
      }
      switch (this.status) {
        case f.SUCCESS:
          this.wrapper.classList.add(u.NOTIFY_SUCCESS);
          break;
        case f.ERROR:
          this.wrapper.classList.add(u.NOTIFY_ERROR);
          break;
        case f.WARNING:
          this.wrapper.classList.add(u.NOTIFY_WARNING);
          break;
        case f.INFO:
          this.wrapper.classList.add(u.NOTIFY_INFO);
          break;
      }
      this.autoclose && (this.wrapper.classList.add(u.NOTIFY_AUTOCLOSE), this.wrapper.style.setProperty("--sn-notify-autoclose-timeout", "".concat(this.autotimeout + this.speed, "ms"))), this.customClass && this.customClass.split(" ").forEach(function(e3) {
        t3.wrapper.classList.add(e3);
      });
    } }, { key: "setContent", value: function t2() {
      var t3 = document.createElement("div");
      t3.classList.add(u.NOTIFY_CONTENT);
      var e3, s2;
      this.title && (e3 = document.createElement("div"), e3.classList.add(u.NOTIFY_TITLE), e3.textContent = this.title.trim(), this.showCloseButton || (e3.style.paddingRight = "0")), this.text && (s2 = document.createElement("div"), s2.classList.add(u.NOTIFY_TEXT), s2.innerHTML = this.text.trim(), this.title || (s2.style.marginTop = "0")), this.wrapper.appendChild(t3), this.title && t3.appendChild(e3), this.text && t3.appendChild(s2);
    } }, { key: "setIcon", value: function t2() {
      var t3 = n(function(t4) {
        switch (t4) {
          case f.SUCCESS:
            return v.SUCCESS;
          case f.ERROR:
            return v.ERROR;
          case f.WARNING:
            return v.WARNING;
          case f.INFO:
            return v.INFO;
        }
      }, "computedIcon"), e3 = document.createElement("div");
      e3.classList.add(u.NOTIFY_ICON), e3.innerHTML = this.customIcon || t3(this.status), (this.status || this.customIcon) && this.wrapper.appendChild(e3);
    } }, { key: "setObserver", value: function t2() {
      var t3 = this;
      var e3 = new IntersectionObserver(function(e4) {
        if (e4[0].intersectionRatio <= 0) t3.close();
        else return;
      }, { threshold: 0 });
      setTimeout(function() {
        e3.observe(t3.wrapper);
      }, this.speed);
    } }, { key: "notifyIn", value: function t2(t2) {
      t2(this);
    } }, { key: "autoClose", value: function t2() {
      var t3 = this;
      setTimeout(function() {
        t3.close();
      }, this.autotimeout + this.speed);
    } }, { key: "close", value: function t2() {
      this.notifyOut(this.selectedNotifyOutEffect);
    } }, { key: "setEffect", value: function t2() {
      switch (this.effect) {
        case I.FADE:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
          break;
        case I.SLIDE:
          this.selectedNotifyInEffect = T, this.selectedNotifyOutEffect = E;
          break;
        default:
          this.selectedNotifyInEffect = N, this.selectedNotifyOutEffect = O;
      }
    } }]);
    return e2;
  }();
  n(m, "Notify");
  var w = m;
  globalThis.Notify = w;
  const allowedStatuses = ["success", "error", "warning", "info"];
  const allowedPositions = [
    // Standard Corners
    "right top",
    "top right",
    "right bottom",
    "bottom right",
    "left top",
    "top left",
    "left bottom",
    "bottom left",
    // Centered Horizontally
    "center top",
    "x-center top",
    "center bottom",
    "x-center bottom",
    // Centered Vertically
    "left center",
    "left y-center",
    "y-center left",
    "right center",
    "right y-center",
    "y-center right",
    // Aliases for Centered Horizontally (already covered but good for robustness)
    "top center",
    "top x-center",
    "bottom center",
    "bottom x-center",
    // Absolute Center
    "center"
  ];
  const defaultConfig = {
    status: "info",
    title: "Notification",
    text: "",
    effect: "fade",
    speed: 300,
    autoclose: true,
    autotimeout: 4e3,
    position: "right top"
  };
  function renderToast(options = {}) {
    const config = {
      ...defaultConfig,
      ...options
    };
    if (!allowedStatuses.includes(config.status)) {
      console.warn(`Invalid status '${config.status}' passed to Toast. Defaulting to 'info'.`);
      config.status = "info";
    }
    if (!allowedPositions.includes(config.position)) {
      console.warn(`Invalid position '${config.position}' passed to Toast. Defaulting to 'right top'.`);
      config.position = "right top";
    }
    new w(config);
  }
  const Toast = {
    custom: renderToast,
    success(text, title = "Success", options = {}) {
      renderToast({
        status: "success",
        title,
        text,
        ...options
      });
    },
    error(text, title = "Error", options = {}) {
      renderToast({
        status: "error",
        title,
        text,
        ...options
      });
    },
    warning(text, title = "Warning", options = {}) {
      renderToast({
        status: "warning",
        title,
        text,
        ...options
      });
    },
    info(text, title = "Info", options = {}) {
      renderToast({
        status: "info",
        title,
        text,
        ...options
      });
    },
    setDefaults(newDefaults = {}) {
      Object.assign(defaultConfig, newDefaults);
    },
    get allowedStatuses() {
      return [...allowedStatuses];
    },
    get allowedPositions() {
      return [...allowedPositions];
    }
  };
  const devnull = function() {
  }, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};
  function subscribe(bundleIds, callbackFn) {
    bundleIds = Array.isArray(bundleIds) ? bundleIds : [bundleIds];
    const depsNotFound = [];
    let i2 = bundleIds.length, numWaiting = i2, fn, bundleId, r2, q;
    fn = function(bundleId2, pathsNotFound) {
      if (pathsNotFound.length) depsNotFound.push(bundleId2);
      numWaiting--;
      if (!numWaiting) callbackFn(depsNotFound);
    };
    while (i2--) {
      bundleId = bundleIds[i2];
      r2 = bundleResultCache[bundleId];
      if (r2) {
        fn(bundleId, r2);
        continue;
      }
      q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];
      q.push(fn);
    }
  }
  function publish(bundleId, pathsNotFound) {
    if (!bundleId) return;
    const q = bundleCallbackQueue[bundleId];
    bundleResultCache[bundleId] = pathsNotFound;
    if (!q) return;
    while (q.length) {
      q[0](bundleId, pathsNotFound);
      q.splice(0, 1);
    }
  }
  function executeCallbacks(args, depsNotFound) {
    if (typeof args === "function") args = { success: args };
    if (depsNotFound.length) (args.error || devnull)(depsNotFound);
    else (args.success || devnull)(args);
  }
  function handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss) {
    let result = ev.type[0];
    if (isLegacyIECss) {
      try {
        if (!e2.sheet.cssText.length) result = "e";
      } catch (x) {
        if (x.code !== 18) result = "e";
      }
    }
    if (result === "e") {
      numTries += 1;
      if (numTries < maxTries) {
        return loadFile(path, callbackFn, args, numTries);
      }
    } else if (e2.rel === "preload" && e2.as === "style") {
      e2.rel = "stylesheet";
      return;
    }
    callbackFn(path, result, ev.defaultPrevented);
  }
  function loadFile(path, callbackFn, args, numTries) {
    const doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\?|#].*$/, ""), pathStripped = path.replace(/^(css|img|module|nomodule)!/, "");
    let isLegacyIECss, hasModuleSupport, e2;
    numTries = numTries || 0;
    if (/(^css!|\.css$)/.test(pathname)) {
      e2 = doc.createElement("link");
      e2.rel = "stylesheet";
      e2.href = pathStripped;
      isLegacyIECss = "hideFocus" in e2;
      if (isLegacyIECss && e2.relList) {
        isLegacyIECss = 0;
        e2.rel = "preload";
        e2.as = "style";
      }
      if (args.inlineStyleNonce) {
        e2.setAttribute("nonce", args.inlineStyleNonce);
      }
    } else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {
      e2 = doc.createElement("img");
      e2.src = pathStripped;
    } else {
      e2 = doc.createElement("script");
      e2.src = pathStripped;
      e2.async = async === void 0 ? true : async;
      if (args.inlineScriptNonce) {
        e2.setAttribute("nonce", args.inlineScriptNonce);
      }
      hasModuleSupport = "noModule" in e2;
      if (/^module!/.test(pathname)) {
        if (!hasModuleSupport) return callbackFn(path, "l");
        e2.type = "module";
      } else if (/^nomodule!/.test(pathname) && hasModuleSupport) {
        return callbackFn(path, "l");
      }
    }
    const onEvent = function(ev) {
      handleResourceEvent(ev, path, e2, callbackFn, args, numTries, maxTries, isLegacyIECss);
    };
    e2.addEventListener("load", onEvent, { once: true });
    e2.addEventListener("error", onEvent, { once: true });
    if (beforeCallbackFn(path, e2) !== false) doc.head.appendChild(e2);
  }
  function loadFiles(paths, callbackFn, args) {
    paths = Array.isArray(paths) ? paths : [paths];
    let numWaiting = paths.length, pathsNotFound = [];
    function fn(path, result, defaultPrevented) {
      if (result === "e") pathsNotFound.push(path);
      if (result === "b") {
        if (defaultPrevented) pathsNotFound.push(path);
        else return;
      }
      numWaiting--;
      if (!numWaiting) callbackFn(pathsNotFound);
    }
    for (let i2 = 0; i2 < paths.length; i2++) {
      loadFile(paths[i2], fn, args);
    }
  }
  function loadjs(paths, arg1, arg2) {
    let bundleId, args;
    if (arg1 && typeof arg1 === "string" && arg1.trim) {
      bundleId = arg1.trim();
    }
    args = (bundleId ? arg2 : arg1) || {};
    if (bundleId) {
      if (bundleId in bundleIdCache) {
        throw "LoadJS";
      } else {
        bundleIdCache[bundleId] = true;
      }
    }
    function loadFn(resolve, reject) {
      loadFiles(paths, function(pathsNotFound) {
        executeCallbacks(args, pathsNotFound);
        if (resolve) {
          executeCallbacks({ success: resolve, error: reject }, pathsNotFound);
        }
        publish(bundleId, pathsNotFound);
      }, args);
    }
    if (args.returnPromise) {
      return new Promise(loadFn);
    } else {
      loadFn();
    }
  }
  loadjs.ready = function ready(deps, args) {
    subscribe(deps, function(depsNotFound) {
      executeCallbacks(args, depsNotFound);
    });
    return loadjs;
  };
  loadjs.done = function done(bundleId) {
    publish(bundleId, []);
  };
  loadjs.reset = function reset() {
    Object.keys(bundleIdCache).forEach((key) => delete bundleIdCache[key]);
    Object.keys(bundleResultCache).forEach((key) => delete bundleResultCache[key]);
    Object.keys(bundleCallbackQueue).forEach((key) => delete bundleCallbackQueue[key]);
  };
  loadjs.isDefined = function isDefined(bundleId) {
    return bundleId in bundleIdCache;
  };
  function registerRzAccordion(Alpine2) {
    Alpine2.data("rzAccordion", () => ({
      selected: "",
      // ID of the currently selected/opened section (if not allowMultiple)
      allowMultiple: false,
      // Whether multiple sections can be open
      init() {
        this.allowMultiple = this.$el.dataset.multiple === "true";
      },
      destroy() {
      }
    }));
  }
  function registerRzAccordionSection(Alpine2) {
    Alpine2.data("rzAccordionSection", () => ({
      open: false,
      sectionId: "",
      expandedClass: "",
      init() {
        this.open = this.$el.dataset.isOpen === "true";
        this.sectionId = this.$el.dataset.sectionId;
        this.expandedClass = this.$el.dataset.expandedClass;
        const self2 = this;
        if (typeof this.selected !== "undefined" && typeof this.allowMultiple !== "undefined") {
          this.$watch("selected", (value, oldValue) => {
            if (value !== self2.sectionId && !self2.allowMultiple) {
              self2.open = false;
            }
          });
        } else {
          console.warn("rzAccordionSection: Could not find 'selected' or 'allowMultiple' in parent scope for $watch.");
        }
      },
      destroy() {
      },
      // Toggle the section's open state and update the parent's 'selected' state.
      toggle() {
        this.selected = this.sectionId;
        this.open = !this.open;
      },
      // Get the CSS classes for the expanded/collapsed chevron icon.
      getExpandedCss() {
        return this.open ? this.expandedClass : "";
      },
      // Get the value for aria-expanded attribute based on the 'open' state.
      getAriaExpanded() {
        return this.open ? "true" : "false";
      }
    }));
  }
  function registerRzAlert(Alpine2) {
    Alpine2.data("rzAlert", () => {
      return {
        showAlert: true,
        dismiss() {
          this.showAlert = false;
        }
      };
    });
  }
  function registerRzBrowser(Alpine2) {
    Alpine2.data("rzBrowser", () => {
      return {
        screenSize: "",
        setDesktopScreenSize() {
          this.screenSize = "";
        },
        setTabletScreenSize() {
          this.screenSize = "max-w-2xl";
        },
        setPhoneScreenSize() {
          this.screenSize = "max-w-sm";
        },
        // Get CSS classes for browser border based on screen size
        getBrowserBorderCss() {
          return [this.screenSize, this.screenSize === "" ? "border-none" : "border-x"];
        },
        // Get CSS classes for desktop screen button styling
        getDesktopScreenCss() {
          return [this.screenSize === "" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for tablet screen button styling
        getTabletScreenCss() {
          return [this.screenSize === "max-w-2xl" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        },
        // Get CSS classes for phone screen button styling
        getPhoneScreenCss() {
          return [this.screenSize === "max-w-sm" ? "text-foreground forced-color-adjust-auto dark:text-foreground" : "opacity-60"];
        }
      };
    });
  }
  function registerRzCheckboxGroupItem(Alpine2) {
    Alpine2.data("rzCheckboxGroupItem", () => {
      return {
        checkbox: null,
        isChecked: false,
        init() {
          this.checkbox = this.$refs.chk;
          this.isChecked = this.checkbox.checked;
        },
        toggleCheckbox() {
          this.isChecked = this.checkbox.checked;
        },
        getIconCss() {
          return this.isChecked ? "" : "hidden";
        }
      };
    });
  }
  function registerRzCodeViewer(Alpine2, require2) {
    Alpine2.data("rzCodeViewer", () => {
      return {
        expand: false,
        border: true,
        copied: false,
        copyTitle: "Copy",
        // Default title
        copiedTitle: "Copied!",
        // Default title
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const codeId = this.$el.dataset.codeid;
          const nonce = this.$el.dataset.nonce;
          this.copyTitle = this.$el.dataset.copyTitle || this.copyTitle;
          this.copiedTitle = this.$el.dataset.copiedTitle || this.copiedTitle;
          require2(assets, {
            success: function() {
              const codeBlock = document.getElementById(codeId);
              if (window.hljs && codeBlock) {
                window.hljs.highlightElement(codeBlock);
              }
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        },
        // Function to check if code is NOT copied (for x-show)
        notCopied() {
          return !this.copied;
        },
        // Function to reset the copied state (e.g., on blur)
        disableCopied() {
          this.copied = false;
        },
        // Function to toggle the expand state
        toggleExpand() {
          this.expand = !this.expand;
        },
        // Function to copy code to clipboard
        copyHTML() {
          navigator.clipboard.writeText(this.$refs.codeBlock.textContent);
          this.copied = !this.copied;
        },
        // Get the title for the copy button (copy/copied)
        getCopiedTitle() {
          return this.copied ? this.copiedTitle : this.copyTitle;
        },
        // Get CSS classes for the copy button based on copied state
        getCopiedCss() {
          return [this.copied ? "focus-visible:outline-success" : "focus-visible:outline-foreground"];
        },
        // Get CSS classes for the code container based on expand state
        getExpandCss() {
          return [this.expand ? "" : "max-h-60"];
        },
        // Get CSS classes for the expand button icon based on expand state
        getExpandButtonCss() {
          return this.expand ? "rotate-180" : "rotate-0";
        }
      };
    });
  }
  function registerRzDateEdit(Alpine2, require2) {
    Alpine2.data("rzDateEdit", () => ({
      options: {},
      placeholder: "",
      prependText: "",
      init() {
        const cfgString = this.$el.dataset.config;
        const inputElem = document.getElementById(this.$el.dataset.uid + "-input");
        if (cfgString) {
          const parsed = JSON.parse(cfgString);
          if (parsed) {
            this.options = parsed.options || {};
            this.placeholder = parsed.placeholder || "";
            this.prependText = parsed.prependText || "";
          }
        }
        const assets = JSON.parse(this.$el.dataset.assets);
        const nonce = this.$el.dataset.nonce;
        require2(assets, {
          success: function() {
            if (window.flatpickr && inputElem) {
              window.flatpickr(inputElem, this.options);
            }
          },
          error: function() {
            console.error("Failed to load Flatpickr assets.");
          }
        }, nonce);
      }
    }));
  }
  function registerRzDropdown(Alpine2) {
    Alpine2.data("rzDropdown", () => ({
      dropdownEl: null,
      anchorCss: "",
      dropdownOpen: false,
      openedWithKeyboard: false,
      init() {
        this.dropdownEl = this.$el;
        this.anchorCss = this.getAnchorCss();
      },
      toggleDropdown() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = !this.dropdownOpen;
      },
      openDropdown() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = true;
        this.openedWithKeyboard = false;
      },
      openWithKeyboard() {
        this.anchorCss = this.getAnchorCss();
        this.dropdownOpen = true;
        this.openedWithKeyboard = true;
        this.focusWrapNext();
      },
      closeDropdown() {
        this.dropdownOpen = false;
        this.openedWithKeyboard = false;
      },
      focusWrapNext() {
        this.$focus.wrap().next();
      },
      focusWrapPrevious() {
        this.$focus.wrap().previous();
      },
      // Computes the Tailwind CSS classes for the dropdown's anchor based on its data attribute
      getAnchorCss() {
        let defaultAnchorRaw = this.dropdownEl.getAttribute("data-anchor") || "";
        let defaultAnchor = defaultAnchorRaw.replace(/-/g, "").toLowerCase();
        const anchorClasses = {
          "topstart": "bottom-full right-0 mb-2 origin-bottom-right",
          "topcenter": "left-1/2 bottom-full transform -translate-x-1/2 mb-2 origin-bottom",
          "topend": "bottom-full left-0 mb-2 origin-bottom-left",
          "start": "right-full top-1/2 -translate-y-1/2 me-2 origin-right",
          "end": "left-full top-1/2 -translate-y-1/2 ms-2 origin-left",
          "bottomstart": "right-0 mt-2 origin-top-right",
          "bottomcenter": "-translate-x-1/2 mt-2 origin-top",
          "bottomend": "left-0 mt-2 origin-top-left"
        };
        let cssClasses = anchorClasses[defaultAnchor] || "";
        const triggerRect = this.dropdownEl.getBoundingClientRect();
        let tempContainer = document.createElement("div");
        tempContainer.style.cssText = "position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;";
        this.dropdownEl.appendChild(tempContainer);
        const originalMenu = this.dropdownEl.querySelector('[role="menu"]');
        if (!originalMenu) {
          return cssClasses;
        }
        let clone = originalMenu.cloneNode(true);
        clone.style.transition = "none";
        clone.style.transform = "none";
        clone.style.opacity = "1";
        clone.style.display = "block";
        tempContainer.appendChild(clone);
        let cloneRect = clone.getBoundingClientRect();
        tempContainer.parentNode.removeChild(tempContainer);
        const margin = 8;
        let wouldClip = false;
        if (defaultAnchor.startsWith("top")) {
          if (triggerRect.top < cloneRect.height + margin) {
            wouldClip = true;
          }
        } else if (defaultAnchor.startsWith("bottom")) {
          if (triggerRect.bottom + cloneRect.height + margin > window.innerHeight) {
            wouldClip = true;
          }
        } else if (defaultAnchor === "start") {
          if (triggerRect.left < cloneRect.width + margin) {
            wouldClip = true;
          }
        } else if (defaultAnchor === "end") {
          if (triggerRect.right + cloneRect.width + margin > window.innerWidth) {
            wouldClip = true;
          }
        }
        if (wouldClip) {
          const fallbackMapping = {
            "topstart": "bottomstart",
            "topcenter": "bottomcenter",
            "topend": "bottomend",
            "bottomstart": "topstart",
            "bottomcenter": "topcenter",
            "bottomend": "topend",
            "start": "end",
            "end": "start"
          };
          let fallbackAnchor = fallbackMapping[defaultAnchor] || defaultAnchor;
          cssClasses = anchorClasses[fallbackAnchor] || cssClasses;
        }
        return cssClasses;
      }
    }));
  }
  function registerRzDarkModeToggle(Alpine2) {
    Alpine2.data("rzDarkModeToggle", () => ({
      mode: "light",
      applyTheme: null,
      init() {
        const hasLocalStorage = typeof window !== "undefined" && "localStorage" in window;
        const allowedModes = ["light", "dark", "auto"];
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        let storedMode = "auto";
        if (hasLocalStorage) {
          storedMode = localStorage.getItem("darkMode") ?? "auto";
          if (!allowedModes.includes(storedMode)) {
            storedMode = "light";
          }
        }
        if (hasLocalStorage) {
          localStorage.setItem("darkMode", storedMode);
        }
        this.applyTheme = () => {
          document.documentElement.classList.toggle(
            "dark",
            storedMode === "dark" || storedMode === "auto" && prefersDark
          );
        };
        this.applyTheme();
        window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", this.applyTheme);
      },
      // Returns true if dark mode should be active
      isDark() {
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        localStorage.getItem("darkMode");
        return this.mode === "dark" || this.mode === "auto" && prefersDark;
      },
      // Returns true if light mode should be active
      isLight() {
        return !this.isDark();
      },
      // Toggle the dark mode setting and dispatch a custom event
      toggle() {
        let storedMode = localStorage.getItem("darkMode");
        const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        if (storedMode === "light")
          storedMode = "dark";
        else if (storedMode === "dark")
          storedMode = "light";
        else if (storedMode === "auto") {
          storedMode = prefersDark ? "light" : "dark";
        }
        this.mode = storedMode;
        localStorage.setItem("darkMode", storedMode);
        const isDark = storedMode === "dark" || storedMode === "auto" && prefersDark;
        document.documentElement.classList.toggle("dark", isDark);
        const darkModeEvent = new CustomEvent("darkModeToggle", {
          detail: { darkMode: isDark }
        });
        window.dispatchEvent(darkModeEvent);
      },
      destroy() {
        if (this.applyTheme) {
          window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", this.applyTheme);
        }
      }
    }));
  }
  function registerRzEmbeddedPreview(Alpine2) {
    Alpine2.data("rzEmbeddedPreview", () => {
      return {
        iframe: null,
        onDarkModeToggle: null,
        init() {
          try {
            this.iframe = this.$refs.iframe;
            const resize = this.debounce(() => {
              this.resizeIframe(this.iframe);
            }, 50);
            this.resizeIframe(this.iframe);
            const resizeObserver = new ResizeObserver((entries) => {
              for (let entry of entries) {
                resize();
              }
            });
            resizeObserver.observe(this.iframe);
            const iframe = this.iframe;
            this.onDarkModeToggle = (event) => {
              iframe.contentWindow.postMessage(event.detail, "*");
            };
            window.addEventListener("darkModeToggle", this.onDarkModeToggle);
          } catch (error) {
            console.error("Cannot access iframe content");
          }
        },
        // Adjusts the iframe height based on its content
        resizeIframe(iframe) {
          if (iframe) {
            try {
              const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document;
              if (iframeDocument) {
                const iframeBody = iframeDocument.body;
                if (!iframeBody) {
                  setInterval(() => {
                    this.resizeIframe(iframe);
                  }, 150);
                } else {
                  const newHeight = iframeBody.scrollHeight + 15;
                  iframe.style.height = newHeight + "px";
                }
              }
            } catch (error) {
              console.error("Error resizing iframe:", error);
            }
          }
        },
        // Debounce helper to limit function calls
        debounce(func, timeout = 300) {
          let timer;
          return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
              func.apply(this, args);
            }, timeout);
          };
        },
        destroy() {
          window.removeEventListener("darkModeToggle", this.onDarkModeToggle);
        }
      };
    });
  }
  function registerRzEmpty(Alpine2) {
    Alpine2.data("rzEmpty", () => {
    });
  }
  function registerRzHeading(Alpine2) {
    Alpine2.data("rzHeading", () => {
      return {
        observer: null,
        headingId: "",
        init() {
          this.headingId = this.$el.dataset.alpineRoot;
          const self2 = this;
          if (typeof this.setCurrentHeading === "function") {
            const callback = (entries, observer) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  self2.setCurrentHeading(self2.headingId);
                }
              });
            };
            const options = { threshold: 0.5 };
            this.observer = new IntersectionObserver(callback, options);
            this.observer.observe(this.$el);
          } else {
            console.warn("rzHeading: Could not find 'setCurrentHeading' function in parent scope.");
          }
        },
        destroy() {
          if (this.observer != null)
            this.observer.disconnect();
        }
      };
    });
  }
  function registerRzMarkdown(Alpine2, require2) {
    Alpine2.data("rzMarkdown", () => {
      return {
        init() {
          const assets = JSON.parse(this.$el.dataset.assets);
          const nonce = this.$el.dataset.nonce;
          require2(assets, {
            success: function() {
              window.hljs.highlightAll();
            },
            error: function() {
              console.error("Failed to load Highlight.js");
            }
          }, nonce);
        }
      };
    });
  }
  function registerRzModal(Alpine2) {
    Alpine2.data("rzModal", () => ({
      modalOpen: false,
      // Main state variable
      eventTriggerName: "",
      closeEventName: "rz:modal-close",
      // Default value, corresponds to Constants.Events.ModalClose
      closeOnEscape: true,
      closeOnClickOutside: true,
      modalId: "",
      bodyId: "",
      footerId: "",
      nonce: "",
      _escapeListener: null,
      _openListener: null,
      _closeEventListener: null,
      init() {
        this.modalId = this.$el.dataset.modalId || "";
        this.bodyId = this.$el.dataset.bodyId || "";
        this.footerId = this.$el.dataset.footerId || "";
        this.nonce = this.$el.dataset.nonce || "";
        this.eventTriggerName = this.$el.dataset.eventTriggerName || "";
        this.closeEventName = this.$el.dataset.closeEventName || this.closeEventName;
        this.closeOnEscape = this.$el.dataset.closeOnEscape !== "false";
        this.closeOnClickOutside = this.$el.dataset.closeOnClickOutside !== "false";
        this.$el.dispatchEvent(new CustomEvent("rz:modal-initialized", {
          detail: { modalId: this.modalId, bodyId: this.bodyId, footerId: this.footerId },
          bubbles: true
        }));
        if (this.eventTriggerName) {
          this._openListener = (e2) => {
            this.openModal(e2);
          };
          window.addEventListener(this.eventTriggerName, this._openListener);
        }
        this._closeEventListener = (event) => {
          if (this.modalOpen) {
            this.closeModalInternally("event");
          }
        };
        window.addEventListener(this.closeEventName, this._closeEventListener);
        this._escapeListener = (e2) => {
          if (this.modalOpen && this.closeOnEscape && e2.key === "Escape") {
            this.closeModalInternally("escape");
          }
        };
        window.addEventListener("keydown", this._escapeListener);
        this.$watch("modalOpen", (value) => {
          const currentWidth = document.body.offsetWidth;
          document.body.classList.toggle("overflow-hidden", value);
          const scrollBarWidth = document.body.offsetWidth - currentWidth;
          document.body.style.setProperty("--page-scrollbar-width", `${scrollBarWidth}px`);
          if (value) {
            this.$nextTick(() => {
              const dialogElement = this.$el.querySelector('[role="document"]');
              const focusable2 = dialogElement?.querySelector(`button, [href], input:not([type='hidden']), select, textarea, [tabindex]:not([tabindex="-1"])`);
              focusable2?.focus();
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-open", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          } else {
            this.$nextTick(() => {
              this.$el.dispatchEvent(new CustomEvent("rz:modal-after-close", {
                detail: { modalId: this.modalId },
                bubbles: true
              }));
            });
          }
        });
      },
      notModalOpen() {
        return !this.modalOpen;
      },
      destroy() {
        if (this._openListener && this.eventTriggerName) {
          window.removeEventListener(this.eventTriggerName, this._openListener);
        }
        if (this._closeEventListener) {
          window.removeEventListener(this.closeEventName, this._closeEventListener);
        }
        if (this._escapeListener) {
          window.removeEventListener("keydown", this._escapeListener);
        }
        document.body.classList.remove("overflow-hidden");
        document.body.style.setProperty("--page-scrollbar-width", `0px`);
      },
      openModal(event = null) {
        const beforeOpenEvent = new CustomEvent("rz:modal-before-open", {
          detail: { modalId: this.modalId, originalEvent: event },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeOpenEvent);
        if (!beforeOpenEvent.defaultPrevented) {
          this.modalOpen = true;
        }
      },
      // Internal close function called by button, escape, backdrop, event
      closeModalInternally(reason = "unknown") {
        const beforeCloseEvent = new CustomEvent("rz:modal-before-close", {
          detail: { modalId: this.modalId, reason },
          bubbles: true,
          cancelable: true
        });
        this.$el.dispatchEvent(beforeCloseEvent);
        if (!beforeCloseEvent.defaultPrevented) {
          document.activeElement?.blur && document.activeElement.blur();
          this.modalOpen = false;
          document.body.classList.remove("overflow-hidden");
          document.body.style.setProperty("--page-scrollbar-width", `0px`);
        }
      },
      // Called only by the explicit close button in the template
      closeModal() {
        this.closeModalInternally("button");
      },
      // Method called by x-on:click.outside on the dialog element
      handleClickOutside() {
        if (this.closeOnClickOutside) {
          this.closeModalInternally("backdrop");
        }
      }
    }));
  }
  function registerRzPrependInput(Alpine2) {
    Alpine2.data("rzPrependInput", () => {
      return {
        prependContainer: null,
        textInput: null,
        init() {
          this.prependContainer = this.$refs.prependContainer;
          this.textInput = this.$refs.textInput;
          let self2 = this;
          setTimeout(() => {
            self2.updatePadding();
          }, 50);
          window.addEventListener("resize", this.updatePadding);
        },
        destroy() {
          window.removeEventListener("resize", this.updatePadding);
        },
        updatePadding() {
          const prependDiv = this.prependContainer;
          const inputElem = this.textInput;
          if (!prependDiv || !inputElem) {
            if (inputElem) {
              inputElem.classList.remove("text-transparent");
            }
            return;
          }
          const prependWidth = prependDiv.offsetWidth;
          const leftPadding = prependWidth + 10;
          inputElem.style.paddingLeft = leftPadding + "px";
          inputElem.classList.remove("text-transparent");
        }
      };
    });
  }
  function registerRzProgress(Alpine2) {
    Alpine2.data("rzProgress", () => ({
      currentVal: 0,
      minVal: 0,
      maxVal: 100,
      percentage: 0,
      label: "",
      init() {
        const element = this.$el;
        this.currentVal = parseInt(element.getAttribute("data-current-val")) || 0;
        this.minVal = parseInt(element.getAttribute("data-min-val")) || 0;
        this.maxVal = parseInt(element.getAttribute("data-max-val")) || 100;
        this.label = element.getAttribute("data-label");
        this.calculatePercentage();
        element.setAttribute("aria-valuenow", this.currentVal);
        element.setAttribute("aria-valuemin", this.minVal);
        element.setAttribute("aria-valuemax", this.maxVal);
        element.setAttribute("aria-valuetext", `${this.percentage}%`);
        this.updateProgressBar();
        const resizeObserver = new ResizeObserver((entries) => {
          this.updateProgressBar();
        });
        resizeObserver.observe(element);
        this.$watch("currentVal", () => {
          this.calculatePercentage();
          this.updateProgressBar();
          element.setAttribute("aria-valuenow", this.currentVal);
          element.setAttribute("aria-valuetext", `${this.percentage}%`);
        });
      },
      calculatePercentage() {
        if (this.maxVal === this.minVal) {
          this.percentage = 0;
        } else {
          this.percentage = Math.min(Math.max((this.currentVal - this.minVal) / (this.maxVal - this.minVal) * 100, 0), 100);
        }
      },
      buildLabel() {
        var label = this.label || "{percent}%";
        this.calculatePercentage();
        return label.replace("{percent}", this.percentage);
      },
      buildInsideLabelPosition() {
        const progressBar = this.$refs.progressBar;
        const barLabel = this.$refs.progressBarLabel;
        const innerLabel = this.$refs.innerLabel;
        if (barLabel && progressBar && innerLabel) {
          innerLabel.innerText = this.buildLabel();
          if (barLabel.clientWidth > progressBar.clientWidth) {
            barLabel.style.left = progressBar.clientWidth + 10 + "px";
          } else {
            barLabel.style.left = progressBar.clientWidth / 2 - barLabel.clientWidth / 2 + "px";
          }
        }
      },
      getLabelCss() {
        const barLabel = this.$refs.progressBarLabel;
        const progressBar = this.$refs.progressBar;
        if (barLabel && progressBar && barLabel.clientWidth > progressBar.clientWidth) {
          return "text-foreground dark:text-foreground";
        }
        return "";
      },
      updateProgressBar() {
        const progressBar = this.$refs.progressBar;
        if (progressBar) {
          progressBar.style.width = `${this.percentage}%`;
          this.buildInsideLabelPosition();
        }
      },
      // Methods to set, increment, or decrement the progress value
      setProgress(value) {
        this.currentVal = value;
      },
      increment(val = 1) {
        this.currentVal = Math.min(this.currentVal + val, this.maxVal);
      },
      decrement(val = 1) {
        this.currentVal = Math.max(this.currentVal - val, this.minVal);
      }
    }));
  }
  function registerRzQuickReferenceContainer(Alpine2) {
    Alpine2.data("rzQuickReferenceContainer", () => {
      return {
        headings: [],
        // Array of heading IDs
        currentHeadingId: "",
        // ID of the currently highlighted heading
        // Initializes the component with headings and the initial current heading from data attributes.
        init() {
          this.headings = JSON.parse(this.$el.dataset.headings || "[]");
          this.currentHeadingId = this.$el.dataset.currentheadingid || "";
        },
        // Handles click events on quick reference links.
        handleHeadingClick() {
          const id = this.$el.dataset.headingid;
          window.requestAnimationFrame(() => {
            this.currentHeadingId = id;
          });
        },
        // Sets the current heading ID based on intersection observer events from rzHeading.
        setCurrentHeading(id) {
          if (this.headings.includes(id)) {
            this.currentHeadingId = id;
          }
        },
        // Provides CSS classes for a link based on whether it's the current heading.
        // Returns an object suitable for :class binding.
        getSelectedCss() {
          const id = this.$el.dataset.headingid;
          return {
            "font-bold": this.currentHeadingId === id
            // Apply 'font-bold' if current
          };
        },
        // Determines the value for the aria-current attribute.
        getSelectedAriaCurrent() {
          const id = this.$el.dataset.headingid;
          return this.currentHeadingId === id ? "true" : null;
        }
      };
    });
  }
  function registerRzTabs(Alpine2) {
    Alpine2.data("rzTabs", () => {
      return {
        buttonRef: null,
        tabSelected: "",
        tabButton: null,
        init() {
          this.buttonRef = document.getElementById(this.$el.dataset.buttonref);
          this.tabSelected = this.$el.dataset.tabselected;
          this.tabButton = this.buttonRef.querySelector("[data-name='" + this.tabSelected + "']");
          this.tabRepositionMarker(this.tabButton);
        },
        tabButtonClicked(tabButton) {
          if (tabButton instanceof Event)
            tabButton = tabButton.target;
          this.tabSelected = tabButton.dataset.name;
          this.tabRepositionMarker(tabButton);
          tabButton.focus();
        },
        tabRepositionMarker(tabButton) {
          this.tabButton = tabButton;
          this.$refs.tabMarker.style.width = tabButton.offsetWidth + "px";
          this.$refs.tabMarker.style.height = tabButton.offsetHeight + "px";
          this.$refs.tabMarker.style.left = tabButton.offsetLeft + "px";
          setTimeout(() => {
            this.$refs.tabMarker.style.opacity = 1;
          }, 150);
        },
        // Get the CSS classes for the tab content panel based on selection
        getTabContentCss() {
          return this.tabSelected === this.$el.dataset.name ? "" : "hidden";
        },
        tabContentActive(tabContent) {
          tabContent = tabContent ?? this.$el;
          return this.tabSelected === tabContent.dataset.name;
        },
        tabButtonActive(tabButton) {
          tabButton = tabButton ?? this.$el;
          return this.tabSelected === tabButton.dataset.name;
        },
        // Get the value for the aria-selected attribute
        getTabButtonAriaSelected() {
          return this.tabSelected === this.$el.dataset.name ? "true" : "false";
        },
        // Get the CSS classes for the tab button text color based on selection
        getSelectedTabTextColorCss() {
          const color = this.$el.dataset.selectedtextcolor ?? "";
          return this.tabSelected === this.$el.dataset.name ? color : "";
        },
        handleResize() {
          this.tabRepositionMarker(this.tabButton);
        },
        handleKeyDown(event) {
          const key = event.key;
          const tabButtons = Array.from(this.buttonRef.querySelectorAll("[role='tab']"));
          const currentIndex = tabButtons.findIndex((button) => this.tabSelected === button.dataset.name);
          let newIndex = currentIndex;
          if (key === "ArrowRight") {
            newIndex = (currentIndex + 1) % tabButtons.length;
            event.preventDefault();
          } else if (key === "ArrowLeft") {
            newIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;
            event.preventDefault();
          } else if (key === "Home") {
            newIndex = 0;
            event.preventDefault();
          } else if (key === "End") {
            newIndex = tabButtons.length - 1;
            event.preventDefault();
          }
          if (newIndex !== currentIndex) {
            this.tabButtonClicked(tabButtons[newIndex]);
          }
        }
      };
    });
  }
  function registerRzSidebar(Alpine2) {
    Alpine2.data("rzSidebar", () => {
      return {
        showSidebar: false,
        isSidebarHidden() {
          return !this.showSidebar;
        },
        toggleSidebar() {
          this.showSidebar = !this.showSidebar;
        },
        hideSidebar() {
          this.showSidebar = false;
        },
        // Return translation classes based on sidebar state for smooth slide-in/out
        getSidebarTranslation() {
          return this.showSidebar ? "translate-x-0" : "-translate-x-60";
        }
      };
    });
  }
  function registerRzSidebarLinkItem(Alpine2) {
    Alpine2.data("rzSidebarLinkItem", () => {
      return {
        isExpanded: false,
        chevronExpandedClass: "",
        chevronCollapsedClass: "",
        init() {
          this.isExpanded = this.$el.dataset.expanded === "true";
          this.chevronExpandedClass = this.$el.dataset.chevronExpandedClass;
          this.chevronCollapsedClass = this.$el.dataset.chevronCollapsedClass;
        },
        isCollapsed() {
          return !this.isExpanded;
        },
        toggleExpanded() {
          this.isExpanded = !this.isExpanded;
        },
        hideSidebar() {
          const sidebarScope = this.$el.closest('[x-data^="rzSidebar"]');
          if (sidebarScope) {
            let data = Alpine2.$data(sidebarScope);
            data.showSidebar = false;
          } else {
            console.warn("Parent sidebar context not found or 'showSidebar' is not defined.");
          }
        },
        getExpandedClass() {
          return this.isExpanded ? this.chevronExpandedClass : this.chevronCollapsedClass;
        },
        // Get the value for the aria-expanded attribute
        getAriaExpanded() {
          return this.isExpanded ? "true" : "false";
        }
      };
    });
  }
  async function generateBundleId(paths) {
    paths = [...paths].sort();
    const joinedPaths = paths.join("|");
    const encoder = new TextEncoder();
    const data = encoder.encode(joinedPaths);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  function rizzyRequire(paths, callbackFn, nonce) {
    generateBundleId(paths).then((bundleId) => {
      if (!loadjs.isDefined(bundleId)) {
        loadjs(
          paths,
          bundleId,
          {
            async: false,
            inlineScriptNonce: nonce,
            inlineStyleNonce: nonce
          }
        );
      }
      loadjs.ready([bundleId], callbackFn);
    });
  }
  function registerComponents(Alpine2) {
    registerRzAccordion(Alpine2);
    registerRzAccordionSection(Alpine2);
    registerRzAlert(Alpine2);
    registerRzBrowser(Alpine2);
    registerRzCheckboxGroupItem(Alpine2);
    registerRzCodeViewer(Alpine2, rizzyRequire);
    registerRzDateEdit(Alpine2, rizzyRequire);
    registerRzDropdown(Alpine2);
    registerRzDarkModeToggle(Alpine2);
    registerRzEmbeddedPreview(Alpine2);
    registerRzEmpty(Alpine2);
    registerRzHeading(Alpine2);
    registerRzMarkdown(Alpine2, rizzyRequire);
    registerRzModal(Alpine2);
    registerRzPrependInput(Alpine2);
    registerRzProgress(Alpine2);
    registerRzQuickReferenceContainer(Alpine2);
    registerRzTabs(Alpine2);
    registerRzSidebar(Alpine2);
    registerRzSidebarLinkItem(Alpine2);
  }
  function $data(idOrElement) {
    if (typeof Alpine === "undefined" || typeof Alpine.$data !== "function") {
      console.error(
        "$data helper: Alpine.js context (Alpine.$data) is not available. Ensure Alpine is loaded and initialized globally before use."
      );
      return void 0;
    }
    let outerElement = null;
    let componentId = null;
    if (typeof idOrElement === "string") {
      if (!idOrElement) {
        console.warn("Rizzy.$data: Invalid componentId provided (empty string).");
        return void 0;
      }
      componentId = idOrElement;
      outerElement = document.getElementById(componentId);
      if (!outerElement) {
        console.warn(`Rizzy.$data: Rizzy component with ID "${componentId}" not found in the DOM.`);
        return void 0;
      }
    } else if (idOrElement instanceof Element) {
      outerElement = idOrElement;
      if (!outerElement.id) {
        console.warn("Rizzy.$data: Provided element does not have an ID attribute, which is required for locating the data-alpine-root.");
        return void 0;
      }
      componentId = outerElement.id;
    } else {
      console.warn("Rizzy.$data: Invalid input provided. Expected a non-empty string ID or an Element object.");
      return void 0;
    }
    const alpineRootSelector = `[data-alpine-root="${componentId}"]`;
    let alpineRootElement = null;
    if (outerElement.matches(alpineRootSelector)) {
      alpineRootElement = outerElement;
    } else {
      alpineRootElement = outerElement.querySelector(alpineRootSelector);
    }
    if (!alpineRootElement) {
      console.warn(
        `Rizzy.$data: Could not locate the designated Alpine root element using selector "${alpineRootSelector}" on or inside the wrapper element (ID: #${componentId}). Verify the 'data-alpine-root' attribute placement.`
      );
      return void 0;
    }
    const alpineData = Alpine.$data(alpineRootElement);
    if (alpineData === void 0) {
      const targetDesc = `${alpineRootElement.tagName.toLowerCase()}${alpineRootElement.id ? "#" + alpineRootElement.id : ""}${alpineRootElement.classList.length ? "." + Array.from(alpineRootElement.classList).join(".") : ""}`;
      console.warn(
        `Rizzy.$data: Located designated Alpine root (${targetDesc}) via 'data-alpine-root="${componentId}"', but Alpine.$data returned undefined. Ensure 'x-data' is correctly defined and initialized on this element.`
      );
    }
    return alpineData;
  }
  Alpine$1.plugin(module_default$2);
  Alpine$1.plugin(module_default$1);
  Alpine$1.plugin(module_default);
  registerComponents(Alpine$1);
  const RizzyUI = {
    Alpine: Alpine$1,
    require: rizzyRequire,
    toast: Toast,
    $data
  };
  window.Alpine = Alpine$1;
  window.Rizzy = { ...window.Rizzy || {}, ...RizzyUI };
  Alpine$1.start();
  return RizzyUI;
});
//# sourceMappingURL=rizzyui.umd.js.map
</file>

<file path="wwwroot/js/safelist.js">
module.exports = ["pointer-events-none","collapse","invisible","visible","sr-only","absolute","fixed","relative","static","sticky","inset-0","inset-y-0","top-0","top-1/2","top-2.5","top-4","top-16","right-0","right-4","right-full","bottom-0","bottom-8","bottom-full","left-0","left-1/2","left-3","left-full","isolate","z-0","z-1","z-10","z-20","z-30","z-40","z-50","z-60","z-[10004]","container","-mx-1","mx-2","mx-auto","-my-4","my-3","my-4","my-5","my-8","my-auto","my-px","ms-2","me-2","prose","prose-xl","mt-1","mt-2","mt-4","mt-16","mr-1","mr-2","mr-4","mr-auto","mb-1","mb-2","mb-3","mb-4","mb-5","mb-10","ml-0","ml-2","ml-4","ml-8","ml-12","ml-auto","ml-px","block","contents","flex","grid","hidden","inline","inline-block","inline-flex","inline-grid","list-item","table","table-cell","table-footer-group","table-header-group","aspect-square","size-3","size-4","size-5","size-6","size-7","size-8","size-10","size-14","size-20","h-0.5","h-2.5","h-4","h-5","h-7","h-8","h-10","h-11","h-16","h-96","h-full","h-px","max-h-60","max-h-[400px]","min-h-28","w-0.5","w-1/2","w-1/3","w-4","w-5","w-48","w-56","w-60","w-64","w-72","w-80","w-[3.25rem]","w-fit","w-full","w-max","w-min","w-screen","max-w-2xl","max-w-3xl","max-w-4xl","max-w-5xl","max-w-6xl","max-w-7xl","max-w-lg","max-w-md","max-w-none","max-w-prose","max-w-sm","max-w-xl","max-w-xs","flex-1","flex-none","flex-shrink","shrink-0","flex-grow","grow","border-collapse","origin-bottom","origin-bottom-left","origin-bottom-right","origin-center","origin-left","origin-right","origin-top","origin-top-left","origin-top-right","-translate-x-1/2","-translate-x-60","translate-x-0","-translate-y-1/2","translate-y-0","translate-y-2","scale-50","scale-90","scale-100","scale-125","!rotate-180","rotate-0","rotate-180","transform","animate-ping","cursor-not-allowed","cursor-pointer","resize","appearance-none","grid-cols-1","grid-cols-2","grid-cols-3","grid-cols-4","grid-cols-5","grid-cols-6","grid-cols-7","grid-cols-8","grid-cols-9","grid-cols-10","grid-cols-11","grid-cols-12","flex-col","flex-row","flex-wrap","content-center","items-center","items-start","justify-between","justify-center","justify-end","justify-start","gap-0","gap-1","gap-1.5","gap-2","gap-3","gap-4","gap-14","space-y-1","space-y-6","-space-x-px","space-x-0.5","space-x-2","space-x-3","divide-y","divide-gray-100","divide-outline","self-start","truncate","overflow-auto","overflow-hidden","overflow-x-auto","overflow-x-hidden","overflow-y-auto","overflow-y-hidden","rounded","rounded-2xl","rounded-full","rounded-lg","rounded-md","rounded-none","rounded-sm","rounded-theme","rounded-xl","rounded-t-none","rounded-t-theme","rounded-l-lg","rounded-l-theme","rounded-r-lg","!rounded-b-none","rounded-b","rounded-b-none","rounded-b-theme","rounded-b-xl","border","border-0","border-2","border-x","border-t","border-t-0","border-r","border-b","border-b-0","border-b-1","border-l","border-l-0","border-dashed","border-dotted","border-none","border-solid","border-destructive","border-gray-200","border-info","border-foreground","border-foreground","border-outline","border-outline-strong","border-primary","border-secondary","border-slate-300","border-success","border-surface","border-surface-tertiary/70","border-transparent","border-warning","border-white","bg-black","bg-blue-200","bg-blue-500","bg-blue-600","bg-destructive","bg-destructive/10","bg-destructive/15","bg-emerald-200","bg-emerald-800","bg-gray-50","bg-gray-100","bg-gray-300","bg-gray-400","bg-green-500","bg-indigo-200","bg-indigo-700","bg-info","bg-info/10","bg-info/15","bg-neutral-100","bg-destructive-foreground","bg-primary-foreground","bg-secondary-foreground","bg-success-foreground","bg-foreground","bg-foreground","bg-warning-foreground","bg-orange-200","bg-orange-500","bg-outline","bg-outline-strong","bg-outline/10","bg-pink-200","bg-pink-500","bg-primary","bg-primary/10","bg-purple-200","bg-purple-600","bg-red-200","bg-red-500","bg-rose-500","bg-secondary","bg-secondary/10","bg-slate-900","bg-success","bg-success/10","bg-success/15","bg-background","bg-secondary","bg-secondary/10","bg-secondary/15","bg-secondary/40","bg-secondary/75","bg-accent","bg-background/10","bg-background/75","bg-teal-200","bg-teal-600","bg-transparent","bg-warning","bg-warning/10","bg-warning/15","bg-white","bg-yellow-300","bg-yellow-500","bg-gradient-to-r","from-primary","to-secondary","mask-repeat","fill-destructive","fill-info","fill-destructive-foreground","fill-info-foreground","fill-primary-foreground","fill-secondary-foreground","fill-success-foreground","fill-foreground","fill-foreground","fill-warning-foreground","fill-outline","fill-outline-strong","fill-primary","fill-secondary","fill-success","fill-surface","fill-secondary","fill-warning","object-cover","p-0.5","p-1","p-2","p-2.5","p-4","p-5","p-6","p-8","p-px","px-1","px-1.5","px-2","px-2.5","px-3","px-4","px-5","px-6","px-8","py-0.5","py-1","py-1.5","py-2","py-3","py-4","ps-14","pt-2","pt-3","pr-0","pr-1","pr-2","pr-8","pb-1","pb-2","pb-5","pb-6","pl-0","pl-2","pl-3","pl-4","text-center","text-justify","text-left","text-right","text-2xl","text-3xl","text-4xl","text-5xl","text-base","text-base/7","text-lg","text-sm","text-xl","text-xs","leading-5","leading-6","leading-loose","leading-none","leading-normal","leading-relaxed","leading-snug","leading-tight","font-bold","font-extrabold","font-light","font-medium","font-normal","font-semibold","font-thin","tracking-wide","text-pretty","break-all","whitespace-nowrap","text-blue-600","text-blue-700","text-destructive","text-emerald-500","text-emerald-700","text-gray-300","text-gray-500","text-gray-600","text-gray-700","text-indigo-700","text-info","text-destructive-foreground","text-info-foreground","text-primary-foreground","text-secondary-foreground","text-success-foreground","text-foreground","text-muted-foreground","text-foreground","text-foreground-tertiary","text-foreground/60","text-warning-foreground","text-orange-700","text-outline","text-outline-strong","text-pink-700","text-primary","text-purple-700","text-red-600","text-red-700","text-rose-500","text-secondary","text-slate-400","text-success","text-surface","text-secondary","text-teal-700","text-transparent","text-warning","text-white","text-yellow-800","capitalize","lowercase","normal-case","uppercase","italic","ordinal","line-through","no-underline","overline","underline","underline-offset-2","placeholder-gray-500","placeholder-foreground","placeholder-muted-foreground","opacity-0","opacity-25","opacity-50","opacity-60","opacity-100","shadow","shadow-lg","shadow-sm","shadow-xl","ring","ring-1","ring-2","ring-black","ring-outline-strong","ring-primary","outline","outline-2","outline-offset-2","blur","invert","filter","filter!","backdrop-blur-sm","backdrop-blur-xl","backdrop-blur-xs","backdrop-brightness-75","transition","transition-all","transition-colors","transition-opacity","transition-transform","duration-75","duration-100","duration-150","duration-200","duration-300","ease-in","ease-in-out","ease-out","forced-color-adjust-auto","select-none","group-hover:border-primary","group","group-hover:opacity-50","peer-checked:scale-100","peer","peer-checked:border-primary","peer-checked:bg-secondary","peer-checked:opacity-100","peer-focus:ring","peer-focus:ring-primary","before:me-6","before:inline-block","before:size-6","before:flex-1","before:translate-x-0","before:transform","before:rounded-full","before:border-t","before:border-dashed","before:border-dotted","before:border-solid","before:border-outline","before:bg-primary-foreground","before:shadow","before:ring-0","before:transition","before:duration-200","before:ease-in-out","after:absolute","after:bottom-0","after:left-0","after:ms-6","after:h-0.5","after:w-full","after:flex-1","after:border-t","after:border-dashed","after:border-dotted","after:border-solid","after:border-outline","after:bg-destructive","after:bg-info","after:bg-destructive-foreground","after:bg-info-foreground","after:bg-primary-foreground","after:bg-secondary-foreground","after:bg-success-foreground","after:bg-foreground","after:bg-foreground","after:bg-warning-foreground","after:bg-outline","after:bg-outline-strong","after:bg-primary","after:bg-secondary","after:bg-success","after:bg-background","after:bg-secondary","after:bg-warning","first:mt-2","first:rounded-l-theme","last:rounded-r-theme","last:rounded-b-lg","checked:border-primary","checked:bg-primary","checked:bg-none","checked:text-primary","checked:before:translate-x-full","checked:before:bg-primary-foreground","hover:border-l-2","hover:border-outline","hover:border-outline-strong","hover:bg-gray-100","hover:bg-primary/5","hover:bg-primary/10","hover:bg-primary/90","hover:bg-secondary","hover:bg-secondary/50","hover:bg-secondary/75","hover:bg-background/10","hover:text-black","hover:text-primary-foreground","hover:text-foreground","hover:text-primary","hover:underline","hover:opacity-75","hover:shadow-sm","focus:z-10","focus:border-primary","focus:underline","focus:ring","focus:ring-2","focus:ring-3","focus:ring-primary","focus:ring-primary/25","focus:ring-primary/50","focus:outline-hidden","focus:outline-offset-0","focus:outline-none","focus:checked:border-primary","focus-visible:rounded-t-none","focus-visible:border-2","focus-visible:border-primary","focus-visible:bg-primary/10","focus-visible:bg-secondary/75","focus-visible:text-foreground","focus-visible:underline","focus-visible:ring-2","focus-visible:ring-destructive","focus-visible:ring-info","focus-visible:ring-primary","focus-visible:ring-secondary","focus-visible:ring-success","focus-visible:ring-warning","focus-visible:ring-offset-2","focus-visible:outline-hidden","focus-visible:outline-2","focus-visible:outline-destructive","focus-visible:outline-info","focus-visible:outline-foreground","focus-visible:outline-outline","focus-visible:outline-primary","focus-visible:outline-secondary","focus-visible:outline-success","focus-visible:outline-surface","focus-visible:outline-secondary","focus-visible:outline-warning","focus-visible:outline-none","active:scale-90","active:border-outline","active:opacity-100","active:shadow-none","active:-outline-offset-2","disabled:pointer-events-none","disabled:cursor-not-allowed","disabled:opacity-50","disabled:opacity-75","aria-[current=page]:z-10","aria-[current=page]:ring-2","aria-[current=page]:ring-primary","motion-safe:animate-spin","motion-safe:transition-transform","motion-reduce:animate-none","motion-reduce:transition-none","sm:inline","sm:flex-row","sm:items-center","sm:justify-between","sm:bg-red-500","sm:text-left","sm:text-2xl","sm:text-base","sm:text-lg","sm:text-sm","sm:text-xl","md:-my-4","md:flex","md:hidden","md:w-1/2","md:w-1/3","md:w-60","md:flex-none","md:translate-x-0","md:flex-row","md:items-center","md:gap-2","md:space-x-5","md:p-6","md:pl-60","md:text-2xl","md:text-3xl","md:text-lg","md:text-xl","lg:prose-xl","lg:flex","lg:p-8","lg:py-1.5","lg:text-2xl","lg:text-3xl","lg:text-4xl","xl:flex","xl:pr-48","xl:pr-56","xl:pr-64","xl:pr-72","xl:pr-80","dark:divide-gray-700","dark","dark:divide-outline","dark:border-destructive","dark:border-gray-600","dark:border-info","dark:border-outline","dark:border-primary","dark:border-slate-700","dark:border-success","dark:border-transparent","dark:border-warning","dark:bg-destructive","dark:bg-destructive/10","dark:bg-emerald-800","dark:bg-gray-700","dark:bg-gray-800","dark:bg-gray-900/50","dark:bg-info","dark:bg-info/10","dark:bg-neutral-700","dark:bg-outline","dark:bg-primary","dark:bg-success","dark:bg-success/10","dark:bg-background","dark:bg-secondary","dark:bg-background/10","dark:bg-warning","dark:bg-warning/10","dark:text-destructive","dark:text-gray-300","dark:text-gray-400","dark:text-gray-500","dark:text-info","dark:text-destructive-foreground","dark:text-info-foreground","dark:text-primary-foreground","dark:text-success-foreground","dark:text-foreground","dark:text-muted-foreground","dark:text-foreground","dark:text-warning-foreground","dark:text-outline","dark:text-primary","dark:text-red-400","dark:text-secondary","dark:text-success","dark:text-warning","dark:placeholder-gray-400","dark:placeholder-muted-foreground","dark:shadow-gray-900","dark:ring-gray-700","dark:ring-offset-gray-900","dark:ring-offset-surface","dark:prose-invert","dark:peer-checked:border-primary","dark:peer-checked:bg-primary","dark:peer-checked:bg-secondary","dark:before:border-outline","dark:before:bg-primary-foreground","dark:after:border-outline","dark:checked:border-primary","dark:checked:border-transparent","dark:checked:bg-primary","dark:checked:before:bg-primary-foreground","dark:hover:border-outline","dark:hover:border-outline-strong","dark:hover:bg-primary/5","dark:hover:bg-secondary","dark:hover:bg-secondary/50","dark:hover:bg-secondary/75","dark:hover:bg-background/5","dark:hover:bg-background/10","dark:hover:text-foreground","dark:hover:text-white","dark:focus:border-primary","dark:focus:ring-primary","dark:focus:ring-primary/40","dark:focus:ring-offset-neutral-600","dark:focus:ring-offset-surface","dark:focus-visible:border-primary","dark:focus-visible:bg-primary/10","dark:focus-visible:bg-secondary/75","dark:focus-visible:bg-background/10","dark:focus-visible:text-foreground","dark:focus-visible:ring-destructive","dark:focus-visible:ring-info","dark:focus-visible:ring-primary","dark:focus-visible:ring-secondary","dark:focus-visible:ring-success","dark:focus-visible:ring-warning","dark:focus-visible:ring-offset-secondary","dark:focus-visible:outline-destructive","dark:focus-visible:outline-info","dark:focus-visible:outline-foreground","dark:focus-visible:outline-outline","dark:focus-visible:outline-primary","dark:focus-visible:outline-secondary","dark:focus-visible:outline-success","dark:focus-visible:outline-surface","dark:focus-visible:outline-secondary","dark:focus-visible:outline-warning","dark:active:border-outline","sn-notifications-container","sn-is-x-center","sn-is-y-center","sn-is-center","sn-is-left","sn-is-right","sn-is-top","sn-is-bottom","sn-notify","sn-notify-icon","sn-notify-close","sn-notify-title","sn-notify-text","sn-notify-outline","sn-notify-success","sn-notify-error","sn-notify-warning","sn-notify-info","sn-notify-filled","sn-notify-fade","sn-notify-fade-in","sn-notify-slide","sn-notify-slide-in","sn-notify-autoclose","form-children-spacing","validation-errors","field-validation-error","input-validation-error","input-validation-valid","validation-summary-errors","validation-summary-valid","prose-compact","prose-comfortable","prose-relaxed","prose-wide","prose-ultrawide","prose-full","scrollbar-hover","grid-pattern"];
</file>

</files>

<instruction>
﻿# RizzyUI LLM-Authoring Guide

**Fully expanded specification for code-generation models — May 2025, rev 2.4**

---

## 0. Why this file exists

This guide is a **contract for any large-language model**—ChatGPT, Claude, Gemini, Azure OpenAI, etc.—that emits source code destined for the **RizzyUI** repository.
If the model follows every rule, a maintainer can:

1. Paste the generated files into `src/RizzyUI/…`.
2. Apply the indicated cross-file edits (see § 14).
3. Run `dotnet build`.

The solution should compile, pass unit tests, and conform to RizzyUI’s conventions **without manual tweaks**.

---

## 1. Output-file syntax (mandatory for new or replacement files)

When the user requests code, wrap each file in a single **`output` block** so automation scripts know where to save it.

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">
  <!-- Razor markup -->
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">
  // C# code-behind
  </file>

  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">
  // Tailwind style provider
  </file>
</files>
```
````

* Never nest `<files>` elements.
* Always close every `<file>` tag.
* If no new files are needed, **omit** the `output` block entirely.

---

## 2. Root element pattern (in every `.razor` file)

```razor
<HtmlElement Element="@EffectiveElement"
             id="@Id"
             class="@RootClass()"
             @attributes="@AdditionalAttributes">
    @* Optional content here, like an Alpine child-container *@
</HtmlElement>
```

* `Element="@EffectiveElement"` keeps the tag overridable (default "div" in `RzComponent`).
* `@Id` is required for HTMX, Alpine, and tests.
* `@RootClass()` is supplied by `RootClass()` in code-behind.
* **Always** write `@attributes="@AdditionalAttributes"` (note the leading `@`).
* **Never** use @* *@ comments inside Razor markup for elements that will be rendered.
* To change the `Element` type, override `OnInitialized()` in the code-behind. Set Element to the new type only if Element is empty or null.
```csharp
        if (string.IsNullOrEmpty(Element))
            Element = "nav";
``` 

---

## 3. `.razor` File Guidelines

*   **Namespace:** Add `@namespace RizzyUI`.
*   **Inheritance:** Add `@inherits RzComponent` (or appropriate base like `RzTypographyBase`).
*   **Root Element:** Use the pattern in §2.
*   **CSS Classes for Internal Elements:**
    *   For HTML elements *inside* the root element, access theme styles **directly** in their `class` attribute:
        *   Static styles: `class="@Theme.RzComponentName.InternalElementStyle"`
        *   Dynamic styles: `class="@Theme.RzComponentName.GetInternalElementVariantCss(Parameter)"`
        *   Combine with other static classes or conditional Alpine classes as needed.
    *   Refer to §6 for Tailwind 4 and semantic token usage.
*   **Alpine Integration:** See §10 for the Alpine child-container convention if Alpine is used.
*   **Accessibility:** Refer to §8 for accessibility guidelines.
*   **Localization:** Refer to §9 for localization guidelines.

---

## 4. Code-behind skeleton (`.razor.cs`)

```csharp
// src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs
using Microsoft.AspNetCore.Components;
using RizzyUI.Extensions;
using Blazicons;
// Add other necessary using statements

namespace RizzyUI;

/// <summary>
/// Brief description of RzFancyThing and its purpose.
/// </summary>
public partial class RzFancyThing : RzComponent
{
    /// <summary>
    /// Gets or sets the content to be rendered inside the component.
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Gets or sets an optional leading icon for the component.
    /// </summary>
    [Parameter] public SvgIcon? LeadingIcon { get; set; }

    /// <summary>
    /// Gets or sets the size of the component. Defaults to Medium.
    /// </summary>
    [Parameter] public Size Size { get; set; } = Size.Medium;

    /// <summary>
    /// Gets or sets a value indicating whether the component is active.
    /// </summary>
    [Parameter] public bool IsActive { get; set; }

    /// <summary>
    /// Gets or sets the ARIA label for the component, providing an accessible name.
    /// If not set, a default localized label may be applied.
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        // Set Element = "button"; or other specific tag if not a div
        // Initialize AriaLabel with localized default if not provided by user (see §9)
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-apply default localized AriaLabel if AriaLabel parameter becomes null
        // Example: AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
    }

    /// <inheritdoc/>
    protected override string? RootClass()
    {
        var s = Theme.RzFancyThing; // Access the specific style provider for this component
        return TwMerge.Merge(
            AdditionalAttributes,
            s.Container,             // Base style from the provider
            s.GetSizeCss(Size),      // Dynamic style from the provider
            IsActive ? s.Active : null // Conditional style from the provider
        );
    }

    /// <summary>Assets that must load before the Alpine module (if any) boots.</summary>
    public static readonly string[] DefaultAssets =
    {
        // Example: Constants.ContentUrl("js/rzfancything.js")
        // If no JS, make this an empty array: = Array.Empty<string>();
    };

    // Other component logic, event callbacks, etc.
}
```

Important for the LLM:

* Start with `/// <summary>...</summary>` for the class.
* **All** public members get `<summary>` XML docs.
* Icons are passed as `SvgIcon?`; render with `<Blazicon Svg="@LeadingIcon" … />`.
* Use `TwMerge.Merge(...)`; never concatenate class strings manually in `RootClass()`.
* Default `Element` to "div" unless overridden in `OnInitialized()`.
* If `DefaultAssets` are not needed, initialize as `public static readonly string[] DefaultAssets = Array.Empty<string>();`.
* Include an `AriaLabel` parameter and initialize it with a localized default if not set by the user (see §9).

---

## 5. Icon-passing protocol

```razor
@* Inside RzFancyThing.razor *@
@if (LeadingIcon is not null)
{
    <Blazicon Svg="@LeadingIcon"
              class="@Theme.RzFancyThing.IconStyle"
              aria-hidden="true" /> @* Icons are often decorative *@
}
```

* Accept icons as `SvgIcon?`.
* Parameter names must be `LeadingIcon` or `TrailingIcon` as appropriate.
* Style the `<Blazicon>` using direct theme access in its `class` attribute.
* Add `aria-hidden="true"` if the icon is purely decorative and its meaning is conveyed by adjacent text or the component's `aria-label`.

---

## 6. Using Tailwind 4 with the RizzyUI Theme System

RizzyUI ships its own **Tailwind 4 plugin** (`/packages/rizzyui/src/css/rizzyui-plugin.css`).
That file defines a palette of **CSS custom-property tokens** (surface, on-surface, primary, etc.) plus a `@variant dark` block that swaps token values when `.dark` is present on `html` or any ancestor.

### 6.1 Semantic tokens, not raw palette colors

You never hard-code `text-blue-600` or `bg-slate-900` in a component.
Instead you write utilities that reference the semantic tokens shipped by the plugin:

```
bg-background
text-foreground
hover:bg-secondary
ring-outline-strong
```

Because the **token names stay identical** across light and dark modes, you do **not** need `dark:` prefixes for these semantic tokens:

```html
<span class="text-foreground">Works in both themes</span>
```

Tailwind expands that to:

```css
.text-foreground { color: var(--color-foreground); }
```

and the plugin’s `@variant dark` ensures `--color-foreground` swaps automatically.

### 6.2 Where utilities live

* **Component markup (`.razor`)** should be free of presentation classes except for small, internal layout helpers (`flex`, `gap-2`, etc.).
* **All root and variant styles** belong in a **style-provider object** (see §7) so end users can swap them out.

Example provider properties:

```csharp
public override string Container  =>
    "inline-flex items-center rounded-full px-3 py-1 bg-background text-foreground";

public override string Active     =>
    "ring-2 ring-primary";

public override string IconStyle  =>
    "size-5 text-muted-foreground";
```

### 6.3 TwMerge: the required glue

Use the injected `TwMerge.Merge(attributes, class1, class2, …)` in the `RootClass()` method of your `.razor.cs` file to combine:

```csharp
// In RzFancyThing.razor.cs
protected override string? RootClass()
{
    var s = Theme.RzFancyThing;
    return TwMerge.Merge(
        AdditionalAttributes,    // User-supplied classes (e.g., from <RzFancyThing class="mt-4">)
        s.Container,             // Base classes from the style provider
        s.GetSizeCss(Size),      // Dynamic classes based on parameters
        IsActive ? s.Active : null // Conditional classes
    );
}
```

TwMerge deduplicates utilities and correctly appends any user-supplied `class` from `AdditionalAttributes`.

### 6.4 Defining size / variant helpers in Style Providers

Enums for variants (like `Size`, `ButtonVariant`) should be defined globally in RizzyUI (e.g., `RizzyUI/Components/Variants.cs`).
Style provider methods (`GetSizeCss`, `GetVariantCss`) take these enums.

```csharp
// In DefaultRzFancyThingStyles.cs
public override string GetSizeCss(Size sz) => sz switch // Using global 'Size' enum
{
    Size.Small => "text-xs py-1 px-2",    // Assuming 'Small' is part of the global 'Size' enum
    Size.Medium => "text-sm py-2 px-3",   // Assuming 'Medium' is part of the global 'Size' enum
    Size.Large => "text-base py-3 px-4",  // Assuming 'Large' is part of the global 'Size' enum
    _             => "text-sm py-2 px-3" // Default case
};
```

### 6.5 Overriding in a custom theme

A consumer can replace the default style provider inside their own `Theme` subclass:

```csharp
public sealed class MyTheme : RzTheme
{
    public MyTheme() : base("MyTheme", "my-theme")
    {
        // Assuming RzFancyThing is the property name in RzTheme for RzFancyThingStylesBase
        RzFancyThing = new MyFancyThingStyles(this);
    }
}

public sealed class MyFancyThingStyles : DefaultRzFancyThingStyles // Or RzStylesBase.RzFancyThingStylesBase
{
    public MyFancyThingStyles(RzTheme t) : base(t) { }

    public override string Container =>
        "inline-flex gap-2 rounded-md px-4 py-2 "
      + "bg-gradient-to-r from-primary to-secondary text-primary-foreground"; // Still uses semantic tokens
}
```

Because all classes still use the plugin’s semantic tokens (like `from-primary`, `text-primary-foreground`), light/dark support is automatic.

### 6.6 No purge / safelist step needed

Tailwind 4’s JIT engine and the RizzyUI build process handle class discovery. Any utility string that appears in a style provider or `.razor` file is automatically retained.

---

## 7. Styling providers (`RzStylesBase`, `Default...Styles.cs`)

1.  **Abstract base** goes into `src/RizzyUI/Styles/RzStylesBase.cs` (add a new nested class):

   ```csharp
   // In RzStylesBase.cs
   public abstract partial class RzStylesBase
   {
       public abstract class RzFancyThingStylesBase
       {
           protected RzFancyThingStylesBase(RzTheme theme) { Theme = theme; }
           protected RzTheme Theme { get; }

           public abstract string Container { get; }
           public abstract string Active { get; }
           public abstract string IconStyle { get; }

           public abstract string GetSizeCss(Size sz); // Using global Size enum
       }
   }
   ```

2.  **Default implementation** (e.g., `src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs`):

   ```csharp
   // In DefaultRzFancyThingStyles.cs
   namespace RizzyUI;

   public sealed class DefaultRzFancyThingStyles : RzStylesBase.RzFancyThingStylesBase
   {
       public DefaultRzFancyThingStyles(RzTheme theme) : base(theme) { }

       public override string Container => "inline-flex items-center rounded-full px-3 py-1 bg-background text-foreground"; // Uses semantic tokens
       public override string Active => "ring-2 ring-primary"; // Uses semantic token
       public override string IconStyle => "size-5 text-muted-foreground"; // Uses semantic token

       public override string GetSizeCss(Size sz) => sz switch // Using global Size enum
       {
           Size.Small => "text-xs",
           Size.Medium => "text-sm",
           Size.Large => "text-base",
           _ => "text-sm"
       };
   }
   ```

> **Why the constructor parameter?**
> Passing `RzTheme theme` lets any style object consult **other** style providers (`theme.RzButton`, etc.), enabling cross-component consistency. Properties in the abstract base should typically be `abstract string` or `abstract/virtual string Get...Css()` to enforce implementation by themes.

---

## 8. Accessibility Best Practices

Ensuring components are accessible is paramount. LLMs must generate components that strive to adhere to WCAG standards where applicable.

*   **Semantic HTML:**
    *   Use the most appropriate HTML element for the component's role. The `Element` property in `RzComponent` (defaulting to "div") should be overridden in `OnInitialized()` if a more semantic tag like `<nav>`, `<button>`, `<aside>`, etc., is suitable.
    *   Example: A navigation component should use `<nav>`, a button should use `<button>` or `<a>` with `role="button"`.

*   **ARIA Attributes:**
    *   **Roles:** Apply appropriate `role` attributes (e.g., `role="alert"`, `role="dialog"`, `role="menuitem"`, `role="tab"`, `role="switch"`). The root element pattern in §2 can have its `role` set via `AdditionalAttributes` or directly if static.
    *   **Labels & Descriptions:**
        *   Every interactive component MUST have an accessible name. This is typically provided via an `AriaLabel` parameter in the `.razor.cs` file. If the component has visible text that serves as its label, ensure it's associated (e.g., `<label for="...">` for form inputs, or `aria-labelledby` pointing to the ID of the visible text element).
        *   Use `aria-label` for concise labels when visible text is insufficient or absent (e.g., icon-only buttons).
        *   Use `aria-labelledby` to associate the component with existing visible text that acts as its label.
        *   Use `aria-describedby` to associate the component with descriptive text that provides more context.
    *   **States & Properties:** Use ARIA attributes to convey state:
        *   `aria-expanded` (for accordions, dropdowns, collapsible sections)
        *   `aria-selected` (for tabs, items in a listbox)
        *   `aria-current` (for pagination, breadcrumbs, steps - e.g., `aria-current="page"` or `aria-current="step"`)
        *   `aria-pressed` (for toggle buttons)
        *   `aria-hidden` (use judiciously, e.g., for purely decorative icons or off-screen content)
        *   `aria-modal="true"` (for modal dialogs)
        *   `aria-live` (for dynamic content updates, e.g., alerts, status messages)
        *   `aria-controls` (to link a control to the region it manages)
        *   For inputs: `aria-required`, `aria-invalid`.

*   **Keyboard Navigation & Focus Management:**
    *   All interactive elements MUST be keyboard operable.
    *   Use `tabindex="0"` for custom interactive elements that should be in the tab order.
    *   Use `tabindex="-1"` for elements that should be programmatically focusable but not in the default tab order.
    *   For composite widgets (like dropdowns, menus, tabs), implement appropriate keyboard navigation patterns (arrow keys, Home/End, Enter/Space). This is often handled by the Alpine.js logic.
    *   Ensure a visible focus indicator. RizzyUI themes generally provide this, but be mindful if overriding default focus styles.
    *   For modals and dropdowns that trap focus, use Alpine's `x-trap.inert="isOpen"` directive.

*   **Screen Reader Text:**
    *   Use the `sr-only` Tailwind class (or equivalent CSS) for text that should only be available to screen readers (e.g., providing context for an icon button).
        ```razor
        <button aria-label="@Localizer["RzComponentName.CloseButtonAriaLabel"]">
            <Blazicon Svg="@MdiIcon.Close" aria-hidden="true" />
            <span class="sr-only">@Localizer["RzComponentName.CloseButtonSrText"]</span> @* Alternative if aria-label isn't sufficient *@
        </button>
        ```

*   **Images & Icons:**
    *   Decorative icons should have `aria-hidden="true"`.
    *   Informative icons (if not accompanied by text) need an accessible label (e.g., via `aria-label` on the button or a `sr-only` span).
    *   Images (e.g., `RzAvatar`) must have meaningful `alt` text or `aria-label`.

*   **Forms:**
    *   Associate labels with form controls using `<label for="...">` and matching `id` on the input. `RzFieldLabel` handles this if `For` is provided.
    *   Use `fieldset` and `legend` for groups of related controls (e.g., radio button groups).
    *   Provide clear validation messages, associated with inputs using `aria-describedby`. `RzValidationMessage` typically handles this.

---

## 9. Localization

All user-facing strings within components (default labels, ARIA labels, titles, placeholders, etc.) MUST be localizable.

*   **Accessing Localizer:**
    *   The `RzComponent` base class injects `IStringLocalizer<RizzyLocalization> Localizer`. Use this to retrieve localized strings.

*   **Resource Key Convention:**
    *   Resource keys should follow the pattern: `ComponentName.ResourceKeyName`.
    *   Example: For a default ARIA label in `RzFancyThing`, the key would be `RzFancyThing.DefaultAriaLabel`.
    *   Example: For a "Close" button text, `RzModal.CloseButtonText`.

*   **Parameter Defaults & Localization:**
    *   Component parameters that accept user-facing strings (e.g., `AriaLabel`, `Title`, `Placeholder`) should allow users to provide their own values.
    *   If the user does *not* provide a value for such a parameter (i.e., it remains `null` or its default), the component should attempt to load a localized default string.
    *   This is typically done in `OnInitialized()` and/or `OnParametersSet()`:
        ```csharp
        // In RzFancyThing.razor.cs
        [Parameter] public string? AriaLabel { get; set; }
        [Parameter] public string? PlaceholderText { get; set; }

        protected override void OnInitialized()
        {
            base.OnInitialized();
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }

        protected override void OnParametersSet()
        {
            base.OnParametersSet();
            // If parameters can be changed after init and might become null
            AriaLabel ??= Localizer["RzFancyThing.DefaultAriaLabel"];
            PlaceholderText ??= Localizer["RzFancyThing.DefaultPlaceholder"];
        }
        ```

*   **Providing New Resource Strings (LLM Output):**
    *   When generating a new component that introduces new localizable strings, the LLM MUST provide the English (default culture) versions of these strings.
    *   These should be presented in a clear key-value format, suitable for a developer to copy into the `src/RizzyUI/Resources/RizzyLocalization.resx` file.
    *   This information should be provided *outside* the main ````output ... ```` block, typically alongside the "Manual Edits Required for Theme Integration" section.

    **Example Presentation for New Resource Strings:**

    ````markdown
    **New English Localization Strings for `RizzyLocalization.resx`:**

    Please add the following entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

    | Name                               | Value                         | Comment (Optional)                  |
    |------------------------------------|-------------------------------|-------------------------------------|
    | `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
    | `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |
    | `RzAnotherComponent.SomeText`      | `Another default string`      |                                     |

    Alternatively, in raw .resx XML format:
    ```xml
    <data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
      <value>Fancy interactive element</value>
      <comment>Default ARIA label for RzFancyThing</comment>
    </data>
    <data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
      <value>Enter fancy text here...</value>
      <comment>Placeholder for RzFancyThing input</comment>
    </data>
    <data name="RzAnotherComponent.SomeText" xml:space="preserve">
      <value>Another default string</value>
    </data>
    ```
    ````

---

## 10. Alpine.js Integration & Asset Bundling

*   **Alpine Child-Container Convention:** If the component uses Alpine.js for interactivity, the root element in the `.razor` file (e.g., `<HtmlElement>`) MUST contain a direct child `<div>` with the following attributes:
    ```razor
    <HtmlElement ...>
        <div data-alpine-root="@Id"
             x-data="rzFancyThing" @* 'rzFancyThing' should match the Alpine component name *@
             data-assets="@_assets" @* Serialized JSON string of asset URLs *@
             data-nonce="@Nonce">
            @* Interactive content, x-ref, x-on:, :class, etc. goes here *@
        </div>
    </HtmlElement>
    ```
    *   `data-alpine-root` MUST exactly equal the component's `@Id`.
    *   `x-data` MUST reference the corresponding Alpine component name (e.g., `rzComponentName`).
    *   `data-assets` (see below) and `data-nonce` are crucial for dynamic asset loading and CSP.

*   **Asset Declaration (`.razor.cs`):**
    *   Define a `public static readonly string[] DefaultAssets` array in the component's code-behind.
    *   Populate it with URLs to necessary JS/CSS files. Use `Constants.ContentUrl("path/to/asset.js")` for library-internal assets.
        ```csharp
        public static readonly string[] DefaultAssets =
        {
            Constants.ContentUrl("js/lib/some-dependency.js"), // Example
            Constants.ContentUrl("js/rzfancything-alpine-module.js") // If module is separate
        };
        // Or if no assets: public static readonly string[] DefaultAssets = Array.Empty<string>();
        ```
    *   In `OnInitialized()` or `OnParametersSet()`, serialize this array to a private string field (e.g., `_assets`):
        ```csharp
        _assets = System.Text.Json.JsonSerializer.Serialize(ComponentAssets ?? DefaultAssets);
        ```

*   **Alpine Component Definition & Asset Loading (JavaScript):**
    *   New Alpine component logic (`Alpine.data('rzFancyThing', ...`) should be defined in `packages/rizzyui/src/js/lib/components.js`.
    *   Within the Alpine component's `init()` function:
        1.  Parse `this.$el.dataset.assets` (the JSON string from `data-assets`).
        2.  Parse `this.$el.dataset.nonce` (the string from `data-nonce`).
        3.  Use the `require(assets, { success: callback, error: errCallback }, nonce)` function (from `components.js`) to load these assets.
        4.  Place the actual Alpine initialization logic (event listeners, watches, etc.) inside the `success` callback of `require`.
        ```javascript
        // In packages/rizzyui/src/js/lib/components.js
        // Make sure 'require' is imported or available in this scope
        Alpine.data('rzFancyThing', () => ({
            someProperty: '',
            init() {
                const assets = JSON.parse(this.$el.dataset.assets || '[]');
                const nonce = this.$el.dataset.nonce || '';
                const self = this; // To retain 'this' context in callbacks

                require(assets, {
                    success: function() {
                        // Asset-dependent initialization logic here
                        // e.g., if an asset was Flatpickr: window.flatpickr(self.$refs.input, {});
                        console.log('Assets for rzFancyThing loaded.');
                        self.setupInteractivity();
                    },
                    error: function(err) {
                        console.error('Failed to load assets for rzFancyThing:', err);
                    }
                }, nonce);
            },
            setupInteractivity() {
                // Main Alpine logic that runs after assets are loaded
                // Example: this.someProperty = this.$el.dataset.initialValue;
            }
            // ... other methods and properties
        }));
        ```

---

## 11. Unit tests (bUnit) (IMPORTANT: ONLY ON REQUEST)

* Render the component and assert:
    * Presence of `data-alpine-root="@Id"` if an `x-data` section is utilized.
    * Correct JSON in `data-assets` if assets are used (verify `_assets` field after rendering).
    * Correct classes after parameter updates using `MarkupMatches`.
    * Correct ARIA attributes are present and have expected (or default localized) values.
    * Test behavior by invoking event handlers if applicable.

---

## 12. The output block example (canonical)

When asked to generate *RzFancyThing*, your response **must** contain an `output` block like this (all XML docs omitted for brevity):

````markdown
```output
<files>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/RzFancyThing.razor.cs">…</file>
  <file path="src/RizzyUI/Components/Fancy/RzFancyThing/Styling/DefaultRzFancyThingStyles.cs">…</file>
  @* If new Alpine module needed and LLM is instructed to generate JS: *@
  @* <file path="packages/rizzyui/src/js/lib/components.js">
    // Append the new Alpine.data('rzFancyThing', ...) to existing content.
    // LLM should indicate this is an APPEND operation.
    // ... existing content ...
    Alpine.data('rzFancyThing', () => ({ /* ... */ }));
  </file> *@
</files>
```
````
*(Note on JS output: If providing JS, clearly state if it's a new file or an append/modification to `components.js`. For simplicity, initially focus on Razor/C# generation; JS generation can be a separate, more complex step.)*

---

## 13. What **not** to place in the `output` block

Changes to **global theme scaffolding** (`RzTheme.cs`, `RzTheme.StyleProviders.cs`, `RzStylesBase.cs` additions to the *partial class itself*) and **localization resource files** (`RizzyLocalization.resx`) go in a **separate, preface section** that appears *before* the `output` block.
That section must identify each existing file and show the lines/entries to insert, either as a diff or as verbatim code snippets/tables.
Never embed these edits in `<file>` tags because CI merges them manually.

---

## 14. Theme integration & Localization (cross-file edits the LLM must describe)

Whenever a new style provider (e.g., `RzFancyThingStylesBase` and its default implementation) is introduced, or new localizable strings are needed, instruct the user accordingly:

````markdown
**Manual Edits Required for Theme Integration & Localization:**

**Theme Integration:**

1.  **Add to `src/RizzyUI/Styles/RzStylesBase.cs`**:
    ```csharp
    // ... (inside public abstract partial class RzStylesBase)
    public abstract class RzFancyThingStylesBase
    {
        // ... (as defined in §7.1 of the guide)
    }
    ```

2.  **Add to `src/RizzyUI/RzTheme.StyleProviders.cs`**:
    ```csharp
    // ... (inside public partial class RzTheme)
    /// <summary>
    /// Gets the style definitions for the <see cref="RzFancyThing" /> component.
    /// </summary>
    public virtual RzStylesBase.RzFancyThingStylesBase RzFancyThing { get; }
    ```

3.  **Add to `src/RizzyUI/RzTheme.cs` constructor**:
    ```csharp
    // ... (inside public RzTheme(string name, string themeCode) constructor)
    RzFancyThing = new DefaultRzFancyThingStyles(this);
    ```

**Localization:**

Please add the following English (default culture) entries to `src/RizzyUI/Resources/RizzyLocalization.resx`:

| Name                               | Value                         | Comment (Optional)                  |
|------------------------------------|-------------------------------|-------------------------------------|
| `RzFancyThing.DefaultAriaLabel`    | `Fancy interactive element`   | `Default ARIA label for RzFancyThing` |
| `RzFancyThing.DefaultPlaceholder`  | `Enter fancy text here...`    | `Placeholder for RzFancyThing input`  |

Alternatively, in raw .resx XML format:
```xml
<data name="RzFancyThing.DefaultAriaLabel" xml:space="preserve">
  <value>Fancy interactive element</value>
  <comment>Default ARIA label for RzFancyThing</comment>
</data>
<data name="RzFancyThing.DefaultPlaceholder" xml:space="preserve">
  <value>Enter fancy text here...</value>
  <comment>Placeholder for RzFancyThing input</comment>
</data>
```
````

---

## 15. Final checklist for the LLM

* CRITICAL - Only generate or modify code directly related to the task requested. You are not permitted to modify code outside the scope of the request.
* Prepend the cross-file edit instructions for theme and localization if needed (§14).
* Provide an `output` block for new or replaced component-specific files only (§1, §12).
* Use the root element pattern (§2) and Alpine child-container convention if Alpine is used (§10).
* `.razor` files: Use direct `@Theme...` access for internal element styling (§3, §5). Implement accessibility attributes (§8).
* `.razor.cs` files: Start with `/// <summary>...</summary>` for the class, ensure public members have `<summary>`, use `TwMerge` in `RootClass()`, define `DefaultAssets`, serialize assets to `_assets` string, set `Element` if not "div", and handle default localized strings for parameters like `AriaLabel` (§4, §9).
* Styling providers: Abstract base in `RzStylesBase.cs` and default implementation in its own file; constructor takes `RzTheme` (§6, §7).
* Asset bundling: Follow the C# -> `data-assets` -> JS `require()` flow (§10).
* Include unit tests *only* when specifically requested (§11).
* Adhere to all specified conventions and avoid manual concatenation of class strings.
* Do not include comments in Razor markup.
* Do not add comments to using statements.
* Any comments added within code blocks should be production-ready and not for commentary on changes.

If all bullets are satisfied, **any** compliant LLM will produce RizzyUI-ready code.
</instruction>
