
using System.Text;
using System.Text.Json;
using System.Web;
using Markdig;
using Markdig.Renderers.Html;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
using Microsoft.AspNetCore.Components;
using Rizzy.Utility;
using RizzyUI.Extensions;

// Add this

// Add this

namespace RizzyUI;

/// <xmldoc>
///     A component that converts Markdown text (provided as ChildContent or Content parameter) into HTML using Markdig.
///     It supports GitHub Flavored Markdown extensions and integrates with Highlight.js for syntax highlighting.
///     Styling is determined by the active <see cref="RzTheme" /> and Tailwind Typography plugin.
/// </xmldoc>
public partial class RzMarkdown : RzComponent
{
    /// <summary> Default assets loaded for RzMarkdown (Highlight.js and Razor plugin). </summary>
    public static string[] DefaultAssets = [ /* Unchanged */];

    private string _assets = string.Empty;

    /// <summary> Reference to the QuickReferenceContainer for heading registration. </summary>
    [CascadingParameter]
    private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }

    /// <summary>
    ///     The Markdig pipeline used for conversion. Defaults to a pipeline with advanced extensions and custom code
    ///     block rendering.
    /// </summary>
    [Parameter]
    public MarkdownPipeline? Pipeline { get; set; }

    /// <summary> The Markdown content provided as a RenderFragment. Used if <see cref="Content" /> is null or empty. </summary>
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    /// <summary> The Markdown content provided as a string. Takes precedence over <see cref="ChildContent" />. </summary>
    [Parameter]
    public string? Content { get; set; } = string.Empty;

    /// <summary> Controls the maximum width of the rendered prose content. Defaults to Comfortable. </summary>
    [Parameter]
    public ProseWidth ProseWidth { get; set; } = ProseWidth.Comfortable;

    /// <summary>
    ///     Optional array of asset URLs (JS/CSS) to load, primarily for syntax highlighting. Defaults to
    ///     <see cref="DefaultAssets" />.
    /// </summary>
    [Parameter]
    public string[] ComponentAssets { get; set; } = DefaultAssets;

    /// <summary> Gets the HTML markup generated by converting the markdown content. </summary>
    protected MarkupString? OutputHtml { get; private set; }

    /// <inheritdoc />
    protected override void OnInitialized()
    {
        base.OnInitialized();

        // Setup default pipeline if none provided
        Pipeline ??= new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseRizzySyntaxHighlighting() // Assumes this extension exists and is correctly implemented
            .Build();

        // Serialize assets only once if they don't change
        _assets = JsonSerializer.Serialize(ComponentAssets);
    }

    /// <inheritdoc />
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-render HTML only if content changes
        RenderMarkdownContent();
    }

    private void RenderMarkdownContent()
    {
        string markdownText;

        if (!string.IsNullOrEmpty(Content))
        {
            markdownText = Content;
        }
        else if (ChildContent != null)
        {
            markdownText = ChildContent.AsMarkupString().Outdent();
            markdownText = HttpUtility.HtmlDecode(markdownText); // Decode potential HTML entities
        }
        else
        {
            markdownText = string.Empty;
        }

        var html = RenderOutput(markdownText);
        OutputHtml = new MarkupString(html);
    }


    /// <inheritdoc />
    protected override string? RootClass()
    {
        return TwMerge.Merge(AdditionalAttributes, Theme.RzMarkdown.Container,
            Theme.RzMarkdown.GetProseWidthCss(ProseWidth));
    }

    // RenderOutput and ExtractPlainText methods remain the same, but ensure they use the correct
    // QuickReferenceContainer type (RzQuickReferenceContainer) if needed.
    private string RenderOutput(string markdownText)
    {
        var document = Markdown.Parse(markdownText, Pipeline);

        // Iterate through heading blocks and register them.
        if (QuickReferenceContainer != null)
            foreach (var block in document)
                if (block is HeadingBlock heading)
                {
                    var level = heading.Level;
                    var headingText = ExtractPlainText(heading.Inline);
                    var attributes = heading.GetAttributes();
                    attributes.Id ??= IdGenerator.UniqueId("heading"); // Ensure ID exists
                    attributes.AddProperty("x-data", "rzHeading"); // Add Alpine data if needed

                    var headingLevel = level switch
                    {
                        1 => HeadingLevel.H1, 2 => HeadingLevel.H2, 3 => HeadingLevel.H3, _ => HeadingLevel.H4
                    };

                    // Ensure QuickReferenceContainer parameter type matches RzQuickReferenceContainer
                    QuickReferenceContainer.RegisterHeading(headingLevel, headingText, attributes.Id);
                }

        return document.ToHtml(Pipeline);
    }

    private string ExtractPlainText(ContainerInline? inline)
    {
        // (Implementation remains the same)
        if (inline == null) return string.Empty;
        var sb = new StringBuilder();
        foreach (var child in inline)
            if (child is LiteralInline literal)
                sb.Append(literal.Content.Text.Substring(literal.Content.Start, literal.Content.Length));
            else if (child is ContainerInline container) sb.Append(ExtractPlainText(container));

        return sb.ToString().Trim();
    }
}