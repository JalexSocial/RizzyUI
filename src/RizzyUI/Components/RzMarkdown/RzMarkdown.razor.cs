using System.Web;
using Rizzy.Utility;
using RizzyUI.Extensions;
using Microsoft.AspNetCore.Components;
using Markdig;
using System.Text.Json;
using Markdig.Syntax;
using Markdig.Syntax.Inlines;
using System.Text;
using Markdig.Renderers.Html;
using Microsoft.Extensions.Options; // Add this
using RizzyUI.Styling;          // Add this

namespace RizzyUI;

/// <xmldoc>
/// A component that converts Markdown text (provided as ChildContent or Content parameter) into HTML using Markdig.
/// It supports GitHub Flavored Markdown extensions and integrates with Highlight.js for syntax highlighting.
/// Styling is determined by the active <see cref="RzTheme"/> and Tailwind Typography plugin.
/// </xmldoc>
public partial class RzMarkdown : RzComponent
{
    /// <summary> Get the currently active theme via Cascading Parameter. </summary>
    [CascadingParameter] protected RzTheme? CascadedTheme { get; set; }
    /// <summary> Reference to the QuickReferenceContainer for heading registration. </summary>
    [CascadingParameter] private RzQuickReferenceContainer? QuickReferenceContainer { get; set; }
    /// <summary> Injected configuration to get the default theme as fallback. </summary>
    [Inject] private IOptions<RizzyUIConfig>? Config { get; set; }
    /// <summary> The effective theme being used (Cascaded or Default). </summary>
    protected RzTheme Theme { get; set; } = default!;

    private string _assets = string.Empty;
    private MarkupString? _outputHtml; // Store rendered HTML

    /// <summary> The Markdig pipeline used for conversion. Defaults to a pipeline with advanced extensions and custom code block rendering. </summary>
    [Parameter] public MarkdownPipeline? Pipeline { get; set; }
    /// <summary> The Markdown content provided as a RenderFragment. Used if <see cref="Content"/> is null or empty. </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }
    /// <summary> The Markdown content provided as a string. Takes precedence over <see cref="ChildContent"/>. </summary>
    [Parameter] public string? Content { get; set; } = string.Empty;
    /// <summary> Controls the maximum width of the rendered prose content. Defaults to Comfortable. </summary>
    [Parameter] public ProseWidth ProseWidth { get; set; } = ProseWidth.Comfortable;
    /// <summary> Default assets loaded for RzMarkdown (Highlight.js and Razor plugin). </summary>
    public static string[] DefaultAssets = [ /* Unchanged */ ];
    /// <summary> Optional array of asset URLs (JS/CSS) to load, primarily for syntax highlighting. Defaults to <see cref="DefaultAssets"/>. </summary>
    [Parameter] public string[] ComponentAssets { get; set; } = DefaultAssets;

    /// <summary> Gets the HTML markup generated by converting the markdown content. </summary>
    protected MarkupString? OutputHtml => _outputHtml;

    /// <inheritdoc/>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        Theme = CascadedTheme ?? Config?.Value.DefaultTheme ?? RzTheme.Default;
        if (Theme == null)
            throw new InvalidOperationException($"{GetType()} requires a cascading RzTheme or a default theme configured.");

        // Setup default pipeline if none provided
        Pipeline ??= new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .UseRizzySyntaxHighlighting() // Assumes this extension exists and is correctly implemented
            .Build();

        // Serialize assets only once if they don't change
        _assets = JsonSerializer.Serialize(ComponentAssets);
    }

    /// <inheritdoc/>
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // Re-render HTML only if content changes
        RenderMarkdownContent();
    }

    private void RenderMarkdownContent()
    {
         if (Theme == null) return; // Ensure theme is available

        string markdownText;

        if (!string.IsNullOrEmpty(Content))
        {
            markdownText = Content;
        }
        else if (ChildContent != null)
        {
            markdownText = ChildContent.AsMarkupString().Outdent();
            markdownText = HttpUtility.HtmlDecode(markdownText); // Decode potential HTML entities
        }
        else
        {
            markdownText = string.Empty;
        }

        var html = RenderOutput(markdownText);
        _outputHtml = new MarkupString(html);
    }


    /// <inheritdoc/>
    protected override string? RootClass()
    {
        var styles = Theme.RzMarkdown;
        return TwMerge.Merge(AdditionalAttributes, styles.Container, styles.GetProseWidthCss(ProseWidth));
    }

    // RenderOutput and ExtractPlainText methods remain the same, but ensure they use the correct
    // QuickReferenceContainer type (RzQuickReferenceContainer) if needed.
    private string RenderOutput(string markdownText)
    {
        var document = Markdig.Markdown.Parse(markdownText, Pipeline);

        // Iterate through heading blocks and register them.
        if (QuickReferenceContainer != null)
        {
            foreach (var block in document)
            {
                if (block is HeadingBlock heading)
                {
                    int level = heading.Level;
                    string headingText = ExtractPlainText(heading.Inline);
                    var attributes = heading.GetAttributes();
                    attributes.Id ??= IdGenerator.UniqueId("heading"); // Ensure ID exists
                    attributes.AddProperty("x-data", "rzHeading"); // Add Alpine data if needed

                    HeadingLevel headingLevel = level switch {
                        1 => HeadingLevel.H1, 2 => HeadingLevel.H2, 3 => HeadingLevel.H3, _ => HeadingLevel.H4,
                    };

                    // Ensure QuickReferenceContainer parameter type matches RzQuickReferenceContainer
                    QuickReferenceContainer.RegisterHeading(headingLevel, headingText, attributes.Id);
                }
            }
        }
        return document.ToHtml(Pipeline);
    }

    private string ExtractPlainText(ContainerInline? inline)
    {
        // (Implementation remains the same)
        if (inline == null) return string.Empty;
        var sb = new StringBuilder();
        foreach (var child in inline) {
            if (child is LiteralInline literal) {
                sb.Append(literal.Content.Text.Substring(literal.Content.Start, literal.Content.Length));
            } else if (child is ContainerInline container) {
                sb.Append(ExtractPlainText(container));
            }
        }
        return sb.ToString().Trim();
    }
}

